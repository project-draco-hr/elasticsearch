{
  byte type=in.readByte();
  long maxDoc=in.readLong();
  long docCount=in.readLong();
  long sumDocFreq=in.readLong();
  long sumTotalTermFreq=in.readLong();
  boolean isSearchable=in.readBoolean();
  boolean isAggregatable=in.readBoolean();
  boolean hasMinMax=in.readBoolean();
switch (type) {
case 0:
    if (hasMinMax) {
      return new Long(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,in.readLong(),in.readLong());
    }
  return new Long(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable);
case 1:
if (hasMinMax) {
  return new Double(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,in.readDouble(),in.readDouble());
}
return new Double(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable);
case 2:
FormatDateTimeFormatter formatter=Joda.forPattern(in.readString());
if (hasMinMax) {
return new Date(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,formatter,in.readLong(),in.readLong());
}
return new Date(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,formatter);
case 3:
if (hasMinMax) {
return new Text(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,in.readBytesRef(),in.readBytesRef());
}
return new Text(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,null,null);
case 4:
InetAddress min=null;
InetAddress max=null;
if (hasMinMax) {
int l1=in.readByte();
byte[] b1=new byte[l1];
int l2=in.readByte();
byte[] b2=new byte[l2];
min=InetAddressPoint.decode(b1);
max=InetAddressPoint.decode(b2);
}
return new Ip(maxDoc,docCount,sumDocFreq,sumTotalTermFreq,isSearchable,isAggregatable,min,max);
default :
throw new IllegalArgumentException("Unknown type.");
}
}
