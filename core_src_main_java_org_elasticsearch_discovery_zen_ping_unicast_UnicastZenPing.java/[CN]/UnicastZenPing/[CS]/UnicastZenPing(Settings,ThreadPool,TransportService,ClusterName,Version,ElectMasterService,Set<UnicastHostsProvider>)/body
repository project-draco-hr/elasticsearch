{
  super(settings);
  this.threadPool=threadPool;
  this.transportService=transportService;
  this.clusterName=clusterName;
  this.electMasterService=electMasterService;
  if (unicastHostsProviders != null) {
    for (    UnicastHostsProvider unicastHostsProvider : unicastHostsProviders) {
      addHostsProvider(unicastHostsProvider);
    }
  }
  this.concurrentConnects=this.settings.getAsInt("discovery.zen.ping.unicast.concurrent_connects",10);
  String[] hostArr=this.settings.getAsArray(DISCOVERY_ZEN_PING_UNICAST_HOSTS);
  for (int i=0; i < hostArr.length; i++) {
    hostArr[i]=hostArr[i].trim();
  }
  List<String> hosts=CollectionUtils.arrayAsArrayList(hostArr);
  final int limitPortCounts;
  if (hosts.isEmpty()) {
    limitPortCounts=LIMIT_LOCAL_PORTS_COUNT;
    hosts.addAll(transportService.getLocalAddresses());
  }
 else {
    limitPortCounts=LIMIT_FOREIGN_PORTS_COUNT;
  }
  logger.debug("using initial hosts {}, with concurrent_connects [{}]",hosts,concurrentConnects);
  List<DiscoveryNode> configuredTargetNodes=new ArrayList<>();
  for (  String host : hosts) {
    try {
      TransportAddress[] addresses=transportService.addressesFromString(host,limitPortCounts);
      for (      TransportAddress address : addresses) {
        configuredTargetNodes.add(new DiscoveryNode(UNICAST_NODE_PREFIX + unicastNodeIdGenerator.incrementAndGet() + "#",address,version.minimumCompatibilityVersion()));
      }
    }
 catch (    Exception e) {
      throw new IllegalArgumentException("Failed to resolve address for [" + host + "]",e);
    }
  }
  this.configuredTargetNodes=configuredTargetNodes.toArray(new DiscoveryNode[configuredTargetNodes.size()]);
  transportService.registerRequestHandler(ACTION_NAME,UnicastPingRequest.class,ThreadPool.Names.SAME,new UnicastPingRequestHandler());
  ThreadFactory threadFactory=EsExecutors.daemonThreadFactory(settings,"[unicast_connect]");
  unicastConnectExecutor=EsExecutors.newScaling("unicast_connect",0,concurrentConnects,60,TimeUnit.SECONDS,threadFactory);
}
