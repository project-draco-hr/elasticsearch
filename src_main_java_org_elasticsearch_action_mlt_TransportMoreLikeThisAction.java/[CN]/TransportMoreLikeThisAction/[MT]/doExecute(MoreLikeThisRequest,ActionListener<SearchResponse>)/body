{
  ClusterState clusterState=clusterService.state();
  final String concreteIndex=clusterState.metaData().concreteIndex(request.getIndex());
  RoutingNode routingNode=clusterState.getRoutingNodes().nodesToShards().get(clusterService.localNode().getId());
  if (routingNode == null) {
    redirect(request,listener,clusterState);
    return;
  }
  boolean hasIndexLocally=false;
  for (  MutableShardRouting shardRouting : routingNode.shards()) {
    if (concreteIndex.equals(shardRouting.index())) {
      hasIndexLocally=true;
      break;
    }
  }
  if (!hasIndexLocally) {
    redirect(request,listener,clusterState);
    return;
  }
  Set<String> getFields=newHashSet();
  if (request.getFields() != null) {
    Collections.addAll(getFields,request.getFields());
  }
  getFields.add(SourceFieldMapper.NAME);
  GetRequest getRequest=getRequest(concreteIndex).setFields(getFields.toArray(new String[getFields.size()])).setType(request.getType()).setId(request.getId()).setRouting(request.getRouting()).setListenerThreaded(true).setOperationThreaded(true);
  request.beforeLocalFork();
  getAction.execute(getRequest,new ActionListener<GetResponse>(){
    @Override public void onResponse(    GetResponse getResponse){
      if (!getResponse.isExists()) {
        listener.onFailure(new ElasticSearchException("document missing"));
        return;
      }
      final BoolQueryBuilder boolBuilder=boolQuery();
      try {
        final DocumentMapper docMapper=indicesService.indexServiceSafe(concreteIndex).mapperService().documentMapper(request.getType());
        if (docMapper == null) {
          throw new ElasticSearchException("No DocumentMapper found for type [" + request.getType() + "]");
        }
        final Set<String> fields=newHashSet();
        if (request.getFields() != null) {
          for (          String field : request.getFields()) {
            FieldMappers fieldMappers=docMapper.mappers().smartName(field);
            if (fieldMappers != null) {
              fields.add(fieldMappers.mapper().names().indexName());
            }
 else {
              fields.add(field);
            }
          }
        }
        if (!fields.isEmpty()) {
          for (Iterator<String> it=fields.iterator(); it.hasNext(); ) {
            String field=it.next();
            GetField getField=getResponse.getField(field);
            if (getField != null) {
              for (              Object value : getField.getValues()) {
                addMoreLikeThis(request,boolBuilder,getField.getName(),value.toString());
              }
              it.remove();
            }
          }
          if (!fields.isEmpty()) {
            parseSource(getResponse,boolBuilder,docMapper,fields,request);
          }
        }
 else {
          parseSource(getResponse,boolBuilder,docMapper,fields,request);
        }
        if (!boolBuilder.hasClauses()) {
          listener.onFailure(new ElasticSearchException("No fields found to fetch the 'likeText' from"));
          return;
        }
        Term uidTerm=docMapper.uidMapper().term(request.getType(),request.getId());
        boolBuilder.mustNot(termQuery(uidTerm.field(),uidTerm.text()));
      }
 catch (      Exception e) {
        listener.onFailure(e);
        return;
      }
      String[] searchIndices=request.getSearchIndices();
      if (searchIndices == null) {
        searchIndices=new String[]{request.getIndex()};
      }
      String[] searchTypes=request.getSearchTypes();
      if (searchTypes == null) {
        searchTypes=new String[]{request.getType()};
      }
      int size=request.getSearchSize() != 0 ? request.getSearchSize() : 10;
      int from=request.getSearchFrom() != 0 ? request.getSearchFrom() : 0;
      SearchRequest searchRequest=searchRequest(searchIndices).setTypes(searchTypes).setSearchType(request.getSearchType()).setScroll(request.getSearchScroll()).setExtraSource(searchSource().query(boolBuilder).from(from).size(size)).setListenerThreaded(request.isListenerThreaded());
      if (request.getSearchSource() != null) {
        searchRequest.setSource(request.getSearchSource(),request.isSearchSourceUnsafe());
      }
      searchAction.execute(searchRequest,new ActionListener<SearchResponse>(){
        @Override public void onResponse(        SearchResponse response){
          listener.onResponse(response);
        }
        @Override public void onFailure(        Throwable e){
          listener.onFailure(e);
        }
      }
);
    }
    @Override public void onFailure(    Throwable e){
      listener.onFailure(e);
    }
  }
);
}
