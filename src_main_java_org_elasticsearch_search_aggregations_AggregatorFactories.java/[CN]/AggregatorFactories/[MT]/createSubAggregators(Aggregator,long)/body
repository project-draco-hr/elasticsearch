{
  Aggregator[] aggregators=new Aggregator[count()];
  for (int i=0; i < factories.length; ++i) {
    final AggregatorFactory factory=factories[i];
    final Aggregator first=createAndRegisterContextAware(parent.context(),factory,parent,estimatedBucketsCount);
    if (first.bucketAggregationMode() == BucketAggregationMode.MULTI_BUCKETS) {
      aggregators[i]=first;
      continue;
    }
    aggregators[i]=new Aggregator(first.name(),BucketAggregationMode.MULTI_BUCKETS,AggregatorFactories.EMPTY,1,first.context(),first.parent()){
      ObjectArray<Aggregator> aggregators;
{
        long arraySize=estimatedBucketsCount > 0 ? estimatedBucketsCount : 1;
        aggregators=bigArrays.newObjectArray(arraySize);
        aggregators.set(0,first);
        for (long i=1; i < arraySize; ++i) {
          aggregators.set(i,createAndRegisterContextAware(parent.context(),factory,parent,estimatedBucketsCount));
        }
      }
      @Override public boolean shouldCollect(){
        return first.shouldCollect();
      }
      @Override protected void doPostCollection(){
        for (long i=0; i < aggregators.size(); ++i) {
          final Aggregator aggregator=aggregators.get(i);
          if (aggregator != null) {
            aggregator.postCollection();
          }
        }
      }
      @Override public void collect(      int doc,      long owningBucketOrdinal) throws IOException {
        aggregators=bigArrays.grow(aggregators,owningBucketOrdinal + 1);
        Aggregator aggregator=aggregators.get(owningBucketOrdinal);
        if (aggregator == null) {
          aggregator=createAndRegisterContextAware(parent.context(),factory,parent,estimatedBucketsCount);
          aggregators.set(owningBucketOrdinal,aggregator);
        }
        aggregator.collect(doc,0);
      }
      @Override public void setNextReader(      AtomicReaderContext reader){
      }
      @Override public InternalAggregation buildAggregation(      long owningBucketOrdinal){
        if (owningBucketOrdinal >= aggregators.size() || aggregators.get(owningBucketOrdinal) == null) {
          return first.buildEmptyAggregation();
        }
 else {
          return aggregators.get(owningBucketOrdinal).buildAggregation(0);
        }
      }
      @Override public InternalAggregation buildEmptyAggregation(){
        return first.buildEmptyAggregation();
      }
      @Override public void doClose(){
        final Iterable<Aggregator> aggregatorsIter=new Iterable<Aggregator>(){
          @Override public Iterator<Aggregator> iterator(){
            return new UnmodifiableIterator<Aggregator>(){
              long i=0;
              @Override public boolean hasNext(){
                return i < aggregators.size();
              }
              @Override public Aggregator next(){
                return aggregators.get(i++);
              }
            }
;
          }
        }
;
        Releasables.close(Iterables.concat(aggregatorsIter,Collections.singleton(aggregators)));
      }
    }
;
  }
  return aggregators;
}
