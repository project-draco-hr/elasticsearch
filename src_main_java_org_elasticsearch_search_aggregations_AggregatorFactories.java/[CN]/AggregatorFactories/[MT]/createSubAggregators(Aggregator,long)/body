{
  Aggregator[] aggregators=new Aggregator[count()];
  for (int i=0; i < factories.length; ++i) {
    final AggregatorFactory factory=factories[i];
    final Aggregator first=createAndRegisterContextAware(parent.context(),factory,parent,estimatedBucketsCount);
    if (first.bucketAggregationMode() == BucketAggregationMode.MULTI_BUCKETS) {
      aggregators[i]=first;
      continue;
    }
    aggregators[i]=new Aggregator(first.name(),BucketAggregationMode.MULTI_BUCKETS,AggregatorFactories.EMPTY,1,first.context(),first.parent(),first.getMetaData()){
      ObjectArray<Aggregator> aggregators;
{
        long arraySize=estimatedBucketsCount > 0 ? estimatedBucketsCount : 1;
        aggregators=bigArrays.newObjectArray(arraySize);
        aggregators.set(0,first);
      }
      @Override public boolean shouldCollect(){
        return first.shouldCollect();
      }
      @Override protected void doPostCollection() throws IOException {
        for (long i=0; i < aggregators.size(); ++i) {
          final Aggregator aggregator=aggregators.get(i);
          if (aggregator != null) {
            aggregator.postCollection();
          }
        }
      }
      @Override public void collect(      int doc,      long owningBucketOrdinal) throws IOException {
        aggregators=bigArrays.grow(aggregators,owningBucketOrdinal + 1);
        Aggregator aggregator=aggregators.get(owningBucketOrdinal);
        if (aggregator == null) {
          aggregator=createAndRegisterContextAware(parent.context(),factory,parent,estimatedBucketsCount);
          aggregators.set(owningBucketOrdinal,aggregator);
        }
        aggregator.collect(doc,0);
      }
      @Override public void setNextReader(      LeafReaderContext reader){
      }
      @Override public InternalAggregation buildAggregation(      long owningBucketOrdinal){
        throw new ElasticsearchIllegalStateException("Invalid context - aggregation must use addResults() to collect child results");
      }
      @Override public InternalAggregation buildEmptyAggregation(){
        return first.buildEmptyAggregation();
      }
      @Override public void doClose(){
        Releasables.close(aggregators);
      }
      @Override public void gatherAnalysis(      BucketAnalysisCollector results,      long owningBucketOrdinal){
        if (owningBucketOrdinal >= aggregators.size() || aggregators.get(owningBucketOrdinal) == null) {
          results.add(first.buildEmptyAggregation());
        }
 else {
          aggregators.get(owningBucketOrdinal).gatherAnalysis(results,0);
        }
      }
    }
;
    aggregators[i].preCollection();
  }
  return aggregators;
}
