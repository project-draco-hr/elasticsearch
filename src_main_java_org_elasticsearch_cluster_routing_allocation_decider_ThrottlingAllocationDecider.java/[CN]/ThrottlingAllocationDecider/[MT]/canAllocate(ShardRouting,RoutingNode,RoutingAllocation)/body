{
  if (shardRouting.primary()) {
    boolean primaryUnassigned=false;
    List<MutableShardRouting> unassigned=allocation.routingNodes().unassigned();
    for (int i1=0; i1 < unassigned.size(); i1++) {
      MutableShardRouting shard=unassigned.get(i1);
      if (shard.shardId().equals(shardRouting.shardId())) {
        primaryUnassigned=true;
        break;
      }
    }
    if (primaryUnassigned) {
      int primariesInRecovery=0;
      List<MutableShardRouting> shards=node.shards();
      for (int i=0; i < shards.size(); i++) {
        MutableShardRouting shard=shards.get(i);
        if (shard.state() == ShardRoutingState.INITIALIZING && shard.primary()) {
          primariesInRecovery++;
        }
      }
      if (primariesInRecovery >= primariesInitialRecoveries) {
        return Decision.THROTTLE;
      }
 else {
        return Decision.YES;
      }
    }
  }
  int currentRecoveries=0;
  List<MutableShardRouting> shards=node.shards();
  for (int i=0; i < shards.size(); i++) {
    MutableShardRouting shard=shards.get(i);
    if (shard.state() == ShardRoutingState.INITIALIZING || shard.state() == ShardRoutingState.RELOCATING) {
      currentRecoveries++;
    }
  }
  if (currentRecoveries >= concurrentRecoveries) {
    return Decision.THROTTLE;
  }
 else {
    return Decision.YES;
  }
}
