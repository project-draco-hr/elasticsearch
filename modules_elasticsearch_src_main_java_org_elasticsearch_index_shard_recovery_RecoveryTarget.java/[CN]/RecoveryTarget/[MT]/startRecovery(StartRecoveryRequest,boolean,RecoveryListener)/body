{
  if (request.sourceNode() == null) {
    listener.onIgnoreRecovery(false,"No node to recovery from, retry on next cluster state update");
    return;
  }
  final InternalIndexShard shard=(InternalIndexShard)indicesService.indexServiceSafe(request.shardId().index().name()).shardSafe(request.shardId().id());
  if (!fromRetry) {
    try {
      shard.recovering();
    }
 catch (    IllegalIndexShardStateException e) {
      listener.onIgnoreRecovery(false,"already in recovering process, " + e.getMessage());
      return;
    }
  }
  if (shard.state() == IndexShardState.CLOSED) {
    listener.onIgnoreRecovery(false,"shard closed, stop recovery");
    return;
  }
  threadPool.cached().execute(new Runnable(){
    @Override public void run(){
      doRecovery(shard,request,listener);
    }
  }
);
}
