{
  if (request.sourceNode() == null) {
    listener.onIgnoreRecovery(false,"No node to recovery from, retry on next cluster state update");
    return;
  }
  IndexService indexService=indicesService.indexService(request.shardId().index().name());
  if (indexService == null) {
    removeAndCleanOnGoingRecovery(request.shardId());
    listener.onIgnoreRecovery(false,"index missing, stop recovery");
    return;
  }
  final InternalIndexShard shard=(InternalIndexShard)indexService.shard(request.shardId().id());
  if (shard == null) {
    removeAndCleanOnGoingRecovery(request.shardId());
    listener.onIgnoreRecovery(false,"shard missing, stop recovery");
    return;
  }
  if (!fromRetry) {
    try {
      shard.recovering();
    }
 catch (    IllegalIndexShardStateException e) {
      listener.onIgnoreRecovery(false,"already in recovering process, " + e.getMessage());
      return;
    }
  }
  if (shard.state() == IndexShardState.CLOSED) {
    removeAndCleanOnGoingRecovery(request.shardId());
    listener.onIgnoreRecovery(false,"shard closed, stop recovery");
    return;
  }
  threadPool.cached().execute(new Runnable(){
    @Override public void run(){
      doRecovery(shard,request,fromRetry,listener);
    }
  }
);
}
