{
  if (shard.state() == IndexShardState.CLOSED) {
    removeAndCleanOnGoingRecovery(request.shardId());
    listener.onIgnoreRecovery(false,"shard closed, stop recovery");
    return;
  }
  RecoveryStatus recovery;
  if (fromRetry) {
    recovery=onGoingRecoveries.get(request.shardId());
  }
 else {
    recovery=new RecoveryStatus();
    onGoingRecoveries.put(request.shardId(),recovery);
  }
  if (!recoveryThrottler.tryRecovery(shard.shardId(),"peer recovery target")) {
    recovery.stage=RecoveryStatus.Stage.THROTTLE;
    recovery.retryTime=System.currentTimeMillis() - recovery.startTime;
    listener.onRetryRecovery(recoveryThrottler.throttleInterval());
    return;
  }
  try {
    logger.trace("[{}][{}] starting recovery from {}",request.shardId().index().name(),request.shardId().id(),request.sourceNode());
    StopWatch stopWatch=new StopWatch().start();
    RecoveryResponse recoveryStatus=transportService.submitRequest(request.sourceNode(),RecoverySource.Actions.START_RECOVERY,request,new FutureTransportResponseHandler<RecoveryResponse>(){
      @Override public RecoveryResponse newInstance(){
        return new RecoveryResponse();
      }
    }
).txGet();
    if (recoveryStatus.retry) {
      if (shard.state() == IndexShardState.CLOSED) {
        listener.onIgnoreRecovery(false,"shard closed, stop recovery");
        return;
      }
      logger.trace("[{}][{}] retrying recovery in [{}], source shard is busy",request.shardId().index().name(),request.shardId().id(),recoveryThrottler.throttleInterval());
      recovery.stage=RecoveryStatus.Stage.THROTTLE;
      recovery.retryTime=System.currentTimeMillis() - recovery.startTime;
      listener.onRetryRecovery(recoveryThrottler.throttleInterval());
      return;
    }
    stopWatch.stop();
    if (logger.isDebugEnabled()) {
      StringBuilder sb=new StringBuilder();
      sb.append('[').append(request.shardId().index().name()).append(']').append('[').append(request.shardId().id()).append("] ");
      sb.append("recovery completed from ").append(request.sourceNode()).append(", took[").append(stopWatch.totalTime()).append("]\n");
      sb.append("   phase1: recovered_files [").append(recoveryStatus.phase1FileNames.size()).append("]").append(" with total_size of [").append(new ByteSizeValue(recoveryStatus.phase1TotalSize)).append("]").append(", took [").append(timeValueMillis(recoveryStatus.phase1Time)).append("], throttling_wait [").append(timeValueMillis(recoveryStatus.phase1ThrottlingWaitTime)).append(']').append("\n");
      sb.append("         : reusing_files   [").append(recoveryStatus.phase1ExistingFileNames.size()).append("] with total_size of [").append(new ByteSizeValue(recoveryStatus.phase1ExistingTotalSize)).append("]\n");
      sb.append("   phase2: recovered [").append(recoveryStatus.phase2Operations).append("]").append(" transaction log operations").append(", took [").append(timeValueMillis(recoveryStatus.phase2Time)).append("]").append("\n");
      sb.append("   phase3: recovered [").append(recoveryStatus.phase3Operations).append("]").append(" transaction log operations").append(", took [").append(timeValueMillis(recoveryStatus.phase3Time)).append("]");
      logger.debug(sb.toString());
    }
    removeAndCleanOnGoingRecovery(request.shardId());
    listener.onRecoveryDone();
  }
 catch (  Exception e) {
    if (shard.state() == IndexShardState.CLOSED) {
      removeAndCleanOnGoingRecovery(request.shardId());
      listener.onIgnoreRecovery(false,"shard closed, stop recovery");
      return;
    }
    Throwable cause=ExceptionsHelper.unwrapCause(e);
    if (cause instanceof RecoveryEngineException) {
      cause=cause.getCause();
    }
    cause=ExceptionsHelper.unwrapCause(cause);
    if (cause instanceof RecoveryEngineException) {
      cause=cause.getCause();
    }
    if (cause instanceof IndexShardNotStartedException || cause instanceof IndexMissingException || cause instanceof IndexShardMissingException) {
      recovery.stage=RecoveryStatus.Stage.THROTTLE;
      recovery.retryTime=System.currentTimeMillis() - recovery.startTime;
      listener.onRetryRecovery(recoveryThrottler.throttleInterval());
      return;
    }
    removeAndCleanOnGoingRecovery(request.shardId());
    logger.trace("[{}][{}] recovery from [{}] failed",e,request.shardId().index().name(),request.shardId().id(),request.sourceNode());
    if (cause instanceof ConnectTransportException) {
      listener.onIgnoreRecovery(true,"source node disconnected");
      return;
    }
    if (cause instanceof IndexShardClosedException) {
      listener.onIgnoreRecovery(true,"source node disconnected");
      return;
    }
    listener.onRecoveryFailure(new RecoveryFailedException(request,e),true);
  }
 finally {
    recoveryThrottler.recoveryDone(shard.shardId(),"peer recovery target");
  }
}
