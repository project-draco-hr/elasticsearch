{
  Preconditions.checkArgument(settings.getAsInt(SETTING_NUMBER_OF_SHARDS,null) != null,"must specify numberOfShards for index [" + index + "]");
  Preconditions.checkArgument(settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,null) != null,"must specify numberOfReplicas for index [" + index + "]");
  this.index=index;
  this.version=version;
  this.state=state;
  this.settings=settings;
  this.mappings=mappings;
  this.customs=customs;
  this.totalNumberOfShards=numberOfShards() * (numberOfReplicas() + 1);
  this.aliases=aliases;
  ImmutableMap<String,String> requireMap=settings.getByPrefix("index.routing.allocation.require.").getAsMap();
  if (requireMap.isEmpty()) {
    requireFilters=null;
  }
 else {
    requireFilters=DiscoveryNodeFilters.buildFromKeyValue(AND,requireMap);
  }
  ImmutableMap<String,String> includeMap=settings.getByPrefix("index.routing.allocation.include.").getAsMap();
  if (includeMap.isEmpty()) {
    includeFilters=null;
  }
 else {
    includeFilters=DiscoveryNodeFilters.buildFromKeyValue(OR,includeMap);
  }
  ImmutableMap<String,String> excludeMap=settings.getByPrefix("index.routing.allocation.exclude.").getAsMap();
  if (excludeMap.isEmpty()) {
    excludeFilters=null;
  }
 else {
    excludeFilters=DiscoveryNodeFilters.buildFromKeyValue(OR,excludeMap);
  }
  indexCreatedVersion=Version.indexCreated(settings);
  final Class<? extends HashFunction> hashFunctionClass=settings.getAsClass(SETTING_LEGACY_ROUTING_HASH_FUNCTION,null);
  if (hashFunctionClass == null) {
    routingHashFunction=MURMUR3_HASH_FUNCTION;
  }
 else {
    try {
      routingHashFunction=hashFunctionClass.newInstance();
    }
 catch (    InstantiationException|IllegalAccessException e) {
      throw new ElasticsearchIllegalStateException("Cannot instantiate hash function",e);
    }
  }
  useTypeForRouting=settings.getAsBoolean(SETTING_LEGACY_ROUTING_USE_TYPE,false);
}
