{
  final Settings settings=settingsBuilder().put("action.admin.cluster.node.shutdown.delay","10ms").put(MockFSDirectoryService.CHECK_INDEX_ON_CLOSE,false).put("gateway.recover_after_nodes",4).put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES,4).put(MockDirectoryHelper.CRASH_INDEX,false).build();
  internalCluster().startNodesAsync(4,settings).get();
  assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(indexSettings()).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE,EnableAllocationDecider.Rebalance.NONE)));
  ensureGreen();
  logger.info("--> indexing docs");
  for (int i=0; i < 1000; i++) {
    client().prepareIndex("test","type").setSource("field","value").execute().actionGet();
    if ((i % 200) == 0) {
      client().admin().indices().prepareFlush().execute().actionGet();
    }
  }
  if (randomBoolean()) {
    client().admin().indices().prepareFlush().execute().actionGet();
  }
  logger.info("Running Cluster Health");
  ensureGreen();
  client().admin().indices().prepareOptimize("test").setMaxNumSegments(100).get();
  client().admin().indices().prepareFlush().setWaitIfOngoing(true).setForce(true).get();
  logger.info("--> disabling allocation while the cluster is shut down");
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE,EnableAllocationDecider.Allocation.NONE)).get();
  logger.info("--> full cluster restart");
  internalCluster().fullRestart();
  logger.info("--> waiting for cluster to return to green after first shutdown");
  ensureGreen();
  logger.info("--> disabling allocation while the cluster is shut down second time");
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE,EnableAllocationDecider.Allocation.NONE)).get();
  logger.info("--> full cluster restart");
  internalCluster().fullRestart();
  logger.info("--> waiting for cluster to return to green after second shutdown");
  ensureGreen();
  RecoveryResponse recoveryResponse=client().admin().indices().prepareRecoveries("test").get();
  for (  ShardRecoveryResponse response : recoveryResponse.shardResponses().get("test")) {
    RecoveryState recoveryState=response.recoveryState();
    long recovered=0;
    for (    RecoveryState.File file : recoveryState.getIndex().fileDetails()) {
      if (file.name().startsWith("segments")) {
        recovered+=file.length();
      }
    }
    if (!recoveryState.getPrimary()) {
      logger.info("--> replica shard {} recovered from {} to {}, recovered {}, reuse {}",response.getShardId(),recoveryState.getSourceNode().name(),recoveryState.getTargetNode().name(),recoveryState.getIndex().recoveredBytes(),recoveryState.getIndex().reusedBytes());
      assertThat("no bytes should be recovered",recoveryState.getIndex().recoveredBytes(),equalTo(recovered));
      assertThat("data should have been reused",recoveryState.getIndex().reusedBytes(),greaterThan(0l));
      assertThat("all bytes should be reused except of the segments file",recoveryState.getIndex().reusedBytes(),equalTo(recoveryState.getIndex().totalBytes() - recovered));
      assertThat("no files should be recovered except of the segments file",recoveryState.getIndex().recoveredFileCount(),equalTo(1));
      assertThat("all files should be reused except of the segments file",recoveryState.getIndex().reusedFileCount(),equalTo(recoveryState.getIndex().totalFileCount() - 1));
      assertThat("> 0 files should be reused",recoveryState.getIndex().reusedFileCount(),greaterThan(0));
    }
 else {
      assertThat(recoveryState.getIndex().recoveredBytes(),equalTo(0l));
      assertThat(recoveryState.getIndex().reusedBytes(),equalTo(recoveryState.getIndex().totalBytes()));
      assertThat(recoveryState.getIndex().recoveredFileCount(),equalTo(0));
      assertThat(recoveryState.getIndex().reusedFileCount(),equalTo(recoveryState.getIndex().totalFileCount()));
    }
  }
}
