{
  return new Aggregator(){
    @Override public boolean needsScores(){
      return in.needsScores();
    }
    @Override public void close() throws ElasticsearchException {
      in.close();
    }
    @Override public String name(){
      return in.name();
    }
    @Override public Aggregator parent(){
      return in.parent();
    }
    @Override public AggregationContext context(){
      return in.context();
    }
    @Override public Aggregator subAggregator(    String name){
      return in.subAggregator(name);
    }
    @Override public InternalAggregation buildAggregation(    long bucket) throws IOException {
      if (selectedBuckets == null) {
        throw new ElasticsearchIllegalStateException("Collection has not been replayed yet.");
      }
      final long rebasedBucket=selectedBuckets.find(bucket);
      if (rebasedBucket == -1) {
        throw new ElasticsearchIllegalStateException("Cannot build for a bucket which has not been collected");
      }
      return in.buildAggregation(rebasedBucket);
    }
    @Override public InternalAggregation buildEmptyAggregation(){
      return in.buildEmptyAggregation();
    }
    @Override public LeafBucketCollector getLeafCollector(    LeafReaderContext ctx) throws IOException {
      throw new ElasticsearchIllegalStateException("Deferred collectors cannot be collected directly. They must be collected through the recording wrapper.");
    }
    @Override public void preCollection() throws IOException {
      throw new ElasticsearchIllegalStateException("Deferred collectors cannot be collected directly. They must be collected through the recording wrapper.");
    }
    @Override public void postCollection() throws IOException {
      throw new ElasticsearchIllegalStateException("Deferred collectors cannot be collected directly. They must be collected through the recording wrapper.");
    }
  }
;
}
