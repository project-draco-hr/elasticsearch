{
  boolean success=false;
  try {
    logger.info("[{}#{}]: cleaning up after test",getTestClass().getSimpleName(),getTestName());
    final Scope currentClusterScope=getCurrentClusterScope();
    try {
      if (currentClusterScope != Scope.TEST) {
        MetaData metaData=client().admin().cluster().prepareState().execute().actionGet().getState().getMetaData();
        assertThat("test leaves persistent cluster metadata behind: " + metaData.persistentSettings().getAsMap(),metaData.persistentSettings().getAsMap().size(),equalTo(0));
        assertThat("test leaves transient cluster metadata behind: " + metaData.transientSettings().getAsMap(),metaData.transientSettings().getAsMap().size(),equalTo(0));
      }
      ensureClusterSizeConsistency();
      cluster().wipe();
      cluster().assertAfterTest();
    }
  finally {
      if (currentClusterScope == Scope.TEST) {
        clearClusters();
      }
    }
    logger.info("[{}#{}]: cleaned up after test",getTestClass().getSimpleName(),getTestName());
    success=true;
  }
 catch (  OutOfMemoryError e) {
    if (e.getMessage().contains("unable to create new native thread")) {
      ElasticsearchTestCase.printStackDump(logger);
    }
    throw e;
  }
 finally {
    if (!success) {
      clearClusters();
      if (currentCluster == GLOBAL_CLUSTER) {
        GLOBAL_CLUSTER.close();
        GLOBAL_CLUSTER=null;
        initializeGlobalCluster();
      }
    }
    if (currentCluster != null) {
      currentCluster.afterTest();
      currentCluster=null;
    }
  }
}
