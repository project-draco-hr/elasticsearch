{
  if (upgradeInProgress) {
    MergeSpecification spec=new IndexUpgraderMergeSpecification();
    for (    SegmentCommitInfo info : segmentInfos) {
      org.apache.lucene.util.Version old=info.info.getVersion();
      org.apache.lucene.util.Version cur=Version.CURRENT.luceneVersion;
      if (cur.major > old.major || cur.major == old.major && cur.minor > old.minor) {
        logger.debug("Adding segment " + info.info.name + " to be upgraded");
        spec.add(new OneMerge(Lists.newArrayList(info)));
      }
      if (spec.merges.size() == MAX_CONCURRENT_UPGRADE_MERGES) {
        logger.debug("Returning " + spec.merges.size() + " merges for upgrade");
        return spec;
      }
    }
    upgradeInProgress=false;
    if (spec.merges.isEmpty() == false) {
      logger.debug("Return " + spec.merges.size() + " merges for end of upgrade");
      return spec;
    }
  }
  return upgradedMergeSpecification(delegate.findForcedMerges(segmentInfos,maxSegmentCount,segmentsToMerge,writer));
}
