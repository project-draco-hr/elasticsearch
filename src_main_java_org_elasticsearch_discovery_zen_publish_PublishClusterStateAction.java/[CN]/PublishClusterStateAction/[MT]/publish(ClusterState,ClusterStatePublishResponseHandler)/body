{
  DiscoveryNode localNode=nodesProvider.nodes().localNode();
  Map<Version,BytesReference> serializedStates=Maps.newHashMap();
  final AtomicBoolean timedOutWaitingForNodes=new AtomicBoolean(false);
  final TimeValue publishTimeout=discoverySettings.getPublishTimeout();
  for (  final DiscoveryNode node : clusterState.nodes()) {
    if (node.equals(localNode)) {
      continue;
    }
    BytesReference bytes=serializedStates.get(node.version());
    if (bytes == null) {
      try {
        BytesStreamOutput bStream=new BytesStreamOutput();
        StreamOutput stream=new HandlesStreamOutput(CompressorFactory.defaultCompressor().streamOutput(bStream));
        stream.setVersion(node.version());
        ClusterState.Builder.writeTo(clusterState,stream);
        stream.close();
        bytes=bStream.bytes();
        serializedStates.put(node.version(),bytes);
      }
 catch (      Throwable e) {
        logger.warn("failed to serialize cluster_state before publishing it to node {}",e,node);
        publishResponseHandler.onFailure(node,e);
        continue;
      }
    }
    try {
      TransportRequestOptions options=TransportRequestOptions.options().withType(TransportRequestOptions.Type.STATE).withCompress(false);
      transportService.sendRequest(node,ACTION_NAME,new BytesTransportRequest(bytes,node.version()),options,new EmptyTransportResponseHandler(ThreadPool.Names.SAME){
        @Override public void handleResponse(        TransportResponse.Empty response){
          if (timedOutWaitingForNodes.get()) {
            logger.debug("node {} responded for cluster state [{}] (took longer than [{}])",node,clusterState.version(),publishTimeout);
          }
          publishResponseHandler.onResponse(node);
        }
        @Override public void handleException(        TransportException exp){
          logger.debug("failed to send cluster state to {}",exp,node);
          publishResponseHandler.onFailure(node,exp);
        }
      }
);
    }
 catch (    Throwable t) {
      logger.debug("error sending cluster state to {}",t,node);
      publishResponseHandler.onFailure(node,t);
    }
  }
  if (publishTimeout.millis() > 0) {
    try {
      timedOutWaitingForNodes.set(!publishResponseHandler.awaitAllNodes(publishTimeout));
      if (timedOutWaitingForNodes.get()) {
        logger.debug("timed out waiting for all nodes to process published state [{}] (timeout [{}])",clusterState.version(),publishTimeout);
      }
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}
