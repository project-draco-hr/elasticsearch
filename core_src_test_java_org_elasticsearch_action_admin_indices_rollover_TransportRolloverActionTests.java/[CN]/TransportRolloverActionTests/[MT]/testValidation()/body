{
  String index1=randomAsciiOfLength(10);
  String alias=randomAsciiOfLength(10);
  String index2=randomAsciiOfLength(10);
  String aliasWithMultipleIndices=randomAsciiOfLength(10);
  final Settings settings=Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED,Version.CURRENT).put(IndexMetaData.SETTING_INDEX_UUID,UUIDs.randomBase64UUID()).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0).build();
  final MetaData metaData=MetaData.builder().put(IndexMetaData.builder(index1).settings(settings).putAlias(AliasMetaData.builder(alias)).putAlias(AliasMetaData.builder(aliasWithMultipleIndices))).put(IndexMetaData.builder(index2).settings(settings).putAlias(AliasMetaData.builder(aliasWithMultipleIndices))).build();
  try {
    TransportRolloverAction.validate(metaData,new RolloverRequest(aliasWithMultipleIndices));
    fail("expected to throw exception");
  }
 catch (  IllegalArgumentException e) {
    assertThat(e.getMessage(),equalTo("source alias maps to multiple indices"));
  }
  try {
    TransportRolloverAction.validate(metaData,new RolloverRequest(randomFrom(index1,index2)));
    fail("expected to throw exception");
  }
 catch (  IllegalArgumentException e) {
    assertThat(e.getMessage(),equalTo("source alias is a concrete index"));
  }
  try {
    TransportRolloverAction.validate(metaData,new RolloverRequest(randomAsciiOfLength(5)));
    fail("expected to throw exception");
  }
 catch (  IllegalArgumentException e) {
    assertThat(e.getMessage(),equalTo("source alias does not exist"));
  }
  TransportRolloverAction.validate(metaData,new RolloverRequest(alias));
}
