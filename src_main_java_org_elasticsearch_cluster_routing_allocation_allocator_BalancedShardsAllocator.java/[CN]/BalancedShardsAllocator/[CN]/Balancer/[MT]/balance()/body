{
  if (this.nodes.isEmpty()) {
    return false;
  }
  if (logger.isTraceEnabled()) {
    logger.trace("Start balancing cluster");
  }
  boolean changed=initialize(allocation.routingNodes());
  NodeSorter sorter=newNodeSorter();
  if (nodes.size() > 1) {
    for (    String index : buildWeightOrderedIndidces(Operation.BALANCE,sorter)) {
      sorter.reset(Operation.BALANCE,index);
      final float[] weights=sorter.weights;
      final ModelNode[] modelNodes=sorter.modelNodes;
      int lowIdx=0;
      int highIdx=weights.length - 1;
      while (true) {
        final ModelNode minNode=modelNodes[lowIdx];
        final ModelNode maxNode=modelNodes[highIdx];
        if (maxNode.numShards(index) > 0) {
          float delta=weights[highIdx] - weights[lowIdx];
          delta=delta <= threshold ? delta : sorter.weight(Operation.THRESHOLD_CHECK,maxNode) - sorter.weight(Operation.THRESHOLD_CHECK,minNode);
          if (delta <= threshold) {
            if (logger.isTraceEnabled()) {
              logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]",index,maxNode.getNodeId(),weights[highIdx],minNode.getNodeId(),weights[lowIdx],delta);
            }
            break;
          }
          if (logger.isTraceEnabled()) {
            logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",maxNode.getNodeId(),weights[highIdx],minNode.getNodeId(),weights[lowIdx],delta);
          }
          if (tryRelocateShard(Operation.BALANCE,minNode,maxNode,index,delta)) {
            weights[lowIdx]=sorter.weight(Operation.BALANCE,modelNodes[lowIdx]);
            weights[highIdx]=sorter.weight(Operation.BALANCE,modelNodes[highIdx]);
            sorter.sort(0,weights.length);
            lowIdx=0;
            highIdx=weights.length - 1;
            changed=true;
            continue;
          }
        }
        if (lowIdx < highIdx - 1) {
          lowIdx++;
        }
 else         if (lowIdx > 0) {
          lowIdx=0;
          highIdx--;
        }
 else {
          break;
        }
      }
    }
  }
  return changed;
}
