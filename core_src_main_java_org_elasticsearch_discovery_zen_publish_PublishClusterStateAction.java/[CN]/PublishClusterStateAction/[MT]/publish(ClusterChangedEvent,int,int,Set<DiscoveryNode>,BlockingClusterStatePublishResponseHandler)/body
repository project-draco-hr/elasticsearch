{
  Map<Version,BytesReference> serializedStates=Maps.newHashMap();
  Map<Version,BytesReference> serializedDiffs=Maps.newHashMap();
  final ClusterState clusterState=clusterChangedEvent.state();
  final ClusterState previousState=clusterChangedEvent.previousState();
  final TimeValue publishTimeout=discoverySettings.getPublishTimeout();
  final boolean sendFullVersion=!discoverySettings.getPublishDiff() || previousState == null;
  final SendingController sendingController=new SendingController(clusterChangedEvent.state(),minMasterNodes,totalMasterNodes,publishResponseHandler);
  buildDiffAndSerializeStates(clusterState,previousState,nodesToPublishTo,sendFullVersion,serializedStates,serializedDiffs);
  for (  final DiscoveryNode node : nodesToPublishTo) {
    if (sendFullVersion || !previousState.nodes().nodeExists(node.id())) {
      sendFullClusterState(clusterState,serializedStates,node,publishTimeout,sendingController);
    }
 else {
      sendClusterStateDiff(clusterState,serializedDiffs,serializedStates,node,publishTimeout,sendingController);
    }
  }
  sendingController.waitForCommit(discoverySettings.getCommitTimeout());
  if (publishTimeout.millis() > 0) {
    try {
      sendingController.setPublishingTimedOut(!publishResponseHandler.awaitAllNodes(publishTimeout));
      if (sendingController.getPublishingTimedOut()) {
        DiscoveryNode[] pendingNodes=publishResponseHandler.pendingNodes();
        if (pendingNodes.length > 0) {
          logger.warn("timed out waiting for all nodes to process published state [{}] (timeout [{}], pending nodes: {})",clusterState.version(),publishTimeout,pendingNodes);
        }
      }
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}
