{
  if (!running()) {
    return;
  }
  final PingRequest pingRequest=new PingRequest(node.id(),clusterName,localNode,clusterStateVersion);
  final TransportRequestOptions options=options().withType(TransportRequestOptions.Type.PING).withTimeout(pingRetryTimeout);
  transportService.sendRequest(node,PING_ACTION_NAME,pingRequest,options,new BaseTransportResponseHandler<PingResponse>(){
    @Override public PingResponse newInstance(){
      return new PingResponse();
    }
    @Override public void handleResponse(    PingResponse response){
      if (!running()) {
        return;
      }
      retryCount=0;
      threadPool.schedule(pingInterval,ThreadPool.Names.SAME,NodeFD.this);
    }
    @Override public void handleException(    TransportException exp){
      if (!running()) {
        return;
      }
      if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {
        handleTransportDisconnect(node);
        return;
      }
      retryCount++;
      logger.trace("[node  ] failed to ping [{}], retry [{}] out of [{}]",exp,node,retryCount,pingRetryCount);
      if (retryCount >= pingRetryCount) {
        logger.debug("[node  ] failed to ping [{}], tried [{}] times, each with  maximum [{}] timeout",node,pingRetryCount,pingRetryTimeout);
        if (nodesFD.remove(node,NodeFD.this)) {
          notifyNodeFailure(node,"failed to ping, tried [" + pingRetryCount + "] times, each with maximum ["+ pingRetryTimeout+ "] timeout");
        }
      }
 else {
        transportService.sendRequest(node,PING_ACTION_NAME,pingRequest,options,this);
      }
    }
    @Override public String executor(){
      return ThreadPool.Names.SAME;
    }
  }
);
}
