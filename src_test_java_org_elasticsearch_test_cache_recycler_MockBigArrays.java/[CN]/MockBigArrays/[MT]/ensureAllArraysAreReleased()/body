{
  final Map<Object,Object> masterCopy=Maps.newHashMap(ACQUIRED_ARRAYS);
  if (!masterCopy.isEmpty()) {
    boolean success=ElasticsearchTestCase.awaitBusy(new Predicate<Object>(){
      @Override public boolean apply(      Object input){
        return Sets.intersection(masterCopy.keySet(),ACQUIRED_ARRAYS.keySet()).isEmpty();
      }
    }
);
    if (!success) {
      masterCopy.keySet().retainAll(ACQUIRED_ARRAYS.keySet());
      ACQUIRED_ARRAYS.keySet().removeAll(masterCopy.keySet());
      if (!masterCopy.isEmpty()) {
        final Object cause=masterCopy.entrySet().iterator().next().getValue();
        throw new RuntimeException(masterCopy.size() + " arrays have not been released",cause instanceof Throwable ? (Throwable)cause : null);
      }
    }
  }
  ArrayList<BigArrays> badBigArrays=new ArrayList<>();
synchronized (INSTANCES) {
    for (    final BigArrays bigArrays : INSTANCES) {
      final boolean sizeIsZero=ElasticsearchTestCase.awaitBusy(new Predicate<Object>(){
        @Override public boolean apply(        Object input){
          return bigArrays.sizeInBytes() == 0;
        }
      }
);
      if (!sizeIsZero) {
        final long sizeInBytes=bigArrays.sizeInBytes();
        if (sizeInBytes != 0) {
          badBigArrays.add(bigArrays);
        }
      }
    }
  }
  if (!badBigArrays.isEmpty()) {
    INSTANCES.removeAll(badBigArrays);
    StringBuilder msg=new StringBuilder("Found [").append(badBigArrays.size()).append("] big arrays which were not fully released. Here is a list of the first 20:");
    for (int i=0; i < Math.min(20,badBigArrays.size()); i++) {
      msg.append("\nbigArray instance with [").append(badBigArrays.get(i).sizeInBytes()).append("] bytes");
    }
    throw new AssertionError(msg.toString());
  }
}
