{
  final SnapshotId snapshotId=new SnapshotId(request.repository(),request.name());
  clusterService.submitStateUpdateTask(request.cause(),new TimeoutClusterStateUpdateTask(){
    private SnapshotMetaData.Entry newSnapshot=null;
    @Override public ClusterState execute(    ClusterState currentState){
      validate(request,currentState);
      MetaData metaData=currentState.metaData();
      MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
      SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
      if (snapshots == null || snapshots.entries().isEmpty()) {
        ImmutableList<String> indices=ImmutableList.copyOf(metaData.concreteIndices(request.indicesOptions(),request.indices()));
        logger.trace("[{}][{}] creating snapshot for indices [{}]",request.repository(),request.name(),indices);
        newSnapshot=new SnapshotMetaData.Entry(snapshotId,request.includeGlobalState(),State.INIT,indices,System.currentTimeMillis(),null);
        snapshots=new SnapshotMetaData(newSnapshot);
      }
 else {
        throw new ConcurrentSnapshotExecutionException(snapshotId,"a snapshot is already running");
      }
      mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
      return ClusterState.builder(currentState).metaData(mdBuilder).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.warn("[{}][{}] failed to create snapshot",t,request.repository(),request.name());
      newSnapshot=null;
      listener.onFailure(t);
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    final ClusterState newState){
      if (newSnapshot != null) {
        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new Runnable(){
          @Override public void run(){
            beginSnapshot(newState,newSnapshot,request.partial,listener);
          }
        }
);
      }
    }
    @Override public TimeValue timeout(){
      return request.masterNodeTimeout();
    }
  }
);
}
