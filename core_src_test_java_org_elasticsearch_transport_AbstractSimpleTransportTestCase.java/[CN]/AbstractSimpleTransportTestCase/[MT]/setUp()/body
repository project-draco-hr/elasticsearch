{
  super.setUp();
  threadPool=new ThreadPool(getClass().getName());
  serviceA=build(Settings.builder().put("name","TS_A",TransportService.TRACE_LOG_INCLUDE_SETTING.getKey(),"",TransportService.TRACE_LOG_EXCLUDE_SETTING.getKey(),"NOTHING").build(),version0,new NamedWriteableRegistry());
  nodeA=new DiscoveryNode("TS_A","TS_A",serviceA.boundAddress().publishAddress(),emptyMap(),version0);
  serviceB=build(Settings.builder().put("name","TS_B",TransportService.TRACE_LOG_INCLUDE_SETTING.getKey(),"",TransportService.TRACE_LOG_EXCLUDE_SETTING.getKey(),"NOTHING").build(),version1,new NamedWriteableRegistry());
  nodeB=new DiscoveryNode("TS_B","TS_B",serviceB.boundAddress().publishAddress(),emptyMap(),version1);
  final boolean useLocalNode=randomBoolean();
  final CountDownLatch latch=new CountDownLatch(useLocalNode ? 2 : 4);
  TransportConnectionListener waitForConnection=new TransportConnectionListener(){
    @Override public void onNodeConnected(    DiscoveryNode node){
      latch.countDown();
    }
    @Override public void onNodeDisconnected(    DiscoveryNode node){
      fail("disconnect should not be called " + node);
    }
  }
;
  serviceA.addConnectionListener(waitForConnection);
  serviceB.addConnectionListener(waitForConnection);
  if (useLocalNode) {
    logger.info("--> using local node optimization");
    serviceA.setLocalNode(nodeA);
    serviceB.setLocalNode(nodeB);
  }
 else {
    logger.info("--> actively connecting to local node");
    serviceA.connectToNode(nodeA);
    serviceB.connectToNode(nodeB);
  }
  serviceA.connectToNode(nodeB);
  serviceB.connectToNode(nodeA);
  assertThat("failed to wait for all nodes to connect",latch.await(5,TimeUnit.SECONDS),equalTo(true));
  serviceA.removeConnectionListener(waitForConnection);
  serviceB.removeConnectionListener(waitForConnection);
}
