{
  super(shardId,indexSettings);
  ReadWriteLock rwl=new ReentrantReadWriteLock();
  readLock=new ReleasableLock(rwl.readLock());
  writeLock=new ReleasableLock(rwl.writeLock());
  this.durabilty=Durabilty.getFromSettings(logger,indexSettings,durabilty);
  this.indexSettingsService=indexSettingsService;
  this.bigArrays=bigArrays;
  this.location=location;
  Files.createDirectories(this.location);
  this.threadPool=threadPool;
  this.type=TranslogFile.Type.fromString(indexSettings.get(INDEX_TRANSLOG_FS_TYPE,TranslogFile.Type.BUFFERED.name()));
  this.bufferSize=(int)indexSettings.getAsBytesSize(INDEX_TRANSLOG_BUFFER_SIZE,ByteSizeValue.parseBytesSizeValue("64k")).bytes();
  syncInterval=indexSettings.getAsTime(INDEX_TRANSLOG_SYNC_INTERVAL,TimeValue.timeValueSeconds(5));
  if (syncInterval.millis() > 0 && threadPool != null) {
    this.syncOnEachOperation=false;
    syncScheduler=threadPool.schedule(syncInterval,ThreadPool.Names.SAME,new Sync());
  }
 else   if (syncInterval.millis() == 0) {
    this.syncOnEachOperation=true;
  }
  if (indexSettingsService != null) {
    indexSettingsService.addListener(applySettings);
  }
  try {
    recoverFromFiles();
    current=createTranslogFile(null);
  }
 catch (  Throwable t) {
    IOUtils.closeWhileHandlingException(uncommittedTranslogs);
    throw t;
  }
}
