{
  left.analyze(settings,definition,variables);
  right.analyze(settings,definition,variables);
  final Type promote=AnalyzerCaster.promoteNumeric(definition,left.actual,right.actual,true,true);
  if (promote == null) {
    throw new ClassCastException(error("Cannot apply multiply [*] to types " + "[" + left.actual.name + "] and ["+ right.actual.name+ "]."));
  }
  left.expected=promote;
  right.expected=promote;
  left=left.cast(settings,definition,variables);
  right=right.cast(settings,definition,variables);
  if (left.constant != null && right.constant != null) {
    final boolean overflow=settings.getNumericOverflow();
    final Sort sort=promote.sort;
    if (sort == Sort.INT) {
      constant=overflow ? (int)left.constant * (int)right.constant : Math.multiplyExact((int)left.constant,(int)right.constant);
    }
 else     if (sort == Sort.LONG) {
      constant=overflow ? (long)left.constant * (long)right.constant : Math.multiplyExact((long)left.constant,(long)right.constant);
    }
 else     if (sort == Sort.FLOAT) {
      constant=overflow ? (float)left.constant * (float)right.constant : org.elasticsearch.painless.Utility.multiplyWithoutOverflow((float)left.constant,(float)right.constant);
    }
 else     if (sort == Sort.DOUBLE) {
      constant=overflow ? (double)left.constant * (double)right.constant : org.elasticsearch.painless.Utility.multiplyWithoutOverflow((double)left.constant,(double)right.constant);
    }
 else {
      throw new IllegalStateException(error("Illegal tree structure."));
    }
  }
  actual=promote;
}
