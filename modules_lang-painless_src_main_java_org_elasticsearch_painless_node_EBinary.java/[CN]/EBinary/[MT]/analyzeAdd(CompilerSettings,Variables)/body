{
  left.analyze(settings,variables);
  right.analyze(settings,variables);
  final Type promote=AnalyzerCaster.promoteAdd(left.actual,right.actual);
  if (promote == null) {
    throw new ClassCastException(error("Cannot apply add [+] to types " + "[" + left.actual.name + "] and ["+ right.actual.name+ "]."));
  }
  final Sort sort=promote.sort;
  if (sort == Sort.STRING) {
    left.expected=left.actual;
    if (left instanceof EBinary && ((EBinary)left).operation == Operation.ADD && left.actual.sort == Sort.STRING) {
      ((EBinary)left).cat=true;
    }
    right.expected=right.actual;
    if (right instanceof EBinary && ((EBinary)right).operation == Operation.ADD && right.actual.sort == Sort.STRING) {
      ((EBinary)right).cat=true;
    }
  }
 else {
    left.expected=promote;
    right.expected=promote;
  }
  left=left.cast(settings,variables);
  right=right.cast(settings,variables);
  if (left.constant != null && right.constant != null) {
    if (sort == Sort.INT) {
      constant=(int)left.constant + (int)right.constant;
    }
 else     if (sort == Sort.LONG) {
      constant=(long)left.constant + (long)right.constant;
    }
 else     if (sort == Sort.FLOAT) {
      constant=(float)left.constant + (float)right.constant;
    }
 else     if (sort == Sort.DOUBLE) {
      constant=(double)left.constant + (double)right.constant;
    }
 else     if (sort == Sort.STRING) {
      constant="" + left.constant + right.constant;
    }
 else {
      throw new IllegalStateException(error("Illegal tree structure."));
    }
  }
  actual=promote;
}
