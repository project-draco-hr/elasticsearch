{
  IndexService percolateIndexService=indicesService.indexServiceSafe(request.shardId().getIndex());
  IndexShard indexShard=percolateIndexService.getShard(request.shardId().id());
  indexShard.readAllowed();
  PercolatorQueriesRegistry percolateQueryRegistry=indexShard.percolateRegistry();
  percolateQueryRegistry.prePercolate();
  long startTime=System.nanoTime();
  String[] filteringAliases=indexNameExpressionResolver.filteringAliases(clusterService.state(),indexShard.shardId().index().name(),request.indices());
  Query aliasFilter=percolateIndexService.aliasFilter(indexShard.getQueryShardContext(),filteringAliases);
  SearchShardTarget searchShardTarget=new SearchShardTarget(clusterService.localNode().id(),request.shardId().getIndex(),request.shardId().id());
  final PercolateContext context=new PercolateContext(request,searchShardTarget,indexShard,percolateIndexService,pageCacheRecycler,bigArrays,scriptService,aliasFilter,parseFieldMatcher,fetchPhase);
  SearchContext.setCurrent(context);
  try {
    ParsedDocument parsedDocument=percolateDocumentParser.parse(request,context,percolateIndexService.mapperService(),percolateIndexService.getQueryShardContext());
    if (context.searcher().getIndexReader().maxDoc() == 0) {
      return new PercolateShardResponse(Lucene.EMPTY_TOP_DOCS,Collections.emptyMap(),Collections.emptyMap(),context);
    }
    if (context.size() < 0) {
      context.size(0);
    }
    PercolatorIndex percolatorIndex;
    boolean isNested=indexShard.mapperService().documentMapper(request.documentType()).hasNestedObjects();
    if (parsedDocument.docs().size() > 1) {
      assert isNested;
      percolatorIndex=multi;
    }
 else {
      percolatorIndex=single;
    }
    percolatorIndex.prepare(context,parsedDocument);
    BucketCollector aggregatorCollector=null;
    if (context.aggregations() != null) {
      AggregationContext aggregationContext=new AggregationContext(context);
      context.aggregations().aggregationContext(aggregationContext);
      Aggregator[] aggregators=context.aggregations().factories().createTopLevelAggregators();
      List<Aggregator> aggregatorCollectors=new ArrayList<>(aggregators.length);
      for (int i=0; i < aggregators.length; i++) {
        if (!(aggregators[i] instanceof GlobalAggregator)) {
          Aggregator aggregator=aggregators[i];
          aggregatorCollectors.add(aggregator);
        }
      }
      context.aggregations().aggregators(aggregators);
      aggregatorCollector=BucketCollector.wrap(aggregatorCollectors);
      aggregatorCollector.preCollection();
    }
    PercolatorQueriesRegistry queriesRegistry=indexShard.percolateRegistry();
    return doPercolate(context,queriesRegistry,aggregationPhase,aggregatorCollector,highlightPhase);
  }
  finally {
    SearchContext.removeCurrent();
    context.close();
    percolateQueryRegistry.postPercolate(System.nanoTime() - startTime);
  }
}
