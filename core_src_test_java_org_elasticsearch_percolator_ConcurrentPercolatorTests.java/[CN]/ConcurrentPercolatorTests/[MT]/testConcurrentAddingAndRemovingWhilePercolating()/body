{
  assertAcked(prepareCreate("index").addMapping("type","field1","type=string"));
  ensureGreen();
  final int numIndexThreads=scaledRandomIntBetween(1,3);
  final int numberPercolateOperation=scaledRandomIntBetween(10,100);
  final AtomicReference<Throwable> exceptionHolder=new AtomicReference<>(null);
  final AtomicInteger idGen=new AtomicInteger(0);
  final Set<String> liveIds=ConcurrentCollections.newConcurrentSet();
  final AtomicBoolean run=new AtomicBoolean(true);
  Thread[] indexThreads=new Thread[numIndexThreads];
  final Semaphore semaphore=new Semaphore(numIndexThreads,true);
  for (int i=0; i < indexThreads.length; i++) {
    final Random rand=new Random(getRandom().nextLong());
    Runnable r=new Runnable(){
      @Override public void run(){
        try {
          XContentBuilder doc=XContentFactory.jsonBuilder().startObject().field("query",termQuery("field1","value")).endObject();
          outer:           while (run.get()) {
            semaphore.acquire();
            try {
              if (!liveIds.isEmpty() && rand.nextInt(100) < 19) {
                String id;
                do {
                  if (liveIds.isEmpty()) {
                    continue outer;
                  }
                  id=Integer.toString(randomInt(idGen.get()));
                }
 while (!liveIds.remove(id));
                DeleteResponse response=client().prepareDelete("index",PercolatorService.TYPE_NAME,id).execute().actionGet();
                assertThat(response.getId(),equalTo(id));
                assertThat("doc[" + id + "] should have been deleted, but isn't",response.isFound(),equalTo(true));
              }
 else {
                String id=Integer.toString(idGen.getAndIncrement());
                IndexResponse response=client().prepareIndex("index",PercolatorService.TYPE_NAME,id).setSource(doc).execute().actionGet();
                liveIds.add(id);
                assertThat(response.isCreated(),equalTo(true));
                assertThat(response.getId(),equalTo(id));
              }
            }
  finally {
              semaphore.release();
            }
          }
        }
 catch (        InterruptedException iex) {
          logger.error("indexing thread was interrupted...",iex);
          run.set(false);
        }
catch (        Throwable t) {
          run.set(false);
          exceptionHolder.set(t);
          logger.error("Error in indexing thread...",t);
        }
      }
    }
;
    indexThreads[i]=new Thread(r);
    indexThreads[i].start();
  }
  XContentBuilder percolateDoc=XContentFactory.jsonBuilder().startObject().startObject("doc").field("field1","value").endObject().endObject();
  for (int counter=0; counter < numberPercolateOperation; counter++) {
    Thread.sleep(5);
    semaphore.acquire(numIndexThreads);
    try {
      if (!run.get()) {
        break;
      }
      int atLeastExpected=liveIds.size();
      PercolateResponse response=client().preparePercolate().setIndices("index").setDocumentType("type").setSource(percolateDoc).execute().actionGet();
      assertThat(response.getShardFailures(),emptyArray());
      assertThat(response.getSuccessfulShards(),equalTo(response.getTotalShards()));
      assertThat(response.getMatches().length,equalTo(atLeastExpected));
    }
  finally {
      semaphore.release(numIndexThreads);
    }
  }
  run.set(false);
  for (  Thread thread : indexThreads) {
    thread.join();
  }
  assertThat("exceptionHolder should have been empty, but holds: " + exceptionHolder.toString(),exceptionHolder.get(),nullValue());
}
