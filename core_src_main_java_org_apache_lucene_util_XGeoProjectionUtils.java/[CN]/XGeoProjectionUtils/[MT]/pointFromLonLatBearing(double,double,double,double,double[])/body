{
  if (pt == null) {
    pt=new double[2];
  }
  final double alpha1=StrictMath.toRadians(bearing);
  final double cosA1=StrictMath.cos(alpha1);
  final double sinA1=StrictMath.sin(alpha1);
  final double tanU1=(1 - FLATTENING) * StrictMath.tan(StrictMath.toRadians(lat));
  final double cosU1=1 / StrictMath.sqrt((1 + tanU1 * tanU1));
  final double sinU1=tanU1 * cosU1;
  final double sig1=StrictMath.atan2(tanU1,cosA1);
  final double sinAlpha=cosU1 * sinA1;
  final double cosSqAlpha=1 - sinAlpha * sinAlpha;
  final double uSq=cosSqAlpha * (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / SEMIMINOR_AXIS2;
  final double A=1 + uSq / 16384D * (4096D + uSq * (-768D + uSq * (320D - 175D * uSq)));
  final double B=uSq / 1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));
  double sigma=dist / (SEMIMINOR_AXIS * A);
  double sigmaP;
  double sinSigma, cosSigma, cos2SigmaM, deltaSigma;
  do {
    cos2SigmaM=StrictMath.cos(2 * sig1 + sigma);
    sinSigma=StrictMath.sin(sigma);
    cosSigma=StrictMath.cos(sigma);
    deltaSigma=B * sinSigma * (cos2SigmaM + (B / 4D) * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - (B / 6) * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma)* (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    sigmaP=sigma;
    sigma=dist / (SEMIMINOR_AXIS * A) + deltaSigma;
  }
 while (StrictMath.abs(sigma - sigmaP) > 1E-12);
  final double tmp=sinU1 * sinSigma - cosU1 * cosSigma * cosA1;
  final double lat2=StrictMath.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosA1,(1 - FLATTENING) * StrictMath.sqrt(sinAlpha * sinAlpha + tmp * tmp));
  final double lambda=StrictMath.atan2(sinSigma * sinA1,cosU1 * cosSigma - sinU1 * sinSigma * cosA1);
  final double c=FLATTENING / 16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));
  final double lam=lambda - (1 - c) * FLATTENING * sinAlpha* (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  pt[0]=lon + StrictMath.toDegrees(lam);
  pt[1]=StrictMath.toDegrees(lat2);
  return pt;
}
