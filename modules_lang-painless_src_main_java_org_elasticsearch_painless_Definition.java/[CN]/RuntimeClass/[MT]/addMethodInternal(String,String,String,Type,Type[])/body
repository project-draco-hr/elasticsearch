{
  final Struct owner=structsMap.get(struct);
  if (owner == null) {
    throw new IllegalArgumentException("Owner struct [" + struct + "] not defined"+ " for method ["+ name+ "].");
  }
  if (!name.matches("^[_a-zA-Z][_a-zA-Z0-9]*$")) {
    throw new IllegalArgumentException("Invalid method name" + " [" + name + "] with the struct ["+ owner.name+ "].");
  }
  MethodKey methodKey=new MethodKey(name,args.length);
  if (owner.constructors.containsKey(methodKey)) {
    throw new IllegalArgumentException("Constructors and methods" + " may not have the same signature [" + methodKey + "] within the same struct"+ " ["+ owner.name+ "].");
  }
  if (owner.staticMethods.containsKey(methodKey) || owner.methods.containsKey(methodKey)) {
    throw new IllegalArgumentException("Duplicate  method signature [" + methodKey + "] found within the struct ["+ owner.name+ "].");
  }
  final Class<?>[] classes=new Class<?>[args.length];
  for (int count=0; count < classes.length; ++count) {
    classes[count]=args[count].clazz;
  }
  final java.lang.reflect.Method reflect;
  try {
    reflect=owner.clazz.getMethod(alias == null ? name : alias,classes);
  }
 catch (  final NoSuchMethodException exception) {
    throw new IllegalArgumentException("Method [" + (alias == null ? name : alias) + "] not found for class ["+ owner.clazz.getName()+ "]"+ " with arguments "+ Arrays.toString(classes)+ ".");
  }
  if (!reflect.getReturnType().equals(rtn.clazz)) {
    throw new IllegalArgumentException("Specified return type class [" + rtn.clazz + "]"+ " does not match the found return type class ["+ reflect.getReturnType()+ "] for the"+ " method ["+ name+ "]"+ " within the struct ["+ owner.name+ "].");
  }
  final org.objectweb.asm.commons.Method asm=org.objectweb.asm.commons.Method.getMethod(reflect);
  MethodHandle handle;
  try {
    handle=MethodHandles.publicLookup().in(owner.clazz).unreflect(reflect);
  }
 catch (  final IllegalAccessException exception) {
    throw new IllegalArgumentException("Method [" + (alias == null ? name : alias) + "]"+ " not found for class ["+ owner.clazz.getName()+ "]"+ " with arguments "+ Arrays.toString(classes)+ ".");
  }
  final int modifiers=reflect.getModifiers();
  final Method method=new Method(name,owner,rtn,Arrays.asList(args),asm,modifiers,handle);
  if (java.lang.reflect.Modifier.isStatic(modifiers)) {
    owner.staticMethods.put(methodKey,method);
  }
 else {
    owner.methods.put(methodKey,method);
  }
}
