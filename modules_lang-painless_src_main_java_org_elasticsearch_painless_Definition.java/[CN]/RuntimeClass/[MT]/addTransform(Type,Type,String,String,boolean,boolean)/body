{
  final Struct owner=structsMap.get(struct);
  if (owner == null) {
    throw new IllegalArgumentException("Owner struct [" + struct + "] not defined for"+ " transform with cast type from ["+ from.name+ "] and cast type to ["+ to.name+ "].");
  }
  if (from.equals(to)) {
    throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "] cannot"+ " have cast type from ["+ from.name+ "] be the same as cast type to ["+ to.name+ "].");
  }
  final Cast cast=new Cast(from,to,explicit);
  if (transformsMap.containsKey(cast)) {
    throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] already defined.");
  }
  final Cast transform;
  final Method method;
  Type upcast=null;
  Type downcast=null;
  final MethodKey methodKey=new MethodKey(name,statik ? 1 : 0);
  if (statik) {
    method=owner.staticMethods.get(methodKey);
    if (method == null) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using a function ["+ name+ "] that is not defined.");
    }
    if (method.arguments.size() != 1) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using function ["+ name+ "] does not have a single type argument.");
    }
    Type argument=method.arguments.get(0);
    if (!argument.clazz.isAssignableFrom(from.clazz)) {
      if (from.clazz.isAssignableFrom(argument.clazz)) {
        upcast=argument;
      }
 else {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using"+ " function ["+ name+ "] cannot cast from type to the function input argument type.");
      }
    }
    final Type rtn=method.rtn;
    if (!to.clazz.isAssignableFrom(rtn.clazz)) {
      if (rtn.clazz.isAssignableFrom(to.clazz)) {
        downcast=to;
      }
 else {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using"+ " function ["+ name+ "] cannot cast to type to the function return argument type.");
      }
    }
  }
 else {
    method=owner.methods.get(methodKey);
    if (method == null) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using a method ["+ name+ "] that is not defined.");
    }
    if (!method.arguments.isEmpty()) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using method ["+ name+ "] does not have a single type argument.");
    }
    if (!owner.clazz.isAssignableFrom(from.clazz)) {
      if (from.clazz.isAssignableFrom(owner.clazz)) {
        upcast=getTypeInternal(owner.name);
      }
 else {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using"+ " method ["+ name+ "] cannot cast from type to the method input argument type.");
      }
    }
    final Type rtn=method.rtn;
    if (!to.clazz.isAssignableFrom(rtn.clazz)) {
      if (rtn.clazz.isAssignableFrom(to.clazz)) {
        downcast=to;
      }
 else {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "]"+ " using method ["+ name+ "] cannot cast to type to the method return argument type.");
      }
    }
  }
  transform=new Transform(cast,method,upcast,downcast);
  transformsMap.put(cast,transform);
}
