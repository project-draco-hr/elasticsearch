{
  final DeleteIndexListener listener=new DeleteIndexListener(mdLock,userListener);
  clusterService.submitStateUpdateTask("delete-index [" + request.index + "]",Priority.URGENT,new TimeoutClusterStateUpdateTask(){
    @Override public TimeValue timeout(){
      return request.masterTimeout;
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    final ClusterState currentState){
      if (!currentState.metaData().hasConcreteIndex(request.index)) {
        throw new IndexNotFoundException(request.index);
      }
      logger.info("[{}] deleting index",request.index);
      RoutingTable.Builder routingTableBuilder=RoutingTable.builder(currentState.routingTable());
      routingTableBuilder.remove(request.index);
      MetaData newMetaData=MetaData.builder(currentState.metaData()).remove(request.index).build();
      RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder(currentState).routingTable(routingTableBuilder).metaData(newMetaData).build());
      ClusterBlocks blocks=ClusterBlocks.builder().blocks(currentState.blocks()).removeIndexBlocks(request.index).build();
      int count=currentState.nodes().size();
      count+=currentState.nodes().dataNodes().size();
      final AtomicInteger counter=new AtomicInteger(count);
      final NodeIndexDeletedAction.Listener nodeIndexDeleteListener=new NodeIndexDeletedAction.Listener(){
        @Override public void onNodeIndexDeleted(        String index,        String nodeId){
          if (index.equals(request.index)) {
            if (counter.decrementAndGet() == 0) {
              listener.onResponse(new Response(true));
              nodeIndexDeletedAction.remove(this);
            }
          }
        }
        @Override public void onNodeIndexStoreDeleted(        String index,        String nodeId){
          if (index.equals(request.index)) {
            if (counter.decrementAndGet() == 0) {
              listener.onResponse(new Response(true));
              nodeIndexDeletedAction.remove(this);
            }
          }
        }
      }
;
      nodeIndexDeletedAction.add(nodeIndexDeleteListener);
      listener.future=threadPool.schedule(request.timeout,ThreadPool.Names.SAME,new Runnable(){
        @Override public void run(){
          listener.onResponse(new Response(false));
          nodeIndexDeletedAction.remove(nodeIndexDeleteListener);
        }
      }
);
      return ClusterState.builder(currentState).routingResult(routingResult).metaData(newMetaData).blocks(blocks).build();
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
    }
  }
);
}
