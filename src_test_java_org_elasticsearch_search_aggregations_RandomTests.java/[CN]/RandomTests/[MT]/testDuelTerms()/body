{
  final int numDocs=atLeast(1000);
  final int maxNumTerms=randomIntBetween(10,10000);
  final IntOpenHashSet valuesSet=new IntOpenHashSet();
  wipeIndices("idx");
  prepareCreate("idx").addMapping("type",jsonBuilder().startObject().startObject("type").startObject("properties").startObject("string_values").field("type","string").field("index","not_analyzed").endObject().startObject("long_values").field("type","long").endObject().startObject("double_values").field("type","double").endObject().endObject().endObject()).execute().actionGet();
  for (int i=0; i < numDocs; ++i) {
    final int[] values=new int[randomInt(4)];
    for (int j=0; j < values.length; ++j) {
      values[j]=randomInt(maxNumTerms - 1) - 1000;
      valuesSet.add(values[j]);
    }
    XContentBuilder source=jsonBuilder().startObject().field("num",randomDouble()).startArray("long_values");
    for (int j=0; j < values.length; ++j) {
      source=source.value(values[j]);
    }
    source=source.endArray().startArray("double_values");
    for (int j=0; j < values.length; ++j) {
      source=source.value((double)values[j]);
    }
    source=source.endArray().startArray("string_values");
    for (int j=0; j < values.length; ++j) {
      source=source.value(Integer.toString(values[j]));
    }
    source=source.endArray().endObject();
    client().prepareIndex("idx","type").setSource(source).execute().actionGet();
  }
  assertNoFailures(client().admin().indices().prepareRefresh("idx").setIndicesOptions(IndicesOptions.lenient()).execute().get());
  SearchResponse resp=client().prepareSearch("idx").addAggregation(terms("long").field("long_values").size(maxNumTerms).subAggregation(min("min").field("num"))).addAggregation(terms("double").field("double_values").size(maxNumTerms).subAggregation(max("max").field("num"))).addAggregation(terms("string_map").field("string_values").executionHint(TermsAggregatorFactory.EXECUTION_HINT_VALUE_MAP).size(maxNumTerms).subAggregation(stats("stats").field("num"))).addAggregation(terms("string_ordinals").field("string_values").executionHint(TermsAggregatorFactory.EXECUTION_HINT_VALUE_ORDINALS).size(maxNumTerms).subAggregation(extendedStats("stats").field("num"))).execute().actionGet();
  assertEquals(0,resp.getFailedShards());
  final Terms longTerms=resp.getAggregations().get("long");
  final Terms doubleTerms=resp.getAggregations().get("double");
  final Terms stringMapTerms=resp.getAggregations().get("string_map");
  final Terms stringOrdinalsTerms=resp.getAggregations().get("string_ordinals");
  assertEquals(valuesSet.size(),longTerms.buckets().size());
  assertEquals(valuesSet.size(),doubleTerms.buckets().size());
  assertEquals(valuesSet.size(),stringMapTerms.buckets().size());
  assertEquals(valuesSet.size(),stringOrdinalsTerms.buckets().size());
  for (  Terms.Bucket bucket : longTerms.buckets()) {
    final Terms.Bucket doubleBucket=doubleTerms.getByTerm(Double.toString(Long.parseLong(bucket.getKey().string())));
    final Terms.Bucket stringMapBucket=stringMapTerms.getByTerm(bucket.getKey().string());
    final Terms.Bucket stringOrdinalsBucket=stringOrdinalsTerms.getByTerm(bucket.getKey().string());
    assertNotNull(doubleBucket);
    assertNotNull(stringMapBucket);
    assertNotNull(stringOrdinalsBucket);
    assertEquals(bucket.getDocCount(),doubleBucket.getDocCount());
    assertEquals(bucket.getDocCount(),stringMapBucket.getDocCount());
    assertEquals(bucket.getDocCount(),stringOrdinalsBucket.getDocCount());
  }
}
