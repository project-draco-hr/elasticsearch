{
  createIndex("idx");
  final int numDocs=atLeast(1000);
  final int maxNumTerms=randomIntBetween(10,2000);
  final int interval=randomIntBetween(1,100);
  final Integer[] values=new Integer[maxNumTerms];
  for (int i=0; i < values.length; ++i) {
    values[i]=randomInt(maxNumTerms * 3) - maxNumTerms;
  }
  for (int i=0; i < numDocs; ++i) {
    XContentBuilder source=jsonBuilder().startObject().field("num",randomDouble()).startArray("values");
    final int numValues=randomInt(4);
    for (int j=0; j < numValues; ++j) {
      source=source.value(randomFrom(values));
    }
    source=source.endArray().endObject();
    client().prepareIndex("idx","type").setSource(source).execute().actionGet();
  }
  assertNoFailures(client().admin().indices().prepareRefresh("idx").setIndicesOptions(IndicesOptions.lenient()).execute().get());
  SearchResponse resp=client().prepareSearch("idx").addAggregation(terms("terms").field("values").script("floor(_value / interval)").param("interval",interval).size(maxNumTerms)).addAggregation(histogram("histo").field("values").interval(interval)).execute().actionGet();
  assertThat(resp.getFailedShards(),equalTo(0));
  Terms terms=resp.getAggregations().get("terms");
  assertThat(terms,notNullValue());
  Histogram histo=resp.getAggregations().get("histo");
  assertThat(histo,notNullValue());
  assertThat(terms.getBuckets().size(),equalTo(histo.getBuckets().size()));
  for (  Terms.Bucket bucket : terms.getBuckets()) {
    final long key=bucket.getKeyAsNumber().longValue() * interval;
    final Histogram.Bucket histoBucket=histo.getBucketByKey(key);
    assertEquals(bucket.getDocCount(),histoBucket.getDocCount());
  }
}
