{
  boolean success=false;
  ArrayList<ImmutableTranslogReader> foundTranslogs=new ArrayList<>();
  final Path tempFile=Files.createTempFile(location,TRANSLOG_FILE_PREFIX,TRANSLOG_FILE_SUFFIX);
  boolean tempFileRenamed=false;
  try (ReleasableLock lock=writeLock.acquire()){
    logger.debug("open uncommitted translog checkpoint {}",checkpoint);
    final String checkpointTranslogFile=getFilename(checkpoint.generation);
    for (long i=translogGeneration.translogFileGeneration; i < checkpoint.generation; i++) {
      Path committedTranslogFile=location.resolve(getFilename(i));
      if (Files.exists(committedTranslogFile) == false) {
        throw new IllegalStateException("translog file doesn't exist with generation: " + i + " lastCommitted: "+ lastCommittedTranslogFileGeneration+ " checkpoint: "+ checkpoint.generation+ " - translog ids must be consecutive");
      }
      final ImmutableTranslogReader reader=openReader(committedTranslogFile,Checkpoint.read(location.resolve(getCommitCheckpointFileName(i))));
      foundTranslogs.add(reader);
      logger.debug("recovered local translog from checkpoint {}",checkpoint);
    }
    foundTranslogs.add(openReader(location.resolve(checkpointTranslogFile),checkpoint));
    Path commitCheckpoint=location.resolve(getCommitCheckpointFileName(checkpoint.generation));
    if (Files.exists(commitCheckpoint)) {
      Checkpoint checkpointFromDisk=Checkpoint.read(commitCheckpoint);
      if (checkpoint.equals(checkpointFromDisk) == false) {
        throw new IllegalStateException("Checkpoint file " + commitCheckpoint.getFileName() + " already exists but has corrupted content expected: "+ checkpoint+ " but got: "+ checkpointFromDisk);
      }
    }
 else {
      Files.copy(location.resolve(CHECKPOINT_FILE_NAME),tempFile,StandardCopyOption.REPLACE_EXISTING);
      IOUtils.fsync(tempFile,false);
      Files.move(tempFile,commitCheckpoint,StandardCopyOption.ATOMIC_MOVE);
      tempFileRenamed=true;
      IOUtils.fsync(commitCheckpoint.getParent(),true);
    }
    success=true;
  }
  finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(foundTranslogs);
    }
    if (tempFileRenamed == false) {
      try {
        Files.delete(tempFile);
      }
 catch (      IOException ex) {
        logger.warn("failed to delete temp file {}",ex,tempFile);
      }
    }
  }
  return foundTranslogs;
}
