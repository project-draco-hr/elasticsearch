{
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicReference<Throwable> error=new AtomicReference<>();
  mappingUpdatedAction.updateMappingOnMaster(indexName,type,update,waitForMappingUpdatePostRecovery,new MappingUpdatedAction.MappingUpdateListener(){
    @Override public void onMappingUpdate(){
      latch.countDown();
    }
    @Override public void onFailure(    Throwable t){
      latch.countDown();
      error.set(t);
    }
  }
);
  cancellableThreads.execute(new CancellableThreads.Interruptable(){
    @Override public void run() throws InterruptedException {
      try {
        if (latch.await(waitForMappingUpdatePostRecovery.millis(),TimeUnit.MILLISECONDS) == false) {
          logger.debug("waited for mapping update on master for [{}], yet timed out",type);
        }
 else {
          if (error.get() != null) {
            throw new IndexShardRecoveryException(shardId,"Failed to propagate mappings on master post recovery",error.get());
          }
        }
      }
 catch (      InterruptedException e) {
        logger.debug("interrupted while waiting for mapping update");
        throw e;
      }
    }
  }
);
}
