{
  indexShard.prepareForIndexRecovery();
  long version=-1;
  final Map<String,Mapping> typesToUpdate;
  SegmentInfos si=null;
  final Store store=indexShard.store();
  store.incRef();
  try {
    try {
      store.failIfCorrupted();
      try {
        si=store.readLastCommittedSegmentsInfo();
      }
 catch (      Throwable e) {
        String files="_unknown_";
        try {
          files=Arrays.toString(store.directory().listAll());
        }
 catch (        Throwable e1) {
          files+=" (failure=" + ExceptionsHelper.detailedMessage(e1) + ")";
        }
        if (indexShouldExists) {
          throw new IndexShardRecoveryException(shardId(),"shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files,e);
        }
      }
      if (si != null) {
        if (indexShouldExists) {
          version=si.getVersion();
        }
 else {
          logger.trace("cleaning existing shard, shouldn't exists");
          IndexWriter writer=new IndexWriter(store.directory(),new IndexWriterConfig(Lucene.STANDARD_ANALYZER).setOpenMode(IndexWriterConfig.OpenMode.CREATE));
          writer.close();
          recoveryState.getTranslog().totalOperations(0);
        }
      }
    }
 catch (    Throwable e) {
      throw new IndexShardRecoveryException(shardId(),"failed to fetch index version after copying it over",e);
    }
    recoveryState.getIndex().updateVersion(version);
    try {
      final RecoveryState.Index index=recoveryState.getIndex();
      if (si != null) {
        final Directory directory=store.directory();
        for (        String name : Lucene.files(si)) {
          long length=directory.fileLength(name);
          index.addFileDetail(name,length,true);
        }
      }
    }
 catch (    IOException e) {
      logger.debug("failed to list file details",e);
    }
    if (indexShouldExists == false) {
      recoveryState.getTranslog().totalOperations(0);
      recoveryState.getTranslog().totalOperationsOnStart(0);
    }
    typesToUpdate=indexShard.performTranslogRecovery();
    indexShard.finalizeRecovery();
    String indexName=indexShard.shardId().index().name();
    for (    Map.Entry<String,Mapping> entry : typesToUpdate.entrySet()) {
      validateMappingUpdate(indexName,entry.getKey(),entry.getValue());
    }
    indexShard.postRecovery("post recovery from shard_store");
  }
 catch (  EngineException e) {
    throw new IndexShardRecoveryException(shardId,"failed to recovery from gateway",e);
  }
 finally {
    store.decRef();
  }
}
