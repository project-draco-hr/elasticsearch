{
  if (closed.compareAndSet(false,true)) {
    final Set<Integer> shardIds=shardIds();
    final CountDownLatch latch=new CountDownLatch(shardIds.size());
    final IndicesService.IndexCloseListener innerListener=listener == null ? null : new PerShardIndexCloseListener(shardIds,listener);
    for (    final int shardId : shardIds) {
      executor=executor == null ? threadPool.generic() : executor;
      executor.execute(new AbstractRunnable(){
        @Override public void onFailure(        Throwable t){
          logger.warn("failed to close shard",t);
        }
        @Override public void doRun(){
          try {
            removeShard(shardId,reason,innerListener);
          }
  finally {
            latch.countDown();
          }
        }
      }
);
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      logger.debug("Interrupted closing index [{}]",e,index().name());
      Thread.currentThread().interrupt();
    }
  }
}
