{
  Injector shardInjector;
  IndexShard indexShard;
synchronized (this) {
    Map<Integer,Injector> tmpShardInjectors=newHashMap(shardsInjectors);
    shardInjector=tmpShardInjectors.remove(shardId);
    if (shardInjector == null) {
      if (!delete) {
        return;
      }
      throw new IndexShardMissingException(new ShardId(index,shardId));
    }
    shardsInjectors=ImmutableMap.copyOf(tmpShardInjectors);
    if (delete) {
      logger.debug("deleting shard_id [{}]",shardId);
    }
    Map<Integer,IndexShard> tmpShardsMap=newHashMap(shards);
    indexShard=tmpShardsMap.remove(shardId);
    shards=ImmutableMap.copyOf(tmpShardsMap);
  }
  ShardId sId=new ShardId(index,shardId);
  indicesLifecycle.beforeIndexShardClosed(sId,indexShard,delete);
  for (  Class<? extends CloseableIndexComponent> closeable : pluginsService.shardServices()) {
    try {
      shardInjector.getInstance(closeable).close(delete);
    }
 catch (    Exception e) {
      logger.debug("failed to clean plugin shard service [{}]",e,closeable);
    }
  }
  try {
    shardInjector.getInstance(TranslogService.class).close();
  }
 catch (  Exception e) {
    logger.debug("failed to close translog service",e);
  }
  if (indexShard != null) {
    try {
      ((InternalIndexShard)indexShard).close(reason);
    }
 catch (    Exception e) {
      logger.debug("failed to close index shard",e);
    }
  }
  try {
    shardInjector.getInstance(Engine.class).close();
  }
 catch (  Exception e) {
    logger.debug("failed to close engine",e);
  }
  try {
    shardInjector.getInstance(MergePolicyProvider.class).close(delete);
  }
 catch (  Exception e) {
    logger.debug("failed to close merge policy provider",e);
  }
  try {
    if (snapshotGateway) {
      shardInjector.getInstance(IndexShardGatewayService.class).snapshotOnClose();
    }
  }
 catch (  Exception e) {
    logger.debug("failed to snapshot gateway on close",e);
  }
  try {
    shardInjector.getInstance(IndexShardGatewayService.class).close(deleteGateway);
  }
 catch (  Exception e) {
    logger.debug("failed to close index shard gateway",e);
  }
  try {
    shardInjector.getInstance(Translog.class).close(delete);
  }
 catch (  Exception e) {
    logger.debug("failed to close translog",e);
  }
  indicesLifecycle.afterIndexShardClosed(sId,delete);
  Store store=shardInjector.getInstance(Store.class);
  if (delete || indexGateway.type().equals(NoneGateway.TYPE) || !indexStore.persistent()) {
    try {
      store.fullDelete();
    }
 catch (    IOException e) {
      logger.warn("failed to clean store on shard deletion",e);
    }
  }
  try {
    store.close();
  }
 catch (  IOException e) {
    logger.warn("failed to close store on shard deletion",e);
  }
  Injectors.close(injector);
  if (delete || indexGateway.type().equals(NoneGateway.TYPE)) {
    FileSystemUtils.deleteRecursively(nodeEnv.shardLocations(sId));
  }
}
