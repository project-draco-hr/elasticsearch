{
  boolean listenerPassed=false;
  final ShardId sId=new ShardId(index,shardId);
  try {
    final Injector shardInjector;
    final IndexShard indexShard;
    Map<Integer,Injector> tmpShardInjectors=newHashMap(shardsInjectors);
    shardInjector=tmpShardInjectors.remove(shardId);
    if (shardInjector == null) {
      return;
    }
    logger.debug("[{}] closing... (reason: [{}])",shardId,reason);
    shardsInjectors=ImmutableMap.copyOf(tmpShardInjectors);
    Map<Integer,IndexShard> tmpShardsMap=newHashMap(shards);
    indexShard=tmpShardsMap.remove(shardId);
    shards=ImmutableMap.copyOf(tmpShardsMap);
    indicesLifecycle.beforeIndexShardClosed(sId,indexShard);
    for (    Class<? extends Closeable> closeable : pluginsService.shardServices()) {
      try {
        shardInjector.getInstance(closeable).close();
      }
 catch (      Throwable e) {
        logger.debug("[{}] failed to clean plugin shard service [{}]",e,shardId,closeable);
      }
    }
    try {
      shardInjector.getInstance(TranslogService.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close translog service",e,shardId);
    }
    if (indexShard != null) {
      try {
        ((InternalIndexShard)indexShard).close(reason);
      }
 catch (      Throwable e) {
        logger.debug("[{}] failed to close index shard",e,shardId);
      }
    }
    try {
      shardInjector.getInstance(Engine.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close engine",e,shardId);
    }
    try {
      shardInjector.getInstance(MergeSchedulerProvider.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close merge policy scheduler",e,shardId);
    }
    try {
      shardInjector.getInstance(MergePolicyProvider.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close merge policy provider",e,shardId);
    }
    try {
      shardInjector.getInstance(IndexShardGatewayService.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close index shard gateway",e,shardId);
    }
    try {
      shardInjector.getInstance(Translog.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close translog",e,shardId);
    }
    try {
      shardInjector.getInstance(PercolatorQueriesRegistry.class).close();
    }
 catch (    Throwable e) {
      logger.debug("[{}] failed to close PercolatorQueriesRegistry",e,shardId);
    }
    indicesLifecycle.afterIndexShardClosed(sId,indexShard);
    final Store store=shardInjector.getInstance(Store.class);
    try {
      listenerPassed=true;
      if (listener == null) {
        store.close();
      }
 else {
        store.close(new Store.OnCloseListener(){
          @Override public void onClose(          ShardId shardId){
            listener.onShardClosed(shardId);
          }
        }
);
      }
    }
 catch (    Throwable e) {
      logger.warn("[{}] failed to close store on shard deletion",e,shardId);
    }
    Injectors.close(injector);
    logger.debug("[{}] closed (reason: [{}])",shardId,reason);
  }
 catch (  Throwable t) {
    if (listenerPassed == false && listener != null) {
      listener.onShardCloseFailed(sId,t);
    }
    throw t;
  }
}
