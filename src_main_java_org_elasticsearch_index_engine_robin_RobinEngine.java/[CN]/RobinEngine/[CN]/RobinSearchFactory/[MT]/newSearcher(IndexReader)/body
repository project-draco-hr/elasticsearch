{
  IndexSearcher searcher=new IndexSearcher(reader);
  searcher.setSimilarity(similarityService.defaultSearchSimilarity());
  if (warmer != null) {
    Searcher currentSearcher=null;
    IndexSearcher newSearcher=null;
    boolean closeNewSearcher=false;
    try {
      if (searcherManager == null) {
        newSearcher=searcher;
      }
 else {
        currentSearcher=searcher();
        List<IndexReader> readers=Lists.newArrayList();
        for (        AtomicReaderContext newReaderContext : searcher.getIndexReader().leaves()) {
          boolean found=false;
          for (          AtomicReaderContext currentReaderContext : currentSearcher.reader().leaves()) {
            if (currentReaderContext.reader().getCoreCacheKey().equals(newReaderContext.reader().getCoreCacheKey())) {
              found=true;
              break;
            }
          }
          if (!found) {
            readers.add(newReaderContext.reader());
          }
        }
        if (!readers.isEmpty()) {
          newSearcher=new IndexSearcher(new MultiReader(readers.toArray(new IndexReader[readers.size()]),false));
          closeNewSearcher=true;
        }
      }
      if (newSearcher != null) {
        IndicesWarmer.WarmerContext context=new IndicesWarmer.WarmerContext(shardId,new SimpleSearcher(searcher),new SimpleSearcher(newSearcher));
        warmer.warm(context);
      }
    }
 catch (    Exception e) {
      if (!closed) {
        logger.warn("failed to prepare/warm",e);
      }
    }
 finally {
      if (currentSearcher != null) {
        currentSearcher.release();
      }
      if (newSearcher != null && closeNewSearcher) {
        try {
          newSearcher.getIndexReader().close();
        }
 catch (        IOException e) {
        }
      }
    }
  }
  return searcher;
}
