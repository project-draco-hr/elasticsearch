{
  if (indexWriter == null) {
    throw new EngineClosedException(shardId,failedEngine);
  }
  if (flush.type() == Flush.Type.NEW_WRITER || flush.type() == Flush.Type.COMMIT_TRANSLOG) {
    if (onGoingRecoveries > 0) {
      throw new FlushNotAllowedEngineException(shardId,"recovery is in progress, flush [" + flush.type() + "] is not allowed");
    }
  }
  int currentFlushing=flushing.incrementAndGet();
  if (currentFlushing > 1 && !flush.waitIfOngoing()) {
    flushing.decrementAndGet();
    throw new FlushNotAllowedEngineException(shardId,"already flushing...");
  }
  flushLock.lock();
  try {
    if (flush.type() == Flush.Type.NEW_WRITER) {
      rwl.writeLock().lock();
      try {
        if (indexWriter == null) {
          throw new EngineClosedException(shardId,failedEngine);
        }
        if (onGoingRecoveries > 0) {
          throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
        }
        dirty=false;
        try {
          indexWriter.close(false);
          indexWriter=createWriter();
          if (flushNeeded || flush.force()) {
            flushNeeded=false;
            long translogId=translogIdGenerator.incrementAndGet();
            indexWriter.commit(MapBuilder.<String,String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)).map());
            translog.newTranslog(translogId);
          }
          SearcherManager current=this.searcherManager;
          this.searcherManager=buildSearchManager(indexWriter);
          current.close();
          refreshVersioningTable(threadPool.estimatedTimeInMillis());
        }
 catch (        OutOfMemoryError e) {
          failEngine(e);
          throw new FlushFailedEngineException(shardId,e);
        }
catch (        IllegalStateException e) {
          if (e.getMessage().contains("OutOfMemoryError")) {
            failEngine(e);
          }
          throw new FlushFailedEngineException(shardId,e);
        }
catch (        Exception e) {
          throw new FlushFailedEngineException(shardId,e);
        }
      }
  finally {
        rwl.writeLock().unlock();
      }
    }
 else     if (flush.type() == Flush.Type.COMMIT_TRANSLOG) {
      boolean makeTransientCurrent=false;
      rwl.readLock().lock();
      try {
        if (indexWriter == null) {
          throw new EngineClosedException(shardId,failedEngine);
        }
        if (onGoingRecoveries > 0) {
          throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
        }
        if (flushNeeded || flush.force()) {
          flushNeeded=false;
          try {
            long translogId=translogIdGenerator.incrementAndGet();
            translog.newTransientTranslog(translogId);
            indexWriter.commit(MapBuilder.<String,String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)).map());
            if (flush.force()) {
              Map<String,String> commitUserData=getCommitUserData(store.directory());
              long committedTranslogId=Long.parseLong(commitUserData.get(Translog.TRANSLOG_ID_KEY));
              if (committedTranslogId != translogId) {
                translog.revertTransient();
              }
 else {
                makeTransientCurrent=true;
              }
            }
 else {
              makeTransientCurrent=true;
            }
            if (makeTransientCurrent) {
              refreshVersioningTable(threadPool.estimatedTimeInMillis());
              translog.makeTransientCurrent();
            }
          }
 catch (          OutOfMemoryError e) {
            translog.revertTransient();
            failEngine(e);
            throw new FlushFailedEngineException(shardId,e);
          }
catch (          IllegalStateException e) {
            if (e.getMessage().contains("OutOfMemoryError")) {
              failEngine(e);
            }
            throw new FlushFailedEngineException(shardId,e);
          }
catch (          Exception e) {
            translog.revertTransient();
            throw new FlushFailedEngineException(shardId,e);
          }
        }
      }
  finally {
        rwl.readLock().unlock();
      }
    }
 else     if (flush.type() == Flush.Type.COMMIT) {
      rwl.readLock().lock();
      try {
        if (indexWriter == null) {
          throw new EngineClosedException(shardId,failedEngine);
        }
        try {
          long translogId=translog.currentId();
          indexWriter.commit(MapBuilder.<String,String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)).map());
        }
 catch (        OutOfMemoryError e) {
          translog.revertTransient();
          failEngine(e);
          throw new FlushFailedEngineException(shardId,e);
        }
catch (        IllegalStateException e) {
          if (e.getMessage().contains("OutOfMemoryError")) {
            failEngine(e);
          }
          throw new FlushFailedEngineException(shardId,e);
        }
catch (        Exception e) {
          throw new FlushFailedEngineException(shardId,e);
        }
      }
  finally {
        rwl.readLock().unlock();
      }
    }
 else {
      throw new ElasticSearchIllegalStateException("flush type [" + flush.type() + "] not supported");
    }
    try {
      SegmentInfos infos=new SegmentInfos();
      infos.read(store.directory());
      lastCommittedSegmentInfos=infos;
    }
 catch (    Exception e) {
      if (!closed) {
        logger.warn("failed to read latest segment infos on flush",e);
      }
    }
  }
  finally {
    flushLock.unlock();
    flushing.decrementAndGet();
  }
}
