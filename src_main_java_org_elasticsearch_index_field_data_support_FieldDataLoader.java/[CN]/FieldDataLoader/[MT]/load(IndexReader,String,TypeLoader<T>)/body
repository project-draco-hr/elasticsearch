{
  loader.init();
  field=StringHelper.intern(field);
  ArrayList<int[]> ordinals=new ArrayList<int[]>();
  int[] idx=new int[reader.maxDoc()];
  ordinals.add(new int[reader.maxDoc()]);
  int t=1;
  TermDocs termDocs=reader.termDocs();
  TermEnum termEnum=reader.terms(new Term(field));
  try {
    int size=Math.min(128,reader.maxDoc());
    int[] docs=new int[size];
    int[] freqs=new int[size];
    do {
      Term term=termEnum.term();
      if (term == null || term.field() != field)       break;
      loader.collectTerm(term.text());
      termDocs.seek(termEnum);
      int number=termDocs.read(docs,freqs);
      while (number > 0) {
        for (int i=0; i < number; i++) {
          int doc=docs[i];
          int[] ordinal;
          if (idx[doc] >= ordinals.size()) {
            ordinal=new int[reader.maxDoc()];
            ordinals.add(ordinal);
          }
 else {
            ordinal=ordinals.get(idx[doc]);
          }
          ordinal[doc]=t;
          idx[doc]++;
        }
        number=termDocs.read(docs,freqs);
      }
      t++;
    }
 while (termEnum.next());
  }
 catch (  RuntimeException e) {
    if (e.getClass().getName().endsWith("StopFillCacheException")) {
    }
 else {
      throw e;
    }
  }
 finally {
    termDocs.close();
    termEnum.close();
  }
  if (ordinals.size() == 1) {
    return loader.buildSingleValue(field,ordinals.get(0));
  }
 else {
    int[][] nativeOrdinals=new int[ordinals.size()][];
    for (int i=0; i < nativeOrdinals.length; i++) {
      nativeOrdinals[i]=ordinals.get(i);
    }
    return loader.buildMultiValue(field,nativeOrdinals);
  }
}
