{
  createIndex();
  final RecoveriesCollection collection=new RecoveriesCollection(logger,getInstanceFromNode(ThreadPool.class));
  final AtomicBoolean failed=new AtomicBoolean();
  final CountDownLatch latch=new CountDownLatch(1);
  final long recoveryId=startRecovery(collection,new RecoveryTarget.RecoveryListener(){
    @Override public void onRecoveryDone(    RecoveryState state){
      latch.countDown();
    }
    @Override public void onRecoveryFailure(    RecoveryState state,    RecoveryFailedException e,    boolean sendShardFailure){
      failed.set(true);
      latch.countDown();
    }
  }
,TimeValue.timeValueMillis(100));
  try {
    latch.await(30,TimeUnit.SECONDS);
    assertTrue("recovery failed to timeout",failed.get());
  }
  finally {
    collection.cancelRecovery(recoveryId,"meh");
  }
}
