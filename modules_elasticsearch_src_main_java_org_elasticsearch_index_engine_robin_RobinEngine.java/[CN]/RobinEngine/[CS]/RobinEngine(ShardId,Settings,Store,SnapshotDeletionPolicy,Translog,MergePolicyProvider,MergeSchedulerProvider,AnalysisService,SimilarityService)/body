{
  super(shardId,indexSettings);
  Preconditions.checkNotNull(store,"Store must be provided to the engine");
  Preconditions.checkNotNull(deletionPolicy,"Snapshot deletion policy must be provided to the engine");
  Preconditions.checkNotNull(translog,"Translog must be provided to the engine");
  this.ramBufferSize=componentSettings.getAsSize("ram_buffer_size",new SizeValue(64,SizeUnit.MB));
  this.refreshInterval=componentSettings.getAsTime("refresh_interval",timeValueSeconds(1));
  this.termIndexInterval=componentSettings.getAsInt("term_index_interval",IndexWriter.DEFAULT_TERM_INDEX_INTERVAL);
  this.store=store;
  this.deletionPolicy=deletionPolicy;
  this.translog=translog;
  this.mergePolicyProvider=mergePolicyProvider;
  this.mergeScheduler=mergeScheduler;
  this.analysisService=analysisService;
  this.similarityService=similarityService;
  try {
    if (IndexWriter.isLocked(store.directory())) {
      logger.trace("Shard is locked, releasing lock");
      store.directory().clearLock(IndexWriter.WRITE_LOCK_NAME);
    }
    IndexWriter writer=new IndexWriter(store.directory(),analysisService.defaultIndexAnalyzer(),true,IndexWriter.MaxFieldLength.UNLIMITED);
    writer.commit();
    writer.close();
  }
 catch (  IOException e) {
    logger.warn("Failed to clean the index",e);
  }
}
