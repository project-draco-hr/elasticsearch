{
  if (indexWriter == null) {
    throw new EngineClosedException(shardId,failedEngine);
  }
  if (disableFlushCounter > 0) {
    throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
  }
  if (!flushing.compareAndSet(false,true)) {
    throw new FlushNotAllowedEngineException(shardId,"Already flushing...");
  }
  rwl.writeLock().lock();
  try {
    if (indexWriter == null) {
      throw new EngineClosedException(shardId,failedEngine);
    }
    if (disableFlushCounter > 0) {
      throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
    }
    if (indexingSearcher.get() != null) {
      indexingSearcher.get().release();
      indexingSearcher.set(null);
    }
    if (flush.full()) {
      dirty=false;
      try {
        indexWriter.close();
        indexWriter=createWriter();
        AcquirableResource<ReaderSearcherHolder> current=nrtResource;
        nrtResource=buildNrtResource(indexWriter);
        current.markForClose();
        translog.newTranslog(newTransactionLogId());
      }
 catch (      Exception e) {
        throw new FlushFailedEngineException(shardId,e);
      }
catch (      OutOfMemoryError e) {
        failEngine(e);
        throw new FlushFailedEngineException(shardId,e);
      }
    }
 else {
      try {
        indexWriter.commit();
        translog.newTranslog(newTransactionLogId());
      }
 catch (      Exception e) {
        throw new FlushFailedEngineException(shardId,e);
      }
catch (      OutOfMemoryError e) {
        failEngine(e);
        throw new FlushFailedEngineException(shardId,e);
      }
    }
    long time=threadPool.estimatedTimeInMillis();
    for (    Map.Entry<String,VersionValue> entry : versionMap.entrySet()) {
      if (entry.getValue().delete()) {
        if ((time - entry.getValue().time()) > gcDeletesInMillis) {
          versionMap.remove(entry.getKey());
        }
      }
 else {
        versionMap.remove(entry.getKey());
      }
    }
    dirty=true;
    refresh(new Refresh(true).force(true));
  }
  finally {
    rwl.writeLock().unlock();
    flushing.set(false);
  }
}
