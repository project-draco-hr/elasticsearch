{
  if (indexWriter == null) {
    throw new EngineClosedException(shardId,failedEngine);
  }
  if (disableFlushCounter > 0) {
    throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
  }
  if (!flushing.compareAndSet(false,true)) {
    throw new FlushNotAllowedEngineException(shardId,"Already flushing...");
  }
  try {
    if (flush.full()) {
      rwl.writeLock().lock();
      try {
        if (indexWriter == null) {
          throw new EngineClosedException(shardId,failedEngine);
        }
        if (disableFlushCounter > 0) {
          throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
        }
        dirty=false;
        try {
          indexWriter.close();
          indexWriter=createWriter();
          if (flushNeeded) {
            flushNeeded=false;
            long translogId=translogIdGenerator.incrementAndGet();
            indexWriter.commit(MapBuilder.<String,String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)).map());
            translog.newTranslog(translogId);
          }
          AcquirableResource<ReaderSearcherHolder> current=nrtResource;
          nrtResource=buildNrtResource(indexWriter);
          current.markForClose();
        }
 catch (        Exception e) {
          throw new FlushFailedEngineException(shardId,e);
        }
catch (        OutOfMemoryError e) {
          failEngine(e);
          throw new FlushFailedEngineException(shardId,e);
        }
      }
  finally {
        rwl.writeLock().unlock();
      }
    }
 else {
      rwl.readLock().lock();
      try {
        if (indexWriter == null) {
          throw new EngineClosedException(shardId,failedEngine);
        }
        if (disableFlushCounter > 0) {
          throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
        }
        if (flushNeeded) {
          flushNeeded=false;
          try {
            long translogId=translogIdGenerator.incrementAndGet();
            translog.newTransientTranslog(translogId);
            indexWriter.commit(MapBuilder.<String,String>newMapBuilder().put(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)).map());
            translog.makeTransientCurrent();
          }
 catch (          Exception e) {
            throw new FlushFailedEngineException(shardId,e);
          }
catch (          OutOfMemoryError e) {
            failEngine(e);
            throw new FlushFailedEngineException(shardId,e);
          }
        }
      }
  finally {
        rwl.readLock().unlock();
      }
    }
    long time=threadPool.estimatedTimeInMillis();
    refresh(new Refresh(true).force(true));
    Searcher searcher=indexingSearcher.get();
    if (searcher != null) {
      indexingSearcher.set(null);
    }
    for (    Map.Entry<String,VersionValue> entry : versionMap.entrySet()) {
      String id=entry.getKey();
synchronized (dirtyLock(id)) {
        VersionValue versionValue=versionMap.get(id);
        if (versionValue == null) {
          continue;
        }
        if (time - versionValue.time() <= 0) {
          continue;
        }
        if (versionValue.delete()) {
          if ((time - versionValue.time()) > gcDeletesInMillis) {
            versionMap.remove(id);
          }
        }
 else {
          versionMap.remove(id);
        }
      }
    }
    if (searcher != null) {
      searcher.release();
    }
  }
  finally {
    flushing.set(false);
  }
}
