{
  XContentParser.Token token=parser.nextToken();
  if (token != XContentParser.Token.FIELD_NAME) {
    throw new ElasticsearchIllegalArgumentException("Unexpected token " + token + " inside inner hit definition. Either specify [path] or [type] object");
  }
  String fieldName=parser.currentName();
  token=parser.nextToken();
  if (token != XContentParser.Token.START_OBJECT) {
    throw new ElasticsearchIllegalArgumentException("Inner hit definition for [" + innerHitName + " starts with a ["+ token+ "], expected a ["+ XContentParser.Token.START_OBJECT+ "].");
  }
  final boolean nested;
switch (fieldName) {
case "path":
    nested=true;
  break;
case "type":
nested=false;
break;
default :
throw new ElasticsearchIllegalArgumentException("Either path or type object must be defined");
}
token=parser.nextToken();
if (token != XContentParser.Token.FIELD_NAME) {
throw new ElasticsearchIllegalArgumentException("Unexpected token " + token + " inside inner hit definition. Either specify [path] or [type] object");
}
fieldName=parser.currentName();
token=parser.nextToken();
if (token != XContentParser.Token.START_OBJECT) {
throw new ElasticsearchIllegalArgumentException("Inner hit definition for [" + innerHitName + " starts with a ["+ token+ "], expected a ["+ XContentParser.Token.START_OBJECT+ "].");
}
NestedQueryParser.LateBindingParentFilter parentFilter=null;
NestedQueryParser.LateBindingParentFilter currentFilter=null;
String nestedPath=null;
String type=null;
if (nested) {
nestedPath=fieldName;
currentFilter=new NestedQueryParser.LateBindingParentFilter();
parentFilter=NestedQueryParser.parentFilterContext.get();
NestedQueryParser.parentFilterContext.set(currentFilter);
}
 else {
type=fieldName;
}
Query query=null;
Map<String,InnerHitsContext.BaseInnerHits> childInnerHits=null;
SubSearchContext subSearchContext=new SubSearchContext(context);
while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
if (token == XContentParser.Token.FIELD_NAME) {
fieldName=parser.currentName();
}
 else if (token == XContentParser.Token.START_OBJECT) {
if ("query".equals(fieldName)) {
query=context.queryParserService().parse(parser).query();
}
 else if ("inner_hits".equals(fieldName)) {
childInnerHits=parseInnerHits(parser,context);
}
 else {
parseCommonInnerHitOptions(parser,token,fieldName,subSearchContext,sortParseElement,sourceParseElement,highlighterParseElement,scriptFieldsParseElement,fieldDataFieldsParseElement);
}
}
 else {
parseCommonInnerHitOptions(parser,token,fieldName,subSearchContext,sortParseElement,sourceParseElement,highlighterParseElement,scriptFieldsParseElement,fieldDataFieldsParseElement);
}
}
token=parser.nextToken();
if (token != XContentParser.Token.END_OBJECT) {
throw new ElasticsearchIllegalArgumentException("Expected [" + XContentParser.Token.END_OBJECT + "] token, but got a ["+ token+ "] token.");
}
token=parser.nextToken();
if (token != XContentParser.Token.END_OBJECT) {
throw new ElasticsearchIllegalArgumentException("Expected [" + XContentParser.Token.END_OBJECT + "] token, but got a ["+ token+ "] token.");
}
if (query == null) {
query=new MatchAllDocsQuery();
}
if (nestedPath != null && type != null) {
throw new ElasticsearchIllegalArgumentException("Either [path] or [type] can be defined not both");
}
 else if (nestedPath != null) {
MapperService.SmartNameObjectMapper smartNameObjectMapper=context.smartNameObjectMapper(nestedPath);
if (smartNameObjectMapper == null || !smartNameObjectMapper.hasMapper()) {
throw new ElasticsearchIllegalArgumentException("path [" + nestedPath + "] doesn't exist");
}
ObjectMapper childObjectMapper=smartNameObjectMapper.mapper();
if (!childObjectMapper.nested().isNested()) {
throw new ElasticsearchIllegalArgumentException("path [" + nestedPath + "] isn't nested");
}
DocumentMapper childDocumentMapper=smartNameObjectMapper.docMapper();
if (currentFilter != null && childDocumentMapper != null) {
currentFilter.filter=context.bitsetFilterCache().getBitDocIdSetFilter(childObjectMapper.nestedTypeFilter());
NestedQueryParser.parentFilterContext.set(parentFilter);
}
ObjectMapper parentObjectMapper=childDocumentMapper.findParentObjectMapper(childObjectMapper);
return new InnerHitsContext.NestedInnerHits(subSearchContext,query,childInnerHits,parentObjectMapper,childObjectMapper);
}
 else if (type != null) {
DocumentMapper documentMapper=context.mapperService().documentMapper(type);
if (documentMapper == null) {
throw new ElasticsearchIllegalArgumentException("type [" + type + "] doesn't exist");
}
return new InnerHitsContext.ParentChildInnerHits(subSearchContext,query,childInnerHits,documentMapper);
}
 else {
throw new ElasticsearchIllegalArgumentException("Either [path] or [type] must be defined");
}
}
