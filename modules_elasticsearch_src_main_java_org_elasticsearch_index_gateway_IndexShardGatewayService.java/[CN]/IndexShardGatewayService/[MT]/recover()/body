{
  if (recovered.compareAndSet(false,true)) {
    if (!indexShard.routingEntry().primary()) {
      throw new ElasticSearchIllegalStateException("Trying to recover when the shard is in backup state");
    }
    indexShard.recovering();
    StopWatch throttlingWaitTime=new StopWatch().start();
    while (!recoveryThrottler.tryRecovery(shardId,"gateway")) {
      try {
        Thread.sleep(recoveryThrottler.throttleInterval().millis());
      }
 catch (      InterruptedException e) {
        if (indexShard.ignoreRecoveryAttempt()) {
          throw new IgnoreGatewayRecoveryException(shardId,"Interrupted while waiting for recovery, but we should ignore ...");
        }
        throw new IndexShardGatewayRecoveryException(shardId,"Interrupted while waiting to recovery",e);
      }
    }
    throttlingWaitTime.stop();
    try {
      logger.debug("starting recovery from {}",shardGateway);
      StopWatch stopWatch=new StopWatch().start();
      IndexShardGateway.RecoveryStatus recoveryStatus=shardGateway.recover();
      lastIndexVersion=recoveryStatus.index().version();
      lastTranslogId=recoveryStatus.translog().translogId();
      lastTranslogSize=recoveryStatus.translog().numberOfOperations();
      if (indexShard.state() != IndexShardState.STARTED) {
        indexShard.start();
      }
      stopWatch.stop();
      if (logger.isDebugEnabled()) {
        StringBuilder sb=new StringBuilder();
        sb.append("recovery completed from ").append(shardGateway).append(", took [").append(stopWatch.totalTime()).append("], throttling_wait [").append(throttlingWaitTime.totalTime()).append("]\n");
        sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(recoveryStatus.index().totalSize()).append("], throttling_wait [").append(recoveryStatus.index().throttlingWaitTime()).append("]\n");
        sb.append("             : reusing_files   [").append(recoveryStatus.index().numberOfExistingFiles()).append("] with total_size [").append(recoveryStatus.index().existingTotalSize()).append("]\n");
        sb.append("    translog : translog_id [").append(recoveryStatus.translog().translogId()).append("], number_of_operations [").append(recoveryStatus.translog().numberOfOperations()).append("] with total_size[").append(recoveryStatus.translog().totalSize()).append("]");
        logger.debug(sb.toString());
      }
      indexShard.refresh(new Engine.Refresh(false));
      scheduleSnapshotIfNeeded();
    }
  finally {
      recoveryThrottler.recoveryDone(shardId,"gateway");
    }
  }
 else {
    throw new IgnoreGatewayRecoveryException(shardId,"Already recovered");
  }
}
