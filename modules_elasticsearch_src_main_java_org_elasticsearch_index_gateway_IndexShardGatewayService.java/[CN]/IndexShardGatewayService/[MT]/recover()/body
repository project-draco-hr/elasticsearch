{
  if (!recovered.compareAndSet(false,true)) {
    throw new IgnoreGatewayRecoveryException(shardId,"already recovered");
  }
  if (indexShard.state() == IndexShardState.CLOSED) {
    throw new IgnoreGatewayRecoveryException(shardId,"shard closed");
  }
  if (!indexShard.routingEntry().primary()) {
    throw new ElasticSearchIllegalStateException("Trying to recover when the shard is in backup state");
  }
  indexShard.recovering();
  StopWatch throttlingWaitTime=new StopWatch().start();
  while (!recoveryThrottler.tryRecovery(shardId,"gateway")) {
    try {
      Thread.sleep(recoveryThrottler.throttleInterval().millis());
    }
 catch (    InterruptedException e) {
      if (indexShard.ignoreRecoveryAttempt()) {
        throw new IgnoreGatewayRecoveryException(shardId,"Interrupted while waiting for recovery, but we should ignore ...");
      }
      throw new IndexShardGatewayRecoveryException(shardId,"Interrupted while waiting to recovery",e);
    }
  }
  throttlingWaitTime.stop();
  try {
    logger.debug("starting recovery from {}",shardGateway);
    StopWatch stopWatch=new StopWatch().start();
    IndexShardGateway.RecoveryStatus recoveryStatus=shardGateway.recover();
    lastIndexVersion=recoveryStatus.index().version();
    lastTranslogId=-1;
    lastTranslogPosition=0;
    lastTranslogLength=0;
    if (indexShard.state() != IndexShardState.STARTED) {
      indexShard.start();
    }
    stopWatch.stop();
    if (logger.isDebugEnabled()) {
      StringBuilder sb=new StringBuilder();
      sb.append("recovery completed from ").append(shardGateway).append(", took [").append(stopWatch.totalTime()).append("], throttling_wait [").append(throttlingWaitTime.totalTime()).append("]\n");
      sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(recoveryStatus.index().totalSize()).append("], throttling_wait [").append(recoveryStatus.index().throttlingWaitTime()).append("]\n");
      sb.append("             : reusing_files   [").append(recoveryStatus.index().numberOfExistingFiles()).append("] with total_size [").append(recoveryStatus.index().existingTotalSize()).append("]\n");
      sb.append("    translog : number_of_operations [").append(recoveryStatus.translog().numberOfOperations()).append("]");
      logger.debug(sb.toString());
    }
    indexShard.refresh(new Engine.Refresh(false));
    scheduleSnapshotIfNeeded();
  }
 catch (  IndexShardGatewayRecoveryException e) {
    if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {
      throw new IgnoreGatewayRecoveryException(shardId,"shard closed");
    }
    throw e;
  }
catch (  IndexShardClosedException e) {
    throw new IgnoreGatewayRecoveryException(shardId,"shard closed");
  }
catch (  IndexShardNotStartedException e) {
    throw new IgnoreGatewayRecoveryException(shardId,"shard closed");
  }
 finally {
    recoveryThrottler.recoveryDone(shardId,"gateway");
  }
}
