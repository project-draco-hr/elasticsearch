{
  if (indexShard.state() == IndexShardState.CLOSED) {
    listener.onIgnoreRecovery("shard closed");
    return;
  }
  if (!indexShard.routingEntry().primary()) {
    listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"Trying to recover when the shard is in backup state",null));
    return;
  }
  try {
    indexShard.recovering();
  }
 catch (  IllegalIndexShardStateException e) {
    listener.onIgnoreRecovery("already in recovering process, " + e.getMessage());
    return;
  }
  threadPool.cached().execute(new Runnable(){
    @Override public void run(){
      recoveryStatus=new RecoveryStatus();
      recoveryStatus.updateStage(RecoveryStatus.Stage.INIT);
      try {
        logger.debug("starting recovery from {} ...",shardGateway);
        shardGateway.recover(recoveryStatus);
        lastIndexVersion=recoveryStatus.index().version();
        lastTranslogId=-1;
        lastTranslogPosition=0;
        lastTranslogLength=0;
        lastTotalTranslogOperations=recoveryStatus.translog().currentTranslogOperations();
        if (indexShard.state() != IndexShardState.STARTED) {
          indexShard.start();
        }
        indexShard.refresh(new Engine.Refresh(false));
        recoveryStatus.time(System.currentTimeMillis() - recoveryStatus.startTime());
        recoveryStatus.updateStage(RecoveryStatus.Stage.DONE);
        if (logger.isDebugEnabled()) {
          StringBuilder sb=new StringBuilder();
          sb.append("recovery completed from ").append(shardGateway).append(", took [").append(timeValueMillis(recoveryStatus.time())).append("]\n");
          sb.append("    index    : files           [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().totalSize())).append("], took[").append(TimeValue.timeValueMillis(recoveryStatus.index().time())).append("], took [").append(TimeValue.timeValueMillis(recoveryStatus.index().time())).append("]\n");
          sb.append("             : recovered_files [").append(recoveryStatus.index().numberOfRecoveredFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().recoveredTotalSize())).append("]\n");
          sb.append("             : reusing_files   [").append(recoveryStatus.index().numberOfReusedFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().reusedTotalSize())).append("]\n");
          sb.append("    translog : number_of_operations [").append(recoveryStatus.translog().currentTranslogOperations()).append("], took [").append(TimeValue.timeValueMillis(recoveryStatus.translog().time())).append("]");
          logger.debug(sb.toString());
        }
        listener.onRecoveryDone();
        scheduleSnapshotIfNeeded();
      }
 catch (      IndexShardGatewayRecoveryException e) {
        if (indexShard.state() == IndexShardState.CLOSED) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        listener.onRecoveryFailed(e);
      }
catch (      IndexShardClosedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      IndexShardNotStartedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      Exception e) {
        listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"failed recovery",e));
      }
    }
  }
);
}
