{
  if (!recovered.compareAndSet(false,true)) {
    listener.onIgnoreRecovery("already recovered");
    return;
  }
  if (indexShard.state() == IndexShardState.CLOSED) {
    listener.onIgnoreRecovery("shard closed");
    return;
  }
  if (!indexShard.routingEntry().primary()) {
    listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"Trying to recover when the shard is in backup state",null));
    return;
  }
  threadPool.cached().execute(new Runnable(){
    @Override public void run(){
      recoveryStatus=new RecoveryStatus();
      recoveryStatus.updateStage(RecoveryStatus.Stage.INIT);
      indexShard.recovering();
      while (!recoveryThrottler.tryRecovery(shardId,"gateway")) {
        if (indexShard.ignoreRecoveryAttempt()) {
          listener.onIgnoreRecovery("ignoring recovery while waiting on retry");
          return;
        }
        recoveryStatus.updateStage(RecoveryStatus.Stage.RETRY);
        try {
          Thread.sleep(recoveryThrottler.throttleInterval().millis());
          recoveryStatus.retryTime(System.currentTimeMillis() - recoveryStatus.startTime());
        }
 catch (        InterruptedException e) {
          if (indexShard.ignoreRecoveryAttempt()) {
            listener.onIgnoreRecovery("Interrupted while waiting for recovery, but we should ignore ...");
          }
 else {
            listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"Interrupted while waiting to recovery",e));
          }
          return;
        }
      }
      try {
        logger.debug("starting recovery from {} ...",shardGateway);
        shardGateway.recover(recoveryStatus);
        lastIndexVersion=recoveryStatus.index().version();
        lastTranslogId=-1;
        lastTranslogPosition=0;
        lastTranslogLength=0;
        if (indexShard.state() != IndexShardState.STARTED) {
          indexShard.start();
        }
        indexShard.refresh(new Engine.Refresh(false));
        recoveryStatus.time(System.currentTimeMillis() - recoveryStatus.startTime());
        recoveryStatus.updateStage(RecoveryStatus.Stage.DONE);
        if (logger.isDebugEnabled()) {
          StringBuilder sb=new StringBuilder();
          sb.append("recovery completed from ").append(shardGateway).append(", took [").append(timeValueMillis(recoveryStatus.time())).append("], retry_time [").append(TimeValue.timeValueMillis(recoveryStatus.retryTime())).append("]\n");
          sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().totalSize())).append("], took [").append(TimeValue.timeValueMillis(recoveryStatus.index().time())).append("], throttling_wait [").append(TimeValue.timeValueMillis(recoveryStatus.index().retryTime())).append("]\n");
          sb.append("             : reusing_files   [").append(recoveryStatus.index().numberOfExistingFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().existingTotalSize())).append("]\n");
          sb.append("    translog : number_of_operations [").append(recoveryStatus.translog().currentTranslogOperations()).append("], took [").append(TimeValue.timeValueMillis(recoveryStatus.translog().time())).append("]");
          logger.debug(sb.toString());
        }
        listener.onRecoveryDone();
        scheduleSnapshotIfNeeded();
      }
 catch (      IndexShardGatewayRecoveryException e) {
        if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        listener.onRecoveryFailed(e);
      }
catch (      IndexShardClosedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      IndexShardNotStartedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      Exception e) {
        listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"failed recovery",e));
      }
 finally {
        recoveryThrottler.recoveryDone(shardId,"gateway");
      }
    }
  }
);
}
