{
  if (!recovered.compareAndSet(false,true)) {
    listener.onIgnoreRecovery("already recovered");
    return;
  }
  if (indexShard.state() == IndexShardState.CLOSED) {
    listener.onIgnoreRecovery("shard closed");
    return;
  }
  if (!indexShard.routingEntry().primary()) {
    listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"Trying to recover when the shard is in backup state",null));
    return;
  }
  threadPool.cached().execute(new Runnable(){
    @Override public void run(){
      indexShard.recovering();
      StopWatch throttlingWaitTime=new StopWatch().start();
      while (!recoveryThrottler.tryRecovery(shardId,"gateway")) {
        try {
          Thread.sleep(recoveryThrottler.throttleInterval().millis());
        }
 catch (        InterruptedException e) {
          if (indexShard.ignoreRecoveryAttempt()) {
            listener.onIgnoreRecovery("Interrupted while waiting for recovery, but we should ignore ...");
            return;
          }
          listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"Interrupted while waiting to recovery",e));
        }
      }
      throttlingWaitTime.stop();
      try {
        logger.debug("starting recovery from {}",shardGateway);
        StopWatch stopWatch=new StopWatch().start();
        IndexShardGateway.RecoveryStatus recoveryStatus=shardGateway.recover();
        lastIndexVersion=recoveryStatus.index().version();
        lastTranslogId=-1;
        lastTranslogPosition=0;
        lastTranslogLength=0;
        if (indexShard.state() != IndexShardState.STARTED) {
          indexShard.start();
        }
        stopWatch.stop();
        if (logger.isDebugEnabled()) {
          StringBuilder sb=new StringBuilder();
          sb.append("recovery completed from ").append(shardGateway).append(", took [").append(stopWatch.totalTime()).append("], throttling_wait [").append(throttlingWaitTime.totalTime()).append("]\n");
          sb.append("    index    : recovered_files [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(recoveryStatus.index().totalSize()).append("], took [").append(recoveryStatus.index().took()).append("], throttling_wait [").append(recoveryStatus.index().throttlingWaitTime()).append("]\n");
          sb.append("             : reusing_files   [").append(recoveryStatus.index().numberOfExistingFiles()).append("] with total_size [").append(recoveryStatus.index().existingTotalSize()).append("]\n");
          sb.append("    translog : number_of_operations [").append(recoveryStatus.translog().numberOfOperations()).append("], took [").append(recoveryStatus.translog().took()).append("]");
          logger.debug(sb.toString());
        }
        indexShard.refresh(new Engine.Refresh(false));
        listener.onRecoveryDone();
        scheduleSnapshotIfNeeded();
      }
 catch (      IndexShardGatewayRecoveryException e) {
        if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        listener.onRecoveryFailed(e);
      }
catch (      IndexShardClosedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      IndexShardNotStartedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      Exception e) {
        listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"failed recovery",e));
      }
 finally {
        recoveryThrottler.recoveryDone(shardId,"gateway");
      }
    }
  }
);
}
