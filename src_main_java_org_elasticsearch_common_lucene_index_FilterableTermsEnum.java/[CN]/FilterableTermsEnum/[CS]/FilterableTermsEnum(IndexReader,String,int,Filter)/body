{
  if ((docsEnumFlag != PostingsEnum.FREQS) && (docsEnumFlag != PostingsEnum.NONE)) {
    throw new ElasticsearchIllegalArgumentException("invalid docsEnumFlag of " + docsEnumFlag);
  }
  this.docsEnumFlag=docsEnumFlag;
  if (filter == null) {
    numDocs=reader.maxDoc();
  }
  List<LeafReaderContext> leaves=reader.leaves();
  List<Holder> enums=Lists.newArrayListWithExpectedSize(leaves.size());
  for (  LeafReaderContext context : leaves) {
    Terms terms=context.reader().terms(field);
    if (terms == null) {
      continue;
    }
    TermsEnum termsEnum=terms.iterator(null);
    if (termsEnum == null) {
      continue;
    }
    Bits bits=null;
    if (filter != null) {
      DocIdSet docIdSet=filter.getDocIdSet(context,context.reader().getLiveDocs());
      if (DocIdSets.isEmpty(docIdSet)) {
        continue;
      }
      bits=DocIdSets.toSafeBits(context.reader().maxDoc(),docIdSet);
      DocIdSetIterator iterator=docIdSet.iterator();
      if (iterator != null) {
        while (iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
          numDocs++;
        }
      }
    }
    enums.add(new Holder(termsEnum,bits));
  }
  this.enums=enums.toArray(new Holder[enums.size()]);
}
