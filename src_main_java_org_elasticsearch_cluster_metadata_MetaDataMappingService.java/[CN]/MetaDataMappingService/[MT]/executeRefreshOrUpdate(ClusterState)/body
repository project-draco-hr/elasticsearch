{
  List<MappingTask> allTasks=new ArrayList<MappingTask>();
  refreshOrUpdateQueue.drainTo(allTasks);
  if (allTasks.isEmpty()) {
    return currentState;
  }
  Map<String,List<MappingTask>> tasksPerIndex=Maps.newHashMap();
  for (  MappingTask task : allTasks) {
    if (task.index == null) {
      logger.debug("ignoring a mapping task of type [{}] with a null index.",task);
    }
    List<MappingTask> indexTasks=tasksPerIndex.get(task.index);
    if (indexTasks == null) {
      indexTasks=new ArrayList<MappingTask>();
      tasksPerIndex.put(task.index,indexTasks);
    }
    indexTasks.add(task);
  }
  boolean dirty=false;
  MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
  for (  Map.Entry<String,List<MappingTask>> entry : tasksPerIndex.entrySet()) {
    String index=entry.getKey();
    List<MappingTask> tasks=entry.getValue();
    boolean removeIndex=false;
    Set<String> processedRefreshes=Sets.newHashSet();
    try {
      for (      MappingTask task : tasks) {
        final IndexMetaData indexMetaData=mdBuilder.get(index);
        if (indexMetaData == null) {
          logger.debug("[{}] ignoring task [{}] - index meta data doesn't exist",index,task);
          continue;
        }
        if (!indexMetaData.isSameUUID(task.indexUUID)) {
          logger.debug("[{}] ignoring task [{}] - index meta data doesn't match task uuid",index,task);
          continue;
        }
        if (task instanceof RefreshTask) {
          RefreshTask refreshTask=(RefreshTask)task;
          IndexService indexService=indicesService.indexService(index);
          if (indexService == null) {
            indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
            removeIndex=true;
            for (            String type : refreshTask.types) {
              if (indexMetaData.mappings().containsKey(type)) {
                indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
              }
            }
          }
          IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(indexMetaData);
          List<String> updatedTypes=Lists.newArrayList();
          for (          String type : refreshTask.types) {
            if (processedRefreshes.contains(type)) {
              continue;
            }
            DocumentMapper mapper=indexService.mapperService().documentMapper(type);
            if (!mapper.mappingSource().equals(indexMetaData.mappings().get(type).source())) {
              updatedTypes.add(type);
              indexMetaDataBuilder.putMapping(new MappingMetaData(mapper));
            }
            processedRefreshes.add(type);
          }
          if (updatedTypes.isEmpty()) {
            continue;
          }
          logger.warn("[{}] re-syncing mappings with cluster state for types [{}]",index,updatedTypes);
          mdBuilder.put(indexMetaDataBuilder);
          dirty=true;
        }
 else         if (task instanceof UpdateTask) {
          UpdateTask updateTask=(UpdateTask)task;
          String type=updateTask.type;
          CompressedString mappingSource=updateTask.mappingSource;
          if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(mappingSource)) {
            logger.debug("[{}] update_mapping [{}] ignoring mapping update task as it's source is equal to ours",index,updateTask.type);
            continue;
          }
          IndexService indexService=indicesService.indexService(index);
          if (indexService == null) {
            indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
            removeIndex=true;
            if (indexMetaData.mappings().containsKey(type)) {
              indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
            }
          }
          DocumentMapper updatedMapper=indexService.mapperService().merge(type,mappingSource.string(),false);
          processedRefreshes.add(type);
          if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {
            logger.debug("[{}] update_mapping [{}] ignoring mapping update task as it results in the same source as what we have",index,updateTask.type);
            continue;
          }
          if (logger.isDebugEnabled()) {
            logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]",index,type,updatedMapper.mappingSource());
          }
 else           if (logger.isInfoEnabled()) {
            logger.info("[{}] update_mapping [{}] (dynamic)",index,type);
          }
          mdBuilder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));
          dirty=true;
        }
 else {
          logger.warn("illegal state, got wrong mapping task type [{}]",task);
        }
      }
    }
  finally {
      if (removeIndex) {
        indicesService.removeIndex(index,"created for mapping processing");
      }
      for (      Object task : tasks) {
        if (task instanceof UpdateTask) {
          ((UpdateTask)task).listener.onResponse(new Response(true));
        }
      }
    }
  }
  if (!dirty) {
    return currentState;
  }
  return newClusterStateBuilder().state(currentState).metaData(mdBuilder).build();
}
