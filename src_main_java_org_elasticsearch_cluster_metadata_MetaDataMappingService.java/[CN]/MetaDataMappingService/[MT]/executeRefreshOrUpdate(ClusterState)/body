{
  List<Object> tasks=new ArrayList<Object>();
  refreshOrUpdateQueue.drainTo(tasks);
  if (tasks.isEmpty()) {
    return currentState;
  }
  Set<String> indicesToRemove=Sets.newHashSet();
  try {
    boolean dirty=false;
    MetaData.Builder mdBuilder=newMetaDataBuilder().metaData(currentState.metaData());
    for (    Object task : tasks) {
      if (task instanceof RefreshTask) {
        RefreshTask refreshTask=(RefreshTask)task;
        String index=refreshTask.index;
        final IndexMetaData indexMetaData=mdBuilder.get(index);
        if (indexMetaData == null) {
          continue;
        }
        IndexService indexService=indicesService.indexService(index);
        if (indexService == null) {
          indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
          indicesToRemove.add(index);
          for (          String type : refreshTask.types) {
            if (indexMetaData.mappings().containsKey(type)) {
              indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
            }
          }
        }
        IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(indexMetaData);
        List<String> updatedTypes=Lists.newArrayList();
        for (        String type : refreshTask.types) {
          DocumentMapper mapper=indexService.mapperService().documentMapper(type);
          if (!mapper.mappingSource().equals(indexMetaData.mappings().get(type).source())) {
            updatedTypes.add(type);
            indexMetaDataBuilder.putMapping(new MappingMetaData(mapper));
          }
        }
        if (updatedTypes.isEmpty()) {
          continue;
        }
        logger.warn("[{}] re-syncing mappings with cluster state for types [{}]",index,updatedTypes);
        mdBuilder.put(indexMetaDataBuilder);
        dirty=true;
      }
 else       if (task instanceof UpdateTask) {
        UpdateTask updateTask=(UpdateTask)task;
        String index=updateTask.index;
        String type=updateTask.type;
        CompressedString mappingSource=updateTask.mappingSource;
        final IndexMetaData indexMetaData=mdBuilder.get(index);
        if (indexMetaData == null) {
          continue;
        }
        if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(mappingSource)) {
          continue;
        }
        IndexService indexService=indicesService.indexService(index);
        if (indexService == null) {
          indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
          indicesToRemove.add(index);
          if (indexMetaData.mappings().containsKey(type)) {
            indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
          }
        }
        DocumentMapper updatedMapper=indexService.mapperService().merge(type,mappingSource.string(),false);
        if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {
          continue;
        }
        if (logger.isDebugEnabled()) {
          try {
            logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]",index,type,updatedMapper.mappingSource().string());
          }
 catch (          Exception e) {
          }
        }
 else         if (logger.isInfoEnabled()) {
          logger.info("[{}] update_mapping [{}] (dynamic)",index,type);
        }
        mdBuilder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));
        dirty=true;
      }
 else {
        logger.warn("illegal state, got wrong mapping task type [{}]",task);
      }
    }
    if (!dirty) {
      return currentState;
    }
    return newClusterStateBuilder().state(currentState).metaData(mdBuilder).build();
  }
  finally {
    for (    String index : indicesToRemove) {
      indicesService.removeIndex(index,"created for mapping processing");
    }
    for (    Object task : tasks) {
      if (task instanceof UpdateTask) {
        ((UpdateTask)task).listener.onResponse(new Response(true));
      }
    }
  }
}
