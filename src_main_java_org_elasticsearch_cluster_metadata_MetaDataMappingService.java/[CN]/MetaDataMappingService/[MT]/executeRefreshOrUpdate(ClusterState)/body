{
  List<Object> allTasks=new ArrayList<Object>();
  refreshOrUpdateQueue.drainTo(allTasks);
  if (allTasks.isEmpty()) {
    return currentState;
  }
  Map<String,List<Object>> tasksPerIndex=Maps.newHashMap();
  for (  Object task : allTasks) {
    String index=null;
    if (task instanceof UpdateTask) {
      index=((UpdateTask)task).index;
    }
 else     if (task instanceof RefreshTask) {
      index=((RefreshTask)task).index;
    }
 else {
      logger.warn("illegal state, got wrong mapping task type [{}]",task);
    }
    if (index != null) {
      List<Object> indexTasks=tasksPerIndex.get(index);
      if (indexTasks == null) {
        indexTasks=new ArrayList<Object>();
        tasksPerIndex.put(index,indexTasks);
      }
      indexTasks.add(task);
    }
  }
  boolean dirty=false;
  MetaData.Builder mdBuilder=newMetaDataBuilder().metaData(currentState.metaData());
  for (  Map.Entry<String,List<Object>> entry : tasksPerIndex.entrySet()) {
    String index=entry.getKey();
    List<Object> tasks=entry.getValue();
    boolean removeIndex=false;
    Set<String> processedRefreshes=Sets.newHashSet();
    try {
      for (      Object task : tasks) {
        if (task instanceof RefreshTask) {
          RefreshTask refreshTask=(RefreshTask)task;
          final IndexMetaData indexMetaData=mdBuilder.get(index);
          if (indexMetaData == null) {
            continue;
          }
          IndexService indexService=indicesService.indexService(index);
          if (indexService == null) {
            indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
            removeIndex=true;
            for (            String type : refreshTask.types) {
              if (indexMetaData.mappings().containsKey(type)) {
                indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
              }
            }
          }
          IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(indexMetaData);
          List<String> updatedTypes=Lists.newArrayList();
          for (          String type : refreshTask.types) {
            if (processedRefreshes.contains(type)) {
              continue;
            }
            DocumentMapper mapper=indexService.mapperService().documentMapper(type);
            if (!mapper.mappingSource().equals(indexMetaData.mappings().get(type).source())) {
              updatedTypes.add(type);
              indexMetaDataBuilder.putMapping(new MappingMetaData(mapper));
            }
            processedRefreshes.add(type);
          }
          if (updatedTypes.isEmpty()) {
            continue;
          }
          logger.warn("[{}] re-syncing mappings with cluster state for types [{}]",index,updatedTypes);
          mdBuilder.put(indexMetaDataBuilder);
          dirty=true;
        }
 else         if (task instanceof UpdateTask) {
          UpdateTask updateTask=(UpdateTask)task;
          String type=updateTask.type;
          CompressedString mappingSource=updateTask.mappingSource;
          final IndexMetaData indexMetaData=mdBuilder.get(index);
          if (indexMetaData == null) {
            continue;
          }
          if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(mappingSource)) {
            continue;
          }
          IndexService indexService=indicesService.indexService(index);
          if (indexService == null) {
            indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
            removeIndex=true;
            if (indexMetaData.mappings().containsKey(type)) {
              indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
            }
          }
          DocumentMapper updatedMapper=indexService.mapperService().merge(type,mappingSource.string(),false);
          processedRefreshes.add(type);
          if (indexMetaData.mappings().containsKey(type) && indexMetaData.mapping(type).source().equals(updatedMapper.mappingSource())) {
            continue;
          }
          if (logger.isDebugEnabled()) {
            try {
              logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]",index,type,updatedMapper.mappingSource().string());
            }
 catch (            Exception e) {
            }
          }
 else           if (logger.isInfoEnabled()) {
            logger.info("[{}] update_mapping [{}] (dynamic)",index,type);
          }
          mdBuilder.put(newIndexMetaDataBuilder(indexMetaData).putMapping(new MappingMetaData(updatedMapper)));
          dirty=true;
        }
 else {
          logger.warn("illegal state, got wrong mapping task type [{}]",task);
        }
      }
    }
  finally {
      if (removeIndex) {
        indicesService.removeIndex(index,"created for mapping processing");
      }
      for (      Object task : tasks) {
        if (task instanceof UpdateTask) {
          ((UpdateTask)task).listener.onResponse(new Response(true));
        }
      }
    }
  }
  if (!dirty) {
    return currentState;
  }
  return newClusterStateBuilder().state(currentState).metaData(mdBuilder).build();
}
