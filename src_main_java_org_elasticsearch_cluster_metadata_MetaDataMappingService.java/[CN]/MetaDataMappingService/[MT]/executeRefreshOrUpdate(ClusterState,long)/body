{
  final List<MappingTask> allTasks=new ArrayList<>();
synchronized (refreshOrUpdateMutex) {
    if (refreshOrUpdateQueue.isEmpty()) {
      return Tuple.tuple(currentState,allTasks);
    }
    if (insertionOrder < refreshOrUpdateProcessedInsertOrder) {
      return Tuple.tuple(currentState,allTasks);
    }
    allTasks.addAll(refreshOrUpdateQueue);
    refreshOrUpdateQueue.clear();
    refreshOrUpdateProcessedInsertOrder=refreshOrUpdateInsertOrder;
  }
  if (allTasks.isEmpty()) {
    return Tuple.tuple(currentState,allTasks);
  }
  Map<String,List<MappingTask>> tasksPerIndex=Maps.newHashMap();
  for (  MappingTask task : allTasks) {
    if (task.index == null) {
      logger.debug("ignoring a mapping task of type [{}] with a null index.",task);
    }
    List<MappingTask> indexTasks=tasksPerIndex.get(task.index);
    if (indexTasks == null) {
      indexTasks=new ArrayList<>();
      tasksPerIndex.put(task.index,indexTasks);
    }
    indexTasks.add(task);
  }
  boolean dirty=false;
  MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
  for (  Map.Entry<String,List<MappingTask>> entry : tasksPerIndex.entrySet()) {
    String index=entry.getKey();
    IndexMetaData indexMetaData=mdBuilder.get(index);
    if (indexMetaData == null) {
      logger.debug("[{}] ignoring tasks - index meta data doesn't exist",index);
      continue;
    }
    List<MappingTask> allIndexTasks=entry.getValue();
    List<MappingTask> tasks=new ArrayList<>();
    for (    MappingTask task : allIndexTasks) {
      if (!indexMetaData.isSameUUID(task.indexUUID)) {
        logger.debug("[{}] ignoring task [{}] - index meta data doesn't match task uuid",index,task);
        continue;
      }
      boolean add=true;
      if (task instanceof UpdateTask) {
        UpdateTask uTask=(UpdateTask)task;
        if (uTask.order != -1 && uTask.nodeId != null) {
          for (int i=0; i < tasks.size(); i++) {
            MappingTask existing=tasks.get(i);
            if (existing instanceof UpdateTask) {
              UpdateTask eTask=(UpdateTask)existing;
              if (eTask.type.equals(uTask.type)) {
                if (eTask.order != -1 && eTask.nodeId != null) {
                  if (eTask.nodeId.equals(uTask.nodeId) && uTask.order > eTask.order) {
                    tasks.set(i,uTask);
                    add=false;
                    break;
                  }
                }
              }
            }
          }
        }
      }
      if (add) {
        tasks.add(task);
      }
    }
    boolean removeIndex=false;
    IndexService indexService=indicesService.indexService(index);
    if (indexService == null) {
      indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
      removeIndex=true;
      Set<String> typesToIntroduce=Sets.newHashSet();
      for (      MappingTask task : tasks) {
        if (task instanceof UpdateTask) {
          typesToIntroduce.add(((UpdateTask)task).type);
        }
 else         if (task instanceof RefreshTask) {
          Collections.addAll(typesToIntroduce,((RefreshTask)task).types);
        }
      }
      for (      String type : typesToIntroduce) {
        if (indexMetaData.mappings().containsKey(type)) {
          indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source(),false);
        }
      }
    }
    IndexMetaData.Builder builder=IndexMetaData.builder(indexMetaData);
    try {
      boolean indexDirty=processIndexMappingTasks(tasks,indexService,builder);
      if (indexDirty) {
        mdBuilder.put(builder);
        dirty=true;
      }
    }
  finally {
      if (removeIndex) {
        indicesService.removeIndex(index,"created for mapping processing");
      }
    }
  }
  if (!dirty) {
    return Tuple.tuple(currentState,allTasks);
  }
  return Tuple.tuple(ClusterState.builder(currentState).metaData(mdBuilder).build(),allTasks);
}
