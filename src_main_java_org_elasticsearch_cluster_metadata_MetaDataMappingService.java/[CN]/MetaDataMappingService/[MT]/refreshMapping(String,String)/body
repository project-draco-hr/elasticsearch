{
synchronized (indicesAndTypesToRefresh) {
    Set<String> sTypes=indicesAndTypesToRefresh.get(index);
    if (sTypes == null) {
      sTypes=Sets.newHashSet();
      indicesAndTypesToRefresh.put(index,sTypes);
    }
    sTypes.addAll(Arrays.asList(types));
  }
  clusterService.submitStateUpdateTask("refresh-mapping [" + index + "]["+ Arrays.toString(types)+ "]",Priority.URGENT,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      boolean createdIndex=false;
      try {
        Set<String> sTypes;
synchronized (indicesAndTypesToRefresh) {
          sTypes=indicesAndTypesToRefresh.remove(index);
        }
        if (sTypes == null || sTypes.isEmpty()) {
          return currentState;
        }
        final IndexMetaData indexMetaData=currentState.metaData().index(index);
        if (indexMetaData == null) {
          return currentState;
        }
        IndexService indexService=indicesService.indexService(index);
        if (indexService == null) {
          indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
          createdIndex=true;
          for (          String type : sTypes) {
            if (indexMetaData.mappings().containsKey(type)) {
              indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source().string(),false);
            }
          }
        }
        IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(indexMetaData);
        List<String> updatedTypes=Lists.newArrayList();
        for (        String type : sTypes) {
          DocumentMapper mapper=indexService.mapperService().documentMapper(type);
          if (!mapper.mappingSource().equals(indexMetaData.mappings().get(type).source())) {
            updatedTypes.add(type);
            indexMetaDataBuilder.putMapping(new MappingMetaData(mapper));
          }
        }
        if (updatedTypes.isEmpty()) {
          return currentState;
        }
        logger.warn("[{}] re-syncing mappings with cluster state for types [{}]",index,updatedTypes);
        MetaData.Builder builder=newMetaDataBuilder().metaData(currentState.metaData());
        builder.put(indexMetaDataBuilder);
        return newClusterStateBuilder().state(currentState).metaData(builder).build();
      }
 catch (      Exception e) {
        logger.warn("failed to dynamically refresh the mapping in cluster_state from shard",e);
        return currentState;
      }
 finally {
        if (createdIndex) {
          indicesService.removeIndex(index,"created for mapping processing");
        }
      }
    }
  }
);
}
