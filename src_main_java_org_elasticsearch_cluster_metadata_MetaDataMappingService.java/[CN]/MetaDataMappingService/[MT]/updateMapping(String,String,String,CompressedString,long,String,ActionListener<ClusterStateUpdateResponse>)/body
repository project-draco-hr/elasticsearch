{
  final long insertOrder;
synchronized (refreshOrUpdateMutex) {
    insertOrder=++refreshOrUpdateInsertOrder;
    refreshOrUpdateQueue.add(new UpdateTask(index,indexUUID,type,mappingSource,order,nodeId,listener));
  }
  clusterService.submitStateUpdateTask("update-mapping [" + index + "]["+ type+ "] / node ["+ nodeId+ "], order ["+ order+ "]",Priority.HIGH,new ProcessedClusterStateUpdateTask(){
    private volatile List<MappingTask> allTasks;
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    final ClusterState currentState) throws Exception {
      Tuple<ClusterState,List<MappingTask>> tuple=executeRefreshOrUpdate(currentState,insertOrder);
      this.allTasks=tuple.v2();
      return tuple.v1();
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      if (allTasks == null) {
        return;
      }
      for (      Object task : allTasks) {
        if (task instanceof UpdateTask) {
          UpdateTask uTask=(UpdateTask)task;
          ClusterStateUpdateResponse response=new ClusterStateUpdateResponse(true);
          try {
            uTask.listener.onResponse(response);
          }
 catch (          Throwable t) {
            logger.debug("failed ot ping back on response of mapping processing for task [{}]",t,uTask.listener);
          }
        }
      }
    }
  }
);
}
