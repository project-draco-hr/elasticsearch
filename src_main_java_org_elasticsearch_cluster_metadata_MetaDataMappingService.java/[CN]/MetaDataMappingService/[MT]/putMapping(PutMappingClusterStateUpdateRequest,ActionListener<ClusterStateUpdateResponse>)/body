{
  clusterService.submitStateUpdateTask("put-mapping [" + request.type() + "]",Priority.HIGH,new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request,listener){
    @Override protected ClusterStateUpdateResponse newResponse(    boolean acknowledged){
      return new ClusterStateUpdateResponse(acknowledged);
    }
    @Override public ClusterState execute(    final ClusterState currentState) throws Exception {
      List<String> indicesToClose=Lists.newArrayList();
      try {
        for (        String index : request.indices()) {
          if (!currentState.metaData().hasIndex(index)) {
            throw new IndexMissingException(new Index(index));
          }
        }
        for (        String index : request.indices()) {
          if (indicesService.hasIndex(index)) {
            continue;
          }
          final IndexMetaData indexMetaData=currentState.metaData().index(index);
          IndexService indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),clusterService.localNode().id());
          indicesToClose.add(indexMetaData.index());
          if (indexMetaData.mappings().containsKey(MapperService.DEFAULT_MAPPING)) {
            indexService.mapperService().merge(MapperService.DEFAULT_MAPPING,indexMetaData.mappings().get(MapperService.DEFAULT_MAPPING).source(),false);
          }
          if (indexMetaData.mappings().containsKey(request.type())) {
            indexService.mapperService().merge(request.type(),indexMetaData.mappings().get(request.type()).source(),false);
          }
        }
        Map<String,DocumentMapper> newMappers=newHashMap();
        Map<String,DocumentMapper> existingMappers=newHashMap();
        for (        String index : request.indices()) {
          IndexService indexService=indicesService.indexService(index);
          if (indexService != null) {
            DocumentMapper newMapper;
            DocumentMapper existingMapper=indexService.mapperService().documentMapper(request.type());
            if (MapperService.DEFAULT_MAPPING.equals(request.type())) {
              newMapper=indexService.mapperService().parse(request.type(),new CompressedString(request.source()),false);
            }
 else {
              newMapper=indexService.mapperService().parse(request.type(),new CompressedString(request.source()));
              if (existingMapper != null) {
                DocumentMapper.MergeResult mergeResult=existingMapper.merge(newMapper,mergeFlags().simulate(true));
                if (!request.ignoreConflicts() && mergeResult.hasConflicts()) {
                  throw new MergeMappingException(mergeResult.conflicts());
                }
              }
            }
            newMappers.put(index,newMapper);
            if (existingMapper != null) {
              existingMappers.put(index,existingMapper);
            }
          }
 else {
            throw new IndexMissingException(new Index(index));
          }
        }
        String mappingType=request.type();
        if (mappingType == null) {
          mappingType=newMappers.values().iterator().next().type();
        }
 else         if (!mappingType.equals(newMappers.values().iterator().next().type())) {
          throw new InvalidTypeNameException("Type name provided does not match type name within mapping definition");
        }
        if (!MapperService.DEFAULT_MAPPING.equals(mappingType) && !PercolatorService.TYPE_NAME.equals(mappingType) && mappingType.charAt(0) == '_') {
          throw new InvalidTypeNameException("Document mapping type name can't start with '_'");
        }
        final Map<String,MappingMetaData> mappings=newHashMap();
        for (        Map.Entry<String,DocumentMapper> entry : newMappers.entrySet()) {
          String index=entry.getKey();
          DocumentMapper newMapper=entry.getValue();
          IndexService indexService=indicesService.indexService(index);
          CompressedString existingSource=null;
          if (existingMappers.containsKey(entry.getKey())) {
            existingSource=existingMappers.get(entry.getKey()).mappingSource();
          }
          DocumentMapper mergedMapper=indexService.mapperService().merge(newMapper.type(),newMapper.mappingSource(),false);
          CompressedString updatedSource=mergedMapper.mappingSource();
          if (existingSource != null) {
            if (existingSource.equals(updatedSource)) {
            }
 else {
              mappings.put(index,new MappingMetaData(mergedMapper));
              if (logger.isDebugEnabled()) {
                logger.debug("[{}] update_mapping [{}] with source [{}]",index,mergedMapper.type(),updatedSource);
              }
 else               if (logger.isInfoEnabled()) {
                logger.info("[{}] update_mapping [{}]",index,mergedMapper.type());
              }
            }
          }
 else {
            mappings.put(index,new MappingMetaData(mergedMapper));
            if (logger.isDebugEnabled()) {
              logger.debug("[{}] create_mapping [{}] with source [{}]",index,newMapper.type(),updatedSource);
            }
 else             if (logger.isInfoEnabled()) {
              logger.info("[{}] create_mapping [{}]",index,newMapper.type());
            }
          }
        }
        if (mappings.isEmpty()) {
          return currentState;
        }
        MetaData.Builder builder=MetaData.builder(currentState.metaData());
        for (        String indexName : request.indices()) {
          IndexMetaData indexMetaData=currentState.metaData().index(indexName);
          if (indexMetaData == null) {
            throw new IndexMissingException(new Index(indexName));
          }
          MappingMetaData mappingMd=mappings.get(indexName);
          if (mappingMd != null) {
            builder.put(IndexMetaData.builder(indexMetaData).putMapping(mappingMd));
          }
        }
        return ClusterState.builder(currentState).metaData(builder).build();
      }
  finally {
        for (        String index : indicesToClose) {
          indicesService.removeIndex(index,"created for mapping processing");
        }
      }
    }
  }
);
}
