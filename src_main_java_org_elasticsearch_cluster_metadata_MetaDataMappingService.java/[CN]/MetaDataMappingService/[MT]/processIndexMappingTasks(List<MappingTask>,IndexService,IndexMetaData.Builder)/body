{
  boolean dirty=false;
  String index=indexService.index().name();
  Set<String> processedRefreshes=Sets.newHashSet();
  for (  MappingTask task : tasks) {
    if (task instanceof RefreshTask) {
      RefreshTask refreshTask=(RefreshTask)task;
      try {
        List<String> updatedTypes=Lists.newArrayList();
        for (        String type : refreshTask.types) {
          if (processedRefreshes.contains(type)) {
            continue;
          }
          DocumentMapper mapper=indexService.mapperService().documentMapper(type);
          if (mapper == null) {
            continue;
          }
          if (!mapper.mappingSource().equals(builder.mapping(type).source())) {
            updatedTypes.add(type);
            builder.putMapping(new MappingMetaData(mapper));
          }
          processedRefreshes.add(type);
        }
        if (updatedTypes.isEmpty()) {
          continue;
        }
        logger.warn("[{}] re-syncing mappings with cluster state for types [{}]",index,updatedTypes);
        dirty=true;
      }
 catch (      Throwable t) {
        logger.warn("[{}] failed to refresh-mapping in cluster state, types [{}]",index,refreshTask.types);
      }
    }
 else     if (task instanceof UpdateTask) {
      UpdateTask updateTask=(UpdateTask)task;
      try {
        String type=updateTask.type;
        CompressedXContent mappingSource=updateTask.mappingSource;
        MappingMetaData mappingMetaData=builder.mapping(type);
        if (mappingMetaData != null && mappingMetaData.source().equals(mappingSource)) {
          logger.debug("[{}] update_mapping [{}] ignoring mapping update task as its source is equal to ours",index,updateTask.type);
          continue;
        }
        DocumentMapper updatedMapper=indexService.mapperService().merge(type,mappingSource,false);
        processedRefreshes.add(type);
        if (mappingMetaData != null && mappingMetaData.source().equals(updatedMapper.mappingSource())) {
          logger.debug("[{}] update_mapping [{}] ignoring mapping update task as it results in the same source as what we have",index,updateTask.type);
          continue;
        }
        if (logger.isDebugEnabled()) {
          logger.debug("[{}] update_mapping [{}] (dynamic) with source [{}]",index,type,updatedMapper.mappingSource());
        }
 else         if (logger.isInfoEnabled()) {
          logger.info("[{}] update_mapping [{}] (dynamic)",index,type);
        }
        builder.putMapping(new MappingMetaData(updatedMapper));
        dirty=true;
      }
 catch (      Throwable t) {
        logger.warn("[{}] failed to update-mapping in cluster state, type [{}]",index,updateTask.type);
      }
    }
 else {
      logger.warn("illegal state, got wrong mapping task type [{}]",task);
    }
  }
  return dirty;
}
