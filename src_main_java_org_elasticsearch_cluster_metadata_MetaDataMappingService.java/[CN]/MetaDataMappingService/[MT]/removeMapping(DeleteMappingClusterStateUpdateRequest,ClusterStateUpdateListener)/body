{
  clusterService.submitStateUpdateTask("remove-mapping [" + request.type() + "]",Priority.HIGH,new AckedClusterStateUpdateTask(){
    @Override public boolean mustAck(    DiscoveryNode discoveryNode){
      return true;
    }
    @Override public void onAllNodesAcked(    @Nullable Throwable t){
      listener.onResponse(new ClusterStateUpdateResponse(true));
    }
    @Override public void onAckTimeout(){
      listener.onResponse(new ClusterStateUpdateResponse(true));
    }
    @Override public TimeValue ackTimeout(){
      return request.ackTimeout();
    }
    @Override public TimeValue timeout(){
      return request.masterNodeTimeout();
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    ClusterState currentState){
      if (request.indices().length == 0) {
        throw new IndexMissingException(new Index("_all"));
      }
      MetaData.Builder builder=newMetaDataBuilder().metaData(currentState.metaData());
      boolean changed=false;
      String latestIndexWithout=null;
      for (      String indexName : request.indices()) {
        IndexMetaData indexMetaData=currentState.metaData().index(indexName);
        if (indexMetaData != null) {
          if (indexMetaData.mappings().containsKey(request.type())) {
            builder.put(newIndexMetaDataBuilder(indexMetaData).removeMapping(request.type()));
            changed=true;
          }
 else {
            latestIndexWithout=indexMetaData.index();
          }
        }
      }
      if (!changed) {
        throw new TypeMissingException(new Index(latestIndexWithout),request.type());
      }
      logger.info("[{}] remove_mapping [{}]",request.indices(),request.type());
      return ClusterState.builder().state(currentState).metaData(builder).build();
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
    }
  }
);
}
