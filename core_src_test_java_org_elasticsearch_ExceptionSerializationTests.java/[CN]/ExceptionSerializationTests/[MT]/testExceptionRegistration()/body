{
  final Set<Class> notRegistered=new HashSet<>();
  final Set<Class> hasDedicatedWrite=new HashSet<>();
  final Set<Class> registered=new HashSet<>();
  final String path="/org/elasticsearch";
  final Path startPath=PathUtils.get(ElasticsearchException.class.getProtectionDomain().getCodeSource().getLocation().toURI()).resolve("org").resolve("elasticsearch");
  final Set<? extends Class> ignore=Sets.newHashSet(org.elasticsearch.test.rest.parser.RestTestParseException.class,org.elasticsearch.test.rest.client.RestException.class,CancellableThreadsTests.CustomException.class,org.elasticsearch.rest.BytesRestResponseTests.WithHeadersException.class,AbstractClientHeadersTestCase.InternalException.class);
  FileVisitor<Path> visitor=new FileVisitor<Path>(){
    private Path pkgPrefix=PathUtils.get(path).getParent();
    @Override public FileVisitResult preVisitDirectory(    Path dir,    BasicFileAttributes attrs) throws IOException {
      Path next=pkgPrefix.resolve(dir.getFileName());
      if (ignore.contains(next)) {
        return FileVisitResult.SKIP_SUBTREE;
      }
      pkgPrefix=next;
      return FileVisitResult.CONTINUE;
    }
    @Override public FileVisitResult visitFile(    Path file,    BasicFileAttributes attrs) throws IOException {
      try {
        String filename=file.getFileName().toString();
        if (filename.endsWith(".class")) {
          Class<?> clazz=loadClass(filename);
          if (ignore.contains(clazz) == false) {
            if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false && isEsException(clazz)) {
              if (ElasticsearchException.isRegistered((Class<? extends Throwable>)clazz) == false && ElasticsearchException.class.equals(clazz.getEnclosingClass()) == false) {
                notRegistered.add(clazz);
              }
 else               if (ElasticsearchException.isRegistered((Class<? extends Throwable>)clazz)) {
                registered.add(clazz);
                try {
                  if (clazz.getDeclaredMethod("writeTo",StreamOutput.class) != null) {
                    hasDedicatedWrite.add(clazz);
                  }
                }
 catch (                Exception e) {
                }
              }
            }
          }
        }
      }
 catch (      ClassNotFoundException e) {
        throw new RuntimeException(e);
      }
      return FileVisitResult.CONTINUE;
    }
    private boolean isEsException(    Class<?> clazz){
      return ElasticsearchException.class.isAssignableFrom(clazz);
    }
    private Class<?> loadClass(    String filename) throws ClassNotFoundException {
      StringBuilder pkg=new StringBuilder();
      for (      Path p : pkgPrefix) {
        pkg.append(p.getFileName().toString()).append(".");
      }
      pkg.append(filename.substring(0,filename.length() - 6));
      return getClass().getClassLoader().loadClass(pkg.toString());
    }
    @Override public FileVisitResult visitFileFailed(    Path file,    IOException exc) throws IOException {
      throw exc;
    }
    @Override public FileVisitResult postVisitDirectory(    Path dir,    IOException exc) throws IOException {
      pkgPrefix=pkgPrefix.getParent();
      return FileVisitResult.CONTINUE;
    }
  }
;
  Files.walkFileTree(startPath,visitor);
  final Path testStartPath=PathUtils.get(ExceptionSerializationTests.class.getResource(path).toURI());
  Files.walkFileTree(testStartPath,visitor);
  assertTrue(notRegistered.remove(TestException.class));
  assertTrue(notRegistered.remove(UnknownHeaderException.class));
  assertTrue("Classes subclassing ElasticsearchException must be registered \n" + notRegistered.toString(),notRegistered.isEmpty());
  assertTrue(registered.removeAll(ElasticsearchException.getRegisteredKeys()));
  assertEquals(registered.toString(),0,registered.size());
}
