{
  if (options.nonOptionArguments().isEmpty() == false) {
    throw new UserError(ExitCodes.USAGE,"Positional arguments not allowed, found " + options.nonOptionArguments());
  }
  if (options.has(versionOption)) {
    if (options.has(daemonizeOption) || options.has(pidfileOption)) {
      throw new UserError(ExitCodes.USAGE,"Elasticsearch version option is mutually exclusive with any other option");
    }
    terminal.println("Version: " + org.elasticsearch.Version.CURRENT + ", Build: "+ Build.CURRENT.shortHash()+ "/"+ Build.CURRENT.date()+ ", JVM: "+ JvmInfo.jvmInfo().version());
    return;
  }
  final boolean daemonize=options.has(daemonizeOption);
  final String pidFile=pidfileOption.value(options);
  final Map<String,String> esSettings=new HashMap<>();
  for (  final KeyValuePair kvp : propertyOption.values(options)) {
    if (!kvp.key.startsWith("es.")) {
      throw new UserError(ExitCodes.USAGE,"Elasticsearch settings must be prefixed with [es.] but was [" + kvp.key + "]");
    }
    if (kvp.value.isEmpty()) {
      throw new UserError(ExitCodes.USAGE,"Elasticsearch setting [" + kvp.key + "] must not be empty");
    }
    esSettings.put(kvp.key,kvp.value);
  }
  init(daemonize,pidFile,esSettings);
}
