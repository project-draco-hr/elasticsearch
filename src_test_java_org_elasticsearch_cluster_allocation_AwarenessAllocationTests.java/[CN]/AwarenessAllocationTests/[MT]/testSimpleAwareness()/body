{
  Settings commonSettings=ImmutableSettings.settingsBuilder().put("cluster.routing.schedule","10ms").put("cluster.routing.allocation.awareness.attributes","rack_id").build();
  logger.info("--> starting 2 nodes on the same rack");
  internalCluster().startNodesAsync(2,ImmutableSettings.settingsBuilder().put(commonSettings).put("node.rack_id","rack_1").build()).get();
  createIndex("test1");
  createIndex("test2");
  NumShards test1=getNumShards("test1");
  NumShards test2=getNumShards("test2");
  final int totalPrimaries=test1.numPrimaries + test2.numPrimaries;
  ensureGreen();
  logger.info("--> starting 1 node on a different rack");
  final String node3=internalCluster().startNode(ImmutableSettings.settingsBuilder().put(commonSettings).put("node.rack_id","rack_2").build());
  assertThat(awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object input){
      logger.info("--> waiting for no relocation");
      ClusterHealthResponse clusterHealth=client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().setWaitForNodes("3").setWaitForRelocatingShards(0).get();
      if (clusterHealth.isTimedOut()) {
        return false;
      }
      logger.info("--> checking current state");
      ClusterState clusterState=client().admin().cluster().prepareState().execute().actionGet().getState();
      ObjectIntHashMap<String> counts=new ObjectIntHashMap<>();
      for (      IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {
        for (        IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {
          for (          ShardRouting shardRouting : indexShardRoutingTable) {
            counts.addTo(clusterState.nodes().get(shardRouting.currentNodeId()).name(),1);
          }
        }
      }
      return counts.get(node3) == totalPrimaries;
    }
  }
,10,TimeUnit.SECONDS),equalTo(true));
}
