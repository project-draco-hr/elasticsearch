{
  WNode node=null, group=null, p;
  for (int spins=-1; ; ) {
    for (; ; ) {
      long s, m, ns;
      WNode h, q;
      Thread w;
      if (group == null && (h=whead) != null && (q=h.next) != null && q.mode != RMODE)       break;
      if ((m=(s=state) & ABITS) < RFULL ? U.compareAndSwapLong(this,STATE,s,ns=s + RUNIT) : (m < WBIT && (ns=tryIncReaderOverflow(s)) != 0L)) {
        if (group != null) {
          for (WNode r=group; ; ) {
            if ((w=r.thread) != null) {
              r.thread=null;
              U.unpark(w);
            }
            if ((r=group.cowait) == null)             break;
            U.compareAndSwapObject(group,WCOWAIT,r,r.cowait);
          }
        }
        return ns;
      }
      if (m >= WBIT)       break;
    }
    if (spins > 0) {
      if (ThreadLocalRandom.current().nextInt() >= 0)       --spins;
    }
 else     if ((p=wtail) == null) {
      WNode h=new WNode(WMODE,null);
      if (U.compareAndSwapObject(this,WHEAD,null,h))       wtail=h;
    }
 else     if (spins < 0)     spins=(p == whead) ? SPINS : 0;
 else     if (node == null)     node=new WNode(WMODE,p);
 else     if (node.prev != p)     node.prev=p;
 else     if (p.mode == RMODE && p != whead) {
      WNode pp=p.prev;
      if (pp != null && p == wtail && U.compareAndSwapObject(p,WCOWAIT,node.cowait=p.cowait,node)) {
        node.thread=Thread.currentThread();
        for (long time; ; ) {
          if (interruptible && Thread.interrupted())           return cancelWaiter(node,p,true);
          if (deadline == 0L)           time=0L;
 else           if ((time=deadline - System.nanoTime()) <= 0L)           return cancelWaiter(node,p,false);
          if (node.thread == null)           break;
          if (p.prev != pp || p.status == CANCELLED || p == whead || p.prev != pp) {
            node.thread=null;
            break;
          }
          if (node.thread == null)           break;
          U.park(false,time);
        }
        group=p;
      }
      node=null;
    }
 else     if (U.compareAndSwapObject(this,WTAIL,p,node)) {
      p.next=node;
      break;
    }
  }
  for (int spins=SPINS; ; ) {
    WNode np, pp, r;
    int ps;
    long m, s, ns;
    Thread w;
    while ((np=node.prev) != p && np != null)     (p=np).next=node;
    if (whead == p) {
      for (int k=spins; ; ) {
        if ((m=(s=state) & ABITS) != WBIT) {
          if (m < RFULL ? U.compareAndSwapLong(this,STATE,s,ns=s + RUNIT) : (ns=tryIncReaderOverflow(s)) != 0L) {
            whead=node;
            node.prev=null;
            while ((r=node.cowait) != null) {
              if (U.compareAndSwapObject(node,WCOWAIT,r,r.cowait) && (w=r.thread) != null) {
                r.thread=null;
                U.unpark(w);
              }
            }
            return ns;
          }
        }
 else         if (ThreadLocalRandom.current().nextInt() >= 0 && --k <= 0)         break;
      }
      if (spins < MAX_HEAD_SPINS)       spins<<=1;
    }
    if ((ps=p.status) == 0)     U.compareAndSwapInt(p,WSTATUS,0,WAITING);
 else     if (ps == CANCELLED) {
      if ((pp=p.prev) != null) {
        node.prev=pp;
        pp.next=node;
      }
    }
 else {
      long time;
      if (deadline == 0L)       time=0L;
 else       if ((time=deadline - System.nanoTime()) <= 0L)       return cancelWaiter(node,node,false);
      node.thread=Thread.currentThread();
      if (node.prev == p && p.status == WAITING && (p != whead || (state & ABITS) != WBIT))       U.park(false,time);
      node.thread=null;
      if (interruptible && Thread.interrupted())       return cancelWaiter(node,node,true);
    }
  }
}
