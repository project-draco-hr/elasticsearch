{
  List<Translog.Location> locations=new ArrayList<>();
  int translogOperations=100;
  final int prepareOp=44;
  Translog.TranslogGeneration translogGeneration=null;
  final boolean sync=randomBoolean();
  for (int op=0; op < translogOperations; op++) {
    locations.add(translog.add(new Translog.Index("test","" + op,Integer.toString(op).getBytes(Charset.forName("UTF-8")))));
    if (op == prepareOp) {
      translogGeneration=translog.getGeneration();
      translog.prepareCommit();
      assertEquals("expected this to be the first commit",1l,translogGeneration.translogFileGeneration);
      assertNotNull(translogGeneration.translogUUID);
    }
  }
  translog.sync();
  TranslogConfig config=translog.getConfig();
  config.setTranslogGeneration(translogGeneration);
  Path ckp=config.getTranslogPath().resolve(Translog.CHECKPOINT_FILE_NAME);
  Checkpoint read=Checkpoint.read(ckp);
  Checkpoint corrupted=new Checkpoint(0,0,0);
  Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)),corrupted,StandardOpenOption.WRITE,StandardOpenOption.CREATE_NEW);
  try (Translog translog=new Translog(config)){
    fail("corrupted");
  }
 catch (  IllegalStateException ex) {
    assertEquals(ex.getMessage(),"Checkpoint file translog-2.ckp already exists but has corrupted content expected: Checkpoint{offset=2683, numOps=55, translogFileGeneration= 2} but got: Checkpoint{offset=0, numOps=0, translogFileGeneration= 0}");
  }
  Checkpoint.write(config.getTranslogPath().resolve(Translog.getCommitCheckpointFileName(read.generation)),read,StandardOpenOption.WRITE,StandardOpenOption.TRUNCATE_EXISTING);
  try (Translog translog=new Translog(config)){
    assertNotNull(translogGeneration);
    assertEquals("lastCommitted must be 2 less than current - we never finished the commit",translogGeneration.translogFileGeneration + 2,translog.currentFileGeneration());
    assertFalse(translog.syncNeeded());
    try (Translog.Snapshot snapshot=translog.newSnapshot()){
      int upTo=sync ? translogOperations : prepareOp;
      for (int i=0; i < upTo; i++) {
        Translog.Operation next=snapshot.next();
        assertNotNull("operation " + i + " must be non-null synced: "+ sync,next);
        assertEquals("payload missmatch, synced: " + sync,i,Integer.parseInt(next.getSource().source.toUtf8()));
      }
    }
   }
 }
