{
  PhraseSuggestionContext suggestion=new PhraseSuggestionContext(suggester);
  XContentParser.Token token;
  String fieldName=null;
  boolean gramSizeSet=false;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      fieldName=parser.currentName();
    }
 else     if (token.isValue()) {
      if (!SuggestUtils.parseSuggestContext(parser,mapperService,fieldName,suggestion)) {
        if ("real_word_error_likelihood".equals(fieldName) || "realWorldErrorLikelihood".equals(fieldName)) {
          suggestion.setRealWordErrorLikelihood(parser.floatValue());
          if (suggestion.realworldErrorLikelyhood() <= 0.0) {
            throw new ElasticsearchIllegalArgumentException("real_word_error_likelihood must be > 0.0");
          }
        }
 else         if ("confidence".equals(fieldName)) {
          suggestion.setConfidence(parser.floatValue());
          if (suggestion.confidence() < 0.0) {
            throw new ElasticsearchIllegalArgumentException("confidence must be >= 0.0");
          }
        }
 else         if ("separator".equals(fieldName)) {
          suggestion.setSeparator(new BytesRef(parser.text()));
        }
 else         if ("max_errors".equals(fieldName) || "maxErrors".equals(fieldName)) {
          suggestion.setMaxErrors(parser.floatValue());
          if (suggestion.maxErrors() <= 0.0) {
            throw new ElasticsearchIllegalArgumentException("max_error must be > 0.0");
          }
        }
 else         if ("gram_size".equals(fieldName) || "gramSize".equals(fieldName)) {
          suggestion.setGramSize(parser.intValue());
          if (suggestion.gramSize() < 1) {
            throw new ElasticsearchIllegalArgumentException("gram_size must be >= 1");
          }
          gramSizeSet=true;
        }
 else         if ("force_unigrams".equals(fieldName) || "forceUnigrams".equals(fieldName)) {
          suggestion.setRequireUnigram(parser.booleanValue());
        }
 else         if ("token_limit".equals(fieldName) || "tokenLimit".equals(fieldName)) {
          int tokenLimit=parser.intValue();
          if (tokenLimit <= 0) {
            throw new ElasticsearchIllegalArgumentException("token_limit must be >= 1");
          }
          suggestion.setTokenLimit(tokenLimit);
        }
 else {
          throw new ElasticsearchIllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
        }
      }
    }
 else     if (token == Token.START_ARRAY) {
      if ("direct_generator".equals(fieldName) || "directGenerator".equals(fieldName)) {
        while ((token=parser.nextToken()) == Token.START_OBJECT) {
          PhraseSuggestionContext.DirectCandidateGenerator generator=new PhraseSuggestionContext.DirectCandidateGenerator();
          while ((token=parser.nextToken()) != Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
              fieldName=parser.currentName();
            }
            if (token.isValue()) {
              parseCandidateGenerator(parser,mapperService,fieldName,generator);
            }
          }
          verifyGenerator(generator);
          suggestion.addGenerator(generator);
        }
      }
 else {
        throw new ElasticsearchIllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
      }
    }
 else     if (token == Token.START_OBJECT) {
      if ("smoothing".equals(fieldName)) {
        parseSmoothingModel(parser,suggestion,fieldName);
      }
 else       if ("highlight".equals(fieldName)) {
        while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
 else           if (token.isValue()) {
            if ("pre_tag".equals(fieldName) || "preTag".equals(fieldName)) {
              suggestion.setPreTag(parser.utf8Bytes());
            }
 else             if ("post_tag".equals(fieldName) || "postTag".equals(fieldName)) {
              suggestion.setPostTag(parser.utf8Bytes());
            }
 else {
              throw new ElasticsearchIllegalArgumentException("suggester[phrase][highlight] doesn't support field [" + fieldName + "]");
            }
          }
        }
      }
 else       if ("collate".equals(fieldName)) {
        while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
 else           if ("query".equals(fieldName) || "filter".equals(fieldName)) {
            String templateNameOrTemplateContent;
            if (token == XContentParser.Token.START_OBJECT) {
              XContentBuilder builder=XContentBuilder.builder(parser.contentType().xContent());
              builder.copyCurrentStructure(parser);
              templateNameOrTemplateContent=builder.string();
            }
 else {
              templateNameOrTemplateContent=parser.text();
            }
            if (templateNameOrTemplateContent == null) {
              throw new ElasticsearchIllegalArgumentException("suggester[phrase][collate] no query/filter found in collate object");
            }
            if (suggestion.getCollateFilterScript() != null) {
              throw new ElasticsearchIllegalArgumentException("suggester[phrase][collate] filter already set, doesn't support additional [" + fieldName + "]");
            }
            if (suggestion.getCollateQueryScript() != null) {
              throw new ElasticsearchIllegalArgumentException("suggester[phrase][collate] query already set, doesn't support additional [" + fieldName + "]");
            }
            CompiledScript compiledScript=suggester.scriptService().compile(MustacheScriptEngineService.NAME,templateNameOrTemplateContent,ScriptType.INLINE,ScriptContext.SEARCH);
            if ("query".equals(fieldName)) {
              suggestion.setCollateQueryScript(compiledScript);
            }
 else {
              suggestion.setCollateFilterScript(compiledScript);
            }
          }
 else           if ("preference".equals(fieldName)) {
            suggestion.setPreference(parser.text());
          }
 else           if ("params".equals(fieldName)) {
            suggestion.setCollateScriptParams(parser.map());
          }
 else           if ("prune".equals(fieldName)) {
            if (parser.isBooleanValue()) {
              suggestion.setCollatePrune(parser.booleanValue());
            }
 else {
              throw new ElasticsearchIllegalArgumentException("suggester[phrase][collate] prune must be either 'true' or 'false'");
            }
          }
 else {
            throw new ElasticsearchIllegalArgumentException("suggester[phrase][collate] doesn't support field [" + fieldName + "]");
          }
        }
      }
 else {
        throw new ElasticsearchIllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
      }
    }
 else {
      throw new ElasticsearchIllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
    }
  }
  if (suggestion.getField() == null) {
    throw new ElasticsearchIllegalArgumentException("The required field option is missing");
  }
  FieldMapper fieldMapper=mapperService.smartNameFieldMapper(suggestion.getField());
  if (fieldMapper == null) {
    throw new ElasticsearchIllegalArgumentException("No mapping found for field [" + suggestion.getField() + "]");
  }
 else   if (suggestion.getAnalyzer() == null) {
    if (fieldMapper.searchAnalyzer() == null) {
      suggestion.setAnalyzer(mapperService.searchAnalyzer());
    }
 else {
      suggestion.setAnalyzer(fieldMapper.searchAnalyzer());
    }
  }
  if (suggestion.model() == null) {
    suggestion.setModel(StupidBackoffScorer.FACTORY);
  }
  if (!gramSizeSet || suggestion.generators().isEmpty()) {
    final ShingleTokenFilterFactory.Factory shingleFilterFactory=SuggestUtils.getShingleFilterFactory(suggestion.getAnalyzer());
    if (!gramSizeSet) {
      if (shingleFilterFactory != null) {
        suggestion.setGramSize(shingleFilterFactory.getMaxShingleSize());
        if (suggestion.getAnalyzer() == null && shingleFilterFactory.getMinShingleSize() > 1 && !shingleFilterFactory.getOutputUnigrams()) {
          throw new ElasticsearchIllegalArgumentException("The default analyzer for field: [" + suggestion.getField() + "] doesn't emit unigrams. If this is intentional try to set the analyzer explicitly");
        }
      }
    }
    if (suggestion.generators().isEmpty()) {
      if (shingleFilterFactory != null && shingleFilterFactory.getMinShingleSize() > 1 && !shingleFilterFactory.getOutputUnigrams() && suggestion.getRequireUnigram()) {
        throw new ElasticsearchIllegalArgumentException("The default candidate generator for phrase suggest can't operate on field: [" + suggestion.getField() + "] since it doesn't emit unigrams. If this is intentional try to set the candidate generator field explicitly");
      }
      DirectCandidateGenerator generator=new DirectCandidateGenerator();
      generator.setField(suggestion.getField());
      suggestion.addGenerator(generator);
    }
  }
  return suggestion;
}
