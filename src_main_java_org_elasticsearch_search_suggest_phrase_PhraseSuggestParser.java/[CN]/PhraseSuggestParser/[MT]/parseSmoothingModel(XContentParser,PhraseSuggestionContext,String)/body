{
  XContentParser.Token token;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      fieldName=parser.currentName();
      if ("linear".equals(fieldName)) {
        ensureNoSmoothing(suggestion);
        final double[] lambdas=new double[3];
        while ((token=parser.nextToken()) != Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
          if (token.isValue()) {
            if ("trigram_lambda".equals(fieldName) || "trigramLambda".equals(fieldName)) {
              lambdas[0]=parser.doubleValue();
              if (lambdas[0] < 0) {
                throw new ElasticsearchIllegalArgumentException("trigram_lambda must be positive");
              }
            }
 else             if ("bigram_lambda".equals(fieldName) || "bigramLambda".equals(fieldName)) {
              lambdas[1]=parser.doubleValue();
              if (lambdas[1] < 0) {
                throw new ElasticsearchIllegalArgumentException("bigram_lambda must be positive");
              }
            }
 else             if ("unigram_lambda".equals(fieldName) || "unigramLambda".equals(fieldName)) {
              lambdas[2]=parser.doubleValue();
              if (lambdas[2] < 0) {
                throw new ElasticsearchIllegalArgumentException("unigram_lambda must be positive");
              }
            }
 else {
              throw new ElasticsearchIllegalArgumentException("suggester[phrase][smoothing][linear] doesn't support field [" + fieldName + "]");
            }
          }
        }
        double sum=0.0d;
        for (int i=0; i < lambdas.length; i++) {
          sum+=lambdas[i];
        }
        if (Math.abs(sum - 1.0) > 0.001) {
          throw new ElasticsearchIllegalArgumentException("linear smoothing lambdas must sum to 1");
        }
        suggestion.setModel(new WordScorer.WordScorerFactory(){
          @Override public WordScorer newScorer(          IndexReader reader,          Terms terms,          String field,          double realWordLikelyhood,          BytesRef separator) throws IOException {
            return new LinearInterpoatingScorer(reader,terms,field,realWordLikelyhood,separator,lambdas[0],lambdas[1],lambdas[2]);
          }
        }
);
      }
 else       if ("laplace".equals(fieldName)) {
        ensureNoSmoothing(suggestion);
        double theAlpha=0.5;
        while ((token=parser.nextToken()) != Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
          if (token.isValue() && "alpha".equals(fieldName)) {
            theAlpha=parser.doubleValue();
          }
        }
        final double alpha=theAlpha;
        suggestion.setModel(new WordScorer.WordScorerFactory(){
          @Override public WordScorer newScorer(          IndexReader reader,          Terms terms,          String field,          double realWordLikelyhood,          BytesRef separator) throws IOException {
            return new LaplaceScorer(reader,terms,field,realWordLikelyhood,separator,alpha);
          }
        }
);
      }
 else       if ("stupid_backoff".equals(fieldName) || "stupidBackoff".equals(fieldName)) {
        ensureNoSmoothing(suggestion);
        double theDiscount=0.4;
        while ((token=parser.nextToken()) != Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
          if (token.isValue() && "discount".equals(fieldName)) {
            theDiscount=parser.doubleValue();
          }
        }
        final double discount=theDiscount;
        suggestion.setModel(new WordScorer.WordScorerFactory(){
          @Override public WordScorer newScorer(          IndexReader reader,          Terms terms,          String field,          double realWordLikelyhood,          BytesRef separator) throws IOException {
            return new StupidBackoffScorer(reader,terms,field,realWordLikelyhood,separator,discount);
          }
        }
);
      }
 else {
        throw new ElasticsearchIllegalArgumentException("suggester[phrase] doesn't support object field [" + fieldName + "]");
      }
    }
  }
}
