{
  PhraseSuggestionContext suggestion=new PhraseSuggestionContext(suggester);
  XContentParser.Token token;
  String fieldName=null;
  boolean gramSizeSet=false;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      fieldName=parser.currentName();
    }
 else     if (token.isValue()) {
      if (!SuggestUtils.parseSuggestContext(parser,context,fieldName,suggestion)) {
        if ("real_word_error_likelihood".equals(fieldName)) {
          suggestion.setRealWordErrorLikelihood(parser.floatValue());
          if (suggestion.realworldErrorLikelyhood() <= 0.0) {
            throw new ElasticSearchIllegalArgumentException("real_word_error_likelihood must be > 0.0");
          }
        }
 else         if ("confidence".equals(fieldName)) {
          suggestion.setConfidence(parser.floatValue());
          if (suggestion.confidence() < 0.0) {
            throw new ElasticSearchIllegalArgumentException("confidence must be >= 0.0");
          }
        }
 else         if ("separator".equals(fieldName)) {
          suggestion.setSeparator(new BytesRef(parser.text()));
        }
 else         if ("max_errors".equals(fieldName)) {
          suggestion.setMaxErrors(parser.floatValue());
          if (suggestion.maxErrors() <= 0.0) {
            throw new ElasticSearchIllegalArgumentException("max_error must be > 0.0");
          }
        }
 else         if ("gram_size".equals(fieldName)) {
          suggestion.setGramSize(parser.intValue());
          if (suggestion.gramSize() < 1) {
            throw new ElasticSearchIllegalArgumentException("gram_size must be >= 1");
          }
          gramSizeSet=true;
        }
 else         if ("force_unigrams".equals(fieldName)) {
          suggestion.setRequireUnigram(parser.booleanValue());
        }
      }
    }
 else     if (token == Token.START_ARRAY) {
      if ("direct_generator".equals(fieldName)) {
        while ((token=parser.nextToken()) == Token.START_OBJECT) {
          PhraseSuggestionContext.DirectCandidateGenerator generator=new PhraseSuggestionContext.DirectCandidateGenerator();
          while ((token=parser.nextToken()) != Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
              fieldName=parser.currentName();
            }
            if (token.isValue()) {
              parseCandidateGenerator(parser,context,fieldName,generator);
            }
          }
          verifyGenerator(context,generator);
          suggestion.addGenerator(generator);
        }
      }
 else {
        throw new ElasticSearchIllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
      }
    }
 else     if (token == Token.START_OBJECT) {
      if ("linear".equals(fieldName)) {
        ensureNoSmoothing(suggestion);
        final double[] lambdas=new double[3];
        while ((token=parser.nextToken()) != Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
          if (token.isValue()) {
            if ("trigram_lambda".equals(fieldName)) {
              lambdas[0]=parser.doubleValue();
              if (lambdas[0] < 0) {
                throw new ElasticSearchIllegalArgumentException("trigram_lambda must be positive");
              }
            }
            if ("bigram_lambda".equals(fieldName)) {
              lambdas[1]=parser.doubleValue();
              if (lambdas[1] < 0) {
                throw new ElasticSearchIllegalArgumentException("bigram_lambda must be positive");
              }
            }
            if ("unigram_lambda".equals(fieldName)) {
              lambdas[2]=parser.doubleValue();
              if (lambdas[2] < 0) {
                throw new ElasticSearchIllegalArgumentException("unigram_lambda must be positive");
              }
            }
          }
        }
        double sum=0.0d;
        for (int i=0; i < lambdas.length; i++) {
          sum+=lambdas[i];
        }
        if (Math.abs(sum - 1.0) > 0.001) {
          throw new ElasticSearchIllegalArgumentException("linear smoothing lambdas must sum to 1");
        }
        suggestion.setModel(new WordScorer.WordScorerFactory(){
          @Override public WordScorer newScorer(          IndexReader reader,          String field,          double realWordLikelyhood,          BytesRef separator) throws IOException {
            return new LinearInterpoatingScorer(reader,field,realWordLikelyhood,separator,lambdas[0],lambdas[1],lambdas[2]);
          }
        }
);
      }
 else       if ("laplace".equals(fieldName)) {
        ensureNoSmoothing(suggestion);
        double theAlpha=0.5;
        while ((token=parser.nextToken()) != Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
          if (token.isValue()) {
            if ("alpha".equals(fieldName)) {
              theAlpha=parser.doubleValue();
            }
          }
        }
        final double alpha=theAlpha;
        suggestion.setModel(new WordScorer.WordScorerFactory(){
          @Override public WordScorer newScorer(          IndexReader reader,          String field,          double realWordLikelyhood,          BytesRef separator) throws IOException {
            return new LaplaceScorer(reader,field,realWordLikelyhood,separator,alpha);
          }
        }
);
      }
 else       if ("stupid_backoff".equals(fieldName)) {
        ensureNoSmoothing(suggestion);
        double theDiscount=0.4;
        while ((token=parser.nextToken()) != Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
          if (token.isValue()) {
            if ("discount".equals(fieldName)) {
              theDiscount=parser.doubleValue();
            }
          }
        }
        final double discount=theDiscount;
        suggestion.setModel(new WordScorer.WordScorerFactory(){
          @Override public WordScorer newScorer(          IndexReader reader,          String field,          double realWordLikelyhood,          BytesRef separator) throws IOException {
            return new StupidBackoffScorer(reader,field,realWordLikelyhood,separator,discount);
          }
        }
);
      }
 else {
        throw new ElasticSearchIllegalArgumentException("suggester[phrase] doesn't support object field [" + fieldName + "]");
      }
    }
 else {
      throw new ElasticSearchIllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
    }
  }
  if (suggestion.getField() == null) {
    throw new ElasticSearchIllegalArgumentException("The required field option is missing");
  }
  if (suggestion.model() == null) {
    suggestion.setModel(LaplaceScorer.FACTORY);
  }
  if (!gramSizeSet || suggestion.generators().isEmpty()) {
    final ShingleTokenFilterFactory.Factory shingleFilterFactory=SuggestUtils.getShingleFilterFactory(suggestion.getAnalyzer() == null ? context.mapperService().fieldSearchAnalyzer(suggestion.getField()) : suggestion.getAnalyzer());
    ;
    if (!gramSizeSet) {
      if (shingleFilterFactory != null) {
        suggestion.setGramSize(shingleFilterFactory.getMaxShingleSize());
        if (suggestion.getAnalyzer() == null && shingleFilterFactory.getMinShingleSize() > 1 && !shingleFilterFactory.getOutputUnigrams()) {
          throw new ElasticSearchIllegalArgumentException("The default analyzer for field: [" + suggestion.getField() + "] doesn't emit unigrams. If this is intentional try to set the analyzer explicitly");
        }
      }
    }
    if (suggestion.generators().isEmpty()) {
      if (shingleFilterFactory != null && shingleFilterFactory.getMinShingleSize() > 1 && !shingleFilterFactory.getOutputUnigrams() && suggestion.getRequireUnigram()) {
        throw new ElasticSearchIllegalArgumentException("The default candidate generator for phrase suggest can't operate on field: [" + suggestion.getField() + "] since it doesn't emit unigrams. If this is intentional try to set the candidate generator field explicitly");
      }
      DirectCandidateGenerator generator=new DirectCandidateGenerator();
      generator.setField(suggestion.getField());
      suggestion.addGenerator(generator);
    }
  }
  return suggestion;
}
