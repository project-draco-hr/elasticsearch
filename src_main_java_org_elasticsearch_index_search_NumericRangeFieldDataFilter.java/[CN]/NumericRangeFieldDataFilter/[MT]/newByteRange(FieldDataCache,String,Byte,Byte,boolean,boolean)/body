{
  return new NumericRangeFieldDataFilter<Byte>(fieldDataCache,field,lowerVal,upperVal,includeLower,includeUpper){
    @Override public DocIdSet getDocIdSet(    AtomicReaderContext ctx,    Bits acceptedDocs) throws IOException {
      final byte inclusiveLowerPoint, inclusiveUpperPoint;
      if (lowerVal != null) {
        byte i=lowerVal.byteValue();
        if (!includeLower && i == Byte.MAX_VALUE)         return null;
        inclusiveLowerPoint=(byte)(includeLower ? i : (i + 1));
      }
 else {
        inclusiveLowerPoint=Byte.MIN_VALUE;
      }
      if (upperVal != null) {
        byte i=upperVal.byteValue();
        if (!includeUpper && i == Byte.MIN_VALUE)         return null;
        inclusiveUpperPoint=(byte)(includeUpper ? i : (i - 1));
      }
 else {
        inclusiveUpperPoint=Byte.MAX_VALUE;
      }
      if (inclusiveLowerPoint > inclusiveUpperPoint)       return null;
      final ByteFieldData fieldData=(ByteFieldData)this.fieldDataCache.cache(FieldDataType.DefaultTypes.BYTE,ctx.reader(),field);
      return new MatchDocIdSet(ctx.reader().maxDoc(),acceptedDocs){
        @Override public boolean isCacheable(){
          return true;
        }
        @Override protected boolean matchDoc(        int doc){
          if (!fieldData.hasValue(doc)) {
            return false;
          }
          if (fieldData.multiValued()) {
            byte[] values=fieldData.values(doc);
            for (            byte value : values) {
              if (value >= inclusiveLowerPoint && value <= inclusiveUpperPoint) {
                return true;
              }
            }
            return false;
          }
 else {
            byte value=fieldData.value(doc);
            return value >= inclusiveLowerPoint && value <= inclusiveUpperPoint;
          }
        }
      }
;
    }
  }
;
}
