{
  boolean success=false;
  try (InputStream partSliceStream=new PartSliceStream(blobContainer,fileInfo)){
    final InputStream stream;
    if (restoreRateLimiter == null) {
      stream=partSliceStream;
    }
 else {
      stream=new RateLimitingInputStream(partSliceStream,restoreRateLimiter,restoreThrottleListener);
    }
    try (final IndexOutput indexOutput=store.createVerifyingOutput(fileInfo.physicalName(),fileInfo.metadata(),IOContext.DEFAULT)){
      final byte[] buffer=new byte[BUFFER_SIZE];
      int length;
      while ((length=stream.read(buffer)) > 0) {
        indexOutput.writeBytes(buffer,0,length);
        recoveryState.getIndex().addRecoveredBytesToFile(fileInfo.name(),length);
      }
      Store.verify(indexOutput);
      indexOutput.close();
      if (fileInfo.metadata().hasLegacyChecksum()) {
        Store.LegacyChecksums legacyChecksums=new Store.LegacyChecksums();
        legacyChecksums.add(fileInfo.metadata());
        legacyChecksums.write(store);
      }
      store.directory().sync(Collections.singleton(fileInfo.physicalName()));
      success=true;
    }
 catch (    CorruptIndexException|IndexFormatTooOldException|IndexFormatTooNewException ex) {
      try {
        store.markStoreCorrupted(ex);
      }
 catch (      IOException e) {
        logger.warn("store cannot be marked as corrupted",e);
      }
      throw ex;
    }
 finally {
      if (success == false) {
        store.deleteQuiet(fileInfo.physicalName());
      }
    }
  }
 }
