{
  final UnicastPingRequest pingRequest=new UnicastPingRequest();
  pingRequest.id=sendPingsHandler.id();
  pingRequest.timeout=timeout;
  DiscoveryNodes discoNodes=nodesProvider.nodes();
  pingRequest.pingResponse=new PingResponse(discoNodes.localNode(),discoNodes.masterNode(),clusterName);
  HashSet<DiscoveryNode> nodesToPingSet=new HashSet<>();
  for (  PingResponse temporalResponse : temporalResponses) {
    if (clusterName.equals(temporalResponse.clusterName())) {
      nodesToPingSet.add(temporalResponse.target());
    }
  }
  for (  UnicastHostsProvider provider : hostsProviders) {
    nodesToPingSet.addAll(provider.buildDynamicNodes());
  }
  for (  ObjectCursor<DiscoveryNode> masterNode : discoNodes.getMasterNodes().values()) {
    nodesToPingSet.add(masterNode.value);
  }
  List<DiscoveryNode> sortedNodesToPing=electMasterService.sortByMasterLikelihood(nodesToPingSet);
  ArrayList<DiscoveryNode> nodesToPing=Lists.newArrayList(configuredTargetNodes);
  nodesToPing.addAll(sortedNodesToPing);
  final CountDownLatch latch=new CountDownLatch(nodesToPing.size());
  for (  final DiscoveryNode node : nodesToPing) {
    boolean nodeFoundByAddressX;
    DiscoveryNode nodeToSendX=discoNodes.findByAddress(node.address());
    if (nodeToSendX != null) {
      nodeFoundByAddressX=true;
    }
 else {
      nodeToSendX=node;
      nodeFoundByAddressX=false;
    }
    final DiscoveryNode nodeToSend=nodeToSendX;
    final boolean nodeFoundByAddress=nodeFoundByAddressX;
    if (!transportService.nodeConnected(nodeToSend)) {
      if (sendPingsHandler.isClosed()) {
        return;
      }
      if (!nodeFoundByAddress) {
        sendPingsHandler.nodeToDisconnect.add(nodeToSend);
      }
      sendPingsHandler.executor().execute(new Runnable(){
        @Override public void run(){
          if (sendPingsHandler.isClosed()) {
            return;
          }
          boolean success=false;
          try {
            if (!nodeFoundByAddress) {
              logger.trace("[{}] connecting (light) to {}",sendPingsHandler.id(),nodeToSend);
              transportService.connectToNodeLight(nodeToSend);
            }
 else {
              logger.trace("[{}] connecting to {}",sendPingsHandler.id(),nodeToSend);
              transportService.connectToNode(nodeToSend);
            }
            logger.trace("[{}] connected to {}",sendPingsHandler.id(),node);
            if (receivedResponses.containsKey(sendPingsHandler.id())) {
              sendPingRequestToNode(sendPingsHandler.id(),timeout,pingRequest,latch,node,nodeToSend);
            }
 else {
              latch.countDown();
              logger.trace("[{}] connect to {} was too long outside of ping window, bailing",sendPingsHandler.id(),node);
            }
            success=true;
          }
 catch (          ConnectTransportException e) {
            logger.trace("[{}] failed to connect to {}",e,sendPingsHandler.id(),nodeToSend);
          }
catch (          Throwable e) {
            logger.warn("[{}] failed send ping to {}",e,sendPingsHandler.id(),nodeToSend);
          }
 finally {
            if (!success) {
              latch.countDown();
            }
          }
        }
      }
);
    }
 else {
      sendPingRequestToNode(sendPingsHandler.id(),timeout,pingRequest,latch,node,nodeToSend);
    }
  }
  if (waitTime != null) {
    try {
      latch.await(waitTime.millis(),TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
    }
  }
}
