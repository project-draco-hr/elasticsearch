{
  final UnicastPingRequest pingRequest=new UnicastPingRequest();
  pingRequest.id=sendPingsHandler.id();
  pingRequest.timeout=timeout;
  DiscoveryNodes discoNodes=contextProvider.nodes();
  pingRequest.pingResponse=createPingResponse(discoNodes);
  HashSet<DiscoveryNode> nodesToPingSet=new HashSet<>();
  for (  PingResponse temporalResponse : temporalResponses) {
    if (clusterName.equals(temporalResponse.clusterName())) {
      nodesToPingSet.add(temporalResponse.node());
    }
  }
  for (  UnicastHostsProvider provider : hostsProviders) {
    nodesToPingSet.addAll(provider.buildDynamicNodes());
  }
  for (  ObjectCursor<DiscoveryNode> masterNode : discoNodes.getMasterNodes().values()) {
    nodesToPingSet.add(masterNode.value);
  }
  List<DiscoveryNode> sortedNodesToPing=electMasterService.sortByMasterLikelihood(nodesToPingSet);
  ArrayList<DiscoveryNode> nodesToPing=Lists.newArrayList(configuredTargetNodes);
  nodesToPing.addAll(sortedNodesToPing);
  final CountDownLatch latch=new CountDownLatch(nodesToPing.size());
  for (  final DiscoveryNode node : nodesToPing) {
    final boolean nodeFoundByAddress;
    DiscoveryNode nodeToSend=discoNodes.findByAddress(node.address());
    if (nodeToSend != null) {
      nodeFoundByAddress=true;
    }
 else {
      nodeToSend=node;
      nodeFoundByAddress=false;
    }
    if (!transportService.nodeConnected(nodeToSend)) {
      if (sendPingsHandler.isClosed()) {
        return;
      }
      if (!nodeFoundByAddress) {
        if (!nodeToSend.id().startsWith(UNICAST_NODE_PREFIX)) {
          DiscoveryNode tempNode=new DiscoveryNode("",UNICAST_NODE_PREFIX + unicastNodeIdGenerator.incrementAndGet() + "_"+ nodeToSend.id()+ "#",nodeToSend.getHostName(),nodeToSend.getHostAddress(),nodeToSend.address(),nodeToSend.attributes(),nodeToSend.version());
          logger.trace("replacing {} with temp node {}",nodeToSend,tempNode);
          nodeToSend=tempNode;
        }
        sendPingsHandler.nodeToDisconnect.add(nodeToSend);
      }
      final DiscoveryNode finalNodeToSend=nodeToSend;
      sendPingsHandler.executor().execute(new Runnable(){
        @Override public void run(){
          if (sendPingsHandler.isClosed()) {
            return;
          }
          boolean success=false;
          try {
            if (!nodeFoundByAddress) {
              logger.trace("[{}] connecting (light) to {}",sendPingsHandler.id(),finalNodeToSend);
              transportService.connectToNodeLight(finalNodeToSend);
            }
 else {
              logger.trace("[{}] connecting to {}",sendPingsHandler.id(),finalNodeToSend);
              transportService.connectToNode(finalNodeToSend);
            }
            logger.trace("[{}] connected to {}",sendPingsHandler.id(),node);
            if (receivedResponses.containsKey(sendPingsHandler.id())) {
              sendPingRequestToNode(sendPingsHandler.id(),timeout,pingRequest,latch,node,finalNodeToSend);
            }
 else {
              latch.countDown();
              logger.trace("[{}] connect to {} was too long outside of ping window, bailing",sendPingsHandler.id(),node);
            }
            success=true;
          }
 catch (          ConnectTransportException e) {
            logger.trace("[{}] failed to connect to {}",e,sendPingsHandler.id(),finalNodeToSend);
          }
catch (          Throwable e) {
            logger.warn("[{}] failed send ping to {}",e,sendPingsHandler.id(),finalNodeToSend);
          }
 finally {
            if (!success) {
              latch.countDown();
            }
          }
        }
      }
);
    }
 else {
      sendPingRequestToNode(sendPingsHandler.id(),timeout,pingRequest,latch,node,nodeToSend);
    }
  }
  if (waitTime != null) {
    try {
      latch.await(waitTime.millis(),TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
    }
  }
}
