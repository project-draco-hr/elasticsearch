{
  final SendPingsHandler sendPingsHandler=new SendPingsHandler(pingIdGenerator.incrementAndGet());
  receivedResponses.put(sendPingsHandler.id(),ConcurrentCollections.<DiscoveryNode,PingResponse>newConcurrentMap());
  sendPings(timeout,null,sendPingsHandler);
  threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 2),ThreadPool.Names.GENERIC,new Runnable(){
    @Override public void run(){
      try {
        sendPings(timeout,null,sendPingsHandler);
        threadPool.schedule(TimeValue.timeValueMillis(timeout.millis() / 2),ThreadPool.Names.GENERIC,new Runnable(){
          @Override public void run(){
            try {
              sendPings(timeout,TimeValue.timeValueMillis(timeout.millis() / 2),sendPingsHandler);
              ConcurrentMap<DiscoveryNode,PingResponse> responses=receivedResponses.remove(sendPingsHandler.id());
              sendPingsHandler.close();
              for (              DiscoveryNode node : sendPingsHandler.nodeToDisconnect) {
                logger.trace("[{}] disconnecting from {}",sendPingsHandler.id(),node);
                transportService.disconnectFromNode(node);
              }
              listener.onPing(responses.values().toArray(new PingResponse[responses.size()]));
            }
 catch (            EsRejectedExecutionException ex) {
              logger.debug("Ping execution rejected",ex);
            }
          }
        }
);
      }
 catch (      EsRejectedExecutionException ex) {
        logger.debug("Ping execution rejected",ex);
      }
    }
  }
);
}
