{
  logger.trace("[{}] sending to {}",id,nodeToSend);
  transportService.sendRequest(nodeToSend,UnicastPingRequestHandler.ACTION,pingRequest,TransportRequestOptions.options().withTimeout((long)(timeout.millis() * 1.25)),new BaseTransportResponseHandler<UnicastPingResponse>(){
    @Override public UnicastPingResponse newInstance(){
      return new UnicastPingResponse();
    }
    @Override public String executor(){
      return ThreadPool.Names.SAME;
    }
    @Override public void handleResponse(    UnicastPingResponse response){
      logger.trace("[{}] received response from {}: {}",id,nodeToSend,Arrays.toString(response.pingResponses));
      try {
        DiscoveryNodes discoveryNodes=nodesProvider.nodes();
        for (        PingResponse pingResponse : response.pingResponses) {
          if (pingResponse.target().id().equals(discoveryNodes.localNodeId())) {
            continue;
          }
          if (!pingResponse.clusterName().equals(clusterName)) {
            logger.debug("[{}] filtering out response from {}, not same cluster_name [{}]",id,pingResponse.target(),pingResponse.clusterName().value());
            continue;
          }
          ConcurrentMap<DiscoveryNode,PingResponse> responses=receivedResponses.get(response.id);
          if (responses == null) {
            logger.warn("received ping response {} with no matching id [{}]",pingResponse,response.id);
          }
 else {
            responses.put(pingResponse.target(),pingResponse);
          }
        }
      }
  finally {
        latch.countDown();
      }
    }
    @Override public void handleException(    TransportException exp){
      latch.countDown();
      if (exp instanceof ConnectTransportException) {
        logger.trace("failed to connect to {}",exp,nodeToSend);
      }
 else {
        logger.warn("failed to send ping to [{}]",exp,node);
      }
    }
  }
);
}
