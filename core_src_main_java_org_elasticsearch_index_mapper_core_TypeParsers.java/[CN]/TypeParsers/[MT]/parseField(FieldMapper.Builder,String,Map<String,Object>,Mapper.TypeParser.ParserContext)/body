{
  NamedAnalyzer indexAnalyzer=builder.fieldType().indexAnalyzer();
  NamedAnalyzer searchAnalyzer=builder.fieldType().searchAnalyzer();
  Version indexVersionCreated=parserContext.indexVersionCreated();
  for (Iterator<Map.Entry<String,Object>> iterator=fieldNode.entrySet().iterator(); iterator.hasNext(); ) {
    Map.Entry<String,Object> entry=iterator.next();
    final String propName=Strings.toUnderscoreCase(entry.getKey());
    final Object propNode=entry.getValue();
    if (propName.equals("index_name") && indexVersionCreated.before(Version.V_2_0_0_beta1)) {
      builder.indexName(propNode.toString());
      iterator.remove();
    }
 else     if (propName.equals("store")) {
      builder.store(parseStore(name,propNode.toString()));
      iterator.remove();
    }
 else     if (propName.equals("index")) {
      parseIndex(name,propNode.toString(),builder);
      iterator.remove();
    }
 else     if (propName.equals(DOC_VALUES)) {
      builder.docValues(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("term_vector")) {
      parseTermVector(name,propNode.toString(),builder);
      iterator.remove();
    }
 else     if (propName.equals("boost")) {
      builder.boost(nodeFloatValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("store_term_vectors")) {
      builder.storeTermVectors(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("store_term_vector_offsets")) {
      builder.storeTermVectorOffsets(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("store_term_vector_positions")) {
      builder.storeTermVectorPositions(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("store_term_vector_payloads")) {
      builder.storeTermVectorPayloads(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("omit_norms")) {
      builder.omitNorms(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("norms")) {
      final Map<String,Object> properties=nodeMapValue(propNode,"norms");
      for (Iterator<Entry<String,Object>> propsIterator=properties.entrySet().iterator(); propsIterator.hasNext(); ) {
        Entry<String,Object> entry2=propsIterator.next();
        final String propName2=Strings.toUnderscoreCase(entry2.getKey());
        final Object propNode2=entry2.getValue();
        if (propName2.equals("enabled")) {
          builder.omitNorms(!nodeBooleanValue(propNode2));
          propsIterator.remove();
        }
 else         if (propName2.equals(Loading.KEY)) {
          builder.normsLoading(Loading.parse(nodeStringValue(propNode2,null),null));
          propsIterator.remove();
        }
      }
      DocumentMapperParser.checkNoRemainingFields(propName,properties,parserContext.indexVersionCreated());
      iterator.remove();
    }
 else     if (propName.equals("omit_term_freq_and_positions")) {
      final IndexOptions op=nodeBooleanValue(propNode) ? IndexOptions.DOCS : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
      if (indexVersionCreated.onOrAfter(Version.V_1_0_0_RC2)) {
        throw new ElasticsearchParseException("'omit_term_freq_and_positions' is not supported anymore - use ['index_options' : 'docs']  instead");
      }
      builder.indexOptions(op);
      iterator.remove();
    }
 else     if (propName.equals("index_options")) {
      builder.indexOptions(nodeIndexOptionValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("analyzer") || propName.equals("index_analyzer") && indexVersionCreated.before(Version.V_2_0_0_beta1)) {
      NamedAnalyzer analyzer=parserContext.analysisService().analyzer(propNode.toString());
      if (analyzer == null) {
        throw new MapperParsingException("analyzer [" + propNode.toString() + "] not found for field ["+ name+ "]");
      }
      indexAnalyzer=analyzer;
      iterator.remove();
    }
 else     if (propName.equals("search_analyzer")) {
      NamedAnalyzer analyzer=parserContext.analysisService().analyzer(propNode.toString());
      if (analyzer == null) {
        throw new MapperParsingException("analyzer [" + propNode.toString() + "] not found for field ["+ name+ "]");
      }
      searchAnalyzer=analyzer;
      iterator.remove();
    }
 else     if (propName.equals("include_in_all")) {
      builder.includeInAll(nodeBooleanValue(propNode));
      iterator.remove();
    }
 else     if (propName.equals("postings_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) {
      iterator.remove();
    }
 else     if (propName.equals("doc_values_format") && indexVersionCreated.before(Version.V_2_0_0_beta1)) {
      iterator.remove();
    }
 else     if (propName.equals("similarity")) {
      builder.similarity(parserContext.getSimilarity(propNode.toString()));
      iterator.remove();
    }
 else     if (propName.equals("fielddata")) {
      final Settings settings=Settings.builder().put(SettingsLoader.Helper.loadNestedFromMap(nodeMapValue(propNode,"fielddata"))).build();
      builder.fieldDataSettings(settings);
      iterator.remove();
    }
 else     if (propName.equals("copy_to")) {
      if (parserContext.isWithinMultiField()) {
        if (indexVersionCreated.after(Version.V_2_1_0) || (indexVersionCreated.after(Version.V_2_0_1) && indexVersionCreated.before(Version.V_2_1_0))) {
          throw new MapperParsingException("copy_to in multi fields is not allowed. Found the copy_to in field [" + name + "] which is within a multi field.");
        }
 else {
          ESLoggerFactory.getLogger("mapping [" + parserContext.type() + "]").warn("Found a copy_to in field [" + name + "] which is within a multi field. This feature has been removed and the copy_to will be removed from the mapping.");
        }
      }
 else {
        parseCopyFields(propNode,builder);
      }
      iterator.remove();
    }
  }
  if (indexAnalyzer == null) {
    if (searchAnalyzer != null) {
      throw new MapperParsingException("analyzer on field [" + name + "] must be set when search_analyzer is set");
    }
  }
 else   if (searchAnalyzer == null) {
    searchAnalyzer=indexAnalyzer;
  }
  builder.indexAnalyzer(indexAnalyzer);
  builder.searchAnalyzer(searchAnalyzer);
}
