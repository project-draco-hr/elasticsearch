{
  super(settings);
  if (!DiscoveryNode.nodeRequiresLocalStorage(settings)) {
    nodeFiles=null;
    nodeIndicesLocations=null;
    locks=null;
    localNodeId=-1;
    return;
  }
  File[] nodesFiles=new File[environment.dataWithClusterFiles().length];
  Lock[] locks=new Lock[environment.dataWithClusterFiles().length];
  int localNodeId=-1;
  IOException lastException=null;
  int maxLocalStorageNodes=settings.getAsInt("node.max_local_storage_nodes",50);
  for (int possibleLockId=0; possibleLockId < maxLocalStorageNodes; possibleLockId++) {
    for (int dirIndex=0; dirIndex < environment.dataWithClusterFiles().length; dirIndex++) {
      File dir=new File(new File(environment.dataWithClusterFiles()[dirIndex],"nodes"),Integer.toString(possibleLockId));
      if (!dir.exists()) {
        FileSystemUtils.mkdirs(dir);
      }
      logger.trace("obtaining node lock on {} ...",dir.getAbsolutePath());
      try {
        NativeFSLockFactory lockFactory=new NativeFSLockFactory(dir.toPath());
        Lock tmpLock=lockFactory.makeLock("node.lock");
        boolean obtained=tmpLock.obtain();
        if (obtained) {
          locks[dirIndex]=tmpLock;
          nodesFiles[dirIndex]=dir;
          localNodeId=possibleLockId;
        }
 else {
          logger.trace("failed to obtain node lock on {}",dir.getAbsolutePath());
          for (int i=0; i < locks.length; i++) {
            if (locks[i] != null) {
              IOUtils.closeWhileHandlingException(locks[i]);
            }
            locks[i]=null;
          }
          break;
        }
      }
 catch (      IOException e) {
        logger.trace("failed to obtain node lock on {}",e,dir.getAbsolutePath());
        lastException=new IOException("failed to obtain lock on " + dir.getAbsolutePath(),e);
        for (int i=0; i < locks.length; i++) {
          IOUtils.closeWhileHandlingException(locks[i]);
          locks[i]=null;
        }
        break;
      }
    }
    if (locks[0] != null) {
      break;
    }
  }
  if (locks[0] == null) {
    throw new ElasticsearchIllegalStateException("Failed to obtain node lock, is the following location writable?: " + Arrays.toString(environment.dataWithClusterFiles()),lastException);
  }
  this.localNodeId=localNodeId;
  this.locks=locks;
  this.nodeFiles=nodesFiles;
  if (logger.isDebugEnabled()) {
    logger.debug("using node location [{}], local_node_id [{}]",nodesFiles,localNodeId);
  }
  if (logger.isTraceEnabled()) {
    StringBuilder sb=new StringBuilder("node data locations details:\n");
    for (    File file : nodesFiles) {
      sb.append(" -> ").append(file.getAbsolutePath()).append(", free_space [").append(new ByteSizeValue(file.getFreeSpace())).append("], usable_space [").append(new ByteSizeValue(file.getUsableSpace())).append("]\n");
    }
    logger.trace(sb.toString());
  }
  this.nodeIndicesLocations=new File[nodeFiles.length];
  for (int i=0; i < nodeFiles.length; i++) {
    nodeIndicesLocations[i]=new File(nodeFiles[i],"indices");
  }
}
