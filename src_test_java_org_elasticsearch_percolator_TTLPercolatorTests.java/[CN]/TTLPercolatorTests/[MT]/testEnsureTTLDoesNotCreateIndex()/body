{
  ensureGreen();
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("indices.ttl.interval",60,TimeUnit.SECONDS).build()).get();
  String typeMapping=XContentFactory.jsonBuilder().startObject().startObject("type1").startObject("_ttl").field("enabled",true).endObject().endObject().endObject().string();
  client().admin().indices().prepareCreate("test").setSettings(settingsBuilder().put("index.number_of_shards",1)).addMapping("type1",typeMapping).execute().actionGet();
  ensureGreen();
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("indices.ttl.interval",1,TimeUnit.SECONDS).build()).get();
  for (int i=0; i < 100; i++) {
    logger.debug("index doc {} ",i);
    try {
      client().prepareIndex("test","type1","" + i).setSource(jsonBuilder().startObject().startObject("query").startObject("term").field("field1","value1").endObject().endObject().endObject()).setTTL(randomIntBetween(1,500)).execute().actionGet();
    }
 catch (    MapperParsingException e) {
      logger.info("failed indexing {}",i,e);
      assertThat(e.getCause(),Matchers.instanceOf(AlreadyExpiredException.class));
    }
  }
  refresh();
  assertThat(awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object input){
      IndicesStatsResponse indicesStatsResponse=client().admin().indices().prepareStats("test").clear().setIndexing(true).get();
      logger.debug("delete count [{}]",indicesStatsResponse.getIndices().get("test").getTotal().getIndexing().getTotal().getDeleteCount());
      return indicesStatsResponse.getIndices().get("test").getTotal().getIndexing().getTotal().getDeleteCount() != 0;
    }
  }
,5,TimeUnit.SECONDS),equalTo(true));
  internalCluster().wipeIndices("test");
  client().admin().indices().prepareCreate("test").addMapping("type1",typeMapping).execute().actionGet();
}
