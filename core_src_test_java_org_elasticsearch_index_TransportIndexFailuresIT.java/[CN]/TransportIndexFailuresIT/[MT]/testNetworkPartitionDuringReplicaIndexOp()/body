{
  final String INDEX="testidx";
  List<String> nodes=internalCluster().startNodesAsync(2,nodeSettings).get();
  createIndex(INDEX);
  ensureGreen(INDEX);
  Settings s=Settings.builder().put("cluster.routing.allocation.enable","none").build();
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(s).get();
  ClusterState state=getNodeClusterState(nodes.get(0));
  IndexShardRoutingTable shard=state.getRoutingTable().index(INDEX).shard(0);
  String primaryNode;
  String replicaNode;
  if (shard.getShards().get(0).primary()) {
    primaryNode=nodes.get(0);
    replicaNode=nodes.get(1);
  }
 else {
    primaryNode=nodes.get(1);
    replicaNode=nodes.get(0);
  }
  logger.info("--> primary shard is on {}",primaryNode);
  IndexResponse resp=internalCluster().client(primaryNode).prepareIndex(INDEX,"doc").setSource("foo","bar").get();
  assertThat("document exists on primary node",internalCluster().client(primaryNode).prepareGet(INDEX,"doc",resp.getId()).setPreference("_only_local").get().isExists(),equalTo(true));
  assertThat("document exists on replica node",internalCluster().client(replicaNode).prepareGet(INDEX,"doc",resp.getId()).setPreference("_only_local").get().isExists(),equalTo(true));
  logger.info("--> preventing index/replica operations");
  TransportService mockTransportService=internalCluster().getInstance(TransportService.class,primaryNode);
  ((MockTransportService)mockTransportService).addFailToSendNoConnectRule(internalCluster().getInstance(Discovery.class,replicaNode).localNode(),ImmutableSet.of(IndexAction.NAME + "[r]"));
  mockTransportService=internalCluster().getInstance(TransportService.class,replicaNode);
  ((MockTransportService)mockTransportService).addFailToSendNoConnectRule(internalCluster().getInstance(Discovery.class,primaryNode).localNode(),ImmutableSet.of(IndexAction.NAME + "[r]"));
  logger.info("--> indexing into primary");
  resp=internalCluster().client(primaryNode).prepareIndex(INDEX,"doc").setSource("foo","baz").get();
  assertBusy(new Runnable(){
    @Override public void run(){
      assertThat(client().admin().cluster().prepareHealth().get().getStatus(),equalTo(ClusterHealthStatus.YELLOW));
    }
  }
);
  assertThat("document should still be indexed and available",client().prepareGet(INDEX,"doc",resp.getId()).get().isExists(),equalTo(true));
  state=getNodeClusterState(randomFrom(nodes.toArray(Strings.EMPTY_ARRAY)));
  RoutingNodes rn=state.routingNodes();
  logger.info("--> counts: total: {}, unassigned: {}, initializing: {}, relocating: {}, started: {}",rn.shards(new Predicate<ShardRouting>(){
    @Override public boolean apply(    ShardRouting input){
      return true;
    }
  }
).size(),rn.shardsWithState(UNASSIGNED).size(),rn.shardsWithState(INITIALIZING).size(),rn.shardsWithState(RELOCATING).size(),rn.shardsWithState(STARTED).size());
  logger.info("--> unassigned: {}, initializing: {}, relocating: {}, started: {}",rn.shardsWithState(UNASSIGNED),rn.shardsWithState(INITIALIZING),rn.shardsWithState(RELOCATING),rn.shardsWithState(STARTED));
  assertThat("only a single shard is now active (replica should be failed and not reallocated)",rn.shardsWithState(STARTED).size(),equalTo(1));
}
