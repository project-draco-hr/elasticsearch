{
  if (k == null || v == null)   throw new NullPointerException();
  int h=spread(k.hashCode());
  int len=0;
  for (Node<V>[] tab=table; ; ) {
    int i, fh;
    Node<V> f;
    Object fk;
    V fv;
    if (tab == null)     tab=initTable();
 else     if ((f=tabAt(tab,i=(tab.length - 1) & h)) == null) {
      if (casTabAt(tab,i,null,new Node<V>(h,k,v,null)))       break;
    }
 else     if ((fh=f.hash) < 0) {
      if ((fk=f.key) instanceof TreeBin) {
        TreeBin<V> t=(TreeBin<V>)fk;
        V oldVal=null;
        t.acquire(0);
        try {
          if (tabAt(tab,i) == f) {
            len=2;
            TreeNode<V> p=t.putTreeNode(h,k,v);
            if (p != null) {
              oldVal=p.val;
              if (!onlyIfAbsent)               p.val=v;
            }
          }
        }
  finally {
          t.release(0);
        }
        if (len != 0) {
          if (oldVal != null)           return oldVal;
          break;
        }
      }
 else       tab=(Node<V>[])fk;
    }
 else     if (onlyIfAbsent && fh == h && (fv=f.val) != null && ((fk=f.key) == k || k.equals(fk)))     return fv;
 else {
      V oldVal=null;
synchronized (f) {
        if (tabAt(tab,i) == f) {
          len=1;
          for (Node<V> e=f; ; ++len) {
            Object ek;
            V ev;
            if (e.hash == h && (ev=e.val) != null && ((ek=e.key) == k || k.equals(ek))) {
              oldVal=ev;
              if (!onlyIfAbsent)               e.val=v;
              break;
            }
            Node<V> last=e;
            if ((e=e.next) == null) {
              last.next=new Node<V>(h,k,v,null);
              if (len >= TREE_THRESHOLD)               replaceWithTreeBin(tab,i,k);
              break;
            }
          }
        }
      }
      if (len != 0) {
        if (oldVal != null)         return oldVal;
        break;
      }
    }
  }
  addCount(1L,len);
  return null;
}
