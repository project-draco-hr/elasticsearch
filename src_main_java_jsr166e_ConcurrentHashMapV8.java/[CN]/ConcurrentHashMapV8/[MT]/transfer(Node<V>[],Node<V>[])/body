{
  int n=tab.length, stride;
  if ((stride=(NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)   stride=MIN_TRANSFER_STRIDE;
  if (nextTab == null) {
    try {
      @SuppressWarnings("rawtypes") Node[] tb=new Node[n << 1];
      nextTab=(Node<V>[])tb;
    }
 catch (    Throwable ex) {
      sizeCtl=Integer.MAX_VALUE;
      return;
    }
    nextTable=nextTab;
    transferOrigin=n;
    transferIndex=n;
    Node<V> rev=new Node<V>(MOVED,tab,null,null);
    for (int k=n; k > 0; ) {
      int nextk=(k > stride) ? k - stride : 0;
      for (int m=nextk; m < k; ++m)       nextTab[m]=rev;
      for (int m=n + nextk; m < n + k; ++m)       nextTab[m]=rev;
      U.putOrderedInt(this,TRANSFERORIGIN,k=nextk);
    }
  }
  int nextn=nextTab.length;
  Node<V> fwd=new Node<V>(MOVED,nextTab,null,null);
  boolean advance=true;
  for (int i=0, bound=0; ; ) {
    int nextIndex, nextBound;
    Node<V> f;
    Object fk;
    while (advance) {
      if (--i >= bound)       advance=false;
 else       if ((nextIndex=transferIndex) <= transferOrigin) {
        i=-1;
        advance=false;
      }
 else       if (U.compareAndSwapInt(this,TRANSFERINDEX,nextIndex,nextBound=(nextIndex > stride ? nextIndex - stride : 0))) {
        bound=nextBound;
        i=nextIndex - 1;
        advance=false;
      }
    }
    if (i < 0 || i >= n || i + n >= nextn) {
      for (int sc; ; ) {
        if (U.compareAndSwapInt(this,SIZECTL,sc=sizeCtl,++sc)) {
          if (sc == -1) {
            nextTable=null;
            table=nextTab;
            sizeCtl=(n << 1) - (n >>> 1);
          }
          return;
        }
      }
    }
 else     if ((f=tabAt(tab,i)) == null) {
      if (casTabAt(tab,i,null,fwd)) {
        setTabAt(nextTab,i,null);
        setTabAt(nextTab,i + n,null);
        advance=true;
      }
    }
 else     if (f.hash >= 0) {
synchronized (f) {
        if (tabAt(tab,i) == f) {
          int runBit=f.hash & n;
          Node<V> lastRun=f, lo=null, hi=null;
          for (Node<V> p=f.next; p != null; p=p.next) {
            int b=p.hash & n;
            if (b != runBit) {
              runBit=b;
              lastRun=p;
            }
          }
          if (runBit == 0)           lo=lastRun;
 else           hi=lastRun;
          for (Node<V> p=f; p != lastRun; p=p.next) {
            int ph=p.hash;
            Object pk=p.key;
            V pv=p.val;
            if ((ph & n) == 0)             lo=new Node<V>(ph,pk,pv,lo);
 else             hi=new Node<V>(ph,pk,pv,hi);
          }
          setTabAt(nextTab,i,lo);
          setTabAt(nextTab,i + n,hi);
          setTabAt(tab,i,fwd);
          advance=true;
        }
      }
    }
 else     if ((fk=f.key) instanceof TreeBin) {
      TreeBin<V> t=(TreeBin<V>)fk;
      t.acquire(0);
      try {
        if (tabAt(tab,i) == f) {
          TreeBin<V> lt=new TreeBin<V>();
          TreeBin<V> ht=new TreeBin<V>();
          int lc=0, hc=0;
          for (Node<V> e=t.first; e != null; e=e.next) {
            int h=e.hash;
            Object k=e.key;
            V v=e.val;
            if ((h & n) == 0) {
              ++lc;
              lt.putTreeNode(h,k,v);
            }
 else {
              ++hc;
              ht.putTreeNode(h,k,v);
            }
          }
          Node<V> ln, hn;
          if (lc < TREE_THRESHOLD) {
            ln=null;
            for (Node<V> p=lt.first; p != null; p=p.next)             ln=new Node<V>(p.hash,p.key,p.val,ln);
          }
 else           ln=new Node<V>(MOVED,lt,null,null);
          setTabAt(nextTab,i,ln);
          if (hc < TREE_THRESHOLD) {
            hn=null;
            for (Node<V> p=ht.first; p != null; p=p.next)             hn=new Node<V>(p.hash,p.key,p.val,hn);
          }
 else           hn=new Node<V>(MOVED,ht,null,null);
          setTabAt(nextTab,i + n,hn);
          setTabAt(tab,i,fwd);
          advance=true;
        }
      }
  finally {
        t.release(0);
      }
    }
 else     advance=true;
  }
}
