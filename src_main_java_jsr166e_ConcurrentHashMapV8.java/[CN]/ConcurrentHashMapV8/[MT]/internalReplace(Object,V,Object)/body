{
  int h=spread(k.hashCode());
  V oldVal=null;
  for (Node<V>[] tab=table; ; ) {
    Node<V> f;
    int i, fh;
    Object fk;
    if (tab == null || (f=tabAt(tab,i=(tab.length - 1) & h)) == null)     break;
 else     if ((fh=f.hash) < 0) {
      if ((fk=f.key) instanceof TreeBin) {
        TreeBin<V> t=(TreeBin<V>)fk;
        boolean validated=false;
        boolean deleted=false;
        t.acquire(0);
        try {
          if (tabAt(tab,i) == f) {
            validated=true;
            TreeNode<V> p=t.getTreeNode(h,k,t.root);
            if (p != null) {
              V pv=p.val;
              if (cv == null || cv == pv || cv.equals(pv)) {
                oldVal=pv;
                if ((p.val=v) == null) {
                  deleted=true;
                  t.deleteTreeNode(p);
                }
              }
            }
          }
        }
  finally {
          t.release(0);
        }
        if (validated) {
          if (deleted)           addCount(-1L,-1);
          break;
        }
      }
 else       tab=(Node<V>[])fk;
    }
 else     if (fh != h && f.next == null)     break;
 else {
      boolean validated=false;
      boolean deleted=false;
synchronized (f) {
        if (tabAt(tab,i) == f) {
          validated=true;
          for (Node<V> e=f, pred=null; ; ) {
            Object ek;
            V ev;
            if (e.hash == h && ((ev=e.val) != null) && ((ek=e.key) == k || k.equals(ek))) {
              if (cv == null || cv == ev || cv.equals(ev)) {
                oldVal=ev;
                if ((e.val=v) == null) {
                  deleted=true;
                  Node<V> en=e.next;
                  if (pred != null)                   pred.next=en;
 else                   setTabAt(tab,i,en);
                }
              }
              break;
            }
            pred=e;
            if ((e=e.next) == null)             break;
          }
        }
      }
      if (validated) {
        if (deleted)         addCount(-1L,-1);
        break;
      }
    }
  }
  return oldVal;
}
