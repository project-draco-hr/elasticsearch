{
  if (nodesIds.length == 0) {
    threadPool.generic().execute(new Runnable(){
      @Override public void run(){
        listener.onResponse(newResponse(request,responses));
      }
    }
);
    return;
  }
  TransportRequestOptions.Builder builder=TransportRequestOptions.builder();
  if (request.timeout() != null) {
    builder.withTimeout(request.timeout());
  }
  builder.withCompress(transportCompress());
  for (int i=0; i < nodesIds.length; i++) {
    final String nodeId=nodesIds[i];
    final int idx=i;
    final DiscoveryNode node=nodes[i];
    try {
      if (node == null) {
        onFailure(idx,nodeId,new NoSuchNodeException(nodeId));
      }
 else       if (!clusterService.localNode().shouldConnectTo(node) && !clusterService.localNode().equals(node)) {
        onFailure(idx,nodeId,new NodeShouldNotConnectException(clusterService.localNode(),node));
      }
 else {
        NodeRequest nodeRequest=newNodeRequest(nodeId,request);
        transportService.sendRequest(node,transportNodeAction,nodeRequest,builder.build(),new BaseTransportResponseHandler<NodeResponse>(){
          @Override public NodeResponse newInstance(){
            return newNodeResponse();
          }
          @Override public void handleResponse(          NodeResponse response){
            onOperation(idx,response);
          }
          @Override public void handleException(          TransportException exp){
            onFailure(idx,node.id(),exp);
          }
          @Override public String executor(){
            return ThreadPool.Names.SAME;
          }
        }
);
      }
    }
 catch (    Throwable t) {
      onFailure(idx,nodeId,t);
    }
  }
}
