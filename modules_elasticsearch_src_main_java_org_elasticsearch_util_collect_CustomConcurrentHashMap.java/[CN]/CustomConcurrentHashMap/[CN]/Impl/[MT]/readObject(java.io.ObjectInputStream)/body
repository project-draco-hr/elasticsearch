{
  try {
    int initialCapacity=in.readInt();
    int concurrencyLevel=in.readInt();
    Strategy<K,V,E> strategy=(Strategy<K,V,E>)in.readObject();
    if (concurrencyLevel > MAX_SEGMENTS) {
      concurrencyLevel=MAX_SEGMENTS;
    }
    int segmentShift=0;
    int segmentCount=1;
    while (segmentCount < concurrencyLevel) {
      ++segmentShift;
      segmentCount<<=1;
    }
    Fields.segmentShift.set(this,32 - segmentShift);
    Fields.segmentMask.set(this,segmentCount - 1);
    Fields.segments.set(this,newSegmentArray(segmentCount));
    if (initialCapacity > MAXIMUM_CAPACITY) {
      initialCapacity=MAXIMUM_CAPACITY;
    }
    int segmentCapacity=initialCapacity / segmentCount;
    if (segmentCapacity * segmentCount < initialCapacity) {
      ++segmentCapacity;
    }
    int segmentSize=1;
    while (segmentSize < segmentCapacity) {
      segmentSize<<=1;
    }
    for (int i=0; i < this.segments.length; ++i) {
      this.segments[i]=new Segment(segmentSize);
    }
    Fields.strategy.set(this,strategy);
    while (true) {
      K key=(K)in.readObject();
      if (key == null) {
        break;
      }
      V value=(V)in.readObject();
      put(key,value);
    }
  }
 catch (  IllegalAccessException e) {
    throw new AssertionError(e);
  }
}
