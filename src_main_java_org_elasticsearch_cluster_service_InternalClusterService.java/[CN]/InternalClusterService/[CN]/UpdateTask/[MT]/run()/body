{
  if (!lifecycle.started()) {
    logger.debug("processing [{}]: ignoring, cluster_service not started",source);
    return;
  }
  logger.debug("processing [{}]: execute",source);
  ClusterState previousClusterState=clusterState;
  ClusterState newClusterState;
  try {
    newClusterState=updateTask.execute(previousClusterState);
  }
 catch (  Throwable e) {
    if (logger.isTraceEnabled()) {
      StringBuilder sb=new StringBuilder("failed to execute cluster state update, state:\nversion [").append(previousClusterState.version()).append("], source [").append(source).append("]\n");
      sb.append(previousClusterState.nodes().prettyPrint());
      sb.append(previousClusterState.routingTable().prettyPrint());
      sb.append(previousClusterState.readOnlyRoutingNodes().prettyPrint());
      logger.trace(sb.toString(),e);
    }
    updateTask.onFailure(source,e);
    return;
  }
  if (previousClusterState == newClusterState) {
    logger.debug("processing [{}]: no change in cluster_state",source);
    if (updateTask instanceof AckedClusterStateUpdateTask) {
      ((AckedClusterStateUpdateTask)updateTask).onAllNodesAcked(null);
    }
    if (updateTask instanceof ProcessedClusterStateUpdateTask) {
      ((ProcessedClusterStateUpdateTask)updateTask).clusterStateProcessed(source,previousClusterState,newClusterState);
    }
    return;
  }
  try {
    Discovery.AckListener ackListener=new NoOpAckListener();
    if (newClusterState.nodes().localNodeMaster()) {
      Builder builder=ClusterState.builder().state(newClusterState).version(newClusterState.version() + 1);
      if (previousClusterState.routingTable() != newClusterState.routingTable()) {
        builder.routingTable(RoutingTable.builder().routingTable(newClusterState.routingTable()).version(newClusterState.routingTable().version() + 1));
      }
      if (previousClusterState.metaData() != newClusterState.metaData()) {
        builder.metaData(MetaData.builder(newClusterState.metaData()).version(newClusterState.metaData().version() + 1));
      }
      newClusterState=builder.build();
      if (updateTask instanceof AckedClusterStateUpdateTask) {
        final AckedClusterStateUpdateTask ackedUpdateTask=(AckedClusterStateUpdateTask)updateTask;
        if (ackedUpdateTask.ackTimeout() == null || ackedUpdateTask.ackTimeout().millis() == 0) {
          ackedUpdateTask.onAckTimeout();
        }
 else {
          try {
            ackListener=new AckCountDownListener(ackedUpdateTask,newClusterState,threadPool);
          }
 catch (          EsRejectedExecutionException ex) {
            if (logger.isDebugEnabled()) {
              logger.debug("Couldn't schedule timeout thread - node might be shutting down",ex);
            }
            ackedUpdateTask.onAckTimeout();
          }
        }
      }
    }
 else {
      if (previousClusterState.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK) && !newClusterState.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
        Builder builder=ClusterState.builder().state(newClusterState);
        builder.routingTable(RoutingTable.builder().routingTable(newClusterState.routingTable()));
        builder.metaData(MetaData.builder(newClusterState.metaData()));
        newClusterState=builder.build();
        logger.debug("got first state from fresh master [{}]",newClusterState.nodes().masterNodeId());
      }
 else       if (newClusterState.version() < previousClusterState.version()) {
        logger.debug("got old cluster state [" + newClusterState.version() + "<"+ previousClusterState.version()+ "] from source ["+ source+ "], ignoring");
        return;
      }
    }
    if (logger.isTraceEnabled()) {
      StringBuilder sb=new StringBuilder("cluster state updated:\nversion [").append(newClusterState.version()).append("], source [").append(source).append("]\n");
      sb.append(newClusterState.nodes().prettyPrint());
      sb.append(newClusterState.routingTable().prettyPrint());
      sb.append(newClusterState.readOnlyRoutingNodes().prettyPrint());
      logger.trace(sb.toString());
    }
 else     if (logger.isDebugEnabled()) {
      logger.debug("cluster state updated, version [{}], source [{}]",newClusterState.version(),source);
    }
    ClusterChangedEvent clusterChangedEvent=new ClusterChangedEvent(source,newClusterState,previousClusterState);
    final DiscoveryNodes.Delta nodesDelta=clusterChangedEvent.nodesDelta();
    if (nodesDelta.hasChanges() && logger.isInfoEnabled()) {
      String summary=nodesDelta.shortSummary();
      if (summary.length() > 0) {
        logger.info("{}, reason: {}",summary,source);
      }
    }
    for (    DiscoveryNode node : nodesDelta.addedNodes()) {
      if (!nodeRequiresConnection(node)) {
        continue;
      }
      try {
        transportService.connectToNode(node);
      }
 catch (      Throwable e) {
        logger.warn("failed to connect to node [" + node + "]",e);
      }
    }
    if (newClusterState.nodes().localNodeMaster()) {
      logger.debug("publishing cluster state version {}",newClusterState.version());
      discoveryService.publish(newClusterState,ackListener);
    }
    clusterState=newClusterState;
    logger.debug("set local cluster state to version {}",newClusterState.version());
    for (    ClusterStateListener listener : priorityClusterStateListeners) {
      listener.clusterChanged(clusterChangedEvent);
    }
    for (    ClusterStateListener listener : clusterStateListeners) {
      listener.clusterChanged(clusterChangedEvent);
    }
    for (    ClusterStateListener listener : lastClusterStateListeners) {
      listener.clusterChanged(clusterChangedEvent);
    }
    if (!nodesDelta.removedNodes().isEmpty()) {
      threadPool.generic().execute(new Runnable(){
        @Override public void run(){
          for (          DiscoveryNode node : nodesDelta.removedNodes()) {
            transportService.disconnectFromNode(node);
          }
        }
      }
);
    }
    if (newClusterState.nodes().localNodeMaster()) {
      try {
        ackListener.onNodeAck(localNode(),null);
      }
 catch (      Throwable t) {
        logger.debug("error while processing ack for master node [{}]",t,newClusterState.nodes().localNode());
      }
    }
    if (updateTask instanceof ProcessedClusterStateUpdateTask) {
      ((ProcessedClusterStateUpdateTask)updateTask).clusterStateProcessed(source,previousClusterState,newClusterState);
    }
    logger.debug("processing [{}]: done applying updated cluster_state (version: {})",source,newClusterState.version());
  }
 catch (  Throwable t) {
    StringBuilder sb=new StringBuilder("failed to apply updated cluster state:\nversion [").append(newClusterState.version()).append("], source [").append(source).append("]\n");
    sb.append(newClusterState.nodes().prettyPrint());
    sb.append(newClusterState.routingTable().prettyPrint());
    sb.append(newClusterState.readOnlyRoutingNodes().prettyPrint());
    logger.warn(sb.toString(),t);
  }
}
