{
  if (!lifecycle.started()) {
    return;
  }
  updateTasksExecutor.execute(new Runnable(){
    @Override public void run(){
      if (!lifecycle.started()) {
        logger.debug("processing [{}]: ignoring, cluster_service not started",source);
        return;
      }
      logger.debug("processing [{}]: execute",source);
      ClusterState previousClusterState=clusterState;
      ClusterState newClusterState;
      try {
        newClusterState=updateTask.execute(previousClusterState);
      }
 catch (      Exception e) {
        StringBuilder sb=new StringBuilder("failed to execute cluster state update, state:\nversion [").append(previousClusterState.version()).append("], source [").append(source).append("]\n");
        sb.append(previousClusterState.nodes().prettyPrint());
        sb.append(previousClusterState.routingTable().prettyPrint());
        sb.append(previousClusterState.readOnlyRoutingNodes().prettyPrint());
        logger.warn(sb.toString(),e);
        return;
      }
      if (previousClusterState == newClusterState) {
        logger.debug("processing [{}]: no change in cluster_state",source);
        return;
      }
      try {
        if (newClusterState.nodes().localNodeMaster()) {
          Builder builder=ClusterState.builder().state(newClusterState).version(newClusterState.version() + 1);
          if (previousClusterState.routingTable() != newClusterState.routingTable()) {
            builder.routingTable(RoutingTable.builder().routingTable(newClusterState.routingTable()).version(newClusterState.routingTable().version() + 1));
          }
          if (previousClusterState.metaData() != newClusterState.metaData()) {
            builder.metaData(MetaData.builder().metaData(newClusterState.metaData()).version(newClusterState.metaData().version() + 1));
          }
          newClusterState=builder.build();
        }
 else {
          if (previousClusterState.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK) && !newClusterState.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
            Builder builder=ClusterState.builder().state(newClusterState);
            builder.routingTable(RoutingTable.builder().routingTable(newClusterState.routingTable()));
            builder.metaData(MetaData.builder().metaData(newClusterState.metaData()));
            newClusterState=builder.build();
            logger.debug("got first state from fresh master [{}]",newClusterState.nodes().masterNodeId());
          }
 else           if (newClusterState.version() < previousClusterState.version()) {
            logger.debug("got old cluster state [" + newClusterState.version() + "<"+ previousClusterState.version()+ "] from source ["+ source+ "], ignoring");
            return;
          }
        }
        if (logger.isTraceEnabled()) {
          StringBuilder sb=new StringBuilder("cluster state updated:\nversion [").append(newClusterState.version()).append("], source [").append(source).append("]\n");
          sb.append(newClusterState.nodes().prettyPrint());
          sb.append(newClusterState.routingTable().prettyPrint());
          sb.append(newClusterState.readOnlyRoutingNodes().prettyPrint());
          logger.trace(sb.toString());
        }
 else         if (logger.isDebugEnabled()) {
          logger.debug("cluster state updated, version [{}], source [{}]",newClusterState.version(),source);
        }
        ClusterChangedEvent clusterChangedEvent=new ClusterChangedEvent(source,newClusterState,previousClusterState);
        final DiscoveryNodes.Delta nodesDelta=clusterChangedEvent.nodesDelta();
        if (nodesDelta.hasChanges() && logger.isInfoEnabled()) {
          String summary=nodesDelta.shortSummary();
          if (summary.length() > 0) {
            logger.info("{}, reason: {}",summary,source);
          }
        }
        for (        DiscoveryNode node : nodesDelta.addedNodes()) {
          if (!nodeRequiresConnection(node)) {
            continue;
          }
          try {
            transportService.connectToNode(node);
          }
 catch (          Exception e) {
            logger.warn("failed to connect to node [" + node + "]",e);
          }
        }
        if (newClusterState.nodes().localNodeMaster()) {
          discoveryService.publish(newClusterState);
        }
        clusterState=newClusterState;
        for (        ClusterStateListener listener : priorityClusterStateListeners) {
          listener.clusterChanged(clusterChangedEvent);
        }
        for (        ClusterStateListener listener : clusterStateListeners) {
          listener.clusterChanged(clusterChangedEvent);
        }
        for (        ClusterStateListener listener : lastClusterStateListeners) {
          listener.clusterChanged(clusterChangedEvent);
        }
        if (!nodesDelta.removedNodes().isEmpty()) {
          threadPool.generic().execute(new Runnable(){
            @Override public void run(){
              for (              DiscoveryNode node : nodesDelta.removedNodes()) {
                transportService.disconnectFromNode(node);
              }
            }
          }
);
        }
        if (updateTask instanceof ProcessedClusterStateUpdateTask) {
          ((ProcessedClusterStateUpdateTask)updateTask).clusterStateProcessed(newClusterState);
        }
        logger.debug("processing [{}]: done applying updated cluster_state",source);
      }
 catch (      Exception e) {
        StringBuilder sb=new StringBuilder("failed to apply updated cluster state:\nversion [").append(newClusterState.version()).append("], source [").append(source).append("]\n");
        sb.append(newClusterState.nodes().prettyPrint());
        sb.append(newClusterState.routingTable().prettyPrint());
        sb.append(newClusterState.readOnlyRoutingNodes().prettyPrint());
        logger.warn(sb.toString(),e);
      }
    }
  }
);
}
