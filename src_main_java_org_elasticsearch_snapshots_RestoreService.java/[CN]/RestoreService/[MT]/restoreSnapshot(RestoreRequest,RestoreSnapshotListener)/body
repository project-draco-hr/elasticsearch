{
  try {
    Repository repository=repositoriesService.repository(request.repository());
    final SnapshotId snapshotId=new SnapshotId(request.repository(),request.name());
    final Snapshot snapshot=repository.readSnapshot(snapshotId);
    ImmutableList<String> filteredIndices=SnapshotUtils.filterIndices(snapshot.indices(),request.indices(),request.indicesOptions());
    final MetaData metaData=repository.readSnapshotMetaData(snapshotId,filteredIndices);
    if (snapshot.state() != SnapshotState.SUCCESS) {
      throw new SnapshotRestoreException(snapshotId,"unsupported snapshot state [" + snapshot.state() + "]");
    }
    if (Version.CURRENT.before(snapshot.version())) {
      throw new SnapshotRestoreException(snapshotId,"incompatible snapshot version [" + snapshot.version() + "]");
    }
    final Map<String,String> renamedIndices=newHashMap();
    for (    String index : filteredIndices) {
      String renamedIndex=index;
      if (request.renameReplacement() != null && request.renamePattern() != null) {
        renamedIndex=index.replaceAll(request.renamePattern(),request.renameReplacement());
      }
      String previousIndex=renamedIndices.put(renamedIndex,index);
      if (previousIndex != null) {
        throw new SnapshotRestoreException(snapshotId,"indices [" + index + "] and ["+ previousIndex+ "] are renamed into the same index ["+ renamedIndex+ "]");
      }
    }
    clusterService.submitStateUpdateTask(request.cause(),new TimeoutClusterStateUpdateTask(){
      RestoreInfo restoreInfo=null;
      @Override public ClusterState execute(      ClusterState currentState){
        RestoreMetaData restoreMetaData=currentState.metaData().custom(RestoreMetaData.TYPE);
        if (restoreMetaData != null && !restoreMetaData.entries().isEmpty()) {
          throw new ConcurrentSnapshotExecutionException(snapshotId,"Restore process is already running in this cluster");
        }
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        RoutingTable.Builder rtBuilder=RoutingTable.builder(currentState.routingTable());
        if (!metaData.indices().isEmpty()) {
          ImmutableMap.Builder<ShardId,RestoreMetaData.ShardRestoreStatus> shards=ImmutableMap.builder();
          for (          Map.Entry<String,String> indexEntry : renamedIndices.entrySet()) {
            String index=indexEntry.getValue();
            if (failed(snapshot,index)) {
              throw new SnapshotRestoreException(snapshotId,"index [" + index + "] wasn't fully snapshotted - cannot restore");
            }
            RestoreSource restoreSource=new RestoreSource(snapshotId,index);
            String renamedIndex=indexEntry.getKey();
            IndexMetaData snapshotIndexMetaData=metaData.index(index);
            IndexMetaData currentIndexMetaData=currentState.metaData().index(renamedIndex);
            if (currentIndexMetaData == null) {
              createIndexService.validateIndexName(renamedIndex,currentState);
              IndexMetaData.Builder indexMdBuilder=IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndex);
              IndexMetaData updatedIndexMetaData=indexMdBuilder.build();
              rtBuilder.addAsNewRestore(updatedIndexMetaData,restoreSource);
              mdBuilder.put(updatedIndexMetaData,true);
            }
 else {
              if (currentIndexMetaData.state() != IndexMetaData.State.CLOSE) {
                throw new SnapshotRestoreException(snapshotId,"cannot restore index [" + renamedIndex + "] because it's open");
              }
              if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {
                throw new SnapshotRestoreException(snapshotId,"cannot restore index [" + renamedIndex + "] with ["+ currentIndexMetaData.getNumberOfShards()+ "] shard from snapshot with ["+ snapshotIndexMetaData.getNumberOfShards()+ "] shards");
              }
              IndexMetaData.Builder indexMdBuilder=IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN);
              indexMdBuilder.version(Math.max(snapshotIndexMetaData.version(),currentIndexMetaData.version() + 1));
              IndexMetaData updatedIndexMetaData=indexMdBuilder.index(renamedIndex).build();
              rtBuilder.addAsRestore(updatedIndexMetaData,restoreSource);
              blocks.removeIndexBlock(renamedIndex,INDEX_CLOSED_BLOCK);
              mdBuilder.put(updatedIndexMetaData,true);
            }
            for (int shard=0; shard < snapshotIndexMetaData.getNumberOfShards(); shard++) {
              shards.put(new ShardId(renamedIndex,shard),new RestoreMetaData.ShardRestoreStatus(clusterService.state().nodes().localNodeId()));
            }
          }
          RestoreMetaData.Entry restoreEntry=new RestoreMetaData.Entry(snapshotId,RestoreMetaData.State.INIT,ImmutableList.copyOf(renamedIndices.keySet()),shards.build());
          mdBuilder.putCustom(RestoreMetaData.TYPE,new RestoreMetaData(restoreEntry));
        }
        if (request.includeGlobalState()) {
          if (metaData.persistentSettings() != null) {
            mdBuilder.persistentSettings(metaData.persistentSettings());
          }
          if (metaData.templates() != null) {
            for (            ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {
              mdBuilder.put(cursor.value);
            }
          }
          if (metaData.customs() != null) {
            for (            ObjectObjectCursor<String,MetaData.Custom> cursor : metaData.customs()) {
              if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {
                mdBuilder.putCustom(cursor.key,cursor.value);
              }
            }
          }
        }
        if (metaData.indices().isEmpty()) {
          restoreInfo=new RestoreInfo(request.name(),ImmutableList.<String>of(),0,0);
        }
        ClusterState updatedState=ClusterState.builder(currentState).metaData(mdBuilder).blocks(blocks).routingTable(rtBuilder).build();
        RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder(updatedState).routingTable(rtBuilder).build());
        return ClusterState.builder(updatedState).routingResult(routingResult).build();
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}] failed to restore snapshot",t,snapshotId);
        listener.onFailure(t);
      }
      @Override public TimeValue timeout(){
        return request.masterNodeTimeout();
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        listener.onResponse(restoreInfo);
      }
    }
);
  }
 catch (  Throwable e) {
    logger.warn("[{}][{}] failed to restore snapshot",e,request.repository(),request.name());
    listener.onFailure(e);
  }
}
