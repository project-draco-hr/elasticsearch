{
  List<InternalAggregation> aggregations=reduceContext.aggregations();
  Multimap<Object,InternalTerms.Bucket> buckets=ArrayListMultimap.create();
  for (  InternalAggregation aggregation : aggregations) {
    InternalTerms terms=(InternalTerms)aggregation;
    for (    Bucket bucket : terms.buckets) {
      buckets.put(bucket.getKeyAsObject(),bucket);
    }
  }
  final int size=Math.min(requiredSize,buckets.size());
  BucketPriorityQueue ordered=new BucketPriorityQueue(size,order.comparator(null));
  for (  Collection<Bucket> l : buckets.asMap().values()) {
    List<Bucket> sameTermBuckets=(List<Bucket>)l;
    final Bucket b=sameTermBuckets.get(0).reduce(sameTermBuckets,reduceContext.bigArrays());
    if (b.docCount >= minDocCount) {
      ordered.insertWithOverflow(b);
    }
  }
  Bucket[] list=new Bucket[ordered.size()];
  for (int i=ordered.size() - 1; i >= 0; i--) {
    list[i]=(Bucket)ordered.pop();
  }
  return newAggregation(name,Arrays.asList(list));
}
