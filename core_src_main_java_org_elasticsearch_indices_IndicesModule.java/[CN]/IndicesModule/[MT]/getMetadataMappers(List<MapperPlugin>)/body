{
  Map<String,MetadataFieldMapper.TypeParser> metadataMappers=new LinkedHashMap<>();
  metadataMappers.put(UidFieldMapper.NAME,new UidFieldMapper.TypeParser());
  metadataMappers.put(IdFieldMapper.NAME,new IdFieldMapper.TypeParser());
  metadataMappers.put(RoutingFieldMapper.NAME,new RoutingFieldMapper.TypeParser());
  metadataMappers.put(IndexFieldMapper.NAME,new IndexFieldMapper.TypeParser());
  metadataMappers.put(SourceFieldMapper.NAME,new SourceFieldMapper.TypeParser());
  metadataMappers.put(TypeFieldMapper.NAME,new TypeFieldMapper.TypeParser());
  metadataMappers.put(AllFieldMapper.NAME,new AllFieldMapper.TypeParser());
  metadataMappers.put(TimestampFieldMapper.NAME,new TimestampFieldMapper.TypeParser());
  metadataMappers.put(TTLFieldMapper.NAME,new TTLFieldMapper.TypeParser());
  metadataMappers.put(VersionFieldMapper.NAME,new VersionFieldMapper.TypeParser());
  metadataMappers.put(ParentFieldMapper.NAME,new ParentFieldMapper.TypeParser());
  for (  MapperPlugin mapperPlugin : mapperPlugins) {
    metadataMappers.putAll(mapperPlugin.getMetadataMappers());
  }
  if (metadataMappers.containsKey(FieldNamesFieldMapper.NAME)) {
    throw new IllegalStateException("Plugin cannot contain metadata mapper [" + FieldNamesFieldMapper.NAME + "]");
  }
  metadataMappers.put(FieldNamesFieldMapper.NAME,new FieldNamesFieldMapper.TypeParser());
  return Collections.unmodifiableMap(metadataMappers);
}
