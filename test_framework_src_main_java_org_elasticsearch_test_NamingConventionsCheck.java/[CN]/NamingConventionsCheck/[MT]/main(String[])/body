{
  NamingConventionsCheck check=new NamingConventionsCheck();
  boolean skipIntegTestsInDisguise=false;
  boolean selfTest=false;
  int i=0;
  while (true) {
switch (args[i]) {
case "--skip-integ-tests-in-disguise":
      skipIntegTestsInDisguise=true;
    i++;
  continue;
case "--self-test":
selfTest=true;
i++;
continue;
case "--":
i++;
break;
default :
fail("Expected -- before a path.");
}
break;
}
check.check(PathUtils.get(args[i]));
if (selfTest) {
assertViolation("WrongName",check.missingSuffix);
assertViolation("WrongNameTheSecond",check.missingSuffix);
assertViolation("DummyAbstractTests",check.notRunnable);
assertViolation("DummyInterfaceTests",check.notRunnable);
assertViolation("InnerTests",check.innerClasses);
assertViolation("NotImplementingTests",check.notImplementing);
assertViolation("PlainUnit",check.pureUnitTest);
}
assertNoViolations("Not all subclasses of " + ESTestCase.class.getSimpleName() + " match the naming convention. Concrete classes must end with [Tests]",check.missingSuffix);
assertNoViolations("Classes ending with [Tests] are abstract or interfaces",check.notRunnable);
assertNoViolations("Found inner classes that are tests, which are excluded from the test runner",check.innerClasses);
String classesToSubclass=String.join(",",ESTestCase.class.getSimpleName(),ESTestCase.class.getSimpleName(),ESTokenStreamTestCase.class.getSimpleName(),LuceneTestCase.class.getSimpleName());
assertNoViolations("Pure Unit-Test found must subclass one of [" + classesToSubclass + "]",check.pureUnitTest);
assertNoViolations("Classes ending with [Tests] must subclass [" + classesToSubclass + "]",check.notImplementing);
if (!skipIntegTestsInDisguise) {
assertNoViolations("Subclasses of ESIntegTestCase should end with IT as they are integration tests",check.integTestsInDisguise);
}
}
