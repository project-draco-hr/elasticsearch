{
  boolean node1IsMasterEligible=randomBoolean();
  boolean node2IsMasterEligible=!node1IsMasterEligible || randomBoolean();
  Future<String> node_1_future=internalCluster().startNodeAsync(ImmutableSettings.builder().put("node.master",node1IsMasterEligible).build());
  Future<String> node_2_future=internalCluster().startNodeAsync(ImmutableSettings.builder().put("node.master",node2IsMasterEligible).build());
  final String node_1=node_1_future.get();
  final String node_2=node_2_future.get();
  final String node_1_id=internalCluster().getInstance(DiscoveryService.class,node_1).localNode().getId();
  final String node_2_id=internalCluster().getInstance(DiscoveryService.class,node_2).localNode().getId();
  logger.debug("node {} (node_1) is {}master eligible",node_1,node1IsMasterEligible ? "" : "not ");
  logger.debug("node {} (node_2) is {}master eligible",node_2,node2IsMasterEligible ? "" : "not ");
  logger.debug("node {} became master",internalCluster().getMasterName());
  final int numShards=scaledRandomIntBetween(2,20);
  assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,numShards)));
  ensureGreen("test");
  waitNoPendingTasksOnAll();
  ClusterStateResponse stateResponse=client().admin().cluster().prepareState().get();
  RoutingNode routingNode=stateResponse.getState().routingNodes().node(node_2_id);
  final int[] node2Shards=new int[routingNode.numberOfOwningShards()];
  int i=0;
  for (  MutableShardRouting mutableShardRouting : routingNode) {
    node2Shards[i]=mutableShardRouting.shardId().id();
    i++;
  }
  logger.info("Node 2 has shards: {}",Arrays.toString(node2Shards));
  final long shardVersions[]=new long[numShards];
  final int shardIds[]=new int[numShards];
  i=0;
  for (  ShardRouting shardRouting : stateResponse.getState().getRoutingTable().allShards("test")) {
    shardVersions[i]=shardRouting.version();
    shardIds[i]=shardRouting.getId();
    i++;
  }
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE,EnableAllocationDecider.Rebalance.NONE)).get();
  internalCluster().getInstance(ClusterService.class,node_2).submitStateUpdateTask("test",Priority.IMMEDIATE,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      IndexRoutingTable.Builder indexRoutingTableBuilder=IndexRoutingTable.builder("test");
      for (int i=0; i < numShards; i++) {
        indexRoutingTableBuilder.addIndexShard(new IndexShardRoutingTable.Builder(new ShardId("test",i),false).addShard(new ImmutableShardRouting("test",i,node_1_id,true,ShardRoutingState.STARTED,shardVersions[shardIds[i]])).build());
      }
      return ClusterState.builder(currentState).routingTable(RoutingTable.builder().add(indexRoutingTableBuilder).build()).build();
    }
    public boolean runOnlyOnMaster(){
      return false;
    }
    @Override public void onFailure(    String source,    Throwable t){
    }
  }
);
  waitNoPendingTasksOnAll();
  logger.info("Checking if shards aren't removed");
  for (  int shard : node2Shards) {
    assertTrue(waitForShardDeletion(node_2,"test",shard));
  }
}
