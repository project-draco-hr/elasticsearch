{
  logger.info("--> starting 2 nodes");
  String node_1=internalCluster().startNode(commonSettings);
  internalCluster().startNode(commonSettings);
  assertThat(cluster().size(),equalTo(2));
  ClusterHealthResponse healthResponse=client().admin().cluster().prepareHealth().setWaitForNodes("2").execute().actionGet();
  assertThat(healthResponse.isTimedOut(),equalTo(false));
  logger.info("--> create an index with 1 shard, 1 replica, nothing should allocate");
  client().admin().indices().prepareCreate("test").setSettings(settingsBuilder().put("index.number_of_shards",1)).execute().actionGet();
  ClusterState state=client().admin().cluster().prepareState().execute().actionGet().getState();
  assertThat(state.routingNodes().unassigned().size(),equalTo(2));
  logger.info("--> explicitly allocate shard 1, actually allocating, no dry run");
  state=client().admin().cluster().prepareReroute().setExplain(randomBoolean()).add(new AllocateAllocationCommand(new ShardId("test",0),node_1,true)).execute().actionGet().getState();
  assertThat(state.routingNodes().unassigned().size(),equalTo(1));
  assertThat(state.routingNodes().node(state.nodes().resolveNode(node_1).id()).get(0).state(),equalTo(ShardRoutingState.INITIALIZING));
  healthResponse=client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();
  assertThat(healthResponse.isTimedOut(),equalTo(false));
  logger.info("--> get the state, verify shard 1 primary allocated");
  state=client().admin().cluster().prepareState().execute().actionGet().getState();
  assertThat(state.routingNodes().unassigned().size(),equalTo(1));
  assertThat(state.routingNodes().node(state.nodes().resolveNode(node_1).id()).get(0).state(),equalTo(ShardRoutingState.STARTED));
  client().prepareIndex("test","type","1").setSource("field","value").setRefresh(true).execute().actionGet();
  logger.info("--> closing all nodes");
  File[] shardLocation=internalCluster().getInstance(NodeEnvironment.class,node_1).shardLocations(new ShardId("test",0));
  assertThat(FileSystemUtils.exists(shardLocation),equalTo(true));
  internalCluster().closeNonSharedNodes(false);
  logger.info("--> deleting the shard data [{}] ",Arrays.toString(shardLocation));
  assertThat(FileSystemUtils.exists(shardLocation),equalTo(true));
  IOUtils.rm(FileSystemUtils.toPaths(shardLocation));
  logger.info("--> starting nodes back, will not allocate the shard since it has no data, but the index will be there");
  node_1=internalCluster().startNode(commonSettings);
  internalCluster().startNode(commonSettings);
  client().admin().cluster().prepareReroute().get();
  assertThat(client().admin().cluster().prepareHealth().setWaitForNodes("2").execute().actionGet().getStatus(),equalTo(ClusterHealthStatus.RED));
  logger.info("--> explicitly allocate primary");
  state=client().admin().cluster().prepareReroute().setExplain(randomBoolean()).add(new AllocateAllocationCommand(new ShardId("test",0),node_1,true)).execute().actionGet().getState();
  assertThat(state.routingNodes().unassigned().size(),equalTo(1));
  assertThat(state.routingNodes().node(state.nodes().resolveNode(node_1).id()).get(0).state(),equalTo(ShardRoutingState.INITIALIZING));
  healthResponse=client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();
  assertThat(healthResponse.isTimedOut(),equalTo(false));
  logger.info("--> get the state, verify shard 1 primary allocated");
  state=client().admin().cluster().prepareState().execute().actionGet().getState();
  assertThat(state.routingNodes().unassigned().size(),equalTo(1));
  assertThat(state.routingNodes().node(state.nodes().resolveNode(node_1).id()).get(0).state(),equalTo(ShardRoutingState.STARTED));
}
