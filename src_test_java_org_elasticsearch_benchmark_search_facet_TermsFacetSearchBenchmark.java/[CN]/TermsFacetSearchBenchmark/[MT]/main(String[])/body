{
  Random random=new Random();
  Settings settings=settingsBuilder().put("index.refresh_interval","-1").put("gateway.type","local").put(SETTING_NUMBER_OF_SHARDS,1).put(SETTING_NUMBER_OF_REPLICAS,0).build();
  String clusterName=TermsFacetSearchBenchmark.class.getSimpleName();
  Node[] nodes=new Node[1];
  for (int i=0; i < nodes.length; i++) {
    nodes[i]=nodeBuilder().clusterName(clusterName).settings(settingsBuilder().put(settings).put("name","node" + i)).node();
  }
  Node clientNode=nodeBuilder().clusterName(clusterName).settings(settingsBuilder().put(settings).put("name","client")).client(true).node();
  client=clientNode.client();
  long[] lValues=new long[NUMBER_OF_TERMS];
  for (int i=0; i < NUMBER_OF_TERMS; i++) {
    lValues[i]=ThreadLocalRandom.current().nextLong();
  }
  String[] sValues=new String[NUMBER_OF_TERMS];
  for (int i=0; i < NUMBER_OF_TERMS; i++) {
    sValues[i]=RandomStrings.randomAsciiOfLength(random,STRING_TERM_SIZE);
  }
  Thread.sleep(10000);
  try {
    client.admin().indices().create(createIndexRequest("test").mapping("type1",jsonBuilder().startObject().startObject("type1").startObject("properties").startObject("s_value_dv").field("type","string").field("index","no").startObject("fielddata").field("format","doc_values").endObject().endObject().startObject("sm_value_dv").field("type","string").field("index","no").startObject("fielddata").field("format","doc_values").endObject().endObject().startObject("l_value_dv").field("type","long").field("index","no").startObject("fielddata").field("format","doc_values").endObject().endObject().startObject("lm_value_dv").field("type","long").field("index","no").startObject("fielddata").field("format","doc_values").endObject().endObject().endObject().endObject().endObject())).actionGet();
    StopWatch stopWatch=new StopWatch().start();
    System.out.println("--> Indexing [" + COUNT + "] ...");
    long ITERS=COUNT / BATCH;
    long i=1;
    int counter=0;
    for (; i <= ITERS; i++) {
      BulkRequestBuilder request=client.prepareBulk();
      for (int j=0; j < BATCH; j++) {
        counter++;
        XContentBuilder builder=jsonBuilder().startObject();
        builder.field("id",Integer.toString(counter));
        final String sValue=sValues[counter % sValues.length];
        final long lValue=lValues[counter % lValues.length];
        builder.field("s_value",sValue);
        builder.field("l_value",lValue);
        builder.field("s_value_dv",sValue);
        builder.field("l_value_dv",lValue);
        for (        String field : new String[]{"sm_value","sm_value_dv"}) {
          builder.startArray(field);
          for (int k=0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {
            builder.value(sValues[ThreadLocalRandom.current().nextInt(sValues.length)]);
          }
          builder.endArray();
        }
        for (        String field : new String[]{"lm_value","lm_value_dv"}) {
          builder.startArray(field);
          for (int k=0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {
            builder.value(lValues[ThreadLocalRandom.current().nextInt(sValues.length)]);
          }
          builder.endArray();
        }
        builder.endObject();
        request.add(Requests.indexRequest("test").type("type1").id(Integer.toString(counter)).source(builder));
      }
      BulkResponse response=request.execute().actionGet();
      if (response.hasFailures()) {
        System.err.println("--> failures...");
      }
      if (((i * BATCH) % 10000) == 0) {
        System.out.println("--> Indexed " + (i * BATCH) + " took "+ stopWatch.stop().lastTaskTime());
        stopWatch.start();
      }
    }
    System.out.println("--> Indexing took " + stopWatch.totalTime() + ", TPS "+ (((double)(COUNT)) / stopWatch.totalTime().secondsFrac()));
  }
 catch (  Exception e) {
    System.out.println("--> Index already exists, ignoring indexing phase, waiting for green");
    ClusterHealthResponse clusterHealthResponse=client.admin().cluster().prepareHealth().setWaitForGreenStatus().setTimeout("10m").execute().actionGet();
    if (clusterHealthResponse.isTimedOut()) {
      System.err.println("--> Timed out waiting for cluster health");
    }
  }
  client.admin().indices().prepareRefresh().execute().actionGet();
  COUNT=client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount();
  System.out.println("--> Number of docs in index: " + COUNT);
  List<StatsResult> stats=Lists.newArrayList();
  stats.add(terms("terms_s","s_value",null));
  stats.add(terms("terms_s_dv","s_value_dv",null));
  stats.add(terms("terms_map_s","s_value","map"));
  stats.add(terms("terms_map_s_dv","s_value_dv","map"));
  stats.add(terms("terms_l","l_value",null));
  stats.add(terms("terms_l_dv","l_value_dv",null));
  stats.add(terms("terms_map_l","l_value","map"));
  stats.add(terms("terms_map_l_dv","l_value_dv","map"));
  stats.add(terms("terms_sm","sm_value",null));
  stats.add(terms("terms_sm_dv","sm_value_dv",null));
  stats.add(terms("terms_map_sm","sm_value","map"));
  stats.add(terms("terms_map_sm_dv","sm_value_dv","map"));
  stats.add(terms("terms_lm","lm_value",null));
  stats.add(terms("terms_lm_dv","lm_value_dv",null));
  stats.add(terms("terms_map_lm","lm_value","map"));
  stats.add(terms("terms_map_lm_dv","lm_value_dv","map"));
  stats.add(termsStats("terms_stats_s_l","s_value","l_value",null));
  stats.add(termsStats("terms_stats_s_l_dv","s_value_dv","l_value_dv",null));
  stats.add(termsStats("terms_stats_s_lm","s_value","lm_value",null));
  stats.add(termsStats("terms_stats_s_lm_dv","s_value_dv","lm_value_dv",null));
  stats.add(termsStats("terms_stats_sm_l","sm_value","l_value",null));
  stats.add(termsStats("terms_stats_sm_l_dv","sm_value_dv","l_value_dv",null));
  System.out.println("------------------ SUMMARY -------------------------------");
  System.out.format("%25s%10s%10s\n","name","took","millis");
  for (  StatsResult stat : stats) {
    System.out.format("%25s%10s%10d\n",stat.name,TimeValue.timeValueMillis(stat.took),(stat.took / QUERY_COUNT));
  }
  System.out.println("------------------ SUMMARY -------------------------------");
  clientNode.close();
  for (  Node node : nodes) {
    node.close();
  }
}
