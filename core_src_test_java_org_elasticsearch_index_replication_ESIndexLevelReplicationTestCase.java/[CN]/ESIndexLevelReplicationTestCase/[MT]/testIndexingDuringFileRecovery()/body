{
  try (ReplicationGroup shards=createGroup(randomInt(1))){
    shards.startAll();
    int docs=shards.indexDocs(randomInt(50));
    shards.flush();
    IndexShard replica=shards.addReplica();
    final CountDownLatch recoveryBlocked=new CountDownLatch(1);
    final CountDownLatch releaseRecovery=new CountDownLatch(1);
    final Future<Void> recoveryFuture=shards.asyncRecoverReplica(replica,new BiFunction<IndexShard,DiscoveryNode,RecoveryTarget>(){
      @Override public RecoveryTarget apply(      IndexShard indexShard,      DiscoveryNode node){
        return new RecoveryTarget(indexShard,node,recoveryListener){
          @Override public void renameAllTempFiles() throws IOException {
            super.renameAllTempFiles();
            recoveryBlocked.countDown();
            try {
              releaseRecovery.await();
            }
 catch (            InterruptedException e) {
              throw new IOException("terminated by interrupt",e);
            }
          }
        }
;
      }
    }
);
    recoveryBlocked.await();
    docs+=shards.indexDocs(randomInt(20));
    releaseRecovery.countDown();
    recoveryFuture.get();
    shards.assertAllEqual(docs);
  }
 }
