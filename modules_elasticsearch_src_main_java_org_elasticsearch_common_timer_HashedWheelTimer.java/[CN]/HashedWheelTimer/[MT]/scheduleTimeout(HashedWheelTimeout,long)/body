{
  if (delay < tickDuration) {
    delay=tickDuration;
  }
  final long lastRoundDelay=delay % roundDuration;
  final long lastTickDelay=delay % tickDuration;
  final long relativeIndex=lastRoundDelay / tickDuration + (lastTickDelay != 0 ? 1 : 0);
  final long remainingRounds=delay / roundDuration - (delay % roundDuration == 0 ? 1 : 0);
  lock.readLock().lock();
  try {
    int stopIndex=(int)(wheelCursor + relativeIndex & mask);
    timeout.stopIndex=stopIndex;
    timeout.remainingRounds=remainingRounds;
    wheel[stopIndex].add(timeout);
  }
  finally {
    lock.readLock().unlock();
  }
}
