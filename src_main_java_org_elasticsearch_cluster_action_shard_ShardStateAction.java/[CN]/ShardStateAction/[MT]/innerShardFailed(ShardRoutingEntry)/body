{
  logger.warn("{} received shard failed for {}",shardRoutingEntry.shardRouting.shardId(),shardRoutingEntry);
  failedShardQueue.add(shardRoutingEntry);
  clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), reason ["+ shardRoutingEntry.reason+ "]",Priority.HIGH,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      List<ShardRoutingEntry> shardRoutingEntries=new ArrayList<ShardRoutingEntry>();
      failedShardQueue.drainTo(shardRoutingEntries);
      if (shardRoutingEntries.isEmpty()) {
        return currentState;
      }
      MetaData metaData=currentState.getMetaData();
      List<ShardRouting> shardRoutingsToBeApplied=new ArrayList<ShardRouting>(shardRoutingEntries.size());
      for (int i=0; i < shardRoutingEntries.size(); i++) {
        ShardRoutingEntry shardRoutingEntry=shardRoutingEntries.get(i);
        ShardRouting shardRouting=shardRoutingEntry.shardRouting;
        IndexMetaData indexMetaData=metaData.index(shardRouting.index());
        if (indexMetaData == null) {
          continue;
        }
        if (!indexMetaData.isSameUUID(shardRoutingEntry.indexUUID)) {
          logger.debug("{} ignoring shard failed, different index uuid, current {}, got {}",shardRouting.shardId(),indexMetaData.getUUID(),shardRoutingEntry);
          continue;
        }
        logger.debug("{} will apply shard failed {}",shardRouting.shardId(),shardRoutingEntry);
        shardRoutingsToBeApplied.add(shardRouting);
      }
      RoutingAllocation.Result routingResult=allocationService.applyFailedShards(currentState,shardRoutingsToBeApplied);
      if (!routingResult.changed()) {
        return currentState;
      }
      return ClusterState.builder(currentState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("unexpected failure during [{}]",t,source);
    }
  }
);
}
