{
  if (logger.isDebugEnabled()) {
    logger.debug("received shard started for {}, reason [{}]",shardRouting,reason);
  }
  startedShardsQueue.add(shardRouting);
  clusterService.submitStateUpdateTask("shard-started (" + shardRouting + "), reason ["+ reason+ "]",Priority.HIGH,new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      List<ShardRouting> shards=new ArrayList<ShardRouting>();
      startedShardsQueue.drainTo(shards);
      if (shards.isEmpty()) {
        return currentState;
      }
      RoutingTable routingTable=currentState.routingTable();
      for (int i=0; i < shards.size(); i++) {
        ShardRouting shardRouting=shards.get(i);
        IndexRoutingTable indexRoutingTable=routingTable.index(shardRouting.index());
        if (indexRoutingTable == null) {
          shards.remove(i);
        }
 else {
          IndexShardRoutingTable indexShardRoutingTable=indexRoutingTable.shard(shardRouting.id());
          for (          ShardRouting entry : indexShardRoutingTable) {
            if (shardRouting.currentNodeId().equals(entry.currentNodeId())) {
              if (entry.started()) {
                shards.remove(i);
              }
            }
          }
        }
      }
      if (shards.isEmpty()) {
        return currentState;
      }
      if (logger.isDebugEnabled()) {
        logger.debug("applying started shards {}, reason [{}]",shards,reason);
      }
      RoutingAllocation.Result routingResult=allocationService.applyStartedShards(currentState,shards,false);
      if (!routingResult.changed()) {
        return currentState;
      }
      return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
      rerouteRequired.set(true);
      clusterService.submitStateUpdateTask("reroute post shard-started (" + shardRouting + "), reason ["+ reason+ "]",Priority.HIGH,new ClusterStateUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState){
          if (rerouteRequired.compareAndSet(true,false)) {
            RoutingAllocation.Result routingResult=allocationService.reroute(currentState);
            if (!routingResult.changed()) {
              return currentState;
            }
            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();
          }
 else {
            return currentState;
          }
        }
      }
);
    }
  }
);
}
