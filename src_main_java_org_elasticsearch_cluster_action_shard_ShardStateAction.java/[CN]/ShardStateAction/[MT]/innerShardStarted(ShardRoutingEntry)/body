{
  logger.debug("received shard started for {}",shardRoutingEntry);
  startedShardsQueue.add(shardRoutingEntry);
  clusterService.submitStateUpdateTask("shard-started (" + shardRoutingEntry.shardRouting + "), reason ["+ shardRoutingEntry.reason+ "]",Priority.URGENT,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      if (shardRoutingEntry.processed) {
        return currentState;
      }
      List<ShardRoutingEntry> shardRoutingEntries=new ArrayList<>();
      startedShardsQueue.drainTo(shardRoutingEntries);
      if (shardRoutingEntries.isEmpty()) {
        return currentState;
      }
      RoutingTable routingTable=currentState.routingTable();
      MetaData metaData=currentState.getMetaData();
      List<ShardRouting> shardRoutingToBeApplied=new ArrayList<>(shardRoutingEntries.size());
      for (int i=0; i < shardRoutingEntries.size(); i++) {
        ShardRoutingEntry shardRoutingEntry=shardRoutingEntries.get(i);
        shardRoutingEntry.processed=true;
        ShardRouting shardRouting=shardRoutingEntry.shardRouting;
        try {
          IndexMetaData indexMetaData=metaData.index(shardRouting.index());
          IndexRoutingTable indexRoutingTable=routingTable.index(shardRouting.index());
          if (indexMetaData == null) {
            continue;
          }
          if (indexRoutingTable == null) {
            continue;
          }
          if (!indexMetaData.isSameUUID(shardRoutingEntry.indexUUID)) {
            logger.debug("{} ignoring shard started, different index uuid, current {}, got {}",shardRouting.shardId(),indexMetaData.getUUID(),shardRoutingEntry);
            continue;
          }
          IndexShardRoutingTable indexShardRoutingTable=indexRoutingTable.shard(shardRouting.id());
          boolean applyShardEvent=true;
          for (          ShardRouting entry : indexShardRoutingTable) {
            if (shardRouting.currentNodeId().equals(entry.currentNodeId())) {
              if (!entry.initializing()) {
                logger.debug("{} ignoring shard started event for {}, current state: {}",shardRouting.shardId(),shardRoutingEntry,entry.state());
                applyShardEvent=false;
              }
            }
          }
          if (applyShardEvent) {
            shardRoutingToBeApplied.add(shardRouting);
            logger.debug("{} will apply shard started {}",shardRouting.shardId(),shardRoutingEntry);
          }
        }
 catch (        Throwable t) {
          logger.error("{} unexpected failure while processing shard started [{}]",t,shardRouting.shardId(),shardRouting);
        }
      }
      if (shardRoutingToBeApplied.isEmpty()) {
        return currentState;
      }
      RoutingAllocation.Result routingResult=allocationService.applyStartedShards(currentState,shardRoutingToBeApplied,true);
      if (!routingResult.changed()) {
        return currentState;
      }
      return ClusterState.builder(currentState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("unexpected failure during [{}]",t,source);
    }
  }
);
}
