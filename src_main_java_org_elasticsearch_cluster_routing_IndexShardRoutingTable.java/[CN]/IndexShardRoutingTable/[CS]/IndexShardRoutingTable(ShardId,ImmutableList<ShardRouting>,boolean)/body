{
  this.shardId=shardId;
  this.shuffler=new RotationShardShuffler(ThreadLocalRandom.current().nextInt());
  this.shards=shards;
  this.primaryAllocatedPostApi=primaryAllocatedPostApi;
  ShardRouting primary=null;
  ImmutableList.Builder<ShardRouting> replicas=ImmutableList.builder();
  ImmutableList.Builder<ShardRouting> activeShards=ImmutableList.builder();
  ImmutableList.Builder<ShardRouting> assignedShards=ImmutableList.builder();
  ImmutableList.Builder<ShardRouting> allInitializingShards=ImmutableList.builder();
  boolean allShardsStarted=true;
  for (  ShardRouting shard : shards) {
    if (shard.primary()) {
      primary=shard;
    }
 else {
      replicas.add(shard);
    }
    if (shard.active()) {
      activeShards.add(shard);
    }
    if (shard.initializing()) {
      allInitializingShards.add(shard);
    }
    if (shard.relocating()) {
      allInitializingShards.add(shard.targetRoutingIfRelocating());
    }
    if (shard.assignedToNode()) {
      assignedShards.add(shard);
    }
    if (shard.state() != ShardRoutingState.STARTED) {
      allShardsStarted=false;
    }
  }
  this.allShardsStarted=allShardsStarted;
  this.primary=primary;
  if (primary != null) {
    this.primaryAsList=ImmutableList.of(primary);
  }
 else {
    this.primaryAsList=ImmutableList.of();
  }
  this.replicas=replicas.build();
  this.activeShards=activeShards.build();
  this.assignedShards=assignedShards.build();
  this.allInitializingShards=allInitializingShards.build();
}
