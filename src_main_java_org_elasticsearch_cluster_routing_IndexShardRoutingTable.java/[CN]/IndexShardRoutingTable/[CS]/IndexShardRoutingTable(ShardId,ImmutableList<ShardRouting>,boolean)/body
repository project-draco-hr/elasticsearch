{
  this.shardId=shardId;
  this.shards=shards;
  this.primaryAllocatedPostApi=primaryAllocatedPostApi;
  this.counter=new AtomicInteger(ThreadLocalRandom.current().nextInt(shards.size()));
  ShardRouting primary=null;
  ImmutableList.Builder<ShardRouting> replicas=ImmutableList.builder();
  ImmutableList.Builder<ShardRouting> activeShards=ImmutableList.builder();
  ImmutableList.Builder<ShardRouting> assignedShards=ImmutableList.builder();
  ImmutableList.Builder<ShardRouting> allInitializingShards=ImmutableList.builder();
  for (  ShardRouting shard : shards) {
    if (shard.primary()) {
      primary=shard;
    }
 else {
      replicas.add(shard);
    }
    if (shard.active()) {
      activeShards.add(shard);
    }
    if (shard.initializing()) {
      allInitializingShards.add(shard);
    }
    if (shard.relocating()) {
      allInitializingShards.add(new ImmutableShardRouting(shard.index(),shard.id(),shard.relocatingNodeId(),shard.currentNodeId(),shard.primary(),ShardRoutingState.INITIALIZING,shard.version()));
    }
    if (shard.assignedToNode()) {
      assignedShards.add(shard);
    }
  }
  this.primary=primary;
  if (primary != null) {
    this.primaryAsList=ImmutableList.of(primary);
  }
 else {
    this.primaryAsList=ImmutableList.of();
  }
  this.replicas=replicas.build();
  this.activeShards=activeShards.build();
  this.assignedShards=assignedShards.build();
  this.allInitializingShards=allInitializingShards.build();
}
