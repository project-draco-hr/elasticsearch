{
  MemcachedRestRequest request=this.request;
  if (request == null) {
    buffer.markReaderIndex();
    if (buffer.readableBytes() < 1) {
      return null;
    }
    short magic=buffer.readUnsignedByte();
    if (magic == 0x80) {
      if (buffer.readableBytes() < 23) {
        buffer.resetReaderIndex();
        return null;
      }
      short opcode=buffer.readUnsignedByte();
      short keyLength=buffer.readShort();
      short extraLength=buffer.readUnsignedByte();
      short dataType=buffer.readUnsignedByte();
      short reserved=buffer.readShort();
      int totalBodyLength=buffer.readInt();
      int opaque=buffer.readInt();
      long cas=buffer.readLong();
      if (buffer.readableBytes() < totalBodyLength) {
        buffer.resetReaderIndex();
        return null;
      }
      buffer.skipBytes(extraLength);
      if (opcode == 0x00) {
        byte[] key=new byte[keyLength];
        buffer.readBytes(key);
        String uri=Unicode.fromBytes(key);
        request=new MemcachedRestRequest(RestRequest.Method.GET,uri,key,-1,true);
        request.setOpaque(opaque);
        return request;
      }
 else       if (opcode == 0x04) {
        byte[] key=new byte[keyLength];
        buffer.readBytes(key);
        String uri=Unicode.fromBytes(key);
        request=new MemcachedRestRequest(RestRequest.Method.DELETE,uri,key,-1,true);
        request.setOpaque(opaque);
        return request;
      }
 else       if (opcode == 0x01) {
        byte[] key=new byte[keyLength];
        buffer.readBytes(key);
        String uri=Unicode.fromBytes(key);
        int size=totalBodyLength - keyLength - extraLength;
        request=new MemcachedRestRequest(RestRequest.Method.POST,uri,key,size,true);
        request.setOpaque(opaque);
        byte[] data=new byte[size];
        buffer.readBytes(data,0,size);
        request.setData(data);
        request.setQuiet(opcode == 0x11);
        return request;
      }
 else       if (opcode == 0x0A || opcode == 0x10) {
        ChannelBuffer writeBuffer=ChannelBuffers.dynamicBuffer(24);
        writeBuffer.writeByte(0x81);
        writeBuffer.writeByte(opcode);
        writeBuffer.writeShort(0);
        writeBuffer.writeByte(0);
        writeBuffer.writeByte(0);
        writeBuffer.writeShort(0x0000);
        writeBuffer.writeInt(0);
        writeBuffer.writeInt(opaque);
        writeBuffer.writeLong(0);
        channel.write(writeBuffer);
        return MemcachedDispatcher.IGNORE_REQUEST;
      }
 else       if (opcode == 0x07) {
        channel.disconnect();
      }
 else {
        logger.error("Unsupported opcode [0x{}], ignoring and closing connection",Integer.toHexString(opcode));
        channel.disconnect();
        return null;
      }
    }
 else {
      buffer.resetReaderIndex();
      boolean done=false;
      StringBuffer sb=this.sb;
      int readableBytes=buffer.readableBytes();
      for (int i=0; i < readableBytes; i++) {
        byte next=buffer.readByte();
        if (!ending && next == CR) {
          ending=true;
        }
 else         if (ending && next == LF) {
          ending=false;
          done=true;
          break;
        }
 else         if (ending) {
          logger.error("Corrupt stream, expected LF, found [0x{}]",Integer.toHexString(next));
          throw new StreamCorruptedException("Expecting LF after CR");
        }
 else {
          sb.append((char)next);
        }
      }
      if (!done) {
        buffer.markReaderIndex();
        return null;
      }
      String[] args=lineSplit.split(sb);
      sb.setLength(0);
      String cmd=args[0];
      if ("get".equals(cmd)) {
        request=new MemcachedRestRequest(RestRequest.Method.GET,args[1],null,-1,false);
        if (args.length > 3) {
          request.setData(Unicode.fromStringAsBytes(args[2]));
        }
        return request;
      }
 else       if ("delete".equals(cmd)) {
        request=new MemcachedRestRequest(RestRequest.Method.DELETE,args[1],null,-1,false);
        return request;
      }
 else       if ("set".equals(cmd)) {
        this.request=new MemcachedRestRequest(RestRequest.Method.POST,args[1],null,Integer.parseInt(args[4]),false);
        buffer.markReaderIndex();
      }
 else       if ("version".equals(cmd)) {
        byte[] bytes=Version.CURRENT.toString().getBytes();
        ChannelBuffer writeBuffer=ChannelBuffers.dynamicBuffer(bytes.length);
        writeBuffer.writeBytes(bytes);
        channel.write(writeBuffer);
        return MemcachedDispatcher.IGNORE_REQUEST;
      }
 else       if ("quit".equals(cmd)) {
        if (channel.isConnected()) {
          channel.disconnect();
        }
      }
 else {
        logger.error("Unsupported command [{}], ignoring and closing connection",cmd);
        if (channel.isConnected()) {
          channel.disconnect();
        }
        return null;
      }
    }
  }
 else {
    if (buffer.readableBytes() < (request.getDataSize() + 2)) {
      return null;
    }
    byte[] data=new byte[request.getDataSize()];
    buffer.readBytes(data,0,data.length);
    byte next=buffer.readByte();
    if (next == CR) {
      next=buffer.readByte();
      if (next == LF) {
        request.setData(data);
        this.request=null;
        return request;
      }
 else {
        this.request=null;
        throw new StreamCorruptedException("Expecting separator after data block");
      }
    }
 else {
      this.request=null;
      throw new StreamCorruptedException("Expecting separator after data block");
    }
  }
  return null;
}
