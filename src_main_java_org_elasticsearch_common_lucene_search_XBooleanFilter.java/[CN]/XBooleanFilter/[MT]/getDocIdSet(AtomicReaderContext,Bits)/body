{
  FixedBitSet res=null;
  final AtomicReader reader=context.reader();
  if (clauses.size() == 1) {
    FilterClause clause=clauses.get(0);
    DocIdSet set=clause.getFilter().getDocIdSet(context,acceptDocs);
    if (clause.getOccur() == Occur.MUST_NOT) {
      if (DocIdSets.isEmpty(set)) {
        return new AllDocIdSet(reader.maxDoc());
      }
 else {
        return new NotDocIdSet(set,reader.maxDoc());
      }
    }
    if (DocIdSets.isEmpty(set)) {
      return null;
    }
    return set;
  }
  List<ResultClause> results=new ArrayList<ResultClause>(clauses.size());
  boolean hasShouldClauses=false;
  boolean hasNonEmptyShouldClause=false;
  boolean hasMustClauses=false;
  boolean hasMustNotClauses=false;
  for (int i=0; i < clauses.size(); i++) {
    FilterClause clause=clauses.get(i);
    DocIdSet set=clause.getFilter().getDocIdSet(context,acceptDocs);
    if (clause.getOccur() == Occur.MUST) {
      hasMustClauses=true;
      if (DocIdSets.isEmpty(set)) {
        return null;
      }
    }
 else     if (clause.getOccur() == Occur.SHOULD) {
      hasShouldClauses=true;
      if (DocIdSets.isEmpty(set)) {
        continue;
      }
      hasNonEmptyShouldClause=true;
    }
 else     if (clause.getOccur() == Occur.MUST_NOT) {
      hasMustNotClauses=true;
      if (DocIdSets.isEmpty(set)) {
        results.add(new ResultClause(null,null,clause));
        continue;
      }
    }
    Bits bits=null;
    if (!DocIdSets.isFastIterator(set)) {
      bits=set.bits();
    }
    results.add(new ResultClause(set,bits,clause));
  }
  if (hasShouldClauses && !hasNonEmptyShouldClause) {
    return null;
  }
  hasNonEmptyShouldClause=false;
  boolean hasBits=false;
  for (int i=0; i < results.size(); i++) {
    ResultClause clause=results.get(i);
    if (clause.bits != null) {
      hasBits=true;
      continue;
    }
    if (clause.clause.getOccur() == Occur.SHOULD) {
      DocIdSetIterator it=clause.docIdSet.iterator();
      if (it == null) {
        continue;
      }
      hasNonEmptyShouldClause=true;
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
      }
      res.or(it);
    }
  }
  for (int i=0; i < results.size(); i++) {
    ResultClause clause=results.get(i);
    if (clause.bits != null) {
      hasBits=true;
      continue;
    }
    if (clause.clause.getOccur() == Occur.MUST) {
      DocIdSetIterator it=clause.docIdSet.iterator();
      if (it == null) {
        return null;
      }
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        res.or(it);
      }
 else {
        res.and(it);
      }
    }
 else     if (clause.clause.getOccur() == Occur.MUST_NOT) {
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        res.set(0,reader.maxDoc());
      }
      if (clause.docIdSet != null) {
        DocIdSetIterator it=clause.docIdSet.iterator();
        if (it != null) {
          res.andNot(it);
        }
      }
    }
  }
  if (!hasBits) {
    if (hasShouldClauses && !hasNonEmptyShouldClause) {
      return null;
    }
 else {
      return res;
    }
  }
  List<ResultClause> orClauses=new ArrayList<ResultClause>();
  for (int i=0; i < results.size(); i++) {
    ResultClause clause=results.get(i);
    if (clause.bits == null) {
      continue;
    }
    if (clause.clause.getOccur() == Occur.SHOULD) {
      if (hasMustClauses || hasMustNotClauses) {
        orClauses.add(clause);
      }
 else {
        if (res == null) {
          DocIdSetIterator it=clause.docIdSet.iterator();
          if (it == null) {
            continue;
          }
          hasNonEmptyShouldClause=true;
          res=new FixedBitSet(reader.maxDoc());
          res.or(it);
        }
 else         if (!hasMustNotClauses && !hasMustClauses) {
          for (int doc=0; doc < reader.maxDoc(); doc++) {
            if (!res.get(doc) && clause.bits.get(doc)) {
              hasNonEmptyShouldClause=true;
              res.set(doc);
            }
          }
        }
      }
    }
 else     if (clause.clause.getOccur() == Occur.MUST) {
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        DocIdSetIterator it=clause.docIdSet.iterator();
        if (it == null) {
          return null;
        }
        res.or(it);
      }
 else {
        Bits bits=clause.bits;
        DocIdSetIterator it=res.iterator();
        for (int doc=it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=it.nextDoc()) {
          if (!bits.get(doc)) {
            res.clear(doc);
          }
        }
      }
    }
 else     if (clause.clause.getOccur() == Occur.MUST_NOT) {
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        res.set(0,reader.maxDoc());
        DocIdSetIterator it=clause.docIdSet.iterator();
        if (it != null) {
          res.andNot(it);
        }
      }
 else {
        Bits bits=clause.bits;
        DocIdSetIterator it=res.iterator();
        for (int doc=it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=it.nextDoc()) {
          if (bits.get(doc)) {
            res.clear(doc);
          }
        }
      }
    }
  }
  if (!orClauses.isEmpty()) {
    DocIdSetIterator it=res.iterator();
    res:     for (int setDoc=it.nextDoc(); setDoc != DocIdSetIterator.NO_MORE_DOCS; setDoc=it.nextDoc()) {
      for (      ResultClause orClause : orClauses) {
        if (orClause.bits.get(setDoc)) {
          hasNonEmptyShouldClause=true;
          continue res;
        }
      }
      res.clear(setDoc);
    }
  }
  if (hasShouldClauses && !hasNonEmptyShouldClause) {
    return null;
  }
 else {
    return res;
  }
}
