{
  FixedBitSet res=null;
  final AtomicReader reader=context.reader();
  if (clauses.size() == 1) {
    FilterClause clause=clauses.get(0);
    DocIdSet set=clause.getFilter().getDocIdSet(context,acceptDocs);
    if (clause.getOccur() == Occur.MUST_NOT) {
      if (DocIdSets.isEmpty(set)) {
        return new AllDocIdSet(reader.maxDoc());
      }
 else {
        return new NotDocIdSet(set,reader.maxDoc());
      }
    }
    if (DocIdSets.isEmpty(set)) {
      return null;
    }
    return set;
  }
  List<ResultClause> results=new ArrayList<ResultClause>(clauses.size());
  boolean hasShouldClauses=false;
  boolean hasNonEmptyShouldClause=false;
  for (int i=0; i < clauses.size(); i++) {
    FilterClause clause=clauses.get(i);
    DocIdSet set=clause.getFilter().getDocIdSet(context,acceptDocs);
    if (clause.getOccur() == Occur.MUST) {
      if (DocIdSets.isEmpty(set)) {
        return null;
      }
    }
 else     if (clause.getOccur() == Occur.SHOULD) {
      hasShouldClauses=true;
      if (DocIdSets.isEmpty(set)) {
        continue;
      }
      hasNonEmptyShouldClause=true;
    }
 else     if (clause.getOccur() == Occur.MUST_NOT) {
      if (DocIdSets.isEmpty(set)) {
        results.add(new ResultClause(null,null,clause));
        continue;
      }
    }
    Bits bits=null;
    if (!DocIdSets.isFastIterator(set)) {
      bits=set.bits();
    }
    results.add(new ResultClause(set,bits,clause));
  }
  if (hasShouldClauses && !hasNonEmptyShouldClause) {
    return null;
  }
  boolean hasBits=false;
  for (int i=0; i < results.size(); i++) {
    ResultClause clause=results.get(i);
    if (clause.bits != null) {
      hasBits=true;
      continue;
    }
    if (clause.clause.getOccur() == Occur.SHOULD) {
      DocIdSetIterator it=clause.docIdSet.iterator();
      if (it == null) {
        continue;
      }
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
      }
      res.or(it);
    }
 else     if (clause.clause.getOccur() == Occur.MUST) {
      DocIdSetIterator it=clause.docIdSet.iterator();
      if (it == null) {
        return null;
      }
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        res.or(it);
      }
 else {
        res.and(it);
      }
    }
 else     if (clause.clause.getOccur() == Occur.MUST_NOT) {
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        res.set(0,reader.maxDoc());
      }
      if (clause.docIdSet != null) {
        DocIdSetIterator it=clause.docIdSet.iterator();
        if (it != null) {
          res.andNot(it);
        }
      }
    }
  }
  if (!hasBits) {
    return res;
  }
  for (int i=0; i < results.size(); i++) {
    ResultClause clause=results.get(i);
    if (clause.bits == null) {
      continue;
    }
    if (clause.clause.getOccur() == Occur.SHOULD) {
      DocIdSetIterator it=clause.docIdSet.iterator();
      if (it == null) {
        continue;
      }
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
      }
      res.or(it);
    }
 else     if (clause.clause.getOccur() == Occur.MUST) {
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        DocIdSetIterator it=clause.docIdSet.iterator();
        if (it == null) {
          return null;
        }
        res.or(it);
      }
 else {
        Bits bits=clause.bits;
        DocIdSetIterator it=res.iterator();
        for (int doc=it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=it.nextDoc()) {
          if (!bits.get(doc)) {
            res.clear(doc);
          }
        }
      }
    }
 else     if (clause.clause.getOccur() == Occur.MUST_NOT) {
      if (res == null) {
        res=new FixedBitSet(reader.maxDoc());
        res.set(0,reader.maxDoc());
        DocIdSetIterator it=clause.docIdSet.iterator();
        if (it != null) {
          res.andNot(it);
        }
      }
 else {
        Bits bits=clause.bits;
        DocIdSetIterator it=res.iterator();
        for (int doc=it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=it.nextDoc()) {
          if (bits.get(doc)) {
            res.clear(doc);
          }
        }
      }
    }
  }
  return res;
}
