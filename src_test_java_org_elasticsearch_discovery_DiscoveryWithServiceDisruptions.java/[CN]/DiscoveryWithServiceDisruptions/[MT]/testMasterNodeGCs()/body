{
  List<String> nodes=startUnicastCluster(3,null,-1);
  String oldMasterNode=internalCluster().getMasterName();
  SingleNodeDisruption masterNodeDisruption=new LongGCDisruption(oldMasterNode,getRandom(),100,200,30000,60000);
  internalCluster().setDisruptionScheme(masterNodeDisruption);
  masterNodeDisruption.startDisrupting();
  Set<String> oldNonMasterNodesSet=new HashSet<>(nodes);
  oldNonMasterNodesSet.remove(oldMasterNode);
  List<String> oldNonMasterNodes=new ArrayList<>(oldNonMasterNodesSet);
  logger.info("waiting for nodes to de-elect master [{}]",oldMasterNode);
  for (  String node : oldNonMasterNodesSet) {
    assertDifferentMaster(node,oldMasterNode);
  }
  logger.info("waiting for nodes to elect a new master");
  ensureStableCluster(2,oldNonMasterNodes.get(0));
  logger.info("waiting for any pinging to stop");
  for (  final String node : oldNonMasterNodes) {
    assertTrue("node [" + node + "] is still joining master",awaitBusy(new Predicate<Object>(){
      @Override public boolean apply(      Object input){
        return !((ZenDiscovery)internalCluster().getInstance(Discovery.class,node)).joiningCluster();
      }
    }
,30,TimeUnit.SECONDS));
  }
  masterNodeDisruption.stopDisrupting();
  ensureStableCluster(3,new TimeValue(DISRUPTION_HEALING_OVERHEAD.millis() + masterNodeDisruption.expectedTimeToHeal().millis()),oldNonMasterNodes.get(0));
  String newMaster=internalCluster().getMasterName();
  assertThat(newMaster,not(equalTo(oldMasterNode)));
  assertMaster(newMaster,nodes);
}
