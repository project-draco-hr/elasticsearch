{
  AttachmentMapper.Builder builder=new AttachmentMapper.Builder(name);
  for (Iterator<Map.Entry<String,Object>> iterator=node.entrySet().iterator(); iterator.hasNext(); ) {
    Map.Entry<String,Object> entry=iterator.next();
    String fieldName=entry.getKey();
    Object fieldNode=entry.getValue();
    if (fieldName.equals("path") && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {
      builder.pathType(parsePathType(name,fieldNode.toString()));
      iterator.remove();
    }
 else     if (fieldName.equals("fields")) {
      Map<String,Object> fieldsNode=(Map<String,Object>)fieldNode;
      for (Iterator<Map.Entry<String,Object>> fieldsIterator=fieldsNode.entrySet().iterator(); fieldsIterator.hasNext(); ) {
        Map.Entry<String,Object> entry1=fieldsIterator.next();
        String propName=entry1.getKey();
        Map<String,Object> propNode=(Map<String,Object>)entry1.getValue();
        Mapper.Builder<?,?> mapperBuilder=findMapperBuilder(propNode,propName,parserContext);
        if (parseMultiField((AbstractFieldMapper.Builder)mapperBuilder,fieldName,parserContext,propName,propNode)) {
          fieldsIterator.remove();
        }
 else         if (propName.equals(name) && parserContext.indexVersionCreated().before(Version.V_2_0_0)) {
          builder.content(mapperBuilder);
          fieldsIterator.remove();
        }
 else {
switch (propName) {
case FieldNames.CONTENT:
            builder.content(mapperBuilder);
          fieldsIterator.remove();
        break;
case FieldNames.DATE:
      builder.date(mapperBuilder);
    fieldsIterator.remove();
  break;
case FieldNames.AUTHOR:
builder.author(mapperBuilder);
fieldsIterator.remove();
break;
case FieldNames.CONTENT_LENGTH:
builder.contentLength(mapperBuilder);
fieldsIterator.remove();
break;
case FieldNames.CONTENT_TYPE:
builder.contentType(mapperBuilder);
fieldsIterator.remove();
break;
case FieldNames.KEYWORDS:
builder.keywords(mapperBuilder);
fieldsIterator.remove();
break;
case FieldNames.LANGUAGE:
builder.language(mapperBuilder);
fieldsIterator.remove();
break;
case FieldNames.TITLE:
builder.title(mapperBuilder);
fieldsIterator.remove();
break;
case FieldNames.NAME:
builder.name(mapperBuilder);
fieldsIterator.remove();
break;
}
}
}
DocumentMapperParser.checkNoRemainingFields(fieldName,fieldsNode,parserContext.indexVersionCreated());
iterator.remove();
}
}
return builder;
}
