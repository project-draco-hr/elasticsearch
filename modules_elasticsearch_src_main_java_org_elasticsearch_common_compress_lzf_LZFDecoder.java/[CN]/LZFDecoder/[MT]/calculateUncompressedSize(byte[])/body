{
  int uncompressedSize=0;
  int ptr=0;
  int blockNr=0;
  while (ptr < data.length) {
    if (ptr == (data.length + 1) && data[ptr] == BYTE_NULL) {
      ++ptr;
      break;
    }
    try {
      if (data[ptr] != LZFChunk.BYTE_Z || data[ptr + 1] != LZFChunk.BYTE_V) {
        throw new IOException("Corrupt input data, block #" + blockNr + " (at offset "+ ptr+ "): did not start with 'ZV' signature bytes");
      }
      int type=(int)data[ptr + 2];
      int blockLen=uint16(data,ptr + 3);
      if (type == LZFChunk.BLOCK_TYPE_NON_COMPRESSED) {
        ptr+=5;
        uncompressedSize+=blockLen;
      }
 else       if (type == LZFChunk.BLOCK_TYPE_COMPRESSED) {
        uncompressedSize+=uint16(data,ptr + 5);
        ptr+=7;
      }
 else {
        throw new IOException("Corrupt input data, block #" + blockNr + " (at offset "+ ptr+ "): unrecognized block type "+ (type & 0xFF));
      }
      ptr+=blockLen;
    }
 catch (    ArrayIndexOutOfBoundsException e) {
      throw new IOException("Corrupt input data, block #" + blockNr + " (at offset "+ ptr+ "): truncated block header");
    }
    ++blockNr;
  }
  if (ptr != data.length) {
    throw new IOException("Corrupt input data: block #" + blockNr + " extends "+ (data.length - ptr)+ " beyond end of input");
  }
  return uncompressedSize;
}
