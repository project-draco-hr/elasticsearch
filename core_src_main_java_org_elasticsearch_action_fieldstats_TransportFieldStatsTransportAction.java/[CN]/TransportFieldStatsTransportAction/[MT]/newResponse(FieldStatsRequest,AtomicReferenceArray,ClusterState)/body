{
  int successfulShards=0;
  int failedShards=0;
  Map<String,String> conflicts=new HashMap<>();
  Map<String,Map<String,FieldStats>> indicesMergedFieldStats=new HashMap<>();
  List<ShardOperationFailedException> shardFailures=new ArrayList<>();
  for (int i=0; i < shardsResponses.length(); i++) {
    Object shardValue=shardsResponses.get(i);
    if (shardValue == null) {
    }
 else     if (shardValue instanceof BroadcastShardOperationFailedException) {
      failedShards++;
      shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException)shardValue));
    }
 else {
      successfulShards++;
      FieldStatsShardResponse shardResponse=(FieldStatsShardResponse)shardValue;
      final String indexName;
      if ("cluster".equals(request.level())) {
        indexName="_all";
      }
 else       if ("indices".equals(request.level())) {
        indexName=shardResponse.getIndex();
      }
 else {
        throw new IllegalArgumentException("Illegal level option [" + request.level() + "]");
      }
      Map<String,FieldStats> indexMergedFieldStats=indicesMergedFieldStats.get(indexName);
      if (indexMergedFieldStats == null) {
        indicesMergedFieldStats.put(indexName,indexMergedFieldStats=new HashMap<>());
      }
      Map<String,FieldStats<?>> fieldStats=shardResponse.getFieldStats();
      for (      Map.Entry<String,FieldStats<?>> entry : fieldStats.entrySet()) {
        FieldStats<?> existing=indexMergedFieldStats.get(entry.getKey());
        if (existing != null) {
          if (existing.getType() != entry.getValue().getType()) {
            if (conflicts.containsKey(entry.getKey()) == false) {
              conflicts.put(entry.getKey(),"Field [" + entry.getKey() + "] of type ["+ FieldStats.typeName(entry.getValue().getType())+ "] conflicts with existing field of type ["+ FieldStats.typeName(existing.getType())+ "] in other index.");
            }
          }
 else {
            existing.accumulate(entry.getValue());
          }
        }
 else {
          indexMergedFieldStats.put(entry.getKey(),entry.getValue());
        }
      }
    }
    for (    String conflictKey : conflicts.keySet()) {
      Iterator<Map.Entry<String,Map<String,FieldStats>>> iterator=indicesMergedFieldStats.entrySet().iterator();
      while (iterator.hasNext()) {
        Map.Entry<String,Map<String,FieldStats>> entry=iterator.next();
        if (entry.getValue().containsKey(conflictKey)) {
          entry.getValue().remove(conflictKey);
        }
      }
    }
  }
  if (request.getIndexConstraints().length != 0) {
    Set<String> fieldStatFields=new HashSet<>(Arrays.asList(request.getFields()));
    for (    IndexConstraint indexConstraint : request.getIndexConstraints()) {
      Iterator<Map.Entry<String,Map<String,FieldStats>>> iterator=indicesMergedFieldStats.entrySet().iterator();
      while (iterator.hasNext()) {
        Map.Entry<String,Map<String,FieldStats>> entry=iterator.next();
        FieldStats indexConstraintFieldStats=entry.getValue().get(indexConstraint.getField());
        if (indexConstraintFieldStats != null && indexConstraintFieldStats.match(indexConstraint)) {
          if (fieldStatFields.contains(indexConstraint.getField()) == false) {
            entry.getValue().remove(indexConstraint.getField());
          }
        }
 else {
          iterator.remove();
        }
      }
    }
  }
  return new FieldStatsResponse(shardsResponses.length(),successfulShards,failedShards,shardFailures,indicesMergedFieldStats,conflicts);
}
