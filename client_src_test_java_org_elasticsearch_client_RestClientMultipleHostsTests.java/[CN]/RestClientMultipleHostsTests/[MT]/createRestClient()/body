{
  CloseableHttpClient httpClient=mock(CloseableHttpClient.class);
  when(httpClient.execute(any(HttpHost.class),any(HttpRequest.class))).thenAnswer(new Answer<CloseableHttpResponse>(){
    @Override public CloseableHttpResponse answer(    InvocationOnMock invocationOnMock) throws Throwable {
      HttpHost httpHost=(HttpHost)invocationOnMock.getArguments()[0];
      HttpUriRequest request=(HttpUriRequest)invocationOnMock.getArguments()[1];
      if (request.getURI().getPath().equals("/soe")) {
        throw new SocketTimeoutException(httpHost.toString());
      }
 else       if (request.getURI().getPath().equals("/coe")) {
        throw new ConnectTimeoutException(httpHost.toString());
      }
 else       if (request.getURI().getPath().equals("/ioe")) {
        throw new IOException(httpHost.toString());
      }
      int statusCode=Integer.parseInt(request.getURI().getPath().substring(1));
      StatusLine statusLine=new BasicStatusLine(new ProtocolVersion("http",1,1),statusCode,"");
      return new CloseableBasicHttpResponse(statusLine);
    }
  }
);
  int numHosts=RandomInts.randomIntBetween(getRandom(),2,5);
  httpHosts=new HttpHost[numHosts];
  for (int i=0; i < numHosts; i++) {
    httpHosts[i]=new HttpHost("localhost",9200 + i);
  }
  failureListener=new TrackingFailureListener();
  restClient=RestClient.builder(httpHosts).setHttpClient(httpClient).setFailureListener(failureListener).build();
}
