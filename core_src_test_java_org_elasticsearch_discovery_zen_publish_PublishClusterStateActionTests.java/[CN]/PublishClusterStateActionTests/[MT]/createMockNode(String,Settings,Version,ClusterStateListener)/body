{
  settings=Settings.builder().put("name",name).put(TransportService.TRACE_LOG_INCLUDE_SETTING.getKey(),"",TransportService.TRACE_LOG_EXCLUDE_SETTING.getKey(),"NOTHING").put(settings).build();
  MockTransportService service=buildTransportService(settings,version);
  DiscoveryNodeService discoveryNodeService=new DiscoveryNodeService(settings,version);
  DiscoveryNode discoveryNode=discoveryNodeService.buildLocalNode(service.boundAddress().publishAddress());
  MockNode node=new MockNode(discoveryNode,service,listener,logger);
  node.action=buildPublishClusterStateAction(settings,service,node,node);
  final CountDownLatch latch=new CountDownLatch(nodes.size() * 2 + 1);
  TransportConnectionListener waitForConnection=new TransportConnectionListener(){
    @Override public void onNodeConnected(    DiscoveryNode node){
      latch.countDown();
    }
    @Override public void onNodeDisconnected(    DiscoveryNode node){
      fail("disconnect should not be called " + node);
    }
  }
;
  node.service.addConnectionListener(waitForConnection);
  for (  MockNode curNode : nodes.values()) {
    curNode.service.addConnectionListener(waitForConnection);
    curNode.connectTo(node.discoveryNode);
    node.connectTo(curNode.discoveryNode);
  }
  node.connectTo(node.discoveryNode);
  assertThat("failed to wait for all nodes to connect",latch.await(5,TimeUnit.SECONDS),equalTo(true));
  for (  MockNode curNode : nodes.values()) {
    curNode.service.removeConnectionListener(waitForConnection);
  }
  node.service.removeConnectionListener(waitForConnection);
  if (nodes.put(name,node) != null) {
    fail("Node with the name " + name + " already exist");
  }
  return node;
}
