{
  settings=Settings.builder().put("name",name).put(TransportService.SETTING_TRACE_LOG_INCLUDE,"",TransportService.SETTING_TRACE_LOG_EXCLUDE,"NOTHING").put(settings).build();
  MockTransportService service=buildTransportService(settings,version);
  DiscoveryNode discoveryNode=new DiscoveryNode(name,name,service.boundAddress().publishAddress(),settings.getByPrefix("node.").getAsMap(),version);
  MockNode node=new MockNode(discoveryNode,service,listener,logger);
  node.action=buildPublishClusterStateAction(settings,service,node,node);
  final CountDownLatch latch=new CountDownLatch(nodes.size() * 2 + 1);
  TransportConnectionListener waitForConnection=new TransportConnectionListener(){
    @Override public void onNodeConnected(    DiscoveryNode node){
      latch.countDown();
    }
    @Override public void onNodeDisconnected(    DiscoveryNode node){
      fail("disconnect should not be called " + node);
    }
  }
;
  node.service.addConnectionListener(waitForConnection);
  for (  MockNode curNode : nodes.values()) {
    curNode.service.addConnectionListener(waitForConnection);
    curNode.connectTo(node.discoveryNode);
    node.connectTo(curNode.discoveryNode);
  }
  node.connectTo(node.discoveryNode);
  assertThat("failed to wait for all nodes to connect",latch.await(5,TimeUnit.SECONDS),equalTo(true));
  for (  MockNode curNode : nodes.values()) {
    curNode.service.removeConnectionListener(waitForConnection);
  }
  node.service.removeConnectionListener(waitForConnection);
  if (nodes.put(name,node) != null) {
    fail("Node with the name " + name + " already exist");
  }
  return node;
}
