{
  ImmutableList.Builder<SnapshotStatus> builder=ImmutableList.builder();
  Set<SnapshotId> currentSnapshotIds=newHashSet();
  if (!currentSnapshots.isEmpty()) {
    Map<String,TransportNodesSnapshotsStatus.NodeSnapshotStatus> nodeSnapshotStatusMap;
    if (nodeSnapshotStatuses != null) {
      nodeSnapshotStatusMap=nodeSnapshotStatuses.getNodesMap();
    }
 else {
      nodeSnapshotStatusMap=newHashMap();
    }
    for (    SnapshotMetaData.Entry entry : currentSnapshots) {
      currentSnapshotIds.add(entry.snapshotId());
      ImmutableList.Builder<SnapshotIndexShardStatus> shardStatusBuilder=ImmutableList.builder();
      for (      ImmutableMap.Entry<ShardId,SnapshotMetaData.ShardSnapshotStatus> shardEntry : entry.shards().entrySet()) {
        SnapshotMetaData.ShardSnapshotStatus status=shardEntry.getValue();
        if (status.nodeId() != null) {
          TransportNodesSnapshotsStatus.NodeSnapshotStatus nodeStatus=nodeSnapshotStatusMap.get(status.nodeId());
          if (nodeStatus != null) {
            ImmutableMap<ShardId,SnapshotIndexShardStatus> shardStatues=nodeStatus.status().get(entry.snapshotId());
            if (shardStatues != null) {
              SnapshotIndexShardStatus shardStatus=shardStatues.get(shardEntry.getKey());
              if (shardStatus != null) {
                shardStatusBuilder.add(shardStatus);
                continue;
              }
            }
          }
        }
        final SnapshotIndexShardStage stage;
switch (shardEntry.getValue().state()) {
case FAILED:
case ABORTED:
case MISSING:
          stage=SnapshotIndexShardStage.FAILURE;
        break;
case INIT:
case STARTED:
      stage=SnapshotIndexShardStage.STARTED;
    break;
case SUCCESS:
  stage=SnapshotIndexShardStage.DONE;
break;
default :
throw new ElasticsearchIllegalArgumentException("Unknown snapshot state " + shardEntry.getValue().state());
}
SnapshotIndexShardStatus shardStatus=new SnapshotIndexShardStatus(shardEntry.getKey().getIndex(),shardEntry.getKey().getId(),stage);
shardStatusBuilder.add(shardStatus);
}
builder.add(new SnapshotStatus(entry.snapshotId(),entry.state(),shardStatusBuilder.build()));
}
}
if (Strings.hasText(request.repository())) {
if (request.snapshots() != null && request.snapshots().length > 0) {
for (String snapshotName : request.snapshots()) {
SnapshotId snapshotId=new SnapshotId(request.repository(),snapshotName);
if (currentSnapshotIds.contains(snapshotId)) {
continue;
}
Snapshot snapshot=snapshotsService.snapshot(snapshotId);
ImmutableList.Builder<SnapshotIndexShardStatus> shardStatusBuilder=ImmutableList.builder();
if (snapshot.state().completed()) {
ImmutableMap<ShardId,IndexShardSnapshotStatus> shardStatues=snapshotsService.snapshotShards(snapshotId);
for (ImmutableMap.Entry<ShardId,IndexShardSnapshotStatus> shardStatus : shardStatues.entrySet()) {
shardStatusBuilder.add(new SnapshotIndexShardStatus(shardStatus.getKey(),shardStatus.getValue()));
}
final SnapshotMetaData.State state;
switch (snapshot.state()) {
case FAILED:
state=SnapshotMetaData.State.FAILED;
break;
case SUCCESS:
state=SnapshotMetaData.State.SUCCESS;
break;
default :
throw new ElasticsearchIllegalArgumentException("Unknown snapshot state " + snapshot.state());
}
builder.add(new SnapshotStatus(snapshotId,state,shardStatusBuilder.build()));
}
}
}
}
return new SnapshotsStatusResponse(builder.build());
}
