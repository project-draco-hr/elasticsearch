{
  InternalTestCluster internalCluster=backwardsCluster().internalCluster();
  TransportService transportService=internalCluster.getInstance(TransportService.class);
  ImmutableMap<String,TransportRequestHandler> requestHandlers=transportService.serverHandlers;
  DiscoveryNodes nodes=client().admin().cluster().prepareState().get().getState().nodes();
  DiscoveryNode selectedNode=null;
  for (  DiscoveryNode node : nodes) {
    if (node.getVersion().before(Version.CURRENT)) {
      selectedNode=node;
      break;
    }
  }
  assertThat(selectedNode,notNullValue());
  final TransportRequest transportRequest=new TransportRequest(){
  }
;
  for (  String action : requestHandlers.keySet()) {
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicReference<TransportException> failure=new AtomicReference<>();
    transportService.sendRequest(selectedNode,action,transportRequest,new TransportResponseHandler<TransportResponse>(){
      @Override public TransportResponse newInstance(){
        return new TransportResponse(){
        }
;
      }
      @Override public void handleResponse(      TransportResponse response){
        latch.countDown();
      }
      @Override public void handleException(      TransportException exp){
        failure.set(exp);
        latch.countDown();
      }
      @Override public String executor(){
        return ThreadPool.Names.SAME;
      }
    }
);
    assertThat(latch.await(5,TimeUnit.SECONDS),equalTo(true));
    if (failure.get() != null) {
      Throwable cause=failure.get().unwrapCause();
      if (isActionNotFoundExpected(selectedNode.version(),action)) {
        assertThat(cause,instanceOf(ActionNotFoundTransportException.class));
      }
 else {
        assertThat(cause,not(instanceOf(ActionNotFoundTransportException.class)));
        if (!(cause instanceof IndexOutOfBoundsException)) {
          cause.printStackTrace();
        }
      }
    }
  }
}
