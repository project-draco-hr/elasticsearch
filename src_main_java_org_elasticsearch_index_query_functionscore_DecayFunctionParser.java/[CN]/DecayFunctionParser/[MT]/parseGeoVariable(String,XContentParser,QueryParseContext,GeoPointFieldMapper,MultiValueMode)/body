{
  XContentParser.Token token;
  String parameterName=null;
  GeoPoint origin=new GeoPoint();
  String scaleString=null;
  String offsetString="0km";
  double decay=0.5;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      parameterName=parser.currentName();
    }
 else     if (parameterName.equals(DecayFunctionBuilder.SCALE)) {
      scaleString=parser.text();
    }
 else     if (parameterName.equals(DecayFunctionBuilder.ORIGIN)) {
      origin=GeoUtils.parseGeoPoint(parser);
    }
 else     if (parameterName.equals(DecayFunctionBuilder.DECAY)) {
      decay=parser.doubleValue();
    }
 else     if (parameterName.equals(DecayFunctionBuilder.OFFSET)) {
      offsetString=parser.text();
    }
 else {
      throw new ElasticsearchParseException("Parameter " + parameterName + " not supported!");
    }
  }
  if (origin == null || scaleString == null) {
    throw new ElasticsearchParseException(DecayFunctionBuilder.ORIGIN + " and " + DecayFunctionBuilder.SCALE+ " must be set for geo fields.");
  }
  double scale=DistanceUnit.DEFAULT.parse(scaleString,DistanceUnit.DEFAULT);
  double offset=DistanceUnit.DEFAULT.parse(offsetString,DistanceUnit.DEFAULT);
  IndexGeoPointFieldData<?> indexFieldData=parseContext.fieldData().getForField(mapper);
  return new GeoFieldDataScoreFunction(origin,scale,decay,offset,getDecayFunction(),indexFieldData,mode);
}
