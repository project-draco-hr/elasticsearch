{
  boolean folded;
  if (style == '>') {
    folded=true;
  }
 else {
    folded=false;
  }
  StringBuilder chunks=new StringBuilder();
  Mark startMark=reader.getMark();
  reader.forward();
  Chomping chompi=scanBlockScalarIndicators(startMark);
  int increment=chompi.getIncrement();
  scanBlockScalarIgnoredLine(startMark);
  int minIndent=this.indent + 1;
  if (minIndent < 1) {
    minIndent=1;
  }
  String breaks=null;
  int maxIndent=0;
  int indent=0;
  Mark endMark;
  if (increment == -1) {
    Object[] brme=scanBlockScalarIndentation();
    breaks=(String)brme[0];
    maxIndent=((Integer)brme[1]).intValue();
    endMark=(Mark)brme[2];
    indent=Math.max(minIndent,maxIndent);
  }
 else {
    indent=minIndent + increment - 1;
    Object[] brme=scanBlockScalarBreaks(indent);
    breaks=(String)brme[0];
    endMark=(Mark)brme[1];
  }
  String lineBreak="";
  while (this.reader.getColumn() == indent && reader.peek() != '\0') {
    chunks.append(breaks);
    boolean leadingNonSpace=" \t".indexOf(reader.peek()) == -1;
    int length=0;
    while (Constant.NULL_OR_LINEBR.hasNo(reader.peek(length))) {
      length++;
    }
    chunks.append(reader.prefix(length));
    reader.forward(length);
    lineBreak=scanLineBreak();
    Object[] brme=scanBlockScalarBreaks(indent);
    breaks=(String)brme[0];
    endMark=(Mark)brme[1];
    if (this.reader.getColumn() == indent && reader.peek() != '\0') {
      if (folded && "\n".equals(lineBreak) && leadingNonSpace&& " \t".indexOf(reader.peek()) == -1) {
        if (breaks.length() == 0) {
          chunks.append(" ");
        }
      }
 else {
        chunks.append(lineBreak);
      }
    }
 else {
      break;
    }
  }
  if (chompi.chompTailIsNotFalse()) {
    chunks.append(lineBreak);
  }
  if (chompi.chompTailIsTrue()) {
    chunks.append(breaks);
  }
  return new ScalarToken(chunks.toString(),false,startMark,endMark,style);
}
