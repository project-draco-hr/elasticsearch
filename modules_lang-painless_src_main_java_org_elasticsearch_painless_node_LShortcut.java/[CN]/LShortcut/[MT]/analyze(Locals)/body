{
  Struct struct=before.struct;
  getter=struct.methods.get(new Definition.MethodKey("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1),0));
  if (getter == null) {
    getter=struct.methods.get(new Definition.MethodKey("is" + Character.toUpperCase(value.charAt(0)) + value.substring(1),0));
  }
  setter=struct.methods.get(new Definition.MethodKey("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1),1));
  if (getter != null && (getter.rtn.sort == Sort.VOID || !getter.arguments.isEmpty())) {
    throw createError(new IllegalArgumentException("Illegal get shortcut on field [" + value + "] for type ["+ struct.name+ "]."));
  }
  if (setter != null && (setter.rtn.sort != Sort.VOID || setter.arguments.size() != 1)) {
    throw createError(new IllegalArgumentException("Illegal set shortcut on field [" + value + "] for type ["+ struct.name+ "]."));
  }
  if (getter != null && setter != null && setter.arguments.get(0) != getter.rtn) {
    throw createError(new IllegalArgumentException("Shortcut argument types must match."));
  }
  if ((getter != null || setter != null) && (!load || getter != null) && (!store || setter != null)) {
    after=setter != null ? setter.arguments.get(0) : getter.rtn;
  }
 else {
    throw createError(new IllegalArgumentException("Illegal shortcut on field [" + value + "] for type ["+ struct.name+ "]."));
  }
  return this;
}
