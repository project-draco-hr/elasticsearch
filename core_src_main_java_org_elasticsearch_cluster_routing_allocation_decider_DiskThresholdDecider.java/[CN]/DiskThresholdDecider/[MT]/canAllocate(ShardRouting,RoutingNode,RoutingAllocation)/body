{
  final Decision decision=earlyTerminate(allocation);
  if (decision != null) {
    return decision;
  }
  final double usedDiskThresholdLow=100.0 - DiskThresholdDecider.this.freeDiskThresholdLow;
  final double usedDiskThresholdHigh=100.0 - DiskThresholdDecider.this.freeDiskThresholdHigh;
  DiskUsage usage=getDiskUsage(node,allocation);
  double freeDiskPercentage=usage.getFreeDiskAsPercentage();
  double usedDiskPercentage=usage.getUsedDiskAsPercentage();
  long freeBytes=usage.getFreeBytes();
  if (logger.isTraceEnabled()) {
    logger.trace("Node [{}] has {}% used disk",node.nodeId(),usedDiskPercentage);
  }
  boolean primaryHasBeenAllocated=allocation.routingTable().index(shardRouting.index()).shard(shardRouting.id()).primaryAllocatedPostApi();
  if (freeBytes < freeBytesThresholdLow.bytes()) {
    if (!shardRouting.primary() || (shardRouting.primary() && primaryHasBeenAllocated)) {
      if (logger.isDebugEnabled()) {
        logger.debug("Less than the required {} free bytes threshold ({} bytes free) on node {}, preventing allocation",freeBytesThresholdLow,freeBytes,node.nodeId());
      }
      return allocation.decision(Decision.NO,NAME,"less than required [%s] free on node, free: [%s]",freeBytesThresholdLow,new ByteSizeValue(freeBytes));
    }
 else     if (freeBytes > freeBytesThresholdHigh.bytes()) {
      if (logger.isDebugEnabled()) {
        logger.debug("Less than the required {} free bytes threshold ({} bytes free) on node {}, " + "but allowing allocation because primary has never been allocated",freeBytesThresholdLow,freeBytes,node.nodeId());
      }
      return allocation.decision(Decision.YES,NAME,"primary has never been allocated before");
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug("Less than the required {} free bytes threshold ({} bytes free) on node {}, " + "preventing allocation even though primary has never been allocated",freeBytesThresholdHigh,freeBytes,node.nodeId());
      }
      return allocation.decision(Decision.NO,NAME,"less than required [%s] free on node, free: [%s]",freeBytesThresholdHigh,new ByteSizeValue(freeBytes));
    }
  }
  if (freeDiskPercentage < freeDiskThresholdLow) {
    if (!shardRouting.primary() || (shardRouting.primary() && primaryHasBeenAllocated)) {
      if (logger.isDebugEnabled()) {
        logger.debug("More than the allowed {} used disk threshold ({} used) on node [{}], preventing allocation",Strings.format1Decimals(usedDiskThresholdLow,"%"),Strings.format1Decimals(usedDiskPercentage,"%"),node.nodeId());
      }
      return allocation.decision(Decision.NO,NAME,"more than allowed [%s%%] used disk on node, free: [%s%%]",usedDiskThresholdLow,freeDiskPercentage);
    }
 else     if (freeDiskPercentage > freeDiskThresholdHigh) {
      if (logger.isDebugEnabled()) {
        logger.debug("More than the allowed {} used disk threshold ({} used) on node [{}], " + "but allowing allocation because primary has never been allocated",Strings.format1Decimals(usedDiskThresholdLow,"%"),Strings.format1Decimals(usedDiskPercentage,"%"),node.nodeId());
      }
      return allocation.decision(Decision.YES,NAME,"primary has never been allocated before");
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug("Less than the required {} free bytes threshold ({} bytes free) on node {}, " + "preventing allocation even though primary has never been allocated",Strings.format1Decimals(freeDiskThresholdHigh,"%"),Strings.format1Decimals(freeDiskPercentage,"%"),node.nodeId());
      }
      return allocation.decision(Decision.NO,NAME,"more than allowed [%s%%] used disk on node, free: [%s%%]",usedDiskThresholdHigh,freeDiskPercentage);
    }
  }
  Map<String,Long> shardSizes=allocation.clusterInfo().getShardSizes();
  Long shardSize=shardSizes.get(shardIdentifierFromRouting(shardRouting));
  shardSize=shardSize == null ? 0 : shardSize;
  double freeSpaceAfterShard=freeDiskPercentageAfterShardAssigned(usage,shardSize);
  long freeBytesAfterShard=freeBytes - shardSize;
  if (freeBytesAfterShard < freeBytesThresholdHigh.bytes()) {
    logger.warn("After allocating, node [{}] would have less than the required {} free bytes threshold ({} bytes free), preventing allocation",node.nodeId(),freeBytesThresholdHigh,freeBytesAfterShard);
    return allocation.decision(Decision.NO,NAME,"after allocation less than required [%s] free on node, free: [%s]",freeBytesThresholdLow,new ByteSizeValue(freeBytesAfterShard));
  }
  if (freeSpaceAfterShard < freeDiskThresholdHigh) {
    logger.warn("After allocating, node [{}] would have more than the allowed {} free disk threshold ({} free), preventing allocation",node.nodeId(),Strings.format1Decimals(freeDiskThresholdHigh,"%"),Strings.format1Decimals(freeSpaceAfterShard,"%"));
    return allocation.decision(Decision.NO,NAME,"after allocation more than allowed [%s%%] used disk on node, free: [%s%%]",usedDiskThresholdLow,freeSpaceAfterShard);
  }
  return allocation.decision(Decision.YES,NAME,"enough disk for shard on node, free: [%s]",new ByteSizeValue(freeBytes));
}
