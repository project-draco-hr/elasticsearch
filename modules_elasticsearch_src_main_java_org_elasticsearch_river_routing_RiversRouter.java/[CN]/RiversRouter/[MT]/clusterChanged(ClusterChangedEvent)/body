{
  if (!event.localNodeMaster()) {
    return;
  }
  if (event.nodesChanged() || event.metaDataChanged() || event.blocksChanged()) {
    riverClusterService.submitStateUpdateTask("reroute_rivers_node_changed",new RiverClusterStateUpdateTask(){
      @Override public RiverClusterState execute(      RiverClusterState currentState){
        if (!event.state().metaData().hasIndex(riverIndexName)) {
          if (!currentState.routing().isEmpty()) {
            return RiverClusterState.builder().state(currentState).routing(RiversRouting.builder()).build();
          }
          return currentState;
        }
        RiversRouting.Builder routingBuilder=RiversRouting.builder().routing(currentState.routing());
        boolean dirty=false;
        IndexMetaData indexMetaData=event.state().metaData().index(riverIndexName);
        for (        MappingMetaData mappingMd : indexMetaData.mappings().values()) {
          String mappingType=mappingMd.type();
          if (!currentState.routing().hasRiverByName(mappingType)) {
            try {
              client.admin().indices().prepareRefresh(riverIndexName).execute().actionGet();
              GetResponse getResponse=client.prepareGet(riverIndexName,mappingType,"_meta").execute().actionGet();
              if (getResponse.exists()) {
                String riverType=XContentMapValues.nodeStringValue(getResponse.sourceAsMap().get("type"),null);
                if (riverType == null) {
                  logger.warn("no river type provided for [{}], ignoring...",riverIndexName);
                }
 else {
                  routingBuilder.put(new RiverRouting(new RiverName(riverType,mappingType),null));
                  dirty=true;
                }
              }
            }
 catch (            ClusterBlockException e) {
            }
catch (            IndexMissingException e) {
            }
catch (            Exception e) {
              logger.warn("failed to get/parse _meta for [{}]",e,mappingType);
            }
          }
        }
        for (        RiverRouting routing : currentState.routing()) {
          if (!indexMetaData.mappings().containsKey(routing.riverName().name())) {
            routingBuilder.remove(routing);
            dirty=true;
          }
        }
        Map<DiscoveryNode,List<RiverRouting>> nodesToRivers=Maps.newHashMap();
        for (        DiscoveryNode node : event.state().nodes()) {
          if (RiverNodeHelper.isRiverNode(node)) {
            nodesToRivers.put(node,Lists.<RiverRouting>newArrayList());
          }
        }
        List<RiverRouting> unassigned=Lists.newArrayList();
        for (        RiverRouting routing : routingBuilder.build()) {
          if (routing.node() == null) {
            unassigned.add(routing);
          }
 else {
            List<RiverRouting> l=nodesToRivers.get(routing.node());
            if (l == null) {
              l=Lists.newArrayList();
              nodesToRivers.put(routing.node(),l);
            }
            l.add(routing);
          }
        }
        for (Iterator<RiverRouting> it=unassigned.iterator(); it.hasNext(); ) {
          RiverRouting routing=it.next();
          DiscoveryNode smallest=null;
          int smallestSize=Integer.MAX_VALUE;
          for (          Map.Entry<DiscoveryNode,List<RiverRouting>> entry : nodesToRivers.entrySet()) {
            if (RiverNodeHelper.isRiverNode(entry.getKey(),routing.riverName())) {
              if (entry.getValue().size() < smallestSize) {
                smallestSize=entry.getValue().size();
                smallest=entry.getKey();
              }
            }
          }
          if (smallest != null) {
            dirty=true;
            it.remove();
            routing.node(smallest);
            nodesToRivers.get(smallest).add(routing);
          }
        }
        if (dirty) {
          return RiverClusterState.builder().state(currentState).routing(routingBuilder).build();
        }
        return currentState;
      }
    }
);
  }
}
