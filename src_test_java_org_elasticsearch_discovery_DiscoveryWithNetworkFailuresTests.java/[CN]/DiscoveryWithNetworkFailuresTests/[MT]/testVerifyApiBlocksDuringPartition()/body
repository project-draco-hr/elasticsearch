{
  internalCluster().startNodesAsync(3,nodeSettings).get();
  ensureStableCluster(3);
  assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,2)));
  ensureGreen("test");
  NetworkPartition networkPartition=addRandomPartition();
  final String isolatedNode=networkPartition.getMinoritySide().get(0);
  final String nonIsolatedNode=networkPartition.getMajoritySide().get(0);
  networkPartition.startDisrupting();
  logger.info("waiting for isolated node [{}] to have no master",isolatedNode);
  final ClusterState[] lastState=new ClusterState[1];
  boolean success=awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object input){
      lastState[0]=getNodeClusterState(isolatedNode);
      DiscoveryNodes localDiscoveryNodes=lastState[0].nodes();
      logger.info("localDiscoveryNodes=" + localDiscoveryNodes.prettyPrint());
      if (localDiscoveryNodes.masterNode() == null) {
        return false;
      }
      for (      ClusterBlockLevel level : DiscoverySettings.NO_MASTER_BLOCK_WRITES.levels()) {
        if (lastState[0].getBlocks().hasGlobalBlock(level)) {
          return false;
        }
      }
      return true;
    }
  }
,10,TimeUnit.SECONDS);
  if (!success) {
    fail("isolated node still has a master or the wrong blocks. Cluster state:\n" + lastState[0].prettyPrint());
  }
  logger.info("wait until elected master has been removed and a new 2 node cluster was from (via [{}])",isolatedNode);
  ensureStableCluster(2,nonIsolatedNode);
  for (  String node : networkPartition.getMajoritySide()) {
    ClusterState nodeState=getNodeClusterState(node);
    success=true;
    if (nodeState.nodes().getMasterNode() == null) {
      success=false;
    }
    if (!nodeState.blocks().global().isEmpty()) {
      success=false;
    }
    if (!success) {
      fail("node [" + node + "] has no master or has blocks, despite of being on the right side of the partition. State dump:\n"+ nodeState.prettyPrint());
    }
  }
  networkPartition.stopDisrupting();
  ensureStableCluster(3,new TimeValue(30000 + networkPartition.expectedTimeToHeal().millis()));
  logger.info("Verify no master block with {} set to {}",DiscoverySettings.NO_MASTER_BLOCK,"all");
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(ImmutableSettings.builder().put(DiscoverySettings.NO_MASTER_BLOCK,"all")).get();
  networkPartition.startDisrupting();
  logger.info("waiting for isolated node [{}] to have no master",isolatedNode);
  success=awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object input){
      lastState[0]=getNodeClusterState(isolatedNode);
      DiscoveryNodes localDiscoveryNodes=lastState[0].nodes();
      logger.info("localDiscoveryNodes=" + localDiscoveryNodes.prettyPrint());
      if (localDiscoveryNodes.masterNode() == null) {
        return false;
      }
      for (      ClusterBlockLevel level : DiscoverySettings.NO_MASTER_BLOCK_ALL.levels()) {
        if (lastState[0].getBlocks().hasGlobalBlock(level)) {
          return false;
        }
      }
      return true;
    }
  }
,10,TimeUnit.SECONDS);
  if (!success) {
    fail("isolated node still has a master or the wrong blocks (expected 'all' block). Cluster state:\n" + lastState[0].prettyPrint());
  }
}
