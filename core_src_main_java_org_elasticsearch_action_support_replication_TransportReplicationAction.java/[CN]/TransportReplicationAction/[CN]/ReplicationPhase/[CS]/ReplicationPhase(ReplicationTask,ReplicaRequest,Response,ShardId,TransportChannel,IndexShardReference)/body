{
  this.task=task;
  this.replicaRequest=replicaRequest;
  this.channel=channel;
  this.finalResponse=finalResponse;
  this.indexShardReference=indexShardReference;
  this.shardId=shardId;
  final ClusterState state=clusterService.state();
  final IndexShardRoutingTable shardRoutingTable=state.getRoutingTable().shardRoutingTableOrNull(shardId);
  final IndexMetaData indexMetaData=state.getMetaData().index(shardId.getIndex());
  List<ShardRouting> shards=shards(shardRoutingTable);
  boolean executeOnReplica=(indexMetaData == null) || shouldExecuteReplication(indexMetaData.getSettings());
  DiscoveryNodes nodes=state.getNodes();
  if (shards.isEmpty()) {
    logger.debug("replication phase for request [{}] on [{}] is skipped due to index deletion after primary operation",replicaRequest,shardId);
  }
  AtomicInteger numberOfPendingShardInstances=new AtomicInteger();
  this.totalShards=countTotalAndPending(shards,executeOnReplica,nodes,numberOfPendingShardInstances);
  this.pending=numberOfPendingShardInstances;
  this.shards=shards;
  this.executeOnReplica=executeOnReplica;
  this.nodes=nodes;
  if (logger.isTraceEnabled()) {
    logger.trace("replication phase started. pending [{}], action [{}], request [{}], cluster state version used [{}]",pending.get(),transportReplicaAction,replicaRequest,state.version());
  }
}
