{
  this.task=task;
  this.replicaRequest=replicaRequest;
  this.channel=channel;
  this.finalResponse=finalResponse;
  this.indexShardReference=indexShardReference;
  this.shardId=shardId;
  final ClusterState state=clusterService.state();
  final IndexRoutingTable index=state.getRoutingTable().index(shardId.getIndex());
  final IndexShardRoutingTable shardRoutingTable=(index != null) ? index.shard(shardId.id()) : null;
  final IndexMetaData indexMetaData=state.getMetaData().index(shardId.getIndex());
  this.shards=(shardRoutingTable != null) ? shardRoutingTable.shards() : Collections.emptyList();
  this.executeOnReplica=(indexMetaData == null) || shouldExecuteReplication(indexMetaData.getSettings());
  this.nodes=state.getNodes();
  if (shards.isEmpty()) {
    logger.debug("replication phase for request [{}] on [{}] is skipped due to index deletion after primary operation",replicaRequest,shardId);
  }
  int numberOfIgnoredShardInstances=0;
  int numberOfPendingShardInstances=0;
  for (  ShardRouting shard : shards) {
    if (shard.primary() == false && executeOnReplica == false) {
      numberOfIgnoredShardInstances++;
      continue;
    }
    if (shard.unassigned()) {
      numberOfIgnoredShardInstances++;
      continue;
    }
    if (nodes.localNodeId().equals(shard.currentNodeId()) == false) {
      numberOfPendingShardInstances++;
    }
    if (shard.relocating() && nodes.localNodeId().equals(shard.relocatingNodeId()) == false) {
      numberOfPendingShardInstances++;
    }
  }
  this.totalShards=1 + numberOfPendingShardInstances + numberOfIgnoredShardInstances;
  this.pending=new AtomicInteger(numberOfPendingShardInstances);
  if (logger.isTraceEnabled()) {
    logger.trace("replication phase started. pending [{}], action [{}], request [{}], cluster state version used [{}]",pending.get(),transportReplicaAction,replicaRequest,state.version());
  }
}
