{
  if (finished.compareAndSet(false,true)) {
    Releasables.close(indexShardReference);
    final ActionWriteResponse.ShardInfo.Failure[] failuresArray;
    if (!shardReplicaFailures.isEmpty()) {
      int slot=0;
      failuresArray=new ActionWriteResponse.ShardInfo.Failure[shardReplicaFailures.size()];
      for (      Map.Entry<String,Throwable> entry : shardReplicaFailures.entrySet()) {
        RestStatus restStatus=ExceptionsHelper.status(entry.getValue());
        failuresArray[slot++]=new ActionWriteResponse.ShardInfo.Failure(shardId.getIndex(),shardId.getId(),entry.getKey(),entry.getValue(),restStatus,false);
      }
    }
 else {
      failuresArray=ActionWriteResponse.EMPTY;
    }
    finalResponse.setShardInfo(new ActionWriteResponse.ShardInfo(totalShards,success.get(),failuresArray));
    try {
      channel.sendResponse(finalResponse);
    }
 catch (    IOException responseException) {
      logger.warn("failed to send error message back to client for action [" + transportReplicaAction + "]",responseException);
    }
    if (logger.isTraceEnabled()) {
      logger.trace("action [{}] completed on all replicas [{}] for request [{}]",transportReplicaAction,shardId,replicaRequest);
    }
  }
}
