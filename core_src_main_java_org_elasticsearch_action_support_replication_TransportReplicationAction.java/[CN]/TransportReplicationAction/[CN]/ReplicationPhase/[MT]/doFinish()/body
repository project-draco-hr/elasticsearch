{
  if (finished.compareAndSet(false,true)) {
    setPhase(task,"finished");
    Releasables.close(indexShardReference);
    final ReplicationResponse.ShardInfo.Failure[] failuresArray;
    if (!shardReplicaFailures.isEmpty()) {
      int slot=0;
      failuresArray=new ReplicationResponse.ShardInfo.Failure[shardReplicaFailures.size()];
      for (      Map.Entry<String,Throwable> entry : shardReplicaFailures.entrySet()) {
        RestStatus restStatus=ExceptionsHelper.status(entry.getValue());
        failuresArray[slot++]=new ReplicationResponse.ShardInfo.Failure(shardId,entry.getKey(),entry.getValue(),restStatus,false);
      }
    }
 else {
      failuresArray=ReplicationResponse.EMPTY;
    }
    finalResponse.setShardInfo(new ReplicationResponse.ShardInfo(totalShards,success.get(),failuresArray));
    if (logger.isTraceEnabled()) {
      logger.trace("finished replicating action [{}], request [{}], shardInfo [{}]",actionName,replicaRequest,finalResponse.getShardInfo());
    }
    try {
      channel.sendResponse(finalResponse);
    }
 catch (    IOException responseException) {
      logger.warn("failed to send error message back to client for action [{}]",responseException,transportReplicaAction);
    }
    if (logger.isTraceEnabled()) {
      logger.trace("action [{}] completed on all replicas [{}] for request [{}]",transportReplicaAction,shardId,replicaRequest);
    }
  }
}
