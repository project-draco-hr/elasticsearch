{
  IndexService percolateIndexService=indicesService.indexServiceSafe(request.index());
  IndexShard indexShard=percolateIndexService.shardSafe(request.shardId());
  ShardPercolateService shardPercolateService=indexShard.shardPercolateService();
  shardPercolateService.prePercolate();
  long startTime=System.nanoTime();
  try {
    ConcurrentMap<Text,Query> percolateQueries=indexShard.percolateRegistry().percolateQueries();
    if (percolateQueries.isEmpty()) {
      return new PercolateShardResponse(StringText.EMPTY_ARRAY,request.index(),request.shardId());
    }
    Tuple<ParsedDocument,Query> parseResult=parsePercolate(percolateIndexService,request.documentType(),request.documentSource());
    ParsedDocument parsedDocument=parseResult.v1();
    Query query=parseResult.v2();
    final MemoryIndex memoryIndex=cache.get();
    try {
      for (      IndexableField field : parsedDocument.rootDoc().getFields()) {
        if (!field.fieldType().indexed()) {
          continue;
        }
        if (field.name().equals(UidFieldMapper.NAME)) {
          continue;
        }
        TokenStream tokenStream;
        try {
          tokenStream=field.tokenStream(parsedDocument.analyzer());
          if (tokenStream != null) {
            memoryIndex.addField(field.name(),tokenStream,field.boost());
          }
        }
 catch (        IOException e) {
          throw new ElasticSearchException("Failed to create token stream",e);
        }
      }
      final IndexSearcher searcher=memoryIndex.createSearcher();
      List<Text> matches=new ArrayList<Text>();
      IndexFieldDataService fieldDataService=percolateIndexService.fieldData();
      IndexCache indexCache=percolateIndexService.cache();
      try {
        if (query == null) {
          Lucene.ExistsCollector collector=new Lucene.ExistsCollector();
          for (          Map.Entry<Text,Query> entry : percolateQueries.entrySet()) {
            collector.reset();
            try {
              searcher.search(entry.getValue(),collector);
            }
 catch (            IOException e) {
              logger.warn("[" + entry.getKey() + "] failed to execute query",e);
            }
            if (collector.exists()) {
              matches.add(entry.getKey());
            }
          }
        }
 else {
          Engine.Searcher percolatorSearcher=indexShard.searcher();
          try {
            percolatorSearcher.searcher().search(query,new QueryCollector(logger,percolateQueries,searcher,fieldDataService,matches));
          }
 catch (          IOException e) {
            logger.warn("failed to execute",e);
          }
 finally {
            percolatorSearcher.release();
          }
        }
      }
  finally {
        indexCache.clear(searcher.getIndexReader());
        fieldDataService.clear(searcher.getIndexReader());
      }
      return new PercolateShardResponse(matches.toArray(new Text[matches.size()]),request.index(),request.shardId());
    }
  finally {
      memoryIndex.reset();
    }
  }
  finally {
    shardPercolateService.postPercolate(System.nanoTime() - startTime);
  }
}
