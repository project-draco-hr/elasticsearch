{
  MetaDataService.MdLock mdLock=metaDataService.indexMetaDataLock(request.index);
  try {
    mdLock.lock();
  }
 catch (  InterruptedException e) {
    userListener.onFailure(e);
    return;
  }
  final DeleteIndexListener listener=new DeleteIndexListener(mdLock,request,userListener);
  clusterService.submitStateUpdateTask("delete-index [" + request.index + "]",Priority.URGENT,new TimeoutClusterStateUpdateTask(){
    @Override public TimeValue timeout(){
      return request.masterTimeout;
    }
    @Override public void onTimeout(    TimeValue timeout,    String source){
      listener.onFailure(new ProcessClusterEventTimeoutException(timeout,source));
    }
    @Override public ClusterState execute(    ClusterState currentState){
      try {
        if (!currentState.metaData().hasConcreteIndex(request.index)) {
          listener.onFailure(new IndexMissingException(new Index(request.index)));
          return currentState;
        }
        logger.info("[{}] deleting index",request.index);
        RoutingTable.Builder routingTableBuilder=RoutingTable.builder().routingTable(currentState.routingTable());
        routingTableBuilder.remove(request.index);
        MetaData newMetaData=newMetaDataBuilder().metaData(currentState.metaData()).remove(request.index).build();
        RoutingAllocation.Result routingResult=allocationService.reroute(newClusterStateBuilder().state(currentState).routingTable(routingTableBuilder).metaData(newMetaData).build());
        ClusterBlocks blocks=ClusterBlocks.builder().blocks(currentState.blocks()).removeIndexBlocks(request.index).build();
        final AtomicInteger counter=new AtomicInteger(currentState.nodes().size());
        final NodeIndexDeletedAction.Listener nodeIndexDeleteListener=new NodeIndexDeletedAction.Listener(){
          @Override public void onNodeIndexDeleted(          String index,          String nodeId){
            if (index.equals(request.index)) {
              if (counter.decrementAndGet() == 0) {
                listener.onResponse(new Response(true));
                nodeIndexDeletedAction.remove(this);
              }
            }
          }
        }
;
        nodeIndexDeletedAction.add(nodeIndexDeleteListener);
        listener.future=threadPool.schedule(request.timeout,ThreadPool.Names.SAME,new Runnable(){
          @Override public void run(){
            listener.onResponse(new Response(false));
            nodeIndexDeletedAction.remove(nodeIndexDeleteListener);
          }
        }
);
        return newClusterStateBuilder().state(currentState).routingResult(routingResult).metaData(newMetaData).blocks(blocks).build();
      }
 catch (      Throwable e) {
        listener.onFailure(e);
        return currentState;
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
    }
  }
);
}
