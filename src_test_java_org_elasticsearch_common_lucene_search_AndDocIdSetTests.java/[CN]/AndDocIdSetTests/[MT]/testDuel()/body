{
  for (int iter=0; iter < 1000; ++iter) {
    final int numSets=1 + random().nextInt(5);
    final int numDocs=1 + random().nextInt(1000);
    FixedBitSet anded=new FixedBitSet(numDocs);
    anded.set(0,numDocs);
    final DocIdSet[] sets=new DocIdSet[numSets];
    for (int i=0; i < numSets; ++i) {
      final FixedBitSet randomSet=randomBitSet(numDocs);
      anded.and(randomSet);
      if (random().nextBoolean()) {
        sets[i]=new BitDocIdSet(randomSet);
      }
 else {
        sets[i]=new DocValuesDocIdSet(numDocs,null){
          @Override protected boolean matchDoc(          int doc){
            return randomSet.get(doc);
          }
        }
;
      }
    }
    AndDocIdSet andSet=new AndDocIdSet(sets);
    Bits andBits=andSet.bits();
    if (andBits != null) {
      for (int i=0; i < numDocs; ++i) {
        assertEquals(anded.get(i),andBits.get(i));
      }
    }
    DocIdSetIterator andIt=andSet.iterator();
    if (andIt == null) {
      assertEquals(0,anded.cardinality());
    }
 else {
      int previous=-1;
      for (int doc=andIt.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc=andIt.nextDoc()) {
        for (int j=previous + 1; j < doc; ++j) {
          assertFalse(anded.get(j));
        }
        assertTrue(anded.get(doc));
        previous=doc;
      }
      for (int j=previous + 1; j < numDocs; ++j) {
        assertFalse(anded.get(j));
      }
    }
  }
}
