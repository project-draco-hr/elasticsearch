{
  final int NUM_THREADS=5;
  final int BYTES_PER_THREAD=1000;
  final Thread[] threads=new Thread[NUM_THREADS];
  final AtomicBoolean tripped=new AtomicBoolean(false);
  final AtomicReference<Throwable> lastException=new AtomicReference<>(null);
  final AtomicReference<ChildMemoryCircuitBreaker> breakerRef=new AtomicReference<>(null);
  final CircuitBreakerService service=new HierarchyCircuitBreakerService(ImmutableSettings.EMPTY,new NodeSettingsService(ImmutableSettings.EMPTY)){
    @Override public CircuitBreaker getBreaker(    CircuitBreaker.Name type){
      return breakerRef.get();
    }
    @Override public void checkParentLimit(    String label) throws CircuitBreakingException {
    }
  }
;
  final BreakerSettings settings=new BreakerSettings(CircuitBreaker.Name.REQUEST,(BYTES_PER_THREAD * NUM_THREADS) - 1,1.0);
  final ChildMemoryCircuitBreaker breaker=new ChildMemoryCircuitBreaker(settings,logger,(HierarchyCircuitBreakerService)service,CircuitBreaker.Name.REQUEST);
  breakerRef.set(breaker);
  for (int i=0; i < NUM_THREADS; i++) {
    threads[i]=new Thread(new Runnable(){
      @Override public void run(){
        for (int j=0; j < BYTES_PER_THREAD; j++) {
          try {
            breaker.addEstimateBytesAndMaybeBreak(1L,"test");
          }
 catch (          CircuitBreakingException e) {
            if (tripped.get()) {
              assertThat("tripped too many times",true,equalTo(false));
            }
 else {
              assertThat(tripped.compareAndSet(false,true),equalTo(true));
            }
          }
catch (          Throwable e2) {
            lastException.set(e2);
          }
        }
      }
    }
);
    threads[i].start();
  }
  for (  Thread t : threads) {
    t.join();
  }
  assertThat("no other exceptions were thrown",lastException.get(),equalTo(null));
  assertThat("breaker was tripped exactly once",tripped.get(),equalTo(true));
  assertThat("breaker was tripped exactly once",breaker.getTrippedCount(),equalTo(1L));
}
