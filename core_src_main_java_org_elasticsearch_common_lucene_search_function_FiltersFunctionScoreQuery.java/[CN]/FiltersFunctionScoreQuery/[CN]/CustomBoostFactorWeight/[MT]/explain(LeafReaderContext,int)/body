{
  Explanation subQueryExpl=subQueryWeight.explain(context,doc);
  if (!subQueryExpl.isMatch()) {
    return subQueryExpl;
  }
  List<Explanation> filterExplanations=new ArrayList<>();
  for (int i=0; i < filterFunctions.length; ++i) {
    Bits docSet=Lucene.asSequentialAccessBits(context.reader().maxDoc(),filterWeights[i].scorer(context));
    if (docSet.get(doc)) {
      FilterFunction filterFunction=filterFunctions[i];
      Explanation functionExplanation=filterFunction.function.getLeafScoreFunction(context).explainScore(doc,subQueryExpl);
      double factor=functionExplanation.getValue();
      float sc=CombineFunction.toFloat(factor);
      Explanation filterExplanation=Explanation.match(sc,"function score, product of:",Explanation.match(1.0f,"match filter: " + filterFunction.filter.toString()),functionExplanation);
      filterExplanations.add(filterExplanation);
    }
  }
  if (filterExplanations.size() == 0) {
    return subQueryExpl;
  }
  FiltersFunctionFactorScorer scorer=(FiltersFunctionFactorScorer)scorer(context);
  int actualDoc=scorer.advance(doc);
  assert(actualDoc == doc);
  double score=scorer.computeScore(doc,subQueryExpl.getValue());
  Explanation factorExplanation=Explanation.match(CombineFunction.toFloat(score),"function score, score mode [" + scoreMode.toString().toLowerCase(Locale.ROOT) + "]",filterExplanations);
  return combineFunction.explain(subQueryExpl,factorExplanation,maxBoost);
}
