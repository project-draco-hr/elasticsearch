{
  super(settings);
  this.environment=environment;
  this.checkLucene=settings.getAsBoolean(PLUGINS_CHECK_LUCENE_KEY,true);
  this.esPluginPropertiesFile=settings.get(ES_PLUGIN_PROPERTIES_FILE_KEY,ES_PLUGIN_PROPERTIES);
  this.loadClasspathPlugins=settings.getAsBoolean(LOAD_PLUGIN_FROM_CLASSPATH,true);
  ImmutableList.Builder<Tuple<PluginInfo,Plugin>> tupleBuilder=ImmutableList.builder();
  String[] defaultPluginsClasses=settings.getAsArray("plugin.types");
  for (  String pluginClass : defaultPluginsClasses) {
    Plugin plugin=loadPlugin(pluginClass,settings);
    PluginInfo pluginInfo=new PluginInfo(plugin.name(),plugin.description(),hasSite(plugin.name()),true,PluginInfo.VERSION_NOT_AVAILABLE);
    if (logger.isTraceEnabled()) {
      logger.trace("plugin loaded from settings [{}]",pluginInfo);
    }
    tupleBuilder.add(new Tuple<>(pluginInfo,plugin));
  }
  try {
    loadPluginsIntoClassLoader();
  }
 catch (  IOException ex) {
    throw new ElasticsearchIllegalStateException("Can't load plugins into classloader",ex);
  }
  if (loadClasspathPlugins) {
    tupleBuilder.addAll(loadPluginsFromClasspath(settings));
  }
  this.plugins=tupleBuilder.build();
  Map<String,Plugin> jvmPlugins=Maps.newHashMap();
  List<String> sitePlugins=Lists.newArrayList();
  for (  Tuple<PluginInfo,Plugin> tuple : this.plugins) {
    jvmPlugins.put(tuple.v2().name(),tuple.v2());
    if (tuple.v1().isSite()) {
      sitePlugins.add(tuple.v1().getName());
    }
  }
  try {
    ImmutableList<Tuple<PluginInfo,Plugin>> tuples=loadSitePlugins();
    for (    Tuple<PluginInfo,Plugin> tuple : tuples) {
      sitePlugins.add(tuple.v1().getName());
    }
  }
 catch (  IOException ex) {
    throw new ElasticsearchIllegalStateException("Can't load site  plugins",ex);
  }
  String[] mandatoryPlugins=settings.getAsArray("plugin.mandatory",null);
  if (mandatoryPlugins != null) {
    Set<String> missingPlugins=Sets.newHashSet();
    for (    String mandatoryPlugin : mandatoryPlugins) {
      if (!jvmPlugins.containsKey(mandatoryPlugin) && !sitePlugins.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {
        missingPlugins.add(mandatoryPlugin);
      }
    }
    if (!missingPlugins.isEmpty()) {
      throw new ElasticsearchException("Missing mandatory plugins [" + Strings.collectionToDelimitedString(missingPlugins,", ") + "]");
    }
  }
  logger.info("loaded {}, sites {}",jvmPlugins.keySet(),sitePlugins);
  MapBuilder<Plugin,List<OnModuleReference>> onModuleReferences=MapBuilder.newMapBuilder();
  for (  Plugin plugin : jvmPlugins.values()) {
    List<OnModuleReference> list=Lists.newArrayList();
    for (    Method method : plugin.getClass().getDeclaredMethods()) {
      if (!method.getName().equals("onModule")) {
        continue;
      }
      if (method.getParameterTypes().length == 0 || method.getParameterTypes().length > 1) {
        logger.warn("Plugin: {} implementing onModule with no parameters or more than one parameter",plugin.name());
        continue;
      }
      Class moduleClass=method.getParameterTypes()[0];
      if (!Module.class.isAssignableFrom(moduleClass)) {
        logger.warn("Plugin: {} implementing onModule by the type is not of Module type {}",plugin.name(),moduleClass);
        continue;
      }
      method.setAccessible(true);
      list.add(new OnModuleReference(moduleClass,method));
    }
    if (!list.isEmpty()) {
      onModuleReferences.put(plugin,list);
    }
  }
  this.onModuleReferences=onModuleReferences.immutableMap();
  this.refreshInterval=settings.getAsTime(PLUGINS_INFO_REFRESH_INTERVAL_KEY,TimeValue.timeValueSeconds(10));
}
