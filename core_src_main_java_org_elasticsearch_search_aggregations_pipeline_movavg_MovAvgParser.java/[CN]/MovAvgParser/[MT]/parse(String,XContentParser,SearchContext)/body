{
  XContentParser.Token token;
  String currentFieldName=null;
  String[] bucketsPaths=null;
  String format=null;
  GapPolicy gapPolicy=GapPolicy.SKIP;
  int window=5;
  Map<String,Object> settings=null;
  String model="simple";
  int predict=0;
  Boolean minimize=null;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentFieldName=parser.currentName();
    }
 else     if (token == XContentParser.Token.VALUE_NUMBER) {
      if (context.parseFieldMatcher().match(currentFieldName,WINDOW)) {
        window=parser.intValue();
        if (window <= 0) {
          throw new SearchParseException(context,"[" + currentFieldName + "] value must be a positive, "+ "non-zero integer.  Value supplied was ["+ predict+ "] in ["+ pipelineAggregatorName+ "].",parser.getTokenLocation());
        }
      }
 else       if (context.parseFieldMatcher().match(currentFieldName,PREDICT)) {
        predict=parser.intValue();
        if (predict <= 0) {
          throw new SearchParseException(context,"[" + currentFieldName + "] value must be a positive, "+ "non-zero integer.  Value supplied was ["+ predict+ "] in ["+ pipelineAggregatorName+ "].",parser.getTokenLocation());
        }
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ pipelineAggregatorName+ "]: ["+ currentFieldName+ "].",parser.getTokenLocation());
      }
    }
 else     if (token == XContentParser.Token.VALUE_STRING) {
      if (context.parseFieldMatcher().match(currentFieldName,FORMAT)) {
        format=parser.text();
      }
 else       if (context.parseFieldMatcher().match(currentFieldName,BUCKETS_PATH)) {
        bucketsPaths=new String[]{parser.text()};
      }
 else       if (context.parseFieldMatcher().match(currentFieldName,GAP_POLICY)) {
        gapPolicy=GapPolicy.parse(context,parser.text(),parser.getTokenLocation());
      }
 else       if (context.parseFieldMatcher().match(currentFieldName,MODEL)) {
        model=parser.text();
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ pipelineAggregatorName+ "]: ["+ currentFieldName+ "].",parser.getTokenLocation());
      }
    }
 else     if (token == XContentParser.Token.START_ARRAY) {
      if (context.parseFieldMatcher().match(currentFieldName,BUCKETS_PATH)) {
        List<String> paths=new ArrayList<>();
        while ((token=parser.nextToken()) != XContentParser.Token.END_ARRAY) {
          String path=parser.text();
          paths.add(path);
        }
        bucketsPaths=paths.toArray(new String[paths.size()]);
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ pipelineAggregatorName+ "]: ["+ currentFieldName+ "].",parser.getTokenLocation());
      }
    }
 else     if (token == XContentParser.Token.START_OBJECT) {
      if (context.parseFieldMatcher().match(currentFieldName,SETTINGS)) {
        settings=parser.map();
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ pipelineAggregatorName+ "]: ["+ currentFieldName+ "].",parser.getTokenLocation());
      }
    }
 else     if (token == XContentParser.Token.VALUE_BOOLEAN) {
      if (context.parseFieldMatcher().match(currentFieldName,MINIMIZE)) {
        minimize=parser.booleanValue();
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ pipelineAggregatorName+ "]: ["+ currentFieldName+ "].",parser.getTokenLocation());
      }
    }
 else {
      throw new SearchParseException(context,"Unexpected token " + token + " in ["+ pipelineAggregatorName+ "].",parser.getTokenLocation());
    }
  }
  if (bucketsPaths == null) {
    throw new SearchParseException(context,"Missing required field [" + BUCKETS_PATH.getPreferredName() + "] for movingAvg aggregation ["+ pipelineAggregatorName+ "]",parser.getTokenLocation());
  }
  ValueFormatter formatter=null;
  if (format != null) {
    formatter=ValueFormat.Patternable.Number.format(format).formatter();
  }
 else {
    formatter=ValueFormatter.RAW;
  }
  MovAvgModel.AbstractModelParser modelParser=movAvgModelParserMapper.get(model);
  if (modelParser == null) {
    throw new SearchParseException(context,"Unknown model [" + model + "] specified.  Valid options are:"+ movAvgModelParserMapper.getAllNames().toString(),parser.getTokenLocation());
  }
  MovAvgModel movAvgModel;
  try {
    movAvgModel=modelParser.parse(settings,pipelineAggregatorName,window,context.parseFieldMatcher());
  }
 catch (  ParseException exception) {
    throw new SearchParseException(context,"Could not parse settings for model [" + model + "].",null,exception);
  }
  if (minimize == null) {
    minimize=movAvgModel.minimizeByDefault();
  }
 else   if (minimize && !movAvgModel.canBeMinimized()) {
    throw new SearchParseException(context,"The [" + model + "] model cannot be minimized.",null);
  }
  return new MovAvgPipelineAggregator.Factory(pipelineAggregatorName,bucketsPaths,formatter,gapPolicy,window,predict,movAvgModel,minimize);
}
