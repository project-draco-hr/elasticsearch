{
  Settings tmpSettings=settingsBuilder().put(tmpEnv.settings()).put(Client.CLIENT_TYPE_SETTING,CLIENT_TYPE).build();
  tmpSettings=TribeService.processSettings(tmpSettings);
  ESLogger logger=Loggers.getLogger(Node.class,tmpSettings.get("name"));
  logger.info("version[{}], pid[{}], build[{}/{}]",version,JvmInfo.jvmInfo().pid(),Build.CURRENT.shortHash(),Build.CURRENT.date());
  logger.info("initializing ...");
  if (logger.isDebugEnabled()) {
    logger.debug("using config [{}], data [{}], logs [{}], plugins [{}]",tmpEnv.configFile(),Arrays.toString(tmpEnv.dataFiles()),tmpEnv.logsFile(),tmpEnv.pluginsFile());
  }
  this.pluginsService=new PluginsService(tmpSettings,tmpEnv.modulesFile(),tmpEnv.pluginsFile(),classpathPlugins);
  this.settings=pluginsService.updatedSettings();
  this.environment=new Environment(this.settings());
  final NodeEnvironment nodeEnvironment;
  try {
    nodeEnvironment=new NodeEnvironment(this.settings,this.environment);
  }
 catch (  IOException ex) {
    throw new IllegalStateException("Failed to created node environment",ex);
  }
  final NetworkService networkService=new NetworkService(settings);
  final SettingsFilter settingsFilter=new SettingsFilter(settings);
  final ThreadPool threadPool=new ThreadPool(settings);
  NamedWriteableRegistry namedWriteableRegistry=new NamedWriteableRegistry();
  boolean success=false;
  try {
    final MonitorService monitorService=new MonitorService(settings,nodeEnvironment,threadPool);
    ModulesBuilder modules=new ModulesBuilder();
    modules.add(new Version.Module(version));
    modules.add(new CircuitBreakerModule(settings));
    for (    Module pluginModule : pluginsService.nodeModules()) {
      modules.add(pluginModule);
    }
    modules.add(new PluginsModule(pluginsService));
    modules.add(new SettingsModule(this.settings,settingsFilter));
    modules.add(new EnvironmentModule(environment));
    modules.add(new NodeModule(this,monitorService));
    modules.add(new NetworkModule(networkService,settings,false,namedWriteableRegistry));
    modules.add(new ScriptModule(this.settings));
    modules.add(new NodeEnvironmentModule(nodeEnvironment));
    modules.add(new ClusterNameModule(this.settings));
    modules.add(new ThreadPoolModule(threadPool));
    modules.add(new DiscoveryModule(this.settings));
    modules.add(new ClusterModule(this.settings));
    modules.add(new IndicesModule());
    modules.add(new SearchModule(settings,namedWriteableRegistry));
    modules.add(new ActionModule(DiscoveryNode.ingestNode(settings),false));
    modules.add(new GatewayModule(settings));
    modules.add(new NodeClientModule());
    modules.add(new PercolatorModule());
    modules.add(new ResourceWatcherModule());
    modules.add(new RepositoriesModule());
    modules.add(new TribeModule());
    modules.add(new AnalysisModule(environment));
    pluginsService.processModules(modules);
    injector=modules.createInjector();
    client=injector.getInstance(Client.class);
    threadPool.setClusterSettings(injector.getInstance(ClusterSettings.class));
    success=true;
  }
 catch (  IOException ex) {
    throw new ElasticsearchException("failed to bind service",ex);
  }
 finally {
    if (!success) {
      nodeEnvironment.close();
      ThreadPool.terminate(threadPool,10,TimeUnit.SECONDS);
    }
  }
  logger.info("initialized");
}
