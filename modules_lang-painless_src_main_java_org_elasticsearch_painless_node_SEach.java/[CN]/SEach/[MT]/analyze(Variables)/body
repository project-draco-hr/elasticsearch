{
  expression.analyze(variables);
  expression.expected=expression.actual;
  expression=expression.cast(variables);
  Sort sort=expression.actual.sort;
  if (sort == Sort.ARRAY) {
    return new SArrayEach(location,maxLoopCounter,type,name,expression,(SBlock)block).copy(this).analyze(variables);
  }
 else   if (sort == Sort.DEF) {
    return new SDefEach(location,maxLoopCounter,type,name,expression,(SBlock)block).copy(this).analyze(variables);
  }
 else   if (Iterable.class.isAssignableFrom(expression.actual.clazz)) {
    final Type type;
    try {
      type=Definition.getType(this.type);
    }
 catch (    IllegalArgumentException exception) {
      throw createError(new IllegalArgumentException("Not a type [" + this.type + "]."));
    }
    variables.incrementScope();
    Type itr=Definition.getType("Iterator");
    variable=variables.addVariable(location,type,name,true,false);
    iterator=variables.addVariable(location,itr,"#itr" + location.getOffset(),true,false);
    method=expression.actual.struct.methods.get(new MethodKey("iterator",0));
    if (method == null) {
      throw location.createError(new IllegalArgumentException("Unable to create iterator for the type [" + expression.actual.name + "]."));
    }
    hasNext=itr.struct.methods.get(new MethodKey("hasNext",0));
    if (hasNext == null) {
      throw location.createError(new IllegalArgumentException("Method [hasNext] does not exist for type [Iterator]."));
    }
 else     if (hasNext.rtn.sort != Sort.BOOL) {
      throw location.createError(new IllegalArgumentException("Method [hasNext] does not return type [boolean]."));
    }
    next=itr.struct.methods.get(new MethodKey("next",0));
    if (next == null) {
      throw location.createError(new IllegalArgumentException("Method [next] does not exist for type [Iterator]."));
    }
 else     if (next.rtn.sort != Sort.DEF) {
      throw location.createError(new IllegalArgumentException("Method [next] does not return type [def]."));
    }
    cast=AnalyzerCaster.getLegalCast(location,Definition.DEF_TYPE,type,true,true);
    if (block == null) {
      throw location.createError(new IllegalArgumentException("Extraneous for each loop."));
    }
    block.beginLoop=true;
    block.inLoop=true;
    block=block.analyze(variables);
    block.statementCount=Math.max(1,block.statementCount);
    if (block.loopEscape && !block.anyContinue) {
      throw createError(new IllegalArgumentException("Extraneous for loop."));
    }
    statementCount=1;
    if (maxLoopCounter > 0) {
      loopCounterSlot=variables.getVariable(location,"#loop").slot;
    }
    variables.decrementScope();
    return this;
  }
 else {
    throw location.createError(new IllegalArgumentException("Illegal for each type [" + expression.actual.name + "]."));
  }
}
