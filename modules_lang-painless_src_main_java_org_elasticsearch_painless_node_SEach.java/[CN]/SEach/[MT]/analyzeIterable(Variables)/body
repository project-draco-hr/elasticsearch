{
  final Type type;
  try {
    type=Definition.getType(this.type);
  }
 catch (  IllegalArgumentException exception) {
    throw createError(new IllegalArgumentException("Not a type [" + this.type + "]."));
  }
  variables.incrementScope();
  Type itr=Definition.getType("Iterator");
  variable=variables.addVariable(location,type,name,true,false);
  iterator=variables.addVariable(location,itr,"#itr" + location.getOffset(),true,false);
  if (expression.actual.sort == Sort.DEF) {
    method=null;
  }
 else {
    method=expression.actual.struct.methods.get(new MethodKey("iterator",0));
    if (method == null) {
      throw location.createError(new IllegalArgumentException("Unable to create iterator for the type [" + expression.actual.name + "]."));
    }
  }
  hasNext=itr.struct.methods.get(new MethodKey("hasNext",0));
  if (hasNext == null) {
    throw location.createError(new IllegalArgumentException("Method [hasNext] does not exist for type [Iterator]."));
  }
 else   if (hasNext.rtn.sort != Sort.BOOL) {
    throw location.createError(new IllegalArgumentException("Method [hasNext] does not return type [boolean]."));
  }
  next=itr.struct.methods.get(new MethodKey("next",0));
  if (next == null) {
    throw location.createError(new IllegalArgumentException("Method [next] does not exist for type [Iterator]."));
  }
 else   if (next.rtn.sort != Sort.DEF) {
    throw location.createError(new IllegalArgumentException("Method [next] does not return type [def]."));
  }
  cast=AnalyzerCaster.getLegalCast(location,Definition.DEF_TYPE,type,true,true);
  if (block == null) {
    throw location.createError(new IllegalArgumentException("Extraneous for each loop."));
  }
  block.beginLoop=true;
  block.inLoop=true;
  block.analyze(variables);
  block.statementCount=Math.max(1,block.statementCount);
  if (block.loopEscape && !block.anyContinue) {
    throw createError(new IllegalArgumentException("Extraneous for loop."));
  }
  statementCount=1;
  if (maxLoopCounter > 0) {
    loopCounterSlot=variables.getVariable(location,"#loop").slot;
  }
  variables.decrementScope();
}
