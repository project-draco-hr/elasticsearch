{
  super.readFrom(in);
  int size=in.readVInt();
  locations=new IntArrayList(size);
  items=new ArrayList<>(size);
  if (in.getVersion().onOrAfter(Version.V_1_4_0)) {
    for (int i=0; i < size; i++) {
      locations.add(in.readVInt());
      items.add(MultiGetRequest.Item.readItem(in));
    }
  }
 else {
    List<String> types=new ArrayList<>(size);
    List<String> ids=new ArrayList<>(size);
    List<String[]> fields=new ArrayList<>(size);
    LongArrayList versions=new LongArrayList(size);
    List<VersionType> versionTypes=new ArrayList<>(size);
    List<FetchSourceContext> fetchSourceContexts=new ArrayList<>(size);
    for (int i=0; i < size; i++) {
      locations.add(in.readVInt());
      if (in.readBoolean()) {
        types.add(in.readSharedString());
      }
 else {
        types.add(null);
      }
      ids.add(in.readString());
      int size1=in.readVInt();
      if (size1 > 0) {
        String[] fieldsArray=new String[size1];
        for (int j=0; j < size1; j++) {
          fieldsArray[j]=in.readString();
        }
        fields.add(fieldsArray);
      }
 else {
        fields.add(null);
      }
      versions.add(Versions.readVersionWithVLongForBW(in));
      versionTypes.add(VersionType.fromValue(in.readByte()));
      fetchSourceContexts.add(FetchSourceContext.optionalReadFromStream(in));
    }
    for (int i=0; i < size; i++) {
      MultiGetRequest.Item item=new MultiGetRequest.Item(index,types.get(i),ids.get(i)).fields(fields.get(i)).version(versions.get(i)).versionType(versionTypes.get(i)).fetchSourceContext(fetchSourceContexts.get(i));
      items.add(item);
    }
  }
  preference=in.readOptionalString();
  refresh=in.readBoolean();
  byte realtime=in.readByte();
  if (realtime == 0) {
    this.realtime=false;
  }
 else   if (realtime == 1) {
    this.realtime=true;
  }
  if (in.getVersion().onOrAfter(Version.V_1_4_0)) {
    ignoreErrorsOnGeneratedFields=in.readBoolean();
  }
}
