{
  this.parentFilter=null;
  final IndexReaderContext topLevelContext=ReaderUtil.getTopLevelContext(ctx);
  final IndexSearcher searcher=new IndexSearcher(topLevelContext);
  searcher.setQueryCache(null);
  final Weight weight=searcher.createNormalizedWeight(childFilter,false);
  Scorer childDocsScorer=weight.scorer(ctx);
  if (childDocsScorer == null) {
    childDocs=null;
  }
 else {
    childDocs=childDocsScorer.iterator();
  }
  return new LeafBucketCollectorBase(sub,null){
    @Override public void collect(    int parentDoc,    long bucket) throws IOException {
      if (parentDoc == 0 || childDocs == null) {
        return;
      }
      if (parentFilter == null) {
        Query parentFilterNotCached=findClosestNestedPath(parent());
        if (parentFilterNotCached == null) {
          parentFilterNotCached=Queries.newNonNestedFilter();
        }
        parentFilter=context.searchContext().bitsetFilterCache().getBitSetProducer(parentFilterNotCached);
        parentDocs=parentFilter.getBitSet(ctx);
        if (parentDocs == null) {
          childDocs=null;
          return;
        }
      }
      final int prevParentDoc=parentDocs.prevSetBit(parentDoc - 1);
      int childDocId=childDocs.docID();
      if (childDocId <= prevParentDoc) {
        childDocId=childDocs.advance(prevParentDoc + 1);
      }
      for (; childDocId < parentDoc; childDocId=childDocs.nextDoc()) {
        collectBucket(sub,childDocId,bucket);
      }
    }
  }
;
}
