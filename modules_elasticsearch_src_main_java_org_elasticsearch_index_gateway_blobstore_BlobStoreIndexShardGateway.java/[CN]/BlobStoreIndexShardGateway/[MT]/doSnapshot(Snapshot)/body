{
  ImmutableMap<String,BlobMetaData> blobs;
  try {
    blobs=blobContainer.listBlobs();
  }
 catch (  IOException e) {
    throw new IndexShardGatewaySnapshotFailedException(shardId,"failed to list blobs",e);
  }
  long generation=findLatestFileNameGeneration(blobs);
  CommitPoints commitPoints=buildCommitPoints(blobs);
  currentSnapshotStatus.index().startTime(System.currentTimeMillis());
  currentSnapshotStatus.updateStage(SnapshotStatus.Stage.INDEX);
  final SnapshotIndexCommit snapshotIndexCommit=snapshot.indexCommit();
  final Translog.Snapshot translogSnapshot=snapshot.translogSnapshot();
  final CountDownLatch indexLatch=new CountDownLatch(snapshotIndexCommit.getFiles().length);
  final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
  final List<CommitPoint.FileInfo> indexCommitPointFiles=Lists.newArrayList();
  int indexNumberOfFiles=0;
  long indexTotalFilesSize=0;
  for (  final String fileName : snapshotIndexCommit.getFiles()) {
    StoreFileMetaData storeMetaData;
    try {
      storeMetaData=store.metaData(fileName);
    }
 catch (    IOException e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to get store file metadata",e);
    }
    boolean snapshotRequired=false;
    if (snapshot.indexChanged() && fileName.equals(snapshotIndexCommit.getSegmentsFileName())) {
      snapshotRequired=true;
    }
    CommitPoint.FileInfo fileInfo=commitPoints.findPhysicalIndexFile(fileName);
    if (fileInfo == null || fileInfo.length() != storeMetaData.length() || !commitPointFileExistsInBlobs(fileInfo,blobs)) {
      snapshotRequired=true;
    }
    if (snapshotRequired) {
      indexNumberOfFiles++;
      indexTotalFilesSize+=storeMetaData.length();
      try {
        CommitPoint.FileInfo snapshotFileInfo=new CommitPoint.FileInfo(fileNameFromGeneration(++generation),storeMetaData.name(),storeMetaData.length());
        indexCommitPointFiles.add(snapshotFileInfo);
        snapshotFile(snapshotIndexCommit.getDirectory(),snapshotFileInfo,indexLatch,failures);
      }
 catch (      IOException e) {
        failures.add(e);
        indexLatch.countDown();
      }
    }
 else {
      indexCommitPointFiles.add(fileInfo);
      indexLatch.countDown();
    }
  }
  currentSnapshotStatus.index().files(indexNumberOfFiles,indexTotalFilesSize);
  try {
    indexLatch.await();
  }
 catch (  InterruptedException e) {
    failures.add(e);
  }
  if (!failures.isEmpty()) {
    throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to perform snapshot (index files)",failures.get(failures.size() - 1));
  }
  currentSnapshotStatus.index().time(System.currentTimeMillis() - currentSnapshotStatus.index().startTime());
  currentSnapshotStatus.updateStage(SnapshotStatus.Stage.TRANSLOG);
  currentSnapshotStatus.translog().startTime(System.currentTimeMillis());
  List<CommitPoint.FileInfo> translogCommitPointFiles=Lists.newArrayList();
  int expectedNumberOfOperations=0;
  boolean snapshotRequired=false;
  if (snapshot.newTranslogCreated()) {
    if (translogSnapshot.lengthInBytes() > 0) {
      snapshotRequired=true;
      expectedNumberOfOperations=translogSnapshot.totalOperations();
    }
  }
 else {
    if (!commitPoints.commits().isEmpty()) {
      CommitPoint commitPoint=commitPoints.commits().get(0);
      boolean allTranslogFilesExists=true;
      for (      CommitPoint.FileInfo fileInfo : commitPoint.translogFiles()) {
        if (!commitPointFileExistsInBlobs(fileInfo,blobs)) {
          allTranslogFilesExists=false;
          break;
        }
      }
      if (allTranslogFilesExists) {
        translogCommitPointFiles.addAll(commitPoint.translogFiles());
        if (snapshot.sameTranslogNewOperations()) {
          translogSnapshot.seekForward(snapshot.lastTranslogPosition());
          if (translogSnapshot.lengthInBytes() > 0) {
            snapshotRequired=true;
            expectedNumberOfOperations=translogSnapshot.totalOperations() - snapshot.lastTotalTranslogOperations();
          }
        }
      }
 else {
        if (translogSnapshot.lengthInBytes() > 0) {
          expectedNumberOfOperations=translogSnapshot.totalOperations();
          snapshotRequired=true;
        }
      }
    }
 else {
      if (translogSnapshot.lengthInBytes() > 0) {
        expectedNumberOfOperations=translogSnapshot.totalOperations();
        snapshotRequired=true;
      }
    }
  }
  currentSnapshotStatus.translog().expectedNumberOfOperations(expectedNumberOfOperations);
  if (snapshotRequired) {
    CommitPoint.FileInfo addedTranslogFileInfo=new CommitPoint.FileInfo(fileNameFromGeneration(++generation),"translog-" + translogSnapshot.translogId(),translogSnapshot.lengthInBytes());
    translogCommitPointFiles.add(addedTranslogFileInfo);
    try {
      snapshotTranslog(translogSnapshot,addedTranslogFileInfo);
    }
 catch (    Exception e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to snapshot translog",e);
    }
  }
  currentSnapshotStatus.translog().time(System.currentTimeMillis() - currentSnapshotStatus.translog().startTime());
  currentSnapshotStatus.updateStage(SnapshotStatus.Stage.FINALIZE);
  long version=0;
  if (!commitPoints.commits().isEmpty()) {
    version=commitPoints.commits().iterator().next().version() + 1;
  }
  String commitPointName="commit-" + Long.toString(version,Character.MAX_RADIX);
  CommitPoint commitPoint=new CommitPoint(version,commitPointName,CommitPoint.Type.GENERATED,indexCommitPointFiles,translogCommitPointFiles);
  try {
    byte[] commitPointData=CommitPoints.toXContent(commitPoint);
    blobContainer.writeBlob(commitPointName,new FastByteArrayInputStream(commitPointData),commitPointData.length);
  }
 catch (  Exception e) {
    throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to write commit point",e);
  }
  List<CommitPoint> newCommitPointsList=Lists.newArrayList();
  newCommitPointsList.add(commitPoint);
  for (  CommitPoint point : commitPoints) {
    if (point.type() == CommitPoint.Type.SAVED) {
      newCommitPointsList.add(point);
    }
  }
  CommitPoints newCommitPoints=new CommitPoints(newCommitPointsList);
  for (  String blobName : blobs.keySet()) {
    if (!blobName.startsWith("commit-")) {
      continue;
    }
    long checkedVersion=Long.parseLong(blobName.substring("commit-".length()),Character.MAX_RADIX);
    if (!newCommitPoints.hasVersion(checkedVersion)) {
      try {
        blobContainer.deleteBlob(blobName);
      }
 catch (      IOException e) {
      }
    }
  }
  for (  String blobName : blobs.keySet()) {
    String name=blobName;
    if (name.startsWith("commit-")) {
      continue;
    }
    if (blobName.contains(".part")) {
      name=blobName.substring(0,blobName.indexOf(".part"));
    }
    if (newCommitPoints.findNameFile(name) == null) {
      try {
        blobContainer.deleteBlob(blobName);
      }
 catch (      IOException e) {
      }
    }
  }
}
