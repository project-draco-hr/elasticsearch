{
  final ImmutableMap<String,BlobMetaData> indicesBlobs;
  try {
    indicesBlobs=indexContainer.listBlobs();
  }
 catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to list content of gateway",e);
  }
  ImmutableMap<String,BlobMetaData> virtualIndicesBlobs=buildVirtualBlobs(indexContainer,indicesBlobs,cachedMd5);
  int numberOfFiles=0;
  long totalSize=0;
  int numberOfExistingFiles=0;
  long existingTotalSize=0;
  List<BlobMetaData> filesToRecover=new ArrayList<BlobMetaData>();
  for (  BlobMetaData virtualMd : virtualIndicesBlobs.values()) {
    try {
      StoreFileMetaData storeMd=store.metaDataWithMd5(virtualMd.name());
      if (storeMd != null && storeMd.md5().equals(virtualMd.md5())) {
        numberOfExistingFiles++;
        existingTotalSize+=virtualMd.sizeInBytes();
        if (logger.isTraceEnabled()) {
          logger.trace("not_recovering [{}], exists in local store and has same md5 [{}]",virtualMd.name(),virtualMd.md5());
        }
      }
 else {
        if (logger.isTraceEnabled()) {
          if (storeMd == null) {
            logger.trace("recovering [{}], does not exists in local store",virtualMd.name());
          }
 else {
            logger.trace("recovering [{}], exists in local store but has different md5: gateway [{}], local [{}]",virtualMd.name(),virtualMd.md5(),storeMd.md5());
          }
        }
        numberOfFiles++;
        totalSize+=virtualMd.sizeInBytes();
        filesToRecover.add(virtualMd);
      }
    }
 catch (    Exception e) {
      filesToRecover.add(virtualMd);
      logger.debug("failed to check local store for existence of [{}]",e,virtualMd.name());
    }
  }
  if (logger.isTraceEnabled()) {
    logger.trace("recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",numberOfFiles,new ByteSizeValue(totalSize),numberOfExistingFiles,new ByteSizeValue(existingTotalSize));
  }
  final AtomicLong throttlingWaitTime=new AtomicLong();
  final CountDownLatch latch=new CountDownLatch(filesToRecover.size());
  final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
  for (  final BlobMetaData fileToRecover : filesToRecover) {
    if (recoveryThrottler.tryStream(shardId,fileToRecover.name())) {
      recoverFile(fileToRecover,indicesBlobs,latch,failures);
    }
 else {
      threadPool.schedule(new Runnable(){
        @Override public void run(){
          throttlingWaitTime.addAndGet(recoveryThrottler.throttleInterval().millis());
          if (recoveryThrottler.tryStream(shardId,fileToRecover.name())) {
            recoverFile(fileToRecover,indicesBlobs,latch,failures);
          }
 else {
            threadPool.schedule(this,recoveryThrottler.throttleInterval());
          }
        }
      }
,recoveryThrottler.throttleInterval());
    }
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Interrupted while recovering index",e);
  }
  if (!failures.isEmpty()) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recovery index",failures.get(0));
  }
  long version=-1;
  try {
    if (IndexReader.indexExists(store.directory())) {
      version=IndexReader.getCurrentVersion(store.directory());
    }
  }
 catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to fetch index version after copying it over",e);
  }
  try {
    for (    String storeFile : store.directory().listAll()) {
      if (!virtualIndicesBlobs.containsKey(storeFile)) {
        try {
          store.directory().deleteFile(storeFile);
        }
 catch (        IOException e) {
        }
      }
    }
  }
 catch (  IOException e) {
  }
  return new RecoveryStatus.Index(version,numberOfFiles,new ByteSizeValue(totalSize),numberOfExistingFiles,new ByteSizeValue(existingTotalSize),TimeValue.timeValueMillis(throttlingWaitTime.get()));
}
