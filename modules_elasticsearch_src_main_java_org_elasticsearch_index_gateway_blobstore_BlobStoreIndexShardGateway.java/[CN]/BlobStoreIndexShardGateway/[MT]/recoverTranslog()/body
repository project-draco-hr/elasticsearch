{
  long translogId;
  try {
    translogId=IndexReader.getCurrentVersion(store.directory());
  }
 catch (  FileNotFoundException e) {
    indexShard.start();
    return RecoveryStatus.Translog.EMPTY;
  }
catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recovery translog, can't read current index version",e);
  }
  if (!translogContainer.blobExists("translog-" + translogId)) {
    indexShard.start();
    return RecoveryStatus.Translog.EMPTY;
  }
  StopWatch timer=new StopWatch().start();
  try {
    indexShard.performRecoveryPrepareForTranslog();
    final AtomicReference<Throwable> failure=new AtomicReference<Throwable>();
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicInteger totalOperations=new AtomicInteger();
    final AtomicLong totalSize=new AtomicLong();
    translogContainer.readBlob("translog-" + translogId,new BlobContainer.ReadBlobListener(){
      FastByteArrayOutputStream bos=new FastByteArrayOutputStream();
      boolean ignore=false;
      @Override public synchronized void onPartial(      byte[] data,      int offset,      int size) throws IOException {
        if (ignore) {
          return;
        }
        bos.write(data,offset,size);
        BytesStreamInput si=new BytesStreamInput(bos.unsafeByteArray(),0,bos.size());
        int position;
        while (true) {
          try {
            position=si.position();
            int opSize=si.readVInt();
            int curPos=si.position();
            if ((si.position() + opSize) > bos.size()) {
              break;
            }
            Translog.Operation operation=TranslogStreams.readTranslogOperation(si);
            if ((si.position() - curPos) != opSize) {
              logger.warn("mismatch in size, expected [{}], got [{}]",opSize,si.position() - curPos);
            }
            totalOperations.incrementAndGet();
            indexShard.performRecoveryOperation(operation);
            if (si.position() >= bos.size()) {
              position=si.position();
              break;
            }
          }
 catch (          Exception e) {
            logger.warn("failed to retrieve translog after [{}] operations, ignoring the rest, considered corrupted",e,totalOperations.get());
            ignore=true;
            latch.countDown();
            return;
          }
        }
        totalSize.addAndGet(position);
        FastByteArrayOutputStream newBos=new FastByteArrayOutputStream();
        int leftOver=bos.size() - position;
        if (leftOver > 0) {
          newBos.write(bos.unsafeByteArray(),position,leftOver);
        }
        bos=newBos;
      }
      @Override public synchronized void onCompleted(){
        latch.countDown();
      }
      @Override public synchronized void onFailure(      Throwable t){
        failure.set(t);
        latch.countDown();
      }
    }
);
    latch.await();
    if (failure.get() != null) {
      throw failure.get();
    }
    indexShard.performRecoveryFinalization(true);
    return new RecoveryStatus.Translog(totalOperations.get(),timer.stop().totalTime());
  }
 catch (  Throwable e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recovery translog",e);
  }
}
