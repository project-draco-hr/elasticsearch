{
  long translogId;
  try {
    translogId=IndexReader.getCurrentVersion(store.directory());
  }
 catch (  FileNotFoundException e) {
    return new RecoveryStatus.Translog(-1,0,new ByteSizeValue(0));
  }
catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recovery translog, can't read current index version",e);
  }
  if (!translogContainer.blobExists("translog-" + translogId)) {
    return new RecoveryStatus.Translog(-1,0,new ByteSizeValue(0));
  }
  try {
    indexShard.performRecoveryPrepareForTranslog();
    int totalOperations=0;
    byte[] translogData=translogContainer.readBlobFully("translog-" + translogId);
    BytesStreamInput si=new BytesStreamInput(translogData);
    while (true) {
      try {
        int numberOfOperations=si.readInt();
        ArrayList<Translog.Operation> operations=Lists.newArrayList();
        for (int i=0; i < numberOfOperations; i++) {
          operations.add(readTranslogOperation(si));
          totalOperations++;
        }
        indexShard.performRecoveryOperations(operations);
        if (si.position() == translogData.length) {
          break;
        }
      }
 catch (      IOException e) {
        if (si.position() >= translogData.length) {
        }
 else {
          throw e;
        }
      }
    }
    indexShard.performRecoveryFinalization();
    long lastTranslogId=indexShard.translog().currentId();
    if (!translogContainer.canAppendToExistingBlob()) {
      indexShard.flush(new Engine.Flush());
      lastTranslogId=-1;
    }
    return new RecoveryStatus.Translog(lastTranslogId,totalOperations,new ByteSizeValue(translogData.length,ByteSizeUnit.BYTES));
  }
 catch (  Exception e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recovery translog, can't read current index version",e);
  }
}
