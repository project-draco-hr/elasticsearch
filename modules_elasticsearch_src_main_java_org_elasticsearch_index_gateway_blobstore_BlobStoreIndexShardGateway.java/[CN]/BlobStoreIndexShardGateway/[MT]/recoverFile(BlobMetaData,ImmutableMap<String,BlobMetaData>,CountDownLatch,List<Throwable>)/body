{
  final IndexOutput indexOutput;
  try {
    indexOutput=store.directory().createOutput(fileToRecover.name());
  }
 catch (  IOException e) {
    recoveryThrottler.streamDone(shardId,fileToRecover.name());
    failures.add(e);
    latch.countDown();
    return;
  }
  String firstFileToRecover=fileToRecover.name();
  if (!blobs.containsKey(fileToRecover.name())) {
    firstFileToRecover=fileToRecover.name() + ".part0";
  }
  if (!blobs.containsKey(firstFileToRecover)) {
    recoveryThrottler.streamDone(shardId,fileToRecover.name());
    logger.warn("no file [{}] to recover, even though it has md5, ignoring it",fileToRecover.name());
    latch.countDown();
    return;
  }
  final AtomicInteger partIndex=new AtomicInteger();
  final MessageDigest digest=Digest.getMd5Digest();
  indexContainer.readBlob(firstFileToRecover,new BlobContainer.ReadBlobListener(){
    @Override public synchronized void onPartial(    byte[] data,    int offset,    int size) throws IOException {
      recoveryStatus.index().addCurrentFilesSize(size);
      indexOutput.writeBytes(data,offset,size);
      digest.update(data,offset,size);
    }
    @Override public synchronized void onCompleted(){
      int part=partIndex.incrementAndGet();
      String partName=fileToRecover.name() + ".part" + part;
      if (blobs.containsKey(partName)) {
        indexContainer.readBlob(partName,this);
        return;
      }
 else {
        try {
          indexOutput.close();
        }
 catch (        IOException e) {
          onFailure(e);
          return;
        }
      }
      String md5=Hex.encodeHexString(digest.digest());
      if (!md5.equals(fileToRecover.md5())) {
        logger.warn("file [{}] has different md5, actual read content [{}], store [{}]",fileToRecover.name(),md5,fileToRecover.md5());
      }
      recoveryThrottler.streamDone(shardId,fileToRecover.name());
      latch.countDown();
    }
    @Override public void onFailure(    Throwable t){
      recoveryThrottler.streamDone(shardId,fileToRecover.name());
      failures.add(t);
      latch.countDown();
    }
  }
);
}
