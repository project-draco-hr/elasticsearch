{
  long totalTimeStart=System.currentTimeMillis();
  boolean indexDirty=false;
  final SnapshotIndexCommit snapshotIndexCommit=snapshot.indexCommit();
  final Translog.Snapshot translogSnapshot=snapshot.translogSnapshot();
  ImmutableMap<String,BlobMetaData> indicesBlobs=null;
  TObjectLongHashMap<String> combinedIndicesBlobs=null;
  int indexNumberOfFiles=0;
  long indexTotalFilesSize=0;
  long indexTime=0;
  if (snapshot.indexChanged()) {
    long time=System.currentTimeMillis();
    indexDirty=true;
    try {
      indicesBlobs=indexContainer.listBlobs();
    }
 catch (    IOException e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to list indices files from gateway",e);
    }
    combinedIndicesBlobs=buildCombinedPartsBlobs(indicesBlobs);
    final CountDownLatch latch=new CountDownLatch(snapshotIndexCommit.getFiles().length);
    final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
    for (    final String fileName : snapshotIndexCommit.getFiles()) {
      if (fileName.equals(snapshotIndexCommit.getSegmentsFileName())) {
        latch.countDown();
        continue;
      }
      long fileSize;
      try {
        fileSize=snapshotIndexCommit.getDirectory().fileLength(fileName);
      }
 catch (      IOException e) {
        throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to get length on local store",e);
      }
      if (combinedIndicesBlobs.contains(fileName) && combinedIndicesBlobs.get(fileName) == fileSize) {
        latch.countDown();
        continue;
      }
      indexNumberOfFiles++;
      indexTotalFilesSize+=fileSize;
      if (combinedIndicesBlobs.contains(fileName)) {
        try {
          indexContainer.deleteBlobsByPrefix(fileName);
        }
 catch (        IOException e) {
          logger.debug("failed to delete [" + fileName + "] before snapshotting, ignoring...");
        }
      }
      try {
        snapshotFile(snapshotIndexCommit.getDirectory(),fileName,latch,failures);
      }
 catch (      IOException e) {
        failures.add(e);
        latch.countDown();
      }
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      failures.add(e);
    }
    if (!failures.isEmpty()) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to perform snapshot (index files)",failures.get(failures.size() - 1));
    }
    indexTime=System.currentTimeMillis() - time;
  }
  final AtomicInteger translogNumberOfOperations=new AtomicInteger();
  long translogTime=0;
  if (snapshot.newTranslogCreated() || snapshot.sameTranslogNewOperations()) {
    long time=System.currentTimeMillis();
    if (snapshot.newTranslogCreated() && translogBlob != null) {
      translogBlob.close();
      translogBlob=null;
    }
    if (translogBlob == null) {
      try {
        translogBlob=translogContainer.appendBlob("translog-" + translogSnapshot.translogId(),!snapshot.newTranslogCreated());
      }
 catch (      IOException e) {
        throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to create translog",e);
      }
    }
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicReference<Throwable> failure=new AtomicReference<Throwable>();
    translogBlob.append(new AppendableBlobContainer.AppendBlobListener(){
      @Override public void withStream(      StreamOutput os) throws IOException {
        int deltaNumberOfOperations;
        Iterable<Translog.Operation> operationsIt;
        if (snapshot.newTranslogCreated()) {
          deltaNumberOfOperations=translogSnapshot.size();
          operationsIt=translogSnapshot;
        }
 else {
          deltaNumberOfOperations=translogSnapshot.size() - snapshot.lastTranslogSize();
          operationsIt=translogSnapshot.skipTo(snapshot.lastTranslogSize());
        }
        os.writeInt(deltaNumberOfOperations);
        for (        Translog.Operation operation : operationsIt) {
          writeTranslogOperation(os,operation);
        }
        translogNumberOfOperations.set(deltaNumberOfOperations);
      }
      @Override public void onCompleted(){
        latch.countDown();
      }
      @Override public void onFailure(      Throwable t){
        failure.set(t);
        latch.countDown();
      }
    }
);
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      failure.set(e);
    }
    if (failure.get() != null) {
      throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to snapshot translog",failure.get());
    }
    translogTime=System.currentTimeMillis() - time;
  }
  if (indexDirty) {
    try {
      indexNumberOfFiles++;
      if (indicesBlobs.containsKey(snapshotIndexCommit.getSegmentsFileName())) {
        indexContainer.deleteBlob(snapshotIndexCommit.getSegmentsFileName());
      }
      indexTotalFilesSize+=snapshotIndexCommit.getDirectory().fileLength(snapshotIndexCommit.getSegmentsFileName());
      long time=System.currentTimeMillis();
      IndexInput indexInput=snapshotIndexCommit.getDirectory().openInput(snapshotIndexCommit.getSegmentsFileName());
      try {
        InputStreamIndexInput is=new InputStreamIndexInput(indexInput,Long.MAX_VALUE);
        indexContainer.writeBlob(snapshotIndexCommit.getSegmentsFileName(),is,is.actualSizeToRead());
      }
  finally {
        try {
          indexInput.close();
        }
 catch (        Exception e) {
        }
      }
      indexTime+=(System.currentTimeMillis() - time);
    }
 catch (    Exception e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to finalize index snapshot into [" + snapshotIndexCommit.getSegmentsFileName() + "]",e);
    }
  }
  if (snapshot.newTranslogCreated()) {
    try {
      translogContainer.deleteBlob("translog-" + snapshot.lastTranslogId());
    }
 catch (    IOException e) {
    }
  }
  if (indexDirty) {
    for (TObjectLongIterator<String> it=combinedIndicesBlobs.iterator(); it.hasNext(); ) {
      it.advance();
      boolean found=false;
      for (      final String fileName : snapshotIndexCommit.getFiles()) {
        if (it.key().equals(fileName)) {
          found=true;
          break;
        }
      }
      if (!found) {
        try {
          indexContainer.deleteBlobsByPrefix(it.key());
        }
 catch (        IOException e) {
          logger.debug("failed to delete unused index files, will retry later...",e);
        }
      }
    }
  }
  return new SnapshotStatus(new TimeValue(System.currentTimeMillis() - totalTimeStart),new SnapshotStatus.Index(indexNumberOfFiles,new ByteSizeValue(indexTotalFilesSize),new TimeValue(indexTime)),new SnapshotStatus.Translog(translogNumberOfOperations.get(),new TimeValue(translogTime)));
}
