{
  long totalTimeStart=System.currentTimeMillis();
  boolean indexDirty=false;
  final SnapshotIndexCommit snapshotIndexCommit=snapshot.indexCommit();
  final Translog.Snapshot translogSnapshot=snapshot.translogSnapshot();
  ImmutableMap<String,BlobMetaData> indicesBlobs=null;
  ImmutableMap<String,BlobMetaData> virtualIndicesBlobs=null;
  int indexNumberOfFiles=0;
  long indexTotalFilesSize=0;
  long indexTime=0;
  if (snapshot.indexChanged()) {
    long time=System.currentTimeMillis();
    indexDirty=true;
    try {
      indicesBlobs=indexContainer.listBlobs();
    }
 catch (    IOException e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to list indices files from gateway",e);
    }
    virtualIndicesBlobs=buildVirtualBlobs(indexContainer,indicesBlobs,cachedMd5);
    final CountDownLatch latch=new CountDownLatch(snapshotIndexCommit.getFiles().length);
    final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
    for (    final String fileName : snapshotIndexCommit.getFiles()) {
      StoreFileMetaData snapshotFileMetaData;
      try {
        snapshotFileMetaData=store.metaDataWithMd5(fileName);
      }
 catch (      IOException e) {
        throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to get store file metadata",e);
      }
      if (fileName.equals(snapshotIndexCommit.getSegmentsFileName())) {
        latch.countDown();
        continue;
      }
      if (virtualIndicesBlobs.containsKey(fileName) && virtualIndicesBlobs.get(fileName).md5().equals(snapshotFileMetaData.md5())) {
        latch.countDown();
        continue;
      }
      indexNumberOfFiles++;
      indexTotalFilesSize+=snapshotFileMetaData.sizeInBytes();
      if (virtualIndicesBlobs.containsKey(fileName)) {
        try {
          cachedMd5.remove(fileName);
          indexContainer.deleteBlobsByPrefix(fileName);
        }
 catch (        IOException e) {
          logger.debug("failed to delete [" + fileName + "] before snapshotting, ignoring...");
        }
      }
      try {
        snapshotFile(snapshotIndexCommit.getDirectory(),snapshotFileMetaData,latch,failures);
      }
 catch (      IOException e) {
        failures.add(e);
        latch.countDown();
      }
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      failures.add(e);
    }
    if (!failures.isEmpty()) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to perform snapshot (index files)",failures.get(failures.size() - 1));
    }
    indexTime=System.currentTimeMillis() - time;
  }
  final AtomicInteger translogNumberOfOperations=new AtomicInteger();
  long translogTime=0;
  if (snapshot.newTranslogCreated() || snapshot.sameTranslogNewOperations()) {
    long time=System.currentTimeMillis();
    if (snapshot.newTranslogCreated() && translogBlob != null) {
      translogBlob.close();
      translogBlob=null;
    }
    if (translogBlob == null) {
      try {
        translogBlob=translogContainer.appendBlob("translog-" + translogSnapshot.translogId());
      }
 catch (      IOException e) {
        throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to create translog",e);
      }
    }
    final CountDownLatch latch=new CountDownLatch(1);
    final AtomicReference<Throwable> failure=new AtomicReference<Throwable>();
    translogBlob.append(new AppendableBlobContainer.AppendBlobListener(){
      @Override public void withStream(      StreamOutput os) throws IOException {
        if (!snapshot.newTranslogCreated()) {
          translogSnapshot.seekForward(snapshot.lastTranslogPosition());
        }
        FastByteArrayOutputStream bos=cachedBos.get();
        if (bos == null) {
          bos=new FastByteArrayOutputStream();
          cachedBos=new SoftReference<FastByteArrayOutputStream>(bos);
        }
        int totalNumberOfOperations=0;
        OutputStreamStreamOutput bosOs=new OutputStreamStreamOutput(bos);
        while (translogSnapshot.hasNext()) {
          bos.reset();
          TranslogStreams.writeTranslogOperation(bosOs,translogSnapshot.next());
          bosOs.flush();
          os.writeVInt(bos.size());
          os.writeBytes(bos.unsafeByteArray(),bos.size());
          totalNumberOfOperations++;
        }
        translogNumberOfOperations.set(totalNumberOfOperations);
      }
      @Override public void onCompleted(){
        latch.countDown();
      }
      @Override public void onFailure(      Throwable t){
        failure.set(t);
        latch.countDown();
      }
    }
);
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      failure.set(e);
    }
    if (failure.get() != null) {
      throw new IndexShardGatewaySnapshotFailedException(shardId,"Failed to snapshot translog",failure.get());
    }
    translogTime=System.currentTimeMillis() - time;
  }
  if (indexDirty) {
    try {
      indexNumberOfFiles++;
      if (indicesBlobs.containsKey(snapshotIndexCommit.getSegmentsFileName())) {
        cachedMd5.remove(snapshotIndexCommit.getSegmentsFileName());
        indexContainer.deleteBlob(snapshotIndexCommit.getSegmentsFileName());
      }
      StoreFileMetaData snapshotFileMetaData=store.metaDataWithMd5(snapshotIndexCommit.getSegmentsFileName());
      indexTotalFilesSize+=snapshotFileMetaData.sizeInBytes();
      long time=System.currentTimeMillis();
      CountDownLatch latch=new CountDownLatch(1);
      CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
      snapshotFile(snapshotIndexCommit.getDirectory(),snapshotFileMetaData,latch,failures);
      latch.await();
      if (!failures.isEmpty()) {
        throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to perform snapshot (segment index file)",failures.get(failures.size() - 1));
      }
      indexTime+=(System.currentTimeMillis() - time);
    }
 catch (    Exception e) {
      if (e instanceof IndexShardGatewaySnapshotFailedException) {
        throw (IndexShardGatewaySnapshotFailedException)e;
      }
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to finalize index snapshot into [" + snapshotIndexCommit.getSegmentsFileName() + "]",e);
    }
  }
  if (snapshot.newTranslogCreated()) {
    try {
      translogContainer.deleteBlob("translog-" + snapshot.lastTranslogId());
    }
 catch (    Exception e) {
    }
  }
  if (indexDirty) {
    for (    BlobMetaData md : virtualIndicesBlobs.values()) {
      boolean found=false;
      for (      final String fileName : snapshotIndexCommit.getFiles()) {
        if (md.name().equals(fileName)) {
          found=true;
          break;
        }
      }
      if (!found) {
        try {
          cachedMd5.remove(md.name());
          indexContainer.deleteBlobsByPrefix(md.name());
        }
 catch (        IOException e) {
          logger.debug("failed to delete unused index files, will retry later...",e);
        }
      }
    }
  }
  return new SnapshotStatus(new TimeValue(System.currentTimeMillis() - totalTimeStart),new SnapshotStatus.Index(indexNumberOfFiles,new ByteSizeValue(indexTotalFilesSize),new TimeValue(indexTime)),new SnapshotStatus.Translog(translogNumberOfOperations.get(),new TimeValue(translogTime)));
}
