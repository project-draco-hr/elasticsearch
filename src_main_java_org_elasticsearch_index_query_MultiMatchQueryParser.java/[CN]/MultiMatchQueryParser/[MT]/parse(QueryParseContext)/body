{
  XContentParser parser=parseContext.parser();
  String text=null;
  float boost=1.0f;
  MatchQuery.Type type=MatchQuery.Type.BOOLEAN;
  MultiMatchQuery multiMatchQuery=new MultiMatchQuery(parseContext);
  String minimumShouldMatch=null;
  List<String> fieldNames=Lists.newArrayList();
  Map<String,Float> fieldNameToBoost=Maps.newHashMap();
  XContentParser.Token token;
  String currentFieldName=null;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentFieldName=parser.currentName();
    }
 else     if (token == XContentParser.Token.START_ARRAY) {
      if ("fields".equals(currentFieldName)) {
        while ((token=parser.nextToken()) != XContentParser.Token.END_ARRAY) {
          String fField=null;
          float fBoost=-1;
          char[] fieldText=parser.textCharacters();
          int end=parser.textOffset() + parser.textLength();
          for (int i=parser.textOffset(); i < end; i++) {
            if (fieldText[i] == '^') {
              int relativeLocation=i - parser.textOffset();
              fField=new String(fieldText,parser.textOffset(),relativeLocation);
              fBoost=Float.parseFloat(new String(fieldText,i + 1,parser.textLength() - relativeLocation - 1));
              break;
            }
          }
          if (fField == null) {
            fField=parser.text();
          }
          if (Regex.isSimpleMatchPattern(fField)) {
            for (            String field : parseContext.mapperService().simpleMatchToIndexNames(fField)) {
              fieldNames.add(field);
              if (fBoost != -1) {
                fieldNameToBoost.put(field,fBoost);
              }
            }
          }
 else {
            fieldNames.add(fField);
            if (fBoost != -1) {
              fieldNameToBoost.put(fField,fBoost);
            }
          }
        }
      }
 else {
        throw new QueryParsingException(parseContext.index(),"[query_string] query does not support [" + currentFieldName + "]");
      }
    }
 else     if (token.isValue()) {
      if ("query".equals(currentFieldName)) {
        text=parser.text();
      }
 else       if ("type".equals(currentFieldName)) {
        String tStr=parser.text();
        if ("boolean".equals(tStr)) {
          type=MatchQuery.Type.BOOLEAN;
        }
 else         if ("phrase".equals(tStr)) {
          type=MatchQuery.Type.PHRASE;
        }
 else         if ("phrase_prefix".equals(tStr) || "phrasePrefix".equals(currentFieldName)) {
          type=MatchQuery.Type.PHRASE_PREFIX;
        }
      }
 else       if ("analyzer".equals(currentFieldName)) {
        String analyzer=parser.text();
        if (parseContext.analysisService().analyzer(analyzer) == null) {
          throw new QueryParsingException(parseContext.index(),"[match] analyzer [" + parser.text() + "] not found");
        }
        multiMatchQuery.setAnalyzer(analyzer);
      }
 else       if ("boost".equals(currentFieldName)) {
        boost=parser.floatValue();
      }
 else       if ("slop".equals(currentFieldName) || "phrase_slop".equals(currentFieldName) || "phraseSlop".equals(currentFieldName)) {
        multiMatchQuery.setPhraseSlop(parser.intValue());
      }
 else       if ("fuzziness".equals(currentFieldName)) {
        multiMatchQuery.setFuzziness(parser.textOrNull());
      }
 else       if ("prefix_length".equals(currentFieldName) || "prefixLength".equals(currentFieldName)) {
        multiMatchQuery.setFuzzyPrefixLength(parser.intValue());
      }
 else       if ("max_expansions".equals(currentFieldName) || "maxExpansions".equals(currentFieldName)) {
        multiMatchQuery.setMaxExpansions(parser.intValue());
      }
 else       if ("operator".equals(currentFieldName)) {
        String op=parser.text();
        if ("or".equalsIgnoreCase(op)) {
          multiMatchQuery.setOccur(BooleanClause.Occur.SHOULD);
        }
 else         if ("and".equalsIgnoreCase(op)) {
          multiMatchQuery.setOccur(BooleanClause.Occur.MUST);
        }
 else {
          throw new QueryParsingException(parseContext.index(),"text query requires operator to be either 'and' or 'or', not [" + op + "]");
        }
      }
 else       if ("minimum_should_match".equals(currentFieldName) || "minimumShouldMatch".equals(currentFieldName)) {
        minimumShouldMatch=parser.textOrNull();
      }
 else       if ("rewrite".equals(currentFieldName)) {
        multiMatchQuery.setRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(),null));
      }
 else       if ("fuzzy_rewrite".equals(currentFieldName) || "fuzzyRewrite".equals(currentFieldName)) {
        multiMatchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(parser.textOrNull(),null));
      }
 else       if ("use_dis_max".equals(currentFieldName) || "useDisMax".equals(currentFieldName)) {
        multiMatchQuery.setUseDisMax(parser.booleanValue());
      }
 else       if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName)) {
        multiMatchQuery.setTieBreaker(parser.intValue());
      }
 else {
        throw new QueryParsingException(parseContext.index(),"[match] query does not support [" + currentFieldName + "]");
      }
    }
  }
  if (text == null) {
    throw new QueryParsingException(parseContext.index(),"No text specified for match_all query");
  }
  if (fieldNames.isEmpty()) {
    throw new QueryParsingException(parseContext.index(),"No fields specified for match_all query");
  }
  Query query=multiMatchQuery.parse(type,fieldNames,text);
  if (query instanceof BooleanQuery) {
    Queries.applyMinimumShouldMatch((BooleanQuery)query,minimumShouldMatch);
  }
  query.setBoost(boost);
  return query;
}
