{
  ImmutableMap.Builder<String,StoreFileMetaData> builder=ImmutableMap.builder();
  Map<String,String> checksumMap=readLegacyChecksums(directory).v1();
  try {
    final SegmentInfos segmentCommitInfos=Store.readSegmentsInfo(commit,directory);
    Version maxVersion=Version.LUCENE_4_0;
    for (    SegmentCommitInfo info : segmentCommitInfos) {
      final Version version=info.info.getVersion();
      if (version == null) {
        throw new IllegalArgumentException("expected valid version value: " + info.info.toString());
      }
      if (version.onOrAfter(maxVersion)) {
        maxVersion=version;
      }
      for (      String file : info.files()) {
        String legacyChecksum=checksumMap.get(file);
        if (version.onOrAfter(FIRST_LUCENE_CHECKSUM_VERSION)) {
          checksumFromLuceneFile(directory,file,builder,logger,version,SEGMENT_INFO_EXTENSION.equals(IndexFileNames.getExtension(file)));
        }
 else {
          builder.put(file,new StoreFileMetaData(file,directory.fileLength(file),legacyChecksum,version));
        }
      }
    }
    final String segmentsFile=segmentCommitInfos.getSegmentsFileName();
    String legacyChecksum=checksumMap.get(segmentsFile);
    if (maxVersion.onOrAfter(FIRST_LUCENE_CHECKSUM_VERSION)) {
      checksumFromLuceneFile(directory,segmentsFile,builder,logger,maxVersion,true);
    }
 else {
      builder.put(segmentsFile,new StoreFileMetaData(segmentsFile,directory.fileLength(segmentsFile),legacyChecksum,maxVersion,hashFile(directory,segmentsFile)));
    }
  }
 catch (  CorruptIndexException|IndexFormatTooOldException|IndexFormatTooNewException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    try {
      Lucene.checkSegmentInfoIntegrity(directory);
    }
 catch (    CorruptIndexException|IndexFormatTooOldException|IndexFormatTooNewException cex) {
      cex.addSuppressed(ex);
      throw cex;
    }
catch (    Throwable e) {
    }
    throw ex;
  }
  return builder.build();
}
