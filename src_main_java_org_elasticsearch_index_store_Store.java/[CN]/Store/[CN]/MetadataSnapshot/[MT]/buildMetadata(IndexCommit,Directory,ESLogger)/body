{
  ImmutableMap.Builder<String,StoreFileMetaData> builder=ImmutableMap.builder();
  Map<String,String> checksumMap=readLegacyChecksums(directory);
  try {
    final SegmentInfos segmentCommitInfos=Store.readSegmentsInfo(commit,directory);
    Version maxVersion=Version.LUCENE_3_0;
    for (    SegmentCommitInfo info : segmentCommitInfos) {
      final Version version=info.info.getVersion();
      if (version != null && version.onOrAfter(maxVersion)) {
        maxVersion=version;
      }
      for (      String file : info.files()) {
        String legacyChecksum=checksumMap.get(file);
        if (version.onOrAfter(Version.LUCENE_4_8) && legacyChecksum == null) {
          checksumFromLuceneFile(directory,file,builder,logger,version,Lucene46SegmentInfoFormat.SI_EXTENSION.equals(IndexFileNames.getExtension(file)));
        }
 else {
          builder.put(file,new StoreFileMetaData(file,directory.fileLength(file),legacyChecksum,null));
        }
      }
    }
    final String segmentsFile=segmentCommitInfos.getSegmentsFileName();
    String legacyChecksum=checksumMap.get(segmentsFile);
    if (maxVersion.onOrAfter(Version.LUCENE_4_8) && legacyChecksum == null) {
      checksumFromLuceneFile(directory,segmentsFile,builder,logger,maxVersion,true);
    }
 else {
      builder.put(segmentsFile,new StoreFileMetaData(segmentsFile,directory.fileLength(segmentsFile),legacyChecksum,null));
    }
  }
 catch (  CorruptIndexException ex) {
    throw ex;
  }
catch (  FileNotFoundException|NoSuchFileException ex) {
    logger.warn("Can't open file to read checksums",ex);
    return ImmutableMap.of();
  }
catch (  Throwable ex) {
    try {
      Lucene.checkSegmentInfoIntegrity(directory);
    }
 catch (    CorruptIndexException cex) {
      cex.addSuppressed(ex);
      throw cex;
    }
catch (    Throwable e) {
    }
    throw ex;
  }
  return builder.build();
}
