{
  failIfCorrupted();
  metadataLock.writeLock().lock();
  try {
    final Directory dir=directory();
    for (    String existingFile : dir.listAll()) {
      if (!sourceMetaData.contains(existingFile) && !Store.isChecksum(existingFile)) {
        try {
          logDeleteFile(reason,existingFile);
          dir.deleteFile(existingFile);
        }
 catch (        Exception e) {
        }
      }
    }
    final Store.MetadataSnapshot metadataOrEmpty=getMetadata();
    final Store.RecoveryDiff recoveryDiff=metadataOrEmpty.recoveryDiff(sourceMetaData);
    if (recoveryDiff.identical.size() != recoveryDiff.size()) {
      if (recoveryDiff.missing.isEmpty()) {
        for (        StoreFileMetaData meta : recoveryDiff.different) {
          StoreFileMetaData local=metadataOrEmpty.get(meta.name());
          StoreFileMetaData remote=sourceMetaData.get(meta.name());
          boolean consistent=(local.checksum() == null && remote.checksum() == null && local.hash().equals(remote.hash()) && local.length() == remote.length());
          if (consistent == false) {
            throw new ElasticsearchIllegalStateException("local version: " + local + " is different from remote version after recovery: "+ remote,null);
          }
        }
      }
 else {
        logger.debug("Files are missing on the recovery target: {} ",recoveryDiff);
        throw new ElasticsearchIllegalStateException("Files are missing on the recovery target: [different=" + recoveryDiff.different + ", missing="+ recoveryDiff.missing+ ']',null);
      }
    }
  }
  finally {
    metadataLock.writeLock().unlock();
  }
}
