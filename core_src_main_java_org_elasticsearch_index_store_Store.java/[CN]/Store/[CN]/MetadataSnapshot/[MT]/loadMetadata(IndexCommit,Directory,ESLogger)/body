{
  long numDocs;
  Map<String,StoreFileMetaData> builder=new HashMap<>();
  Map<String,String> commitUserDataBuilder=new HashMap<>();
  try {
    final SegmentInfos segmentCommitInfos=Store.readSegmentsInfo(commit,directory);
    numDocs=Lucene.getNumDocs(segmentCommitInfos);
    commitUserDataBuilder.putAll(segmentCommitInfos.getUserData());
    Version maxVersion=segmentCommitInfos.getMinSegmentLuceneVersion();
    for (    SegmentCommitInfo info : segmentCommitInfos) {
      final Version version=info.info.getVersion();
      if (version == null) {
        throw new IllegalArgumentException("expected valid version value: " + info.info.toString());
      }
      if (version.onOrAfter(maxVersion)) {
        maxVersion=version;
      }
      for (      String file : info.files()) {
        if (version.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {
          checksumFromLuceneFile(directory,file,builder,logger,version,SEGMENT_INFO_EXTENSION.equals(IndexFileNames.getExtension(file)));
        }
 else {
          throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: "+ version);
        }
      }
    }
    if (maxVersion == null) {
      maxVersion=StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION;
    }
    final String segmentsFile=segmentCommitInfos.getSegmentsFileName();
    if (maxVersion.onOrAfter(StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION)) {
      checksumFromLuceneFile(directory,segmentsFile,builder,logger,maxVersion,true);
    }
 else {
      throw new IllegalStateException("version must be onOrAfter: " + StoreFileMetaData.FIRST_LUCENE_CHECKSUM_VERSION + " but was: "+ maxVersion);
    }
  }
 catch (  CorruptIndexException|IndexNotFoundException|IndexFormatTooOldException|IndexFormatTooNewException ex) {
    throw ex;
  }
catch (  Exception ex) {
    try {
      logger.warn("failed to build store metadata. checking segment info integrity (with commit [{}])",ex,commit == null ? "no" : "yes");
      Lucene.checkSegmentInfoIntegrity(directory);
    }
 catch (    CorruptIndexException|IndexFormatTooOldException|IndexFormatTooNewException cex) {
      cex.addSuppressed(ex);
      throw cex;
    }
catch (    Exception inner) {
      inner.addSuppressed(ex);
      throw inner;
    }
    throw ex;
  }
  return new LoadedMetadata(unmodifiableMap(builder),unmodifiableMap(commitUserDataBuilder),numDocs);
}
