{
  long numDocs;
  ImmutableMap.Builder<String,StoreFileMetaData> builder=ImmutableMap.builder();
  Map<String,String> checksumMap=readLegacyChecksums(directory).v1();
  ImmutableMap.Builder<String,String> commitUserDataBuilder=ImmutableMap.builder();
  try {
    final SegmentInfos segmentCommitInfos=Store.readSegmentsInfo(commit,directory);
    numDocs=Lucene.getNumDocs(segmentCommitInfos);
    commitUserDataBuilder.putAll(segmentCommitInfos.getUserData());
    Version maxVersion=Version.LUCENE_4_0;
    for (    SegmentCommitInfo info : segmentCommitInfos) {
      final Version version=info.info.getVersion();
      if (version == null) {
        throw new IllegalArgumentException("expected valid version value: " + info.info.toString());
      }
      if (version.onOrAfter(maxVersion)) {
        maxVersion=version;
      }
      for (      String file : info.files()) {
        String legacyChecksum=checksumMap.get(file);
        if (version.onOrAfter(FIRST_LUCENE_CHECKSUM_VERSION)) {
          checksumFromLuceneFile(directory,file,builder,logger,version,SEGMENT_INFO_EXTENSION.equals(IndexFileNames.getExtension(file)));
        }
 else {
          builder.put(file,new StoreFileMetaData(file,directory.fileLength(file),legacyChecksum,version));
        }
      }
    }
    final String segmentsFile=segmentCommitInfos.getSegmentsFileName();
    String legacyChecksum=checksumMap.get(segmentsFile);
    if (maxVersion.onOrAfter(FIRST_LUCENE_CHECKSUM_VERSION)) {
      checksumFromLuceneFile(directory,segmentsFile,builder,logger,maxVersion,true);
    }
 else {
      final BytesRefBuilder fileHash=new BytesRefBuilder();
      final long length;
      try (final IndexInput in=directory.openInput(segmentsFile,IOContext.READONCE)){
        length=in.length();
        hashFile(fileHash,new InputStreamIndexInput(in,length),length);
      }
       builder.put(segmentsFile,new StoreFileMetaData(segmentsFile,length,legacyChecksum,maxVersion,fileHash.get()));
    }
  }
 catch (  CorruptIndexException|IndexNotFoundException|IndexFormatTooOldException|IndexFormatTooNewException ex) {
    throw ex;
  }
catch (  Throwable ex) {
    try {
      logger.warn("failed to build store metadata. checking segment info integrity (with commit [{}])",ex,commit == null ? "no" : "yes");
      Lucene.checkSegmentInfoIntegrity(directory);
    }
 catch (    CorruptIndexException|IndexFormatTooOldException|IndexFormatTooNewException cex) {
      cex.addSuppressed(ex);
      throw cex;
    }
catch (    Throwable e) {
    }
    throw ex;
  }
  return new LoadedMetadata(builder.build(),commitUserDataBuilder.build(),numDocs);
}
