{
  int iterations=atLeast(400);
  for (int iter=0; iter < iterations; iter++) {
    int numClauses=1 + random().nextInt(10);
    FilterClause[] clauses=new FilterClause[numClauses];
    BooleanQuery topLevel=new BooleanQuery();
    BooleanQuery orQuery=new BooleanQuery();
    boolean hasMust=false;
    boolean hasShould=false;
    boolean hasMustNot=false;
    for (int i=0; i < numClauses; i++) {
      int field=random().nextInt(5);
      char value=distinctValues[random().nextInt(distinctValues.length)];
switch (random().nextInt(10)) {
case 9:
case 8:
case 7:
case 6:
case 5:
        hasMust=true;
      if (rarely()) {
        clauses[i]=new FilterClause(new EmptyFilter(),MUST);
        topLevel.add(new BooleanClause(new MatchNoDocsQuery(),MUST));
      }
 else {
        clauses[i]=newFilterClause(field,value,MUST,random().nextBoolean());
        topLevel.add(new BooleanClause(new TermQuery(new Term(String.valueOf(field),String.valueOf(value))),MUST));
      }
    break;
case 4:
case 3:
case 2:
case 1:
  hasShould=true;
if (rarely()) {
  clauses[i]=new FilterClause(new EmptyFilter(),SHOULD);
  orQuery.add(new BooleanClause(new MatchNoDocsQuery(),SHOULD));
}
 else {
  clauses[i]=newFilterClause(field,value,SHOULD,random().nextBoolean());
  orQuery.add(new BooleanClause(new TermQuery(new Term(String.valueOf(field),String.valueOf(value))),SHOULD));
}
break;
case 0:
hasMustNot=true;
if (rarely()) {
clauses[i]=new FilterClause(new EmptyFilter(),MUST_NOT);
topLevel.add(new BooleanClause(new MatchNoDocsQuery(),MUST_NOT));
}
 else {
clauses[i]=newFilterClause(field,value,MUST_NOT,random().nextBoolean());
topLevel.add(new BooleanClause(new TermQuery(new Term(String.valueOf(field),String.valueOf(value))),MUST_NOT));
}
break;
}
}
if (orQuery.getClauses().length > 0) {
topLevel.add(new BooleanClause(orQuery,MUST));
}
if (hasMustNot && !hasMust && !hasShould) {
topLevel.add(new BooleanClause(new MatchAllDocsQuery(),MUST));
}
XBooleanFilter booleanFilter=createBooleanFilter(clauses);
FixedBitSet leftResult=new FixedBitSet(reader.maxDoc());
FixedBitSet rightResult=new FixedBitSet(reader.maxDoc());
DocIdSet left=booleanFilter.getDocIdSet(reader.getContext(),reader.getLiveDocs());
DocIdSet right=new QueryWrapperFilter(topLevel).getDocIdSet(reader.getContext(),reader.getLiveDocs());
if (left == null || right == null) {
if (left == null && right != null) {
assertThat(errorMsg(clauses,topLevel),(right.iterator() == null ? DocIdSetIterator.NO_MORE_DOCS : right.iterator().nextDoc()),equalTo(DocIdSetIterator.NO_MORE_DOCS));
}
if (left != null && right == null) {
assertThat(errorMsg(clauses,topLevel),(left.iterator() == null ? DocIdSetIterator.NO_MORE_DOCS : left.iterator().nextDoc()),equalTo(DocIdSetIterator.NO_MORE_DOCS));
}
}
 else {
DocIdSetIterator leftIter=left.iterator();
DocIdSetIterator rightIter=right.iterator();
if (leftIter != null) {
leftResult.or(leftIter);
}
if (rightIter != null) {
rightResult.or(rightIter);
}
assertThat(leftResult.cardinality(),equalTo(rightResult.cardinality()));
for (int i=0; i < reader.maxDoc(); i++) {
assertThat(errorMsg(clauses,topLevel) + " -- failed at index " + i,leftResult.get(i),equalTo(rightResult.get(i)));
}
}
}
}
