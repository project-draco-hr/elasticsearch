{
  if (event.source().equals(CLUSTER_UPDATE_TASK_SOURCE)) {
    return;
  }
  if (event.state().nodes().localNodeMaster()) {
    if (scheduledRoutingTableFuture == null) {
      routingTableDirty=true;
      scheduledRoutingTableFuture=threadPool.scheduleWithFixedDelay(new RoutingTableUpdater(),schedule);
    }
    if (event.nodesRemoved()) {
      routingTableDirty=true;
      reroute();
    }
 else {
      if (event.nodesAdded()) {
        for (        DiscoveryNode node : event.nodesDelta().addedNodes()) {
          if (node.dataNode()) {
            routingTableDirty=true;
            break;
          }
        }
      }
    }
    long nextDelaySetting=UnassignedInfo.findSmallestDelayedAllocationSetting(settings,event.state());
    if (nextDelaySetting > 0 && nextDelaySetting < registeredNextDelaySetting) {
      FutureUtils.cancel(registeredNextDelayFuture);
      registeredNextDelaySetting=nextDelaySetting;
      TimeValue nextDelay=TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(settings,event.state()));
      logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",UnassignedInfo.getNumberOfDelayedUnassigned(settings,event.state()),nextDelay);
      registeredNextDelayFuture=threadPool.schedule(nextDelay,ThreadPool.Names.SAME,new AbstractRunnable(){
        @Override protected void doRun() throws Exception {
          routingTableDirty=true;
          registeredNextDelaySetting=Long.MAX_VALUE;
          reroute();
        }
        @Override public void onFailure(        Throwable t){
          logger.warn("failed to schedule/execute reroute post unassigned shard",t);
        }
      }
);
    }
 else {
      logger.trace("no need to schedule reroute due to delayed unassigned, next_delay_setting [{}], registered [{}]",nextDelaySetting,registeredNextDelaySetting);
    }
  }
 else {
    FutureUtils.cancel(scheduledRoutingTableFuture);
    scheduledRoutingTableFuture=null;
  }
}
