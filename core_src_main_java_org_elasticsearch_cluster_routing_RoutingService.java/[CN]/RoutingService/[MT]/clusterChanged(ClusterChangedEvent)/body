{
  if (event.source().startsWith(CLUSTER_UPDATE_TASK_SOURCE)) {
    return;
  }
  if (event.state().nodes().localNodeMaster()) {
    long nextDelaySetting=UnassignedInfo.findSmallestDelayedAllocationSetting(settings,event.state());
    if (nextDelaySetting > 0 && nextDelaySetting < registeredNextDelaySetting) {
      FutureUtils.cancel(registeredNextDelayFuture);
      registeredNextDelaySetting=nextDelaySetting;
      TimeValue nextDelay=TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(System.currentTimeMillis(),settings,event.state()));
      int unassignedDelayedShards=UnassignedInfo.getNumberOfDelayedUnassigned(unassignedShardsAllocatedTimestamp,settings,event.state());
      if (unassignedDelayedShards > 0) {
        logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",unassignedDelayedShards,nextDelay);
        registeredNextDelayFuture=threadPool.schedule(nextDelay,ThreadPool.Names.SAME,new AbstractRunnable(){
          @Override protected void doRun() throws Exception {
            registeredNextDelaySetting=Long.MAX_VALUE;
            reroute("assign delayed unassigned shards");
          }
          @Override public void onFailure(          Throwable t){
            logger.warn("failed to schedule/execute reroute post unassigned shard",t);
            registeredNextDelaySetting=Long.MAX_VALUE;
          }
        }
);
      }
    }
 else {
      logger.trace("no need to schedule reroute due to delayed unassigned, next_delay_setting [{}], registered [{}]",nextDelaySetting,registeredNextDelaySetting);
    }
  }
}
