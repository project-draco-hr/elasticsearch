{
  if (event.state().nodes().localNodeMaster()) {
    long nextDelaySetting=UnassignedInfo.findSmallestDelayedAllocationSetting(settings,event.state());
    if (nextDelaySetting > 0 && nextDelaySetting < registeredNextDelaySetting) {
      FutureUtils.cancel(registeredNextDelayFuture);
      registeredNextDelaySetting=nextDelaySetting;
      long nextDelayBasedOnUnassignedShardsAllocatedTimestamp=UnassignedInfo.findNextDelayedAllocationIn(unassignedShardsAllocatedTimestamp,settings,event.state());
      long nextDelayMillis=nextDelayBasedOnUnassignedShardsAllocatedTimestamp - (System.currentTimeMillis() - unassignedShardsAllocatedTimestamp);
      if (nextDelayMillis < 0) {
        nextDelayMillis=0;
      }
      TimeValue nextDelay=TimeValue.timeValueMillis(nextDelayMillis);
      int unassignedDelayedShards=UnassignedInfo.getNumberOfDelayedUnassigned(unassignedShardsAllocatedTimestamp,settings,event.state());
      if (unassignedDelayedShards > 0) {
        logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",unassignedDelayedShards,nextDelay);
        registeredNextDelayFuture=threadPool.schedule(nextDelay,ThreadPool.Names.SAME,new AbstractRunnable(){
          @Override protected void doRun() throws Exception {
            registeredNextDelaySetting=Long.MAX_VALUE;
            reroute("assign delayed unassigned shards");
          }
          @Override public void onFailure(          Throwable t){
            logger.warn("failed to schedule/execute reroute post unassigned shard",t);
            registeredNextDelaySetting=Long.MAX_VALUE;
          }
        }
);
      }
    }
 else {
      logger.trace("no need to schedule reroute due to delayed unassigned, next_delay_setting [{}], registered [{}]",nextDelaySetting,registeredNextDelaySetting);
    }
  }
}
