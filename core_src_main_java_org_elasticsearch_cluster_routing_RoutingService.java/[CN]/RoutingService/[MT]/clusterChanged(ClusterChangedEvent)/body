{
  if (event.source().startsWith(CLUSTER_UPDATE_TASK_SOURCE)) {
    return;
  }
  if (event.state().nodes().localNodeMaster()) {
    long nextDelaySetting=UnassignedInfo.findSmallestDelayedAllocationSetting(settings,event.state());
    if (nextDelaySetting > 0 && nextDelaySetting < registeredNextDelaySetting) {
      FutureUtils.cancel(registeredNextDelayFuture);
      registeredNextDelaySetting=nextDelaySetting;
      TimeValue nextDelay=TimeValue.timeValueMillis(UnassignedInfo.findNextDelayedAllocationIn(settings,event.state()));
      logger.info("delaying allocation for [{}] unassigned shards, next check in [{}]",UnassignedInfo.getNumberOfDelayedUnassigned(settings,event.state()),nextDelay);
      registeredNextDelayFuture=threadPool.schedule(nextDelay,ThreadPool.Names.SAME,new AbstractRunnable(){
        @Override protected void doRun() throws Exception {
          registeredNextDelaySetting=Long.MAX_VALUE;
          reroute("assign delayed unassigned shards");
        }
        @Override public void onFailure(        Throwable t){
          logger.warn("failed to schedule/execute reroute post unassigned shard",t);
        }
      }
);
    }
 else {
      logger.trace("no need to schedule reroute due to delayed unassigned, next_delay_setting [{}], registered [{}]",nextDelaySetting,registeredNextDelaySetting);
    }
  }
}
