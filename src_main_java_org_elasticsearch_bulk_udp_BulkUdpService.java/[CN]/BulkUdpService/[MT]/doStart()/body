{
  if (!enabled) {
    return;
  }
  bulkProcessor=BulkProcessor.builder(client,new BulkListener()).setBulkActions(bulkActions).setBulkSize(bulkSize).setFlushInterval(flushInterval).setConcurrentRequests(concurrentRequests).build();
  bootstrap=new ConnectionlessBootstrap(new NioDatagramChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings,"bulk_udp_worker"))));
  bootstrap.setOption("receiveBufferSize",receiveBufferSize.bytesAsInt());
  bootstrap.setOption("receiveBufferSizePredictorFactory",receiveBufferSizePredictorFactory);
  bootstrap.setOption("broadcast","false");
  bootstrap.setPipelineFactory(new ChannelPipelineFactory(){
    @Override public ChannelPipeline getPipeline() throws Exception {
      return Channels.pipeline(new Handler());
    }
  }
);
  InetAddress hostAddressX;
  try {
    hostAddressX=networkService.resolveBindHostAddress(host);
  }
 catch (  IOException e) {
    logger.warn("failed to resolve host {}",e,host);
    return;
  }
  final InetAddress hostAddress=hostAddressX;
  PortsRange portsRange=new PortsRange(port);
  final AtomicReference<Exception> lastException=new AtomicReference<>();
  boolean success=portsRange.iterate(new PortsRange.PortCallback(){
    @Override public boolean onPortNumber(    int portNumber){
      try {
        channel=bootstrap.bind(new InetSocketAddress(hostAddress,portNumber));
      }
 catch (      Exception e) {
        lastException.set(e);
        return false;
      }
      return true;
    }
  }
);
  if (!success) {
    logger.warn("failed to bind to {}/{}",lastException.get(),hostAddress,port);
    return;
  }
  logger.info("address {}",channel.getLocalAddress());
}
