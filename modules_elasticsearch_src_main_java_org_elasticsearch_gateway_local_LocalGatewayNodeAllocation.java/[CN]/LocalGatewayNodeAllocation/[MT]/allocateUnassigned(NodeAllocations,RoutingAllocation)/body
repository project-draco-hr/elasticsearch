{
  boolean changed=false;
  DiscoveryNodes nodes=allocation.nodes();
  RoutingNodes routingNodes=allocation.routingNodes();
  for (  IndexRoutingTable indexRoutingTable : routingNodes.routingTable()) {
    if (!routingNodes.blocks().hasIndexBlock(indexRoutingTable.index(),LocalGateway.INDEX_NOT_RECOVERED_BLOCK)) {
      continue;
    }
    if (indexRoutingTable.allPrimaryShardsUnassigned()) {
      Set<String> nodesIds=Sets.newHashSet();
      nodesIds.addAll(nodes.dataNodes().keySet());
      TransportNodesListGatewayStartedShards.NodesLocalGatewayStartedShards nodesState=listGatewayStartedShards.list(nodesIds,null).actionGet();
      if (nodesState.failures().length > 0) {
        for (        FailedNodeException failedNodeException : nodesState.failures()) {
          logger.warn("failed to fetch shards state from node",failedNodeException);
        }
      }
      Map<ShardId,Tuple<DiscoveryNode,Long>> shards=Maps.newHashMap();
      TObjectIntHashMap<ShardId> shardsCounts=new ExtTObjectIntHasMap<ShardId>().defaultReturnValue(-1);
      for (      TransportNodesListGatewayStartedShards.NodeLocalGatewayStartedShards nodeState : nodesState) {
        if (nodeState.state() == null) {
          continue;
        }
        for (        Map.Entry<ShardId,Long> entry : nodeState.state().shards().entrySet()) {
          ShardId shardId=entry.getKey();
          if (shardId.index().name().equals(indexRoutingTable.index())) {
            shardsCounts.adjustOrPutValue(shardId,1,1);
            Tuple<DiscoveryNode,Long> t=shards.get(shardId);
            if (t == null || entry.getValue() > t.v2().longValue()) {
              t=new Tuple<DiscoveryNode,Long>(nodeState.node(),entry.getValue());
              shards.put(shardId,t);
            }
          }
        }
      }
      if (shards.size() < indexRoutingTable.shards().size()) {
        moveIndexToIgnoreUnassigned(routingNodes,indexRoutingTable);
      }
 else {
        int requiredNumber=1;
        IndexMetaData indexMetaData=routingNodes.metaData().index(indexRoutingTable.index());
        if ("quorum".equals(initialShards)) {
          if (indexMetaData.numberOfReplicas() > 1) {
            requiredNumber=((1 + indexMetaData.numberOfReplicas()) / 2) + 1;
          }
        }
 else         if ("full".equals(initialShards)) {
          requiredNumber=indexMetaData.numberOfReplicas() + 1;
        }
 else         if ("full-1".equals(initialShards)) {
          if (indexMetaData.numberOfReplicas() > 1) {
            requiredNumber=indexMetaData.numberOfReplicas();
          }
        }
 else {
          requiredNumber=Integer.parseInt(initialShards);
        }
        boolean allocate=true;
        for (TObjectIntIterator<ShardId> it=shardsCounts.iterator(); it.hasNext(); ) {
          it.advance();
          if (it.value() < requiredNumber) {
            allocate=false;
          }
        }
        if (allocate) {
          changed=true;
          for (Iterator<MutableShardRouting> it=routingNodes.unassigned().iterator(); it.hasNext(); ) {
            MutableShardRouting shardRouting=it.next();
            if (shardRouting.index().equals(indexRoutingTable.index())) {
              if (shardRouting.primary()) {
                DiscoveryNode node=shards.get(shardRouting.shardId()).v1();
                logger.debug("[{}][{}] initial allocation to [{}]",shardRouting.index(),shardRouting.id(),node);
                RoutingNode routingNode=routingNodes.node(node.id());
                routingNode.add(shardRouting);
                it.remove();
              }
            }
          }
        }
 else {
          moveIndexToIgnoreUnassigned(routingNodes,indexRoutingTable);
        }
      }
    }
  }
  if (!routingNodes.hasUnassigned()) {
    return changed;
  }
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    boolean canBeAllocatedToAtLeastOneNode=false;
    for (    DiscoveryNode discoNode : nodes.dataNodes().values()) {
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (nodeAllocations.canAllocate(shard,node,allocation).allocate()) {
        canBeAllocatedToAtLeastOneNode=true;
        break;
      }
    }
    if (!canBeAllocatedToAtLeastOneNode) {
      continue;
    }
    ConcurrentMap<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores=buildShardStores(nodes,shard);
    long lastSizeMatched=0;
    DiscoveryNode lastDiscoNodeMatched=null;
    RoutingNode lastNodeMatched=null;
    for (    Map.Entry<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {
      DiscoveryNode discoNode=nodeStoreEntry.getKey();
      TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData=nodeStoreEntry.getValue();
      logger.trace("{}: checking node [{}]",shard,discoNode);
      if (storeFilesMetaData == null) {
        continue;
      }
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (nodeAllocations.canAllocate(shard,node,allocation) == Decision.NO) {
        continue;
      }
      if (storeFilesMetaData.allocated()) {
        continue;
      }
      if (!shard.primary()) {
        MutableShardRouting primaryShard=routingNodes.findPrimaryForReplica(shard);
        if (primaryShard != null && primaryShard.active()) {
          DiscoveryNode primaryNode=nodes.get(primaryShard.currentNodeId());
          if (primaryNode != null) {
            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore=shardStores.get(primaryNode);
            if (primaryNodeStore != null && primaryNodeStore.allocated()) {
              long sizeMatched=0;
              for (              StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
                if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).length() == storeFileMetaData.length()) {
                  sizeMatched+=storeFileMetaData.length();
                }
              }
              if (sizeMatched > lastSizeMatched) {
                lastSizeMatched=sizeMatched;
                lastDiscoNodeMatched=discoNode;
                lastNodeMatched=node;
              }
            }
          }
        }
      }
    }
    if (lastNodeMatched != null) {
      if (nodeAllocations.canAllocate(shard,lastNodeMatched,allocation) == NodeAllocation.Decision.THROTTLE) {
        if (logger.isTraceEnabled()) {
          logger.debug("[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        unassignedIterator.remove();
        routingNodes.ignoredUnassigned().add(shard);
      }
 else {
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        changed=true;
        lastNodeMatched.add(shard);
        unassignedIterator.remove();
      }
    }
  }
  return changed;
}
