{
  boolean changed=false;
  DiscoveryNodes nodes=allocation.nodes();
  RoutingNodes routingNodes=allocation.routingNodes();
  TransportNodesListGatewayStartedShards.NodesLocalGatewayStartedShards nodesState=null;
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    if (!shard.primary()) {
      continue;
    }
    if (!routingNodes.routingTable().index(shard.index()).shard(shard.id()).allocatedPostApi()) {
      continue;
    }
    if (nodesState == null) {
      Set<String> nodesIds=Sets.newHashSet();
      nodesIds.addAll(nodes.dataNodes().keySet());
      nodesState=listGatewayStartedShards.list(nodesIds,null).actionGet();
      if (nodesState.failures().length > 0) {
        StringBuilder sb=new StringBuilder("failures when trying to list started shards on nodes:");
        for (int i=0; i < nodesState.failures().length; i++) {
          Throwable cause=ExceptionsHelper.unwrapCause(nodesState.failures()[i]);
          if (cause instanceof ConnectTransportException) {
            continue;
          }
          sb.append("\n    -> ").append(nodesState.failures()[i].getDetailedMessage());
        }
        logger.warn(sb.toString());
      }
    }
    int numberOfAllocationsFound=0;
    long highestVersion=-1;
    DiscoveryNode nodeWithHighestVersion=null;
    for (    TransportNodesListGatewayStartedShards.NodeLocalGatewayStartedShards nodeState : nodesState) {
      if (nodeState.state() == null) {
        continue;
      }
      if (allocation.shouldIgnoreShardForNode(shard.shardId(),nodeState.node().id())) {
        continue;
      }
      Long version=nodeState.state().shards().get(shard.shardId());
      if (version != null) {
        numberOfAllocationsFound++;
        if (highestVersion == -1) {
          nodeWithHighestVersion=nodeState.node();
          highestVersion=version;
        }
 else {
          if (version > highestVersion) {
            nodeWithHighestVersion=nodeState.node();
            highestVersion=version;
          }
        }
      }
    }
    int requiredAllocation=1;
    IndexMetaData indexMetaData=routingNodes.metaData().index(shard.index());
    if ("quorum".equals(initialShards)) {
      if (indexMetaData.numberOfReplicas() > 1) {
        requiredAllocation=((1 + indexMetaData.numberOfReplicas()) / 2) + 1;
      }
    }
 else     if ("full".equals(initialShards)) {
      requiredAllocation=indexMetaData.numberOfReplicas() + 1;
    }
 else     if ("full-1".equals(initialShards)) {
      if (indexMetaData.numberOfReplicas() > 1) {
        requiredAllocation=indexMetaData.numberOfReplicas();
      }
    }
 else {
      requiredAllocation=Integer.parseInt(initialShards);
    }
    if (numberOfAllocationsFound < requiredAllocation) {
      unassignedIterator.remove();
      routingNodes.ignoredUnassigned().add(shard);
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}]: not allocating, number_of_allocated_shards_found [{}], required_number [{}]",shard.index(),shard.id(),numberOfAllocationsFound,requiredAllocation);
      }
      continue;
    }
    RoutingNode node=routingNodes.node(nodeWithHighestVersion.id());
    if (nodeAllocations.canAllocate(shard,node,allocation) == NodeAllocation.Decision.THROTTLE) {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}]: throttling allocation [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,nodeWithHighestVersion);
      }
      unassignedIterator.remove();
      routingNodes.ignoredUnassigned().add(shard);
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}]: allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,nodeWithHighestVersion);
      }
      changed=true;
      node.add(shard);
      unassignedIterator.remove();
    }
  }
  if (!routingNodes.hasUnassigned()) {
    return changed;
  }
  unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    boolean canBeAllocatedToAtLeastOneNode=false;
    for (    DiscoveryNode discoNode : nodes.dataNodes().values()) {
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (nodeAllocations.canAllocate(shard,node,allocation).allocate()) {
        canBeAllocatedToAtLeastOneNode=true;
        break;
      }
    }
    if (!canBeAllocatedToAtLeastOneNode) {
      continue;
    }
    ConcurrentMap<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores=buildShardStores(nodes,shard);
    long lastSizeMatched=0;
    DiscoveryNode lastDiscoNodeMatched=null;
    RoutingNode lastNodeMatched=null;
    for (    Map.Entry<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {
      DiscoveryNode discoNode=nodeStoreEntry.getKey();
      TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData=nodeStoreEntry.getValue();
      logger.trace("{}: checking node [{}]",shard,discoNode);
      if (storeFilesMetaData == null) {
        continue;
      }
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (nodeAllocations.canAllocate(shard,node,allocation) == Decision.NO) {
        continue;
      }
      if (storeFilesMetaData.allocated()) {
        continue;
      }
      if (!shard.primary()) {
        MutableShardRouting primaryShard=routingNodes.findPrimaryForReplica(shard);
        if (primaryShard != null && primaryShard.active()) {
          DiscoveryNode primaryNode=nodes.get(primaryShard.currentNodeId());
          if (primaryNode != null) {
            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore=shardStores.get(primaryNode);
            if (primaryNodeStore != null && primaryNodeStore.allocated()) {
              long sizeMatched=0;
              for (              StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
                if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).isSame(storeFileMetaData)) {
                  sizeMatched+=storeFileMetaData.length();
                }
              }
              if (sizeMatched > lastSizeMatched) {
                lastSizeMatched=sizeMatched;
                lastDiscoNodeMatched=discoNode;
                lastNodeMatched=node;
              }
            }
          }
        }
      }
    }
    if (lastNodeMatched != null) {
      if (nodeAllocations.canAllocate(shard,lastNodeMatched,allocation) == NodeAllocation.Decision.THROTTLE) {
        if (logger.isTraceEnabled()) {
          logger.debug("[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        unassignedIterator.remove();
        routingNodes.ignoredUnassigned().add(shard);
      }
 else {
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        changed=true;
        lastNodeMatched.add(shard);
        unassignedIterator.remove();
      }
    }
  }
  return changed;
}
