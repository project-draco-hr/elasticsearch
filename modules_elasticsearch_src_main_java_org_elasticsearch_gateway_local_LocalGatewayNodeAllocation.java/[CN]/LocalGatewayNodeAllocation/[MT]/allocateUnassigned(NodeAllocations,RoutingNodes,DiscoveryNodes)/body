{
  boolean changed=false;
  for (  IndexRoutingTable indexRoutingTable : routingNodes.routingTable()) {
    if (!routingNodes.blocks().hasIndexBlock(indexRoutingTable.index(),LocalGateway.INDEX_NOT_RECOVERED_BLOCK)) {
      continue;
    }
    if (indexRoutingTable.allPrimaryShardsUnassigned()) {
      Set<String> nodesIds=Sets.newHashSet();
      nodesIds.addAll(nodes.dataNodes().keySet());
      nodesIds.addAll(nodes.masterNodes().keySet());
      TransportNodesListGatewayState.NodesLocalGatewayState nodesState=listGatewayState.list(nodesIds,null).actionGet();
      Map<ShardId,Tuple<DiscoveryNode,Long>> shards=Maps.newHashMap();
      for (      TransportNodesListGatewayState.NodeLocalGatewayState nodeState : nodesState) {
        for (        Map.Entry<ShardId,Long> entry : nodeState.state().shards().entrySet()) {
          if (entry.getKey().index().name().equals(indexRoutingTable.index())) {
            Tuple<DiscoveryNode,Long> t=shards.get(entry.getKey());
            if (t == null || entry.getValue() > t.v2().longValue()) {
              t=new Tuple<DiscoveryNode,Long>(nodeState.node(),entry.getValue());
              shards.put(entry.getKey(),t);
            }
          }
        }
      }
      if (shards.size() < indexRoutingTable.shards().size()) {
        for (Iterator<MutableShardRouting> it=routingNodes.unassigned().iterator(); it.hasNext(); ) {
          MutableShardRouting shardRouting=it.next();
          if (shardRouting.index().equals(indexRoutingTable.index())) {
            it.remove();
            routingNodes.ignoredUnassigned().add(shardRouting);
          }
        }
      }
 else {
        changed=true;
        for (Iterator<MutableShardRouting> it=routingNodes.unassigned().iterator(); it.hasNext(); ) {
          MutableShardRouting shardRouting=it.next();
          if (shardRouting.primary()) {
            DiscoveryNode node=shards.get(shardRouting.shardId()).v1();
            logger.debug("[{}][{}] initial allocation to [{}]",shardRouting.index(),shardRouting.id(),node);
            RoutingNode routingNode=routingNodes.node(node.id());
            routingNode.add(shardRouting);
            it.remove();
          }
        }
      }
    }
  }
  if (!routingNodes.hasUnassigned()) {
    return changed;
  }
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    InternalIndexService indexService=(InternalIndexService)indicesService.indexService(shard.index());
    if (indexService == null) {
      continue;
    }
    if (!indexService.store().persistent()) {
      continue;
    }
    boolean canBeAllocatedToAtLeastOneNode=false;
    for (    DiscoveryNode discoNode : nodes.dataNodes().values()) {
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (nodeAllocations.canAllocate(shard,node,routingNodes).allocate()) {
        canBeAllocatedToAtLeastOneNode=true;
        break;
      }
    }
    if (!canBeAllocatedToAtLeastOneNode) {
      continue;
    }
    ConcurrentMap<DiscoveryNode,IndexStore.StoreFilesMetaData> shardStores=buildShardStores(nodes,shard);
    long lastSizeMatched=0;
    DiscoveryNode lastDiscoNodeMatched=null;
    RoutingNode lastNodeMatched=null;
    for (    Map.Entry<DiscoveryNode,IndexStore.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {
      DiscoveryNode discoNode=nodeStoreEntry.getKey();
      IndexStore.StoreFilesMetaData storeFilesMetaData=nodeStoreEntry.getValue();
      logger.trace("{}: checking node [{}]",shard,discoNode);
      if (storeFilesMetaData == null) {
        continue;
      }
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (nodeAllocations.canAllocate(shard,node,routingNodes) == Decision.NO) {
        continue;
      }
      if (storeFilesMetaData.allocated()) {
        continue;
      }
      if (!shard.primary()) {
        MutableShardRouting primaryShard=routingNodes.findPrimaryForReplica(shard);
        if (primaryShard != null && primaryShard.active()) {
          DiscoveryNode primaryNode=nodes.get(primaryShard.currentNodeId());
          if (primaryNode != null) {
            IndexStore.StoreFilesMetaData primaryNodeStore=shardStores.get(primaryNode);
            if (primaryNodeStore != null && primaryNodeStore.allocated()) {
              long sizeMatched=0;
              for (              StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
                if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).length() == storeFileMetaData.length()) {
                  sizeMatched+=storeFileMetaData.length();
                }
              }
              if (sizeMatched > lastSizeMatched) {
                lastSizeMatched=sizeMatched;
                lastDiscoNodeMatched=discoNode;
                lastNodeMatched=node;
              }
            }
          }
        }
      }
    }
    if (lastNodeMatched != null) {
      if (nodeAllocations.canAllocate(shard,lastNodeMatched,routingNodes) == NodeAllocation.Decision.THROTTLE) {
        if (logger.isTraceEnabled()) {
          logger.debug("[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        unassignedIterator.remove();
        routingNodes.ignoredUnassigned().add(shard);
      }
 else {
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        changed=true;
        lastNodeMatched.add(shard);
        unassignedIterator.remove();
      }
    }
  }
  return changed;
}
