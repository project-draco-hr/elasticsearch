{
  Settings.Builder updatedSettingsBuilder=Settings.settingsBuilder();
  updatedSettingsBuilder.put(request.settings()).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX);
  request.settings(updatedSettingsBuilder.build());
  clusterService.submitStateUpdateTask("create-index [" + request.index() + "], cause ["+ request.cause()+ "]",Priority.URGENT,new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request,listener){
    @Override protected ClusterStateUpdateResponse newResponse(    boolean acknowledged){
      return new ClusterStateUpdateResponse(acknowledged);
    }
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      boolean indexCreated=false;
      String removalReason=null;
      try {
        validate(request,currentState);
        for (        Alias alias : request.aliases()) {
          aliasValidator.validateAlias(alias,request.index(),currentState.metaData());
        }
        List<IndexTemplateMetaData> templates=findTemplates(request,currentState,indexTemplateFilter);
        Map<String,Custom> customs=new HashMap<>();
        Map<String,Map<String,Object>> mappings=new HashMap<>();
        Map<String,AliasMetaData> templatesAliases=new HashMap<>();
        List<String> templateNames=new ArrayList<>();
        for (        Map.Entry<String,String> entry : request.mappings().entrySet()) {
          mappings.put(entry.getKey(),parseMapping(entry.getValue()));
        }
        for (        Map.Entry<String,Custom> entry : request.customs().entrySet()) {
          customs.put(entry.getKey(),entry.getValue());
        }
        for (        IndexTemplateMetaData template : templates) {
          templateNames.add(template.getName());
          for (          ObjectObjectCursor<String,CompressedXContent> cursor : template.mappings()) {
            if (mappings.containsKey(cursor.key)) {
              XContentHelper.mergeDefaults(mappings.get(cursor.key),parseMapping(cursor.value.string()));
            }
 else {
              mappings.put(cursor.key,parseMapping(cursor.value.string()));
            }
          }
          for (          ObjectObjectCursor<String,Custom> cursor : template.customs()) {
            String type=cursor.key;
            IndexMetaData.Custom custom=cursor.value;
            IndexMetaData.Custom existing=customs.get(type);
            if (existing == null) {
              customs.put(type,custom);
            }
 else {
              IndexMetaData.Custom merged=existing.mergeWith(custom);
              customs.put(type,merged);
            }
          }
          for (          ObjectObjectCursor<String,AliasMetaData> cursor : template.aliases()) {
            AliasMetaData aliasMetaData=cursor.value;
            if (request.aliases().contains(new Alias(aliasMetaData.alias()))) {
              continue;
            }
            if (templatesAliases.containsKey(cursor.key)) {
              continue;
            }
            if (aliasMetaData.alias().contains("{index}")) {
              String templatedAlias=aliasMetaData.alias().replace("{index}",request.index());
              aliasMetaData=AliasMetaData.newAliasMetaData(aliasMetaData,templatedAlias);
            }
            aliasValidator.validateAliasMetaData(aliasMetaData,request.index(),currentState.metaData());
            templatesAliases.put(aliasMetaData.alias(),aliasMetaData);
          }
        }
        Settings.Builder indexSettingsBuilder=settingsBuilder();
        for (int i=templates.size() - 1; i >= 0; i--) {
          indexSettingsBuilder.put(templates.get(i).settings());
        }
        indexSettingsBuilder.put(request.settings());
        if (request.index().equals(ScriptService.SCRIPT_INDEX)) {
          indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,1));
        }
 else {
          if (indexSettingsBuilder.get(SETTING_NUMBER_OF_SHARDS) == null) {
            indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,5));
          }
        }
        if (request.index().equals(ScriptService.SCRIPT_INDEX)) {
          indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,0));
          indexSettingsBuilder.put(SETTING_AUTO_EXPAND_REPLICAS,"0-all");
        }
 else {
          if (indexSettingsBuilder.get(SETTING_NUMBER_OF_REPLICAS) == null) {
            indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,1));
          }
        }
        if (settings.get(SETTING_AUTO_EXPAND_REPLICAS) != null && indexSettingsBuilder.get(SETTING_AUTO_EXPAND_REPLICAS) == null) {
          indexSettingsBuilder.put(SETTING_AUTO_EXPAND_REPLICAS,settings.get(SETTING_AUTO_EXPAND_REPLICAS));
        }
        if (indexSettingsBuilder.get(SETTING_VERSION_CREATED) == null) {
          DiscoveryNodes nodes=currentState.nodes();
          final Version createdVersion=Version.smallest(version,nodes.smallestNonClientNodeVersion());
          indexSettingsBuilder.put(SETTING_VERSION_CREATED,createdVersion);
        }
        if (indexSettingsBuilder.get(SETTING_CREATION_DATE) == null) {
          indexSettingsBuilder.put(SETTING_CREATION_DATE,new DateTime(DateTimeZone.UTC).getMillis());
        }
        indexSettingsBuilder.put(SETTING_INDEX_UUID,Strings.randomBase64UUID());
        Settings actualIndexSettings=indexSettingsBuilder.build();
        final IndexMetaData tmpImd=IndexMetaData.builder(request.index()).settings(actualIndexSettings).build();
        indicesService.createIndex(tmpImd,Collections.EMPTY_LIST);
        indexCreated=true;
        IndexService indexService=indicesService.indexServiceSafe(request.index());
        MapperService mapperService=indexService.mapperService();
        if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {
          try {
            mapperService.merge(MapperService.DEFAULT_MAPPING,new CompressedXContent(XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string()),false,request.updateAllTypes());
          }
 catch (          Exception e) {
            removalReason="failed on parsing default mapping on index creation";
            throw new MapperParsingException("Failed to parse mapping [{}]: {}",e,MapperService.DEFAULT_MAPPING,e.getMessage());
          }
        }
        for (        Map.Entry<String,Map<String,Object>> entry : mappings.entrySet()) {
          if (entry.getKey().equals(MapperService.DEFAULT_MAPPING)) {
            continue;
          }
          try {
            mapperService.merge(entry.getKey(),new CompressedXContent(XContentFactory.jsonBuilder().map(entry.getValue()).string()),true,request.updateAllTypes());
          }
 catch (          Exception e) {
            removalReason="failed on parsing mappings on index creation";
            throw new MapperParsingException("Failed to parse mapping [{}]: {}",e,entry.getKey(),e.getMessage());
          }
        }
        IndexQueryParserService indexQueryParserService=indexService.queryParserService();
        for (        Alias alias : request.aliases()) {
          if (Strings.hasLength(alias.filter())) {
            aliasValidator.validateAliasFilter(alias.name(),alias.filter(),indexQueryParserService);
          }
        }
        for (        AliasMetaData aliasMetaData : templatesAliases.values()) {
          if (aliasMetaData.filter() != null) {
            aliasValidator.validateAliasFilter(aliasMetaData.alias(),aliasMetaData.filter().uncompressed(),indexQueryParserService);
          }
        }
        Map<String,MappingMetaData> mappingsMetaData=new HashMap<>();
        for (        DocumentMapper mapper : mapperService.docMappers(true)) {
          MappingMetaData mappingMd=new MappingMetaData(mapper);
          mappingsMetaData.put(mapper.type(),mappingMd);
        }
        final IndexMetaData.Builder indexMetaDataBuilder=IndexMetaData.builder(request.index()).settings(actualIndexSettings);
        for (        MappingMetaData mappingMd : mappingsMetaData.values()) {
          indexMetaDataBuilder.putMapping(mappingMd);
        }
        for (        AliasMetaData aliasMetaData : templatesAliases.values()) {
          indexMetaDataBuilder.putAlias(aliasMetaData);
        }
        for (        Alias alias : request.aliases()) {
          AliasMetaData aliasMetaData=AliasMetaData.builder(alias.name()).filter(alias.filter()).indexRouting(alias.indexRouting()).searchRouting(alias.searchRouting()).build();
          indexMetaDataBuilder.putAlias(aliasMetaData);
        }
        for (        Map.Entry<String,Custom> customEntry : customs.entrySet()) {
          indexMetaDataBuilder.putCustom(customEntry.getKey(),customEntry.getValue());
        }
        indexMetaDataBuilder.state(request.state());
        final IndexMetaData indexMetaData;
        try {
          indexMetaData=indexMetaDataBuilder.build();
        }
 catch (        Exception e) {
          removalReason="failed to build index metadata";
          throw e;
        }
        indexService.getIndexEventListener().beforeIndexAddedToCluster(new Index(request.index()),indexMetaData.getSettings());
        MetaData newMetaData=MetaData.builder(currentState.metaData()).put(indexMetaData,false).build();
        String maybeShadowIndicator=IndexMetaData.isIndexUsingShadowReplicas(indexMetaData.getSettings()) ? "s" : "";
        logger.info("[{}] creating index, cause [{}], templates {}, shards [{}]/[{}{}], mappings {}",request.index(),request.cause(),templateNames,indexMetaData.getNumberOfShards(),indexMetaData.getNumberOfReplicas(),maybeShadowIndicator,mappings.keySet());
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        if (!request.blocks().isEmpty()) {
          for (          ClusterBlock block : request.blocks()) {
            blocks.addIndexBlock(request.index(),block);
          }
        }
        blocks.updateBlocks(indexMetaData);
        ClusterState updatedState=ClusterState.builder(currentState).blocks(blocks).metaData(newMetaData).build();
        if (request.state() == State.OPEN) {
          RoutingTable.Builder routingTableBuilder=RoutingTable.builder(updatedState.routingTable()).addAsNew(updatedState.metaData().index(request.index()));
          RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder(updatedState).routingTable(routingTableBuilder.build()).build());
          updatedState=ClusterState.builder(updatedState).routingResult(routingResult).build();
        }
        removalReason="cleaning up after validating index on master";
        return updatedState;
      }
  finally {
        if (indexCreated) {
          indicesService.removeIndex(request.index(),removalReason != null ? removalReason : "failed to create index");
        }
      }
    }
  }
);
}
