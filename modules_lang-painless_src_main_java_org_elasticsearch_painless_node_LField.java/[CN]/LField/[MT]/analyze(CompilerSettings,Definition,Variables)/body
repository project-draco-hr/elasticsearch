{
  if (before == null) {
    throw new IllegalStateException(error("Illegal tree structure."));
  }
  final Sort sort=before.sort;
  if (sort == Sort.ARRAY) {
    return new LArrayLength(location,value).copy(this).analyze(settings,definition,variables);
  }
 else   if (sort == Sort.DEF) {
    return new LDefField(location,value).copy(this).analyze(settings,definition,variables);
  }
  final Struct struct=before.struct;
  field=statik ? struct.statics.get(value) : struct.members.get(value);
  if (field != null) {
    if (store && java.lang.reflect.Modifier.isFinal(field.reflect.getModifiers())) {
      throw new IllegalArgumentException(error("Cannot write to read-only field [" + value + "] for type ["+ struct.name+ "]."));
    }
    after=field.type;
    return this;
  }
 else {
    final boolean shortcut=struct.methods.containsKey("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1)) || struct.methods.containsKey("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1));
    if (shortcut) {
      return new LShortcut(location,value).copy(this).analyze(settings,definition,variables);
    }
 else {
      final EConstant index=new EConstant(location,value);
      index.analyze(settings,definition,variables);
      try {
        before.clazz.asSubclass(Map.class);
        return new LMapShortcut(location,index).copy(this).analyze(settings,definition,variables);
      }
 catch (      final ClassCastException exception) {
      }
      try {
        before.clazz.asSubclass(List.class);
        return new LListShortcut(location,index).copy(this).analyze(settings,definition,variables);
      }
 catch (      final ClassCastException exception) {
      }
    }
  }
  throw new IllegalArgumentException(error("Unknown field [" + value + "] for type ["+ struct.name+ "]."));
}
