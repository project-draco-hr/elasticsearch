{
  if (before == null) {
    throw new IllegalStateException(error("Illegal tree structure."));
  }
  final Sort sort=before.sort;
  if (sort == Sort.ARRAY) {
    return new LArrayLength(line,location,value).copy(this).analyze(settings,variables);
  }
 else   if (sort == Sort.DEF) {
    return new LDefField(line,location,value).copy(this).analyze(settings,variables);
  }
  final Struct struct=before.struct;
  field=statik ? struct.staticMembers.get(value) : struct.members.get(value);
  if (field != null) {
    if (store && java.lang.reflect.Modifier.isFinal(field.reflect.getModifiers())) {
      throw new IllegalArgumentException(error("Cannot write to read-only field [" + value + "] for type ["+ struct.name+ "]."));
    }
    after=field.type;
    return this;
  }
 else {
    final boolean shortcut=struct.methods.containsKey(new Definition.MethodKey("get" + Character.toUpperCase(value.charAt(0)) + value.substring(1),0)) || struct.methods.containsKey(new Definition.MethodKey("set" + Character.toUpperCase(value.charAt(0)) + value.substring(1),1));
    if (shortcut) {
      return new LShortcut(line,location,value).copy(this).analyze(settings,variables);
    }
 else {
      final EConstant index=new EConstant(line,location,value);
      index.analyze(settings,variables);
      if (Map.class.isAssignableFrom(before.clazz)) {
        return new LMapShortcut(line,location,index).copy(this).analyze(settings,variables);
      }
      if (List.class.isAssignableFrom(before.clazz)) {
        return new LListShortcut(line,location,index).copy(this).analyze(settings,variables);
      }
    }
  }
  throw new IllegalArgumentException(error("Unknown field [" + value + "] for type ["+ struct.name+ "]."));
}
