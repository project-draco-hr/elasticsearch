{
class RetryHelper extends AbstractRunnable implements ActionListener<SearchResponse> {
    private final Iterator<TimeValue> retries=backoffPolicy.iterator();
    private volatile int retryCount=0;
    @Override protected void doRun() throws Exception {
      action.accept(this);
    }
    @Override public void onResponse(    SearchResponse response){
      onResponse.accept(response);
    }
    @Override public void onFailure(    Exception e){
      if (ExceptionsHelper.unwrap(e,EsRejectedExecutionException.class) != null) {
        if (retries.hasNext()) {
          retryCount+=1;
          TimeValue delay=retries.next();
          logger.trace("retrying rejected search after [{}]",e,delay);
          countSearchRetry.run();
          threadPool.schedule(delay,ThreadPool.Names.SAME,this);
        }
 else {
          logger.warn("giving up on search because we retried [{}] times without success",e,retryCount);
          fail.accept(e);
        }
      }
 else {
        logger.warn("giving up on search because it failed with a non-retryable exception",e);
        fail.accept(e);
      }
    }
  }
  new RetryHelper().run();
}
