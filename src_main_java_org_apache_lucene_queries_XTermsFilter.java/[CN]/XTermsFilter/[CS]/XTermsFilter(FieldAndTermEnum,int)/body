{
  int hash=9;
  byte[] serializedTerms=new byte[0];
  this.offsets=new int[length + 1];
  int lastEndOffset=0;
  int index=0;
  ArrayList<TermsAndField> termsAndFields=new ArrayList<>();
  TermsAndField lastTermsAndField=null;
  BytesRef previousTerm=null;
  String previousField=null;
  BytesRef currentTerm;
  String currentField;
  while ((currentTerm=iter.next()) != null) {
    currentField=iter.field();
    if (currentField == null) {
      throw new IllegalArgumentException("Field must not be null");
    }
    if (previousField != null) {
      if (previousField.equals(currentField)) {
        if (previousTerm.bytesEquals(currentTerm)) {
          continue;
        }
      }
 else {
        final int start=lastTermsAndField == null ? 0 : lastTermsAndField.end;
        lastTermsAndField=new TermsAndField(start,index,previousField);
        termsAndFields.add(lastTermsAndField);
      }
    }
    hash=PRIME * hash + currentField.hashCode();
    hash=PRIME * hash + currentTerm.hashCode();
    if (serializedTerms.length < lastEndOffset + currentTerm.length) {
      serializedTerms=ArrayUtil.grow(serializedTerms,lastEndOffset + currentTerm.length);
    }
    System.arraycopy(currentTerm.bytes,currentTerm.offset,serializedTerms,lastEndOffset,currentTerm.length);
    offsets[index]=lastEndOffset;
    lastEndOffset+=currentTerm.length;
    index++;
    previousTerm=currentTerm;
    previousField=currentField;
  }
  offsets[index]=lastEndOffset;
  final int start=lastTermsAndField == null ? 0 : lastTermsAndField.end;
  lastTermsAndField=new TermsAndField(start,index,previousField);
  termsAndFields.add(lastTermsAndField);
  this.termsBytes=ArrayUtil.shrink(serializedTerms,lastEndOffset);
  this.termsAndFields=termsAndFields.toArray(new TermsAndField[termsAndFields.size()]);
  this.hashCode=hash;
}
