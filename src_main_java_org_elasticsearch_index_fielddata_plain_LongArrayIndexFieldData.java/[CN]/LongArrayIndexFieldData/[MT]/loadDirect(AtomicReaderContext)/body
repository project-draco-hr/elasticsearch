{
  AtomicReader reader=context.reader();
  Terms terms=reader.terms(getFieldNames().indexName());
  if (terms == null) {
    return LongArrayAtomicFieldData.EMPTY;
  }
  final TLongArrayList values=new TLongArrayList();
  values.add(0);
  OrdinalsBuilder builder=new OrdinalsBuilder(terms,reader.maxDoc());
  try {
    BytesRefIterator iter=builder.buildFromTerms(builder.wrapNumeric64Bit(terms.iterator(null)),reader.getLiveDocs());
    BytesRef term;
    long max=Long.MIN_VALUE;
    long min=Long.MAX_VALUE;
    while ((term=iter.next()) != null) {
      long value=NumericUtils.prefixCodedToLong(term);
      values.add(value);
      if (value > max) {
        max=value;
      }
      if (value < min) {
        min=value;
      }
    }
    Ordinals build=builder.build(fieldDataType.getSettings());
    if (fieldDataType.getSettings().getAsBoolean("optimize_type",true)) {
      if (min >= Byte.MIN_VALUE && max <= Byte.MAX_VALUE) {
        return ByteArrayIndexFieldData.build(reader,fieldDataType,builder,build,new ByteArrayIndexFieldData.BuilderBytes(){
          @Override public byte get(          int index){
            return (byte)values.get(index);
          }
          @Override public byte[] toArray(){
            byte[] bValues=new byte[values.size()];
            int i=0;
            for (TLongIterator it=values.iterator(); it.hasNext(); ) {
              bValues[i++]=(byte)it.next();
            }
            return bValues;
          }
        }
);
      }
 else       if (min >= Short.MIN_VALUE && max <= Short.MAX_VALUE) {
        return ShortArrayIndexFieldData.build(reader,fieldDataType,builder,build,new ShortArrayIndexFieldData.BuilderShorts(){
          @Override public short get(          int index){
            return (short)values.get(index);
          }
          @Override public short[] toArray(){
            short[] sValues=new short[values.size()];
            int i=0;
            for (TLongIterator it=values.iterator(); it.hasNext(); ) {
              sValues[i++]=(short)it.next();
            }
            return sValues;
          }
        }
);
      }
 else       if (min >= Integer.MIN_VALUE && max <= Integer.MAX_VALUE) {
        return IntArrayIndexFieldData.build(reader,fieldDataType,builder,build,new IntArrayIndexFieldData.BuilderIntegers(){
          @Override public int get(          int index){
            return (int)values.get(index);
          }
          @Override public int[] toArray(){
            int[] iValues=new int[values.size()];
            int i=0;
            for (TLongIterator it=values.iterator(); it.hasNext(); ) {
              iValues[i++]=(int)it.next();
            }
            return iValues;
          }
        }
);
      }
    }
    if (!build.isMultiValued() && CommonSettings.removeOrdsOnSingleValue(fieldDataType)) {
      Docs ordinals=build.ordinals();
      long[] sValues=new long[reader.maxDoc()];
      int maxDoc=reader.maxDoc();
      for (int i=0; i < maxDoc; i++) {
        sValues[i]=values.get(ordinals.getOrd(i));
      }
      final FixedBitSet set=builder.buildDocsWithValuesSet();
      if (set == null) {
        return new LongArrayAtomicFieldData.Single(sValues,reader.maxDoc());
      }
 else {
        return new LongArrayAtomicFieldData.SingleFixedSet(sValues,reader.maxDoc(),set);
      }
    }
 else {
      return new LongArrayAtomicFieldData.WithOrdinals(values.toArray(),reader.maxDoc(),build);
    }
  }
  finally {
    builder.close();
  }
}
