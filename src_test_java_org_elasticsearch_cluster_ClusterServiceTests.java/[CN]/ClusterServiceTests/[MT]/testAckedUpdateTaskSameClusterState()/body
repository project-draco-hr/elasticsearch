{
  Settings settings=settingsBuilder().put("discovery.type","local").build();
  internalCluster().startNode(settings);
  ClusterService clusterService=internalCluster().getInstance(ClusterService.class);
  final AtomicBoolean allNodesAcked=new AtomicBoolean(false);
  final AtomicBoolean ackTimeout=new AtomicBoolean(false);
  final AtomicBoolean onFailure=new AtomicBoolean(false);
  final AtomicBoolean executed=new AtomicBoolean(false);
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch processedLatch=new CountDownLatch(1);
  clusterService.submitStateUpdateTask("test",new AckedClusterStateUpdateTask<Void>(null,null){
    @Override protected Void newResponse(    boolean acknowledged){
      return null;
    }
    @Override public void onAllNodesAcked(    @Nullable Throwable t){
      allNodesAcked.set(true);
      latch.countDown();
    }
    @Override public void onAckTimeout(){
      ackTimeout.set(true);
      latch.countDown();
    }
    @Override public TimeValue ackTimeout(){
      return TimeValue.timeValueSeconds(10);
    }
    @Override public TimeValue timeout(){
      return TimeValue.timeValueSeconds(10);
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      processedLatch.countDown();
    }
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      executed.set(true);
      return currentState;
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("failed to execute callback in test {}",t,source);
      onFailure.set(true);
      latch.countDown();
    }
  }
);
  assertThat(latch.await(1,TimeUnit.SECONDS),equalTo(true));
  assertThat(allNodesAcked.get(),equalTo(true));
  assertThat(ackTimeout.get(),equalTo(false));
  assertThat(executed.get(),equalTo(true));
  assertThat(onFailure.get(),equalTo(false));
  assertThat(processedLatch.await(1,TimeUnit.SECONDS),equalTo(true));
}
