{
  XContentParser parser=parseContext.parser();
  PhraseSuggestionBuilder suggestion=new PhraseSuggestionBuilder(suggestionName);
  ParseFieldMatcher parseFieldMatcher=parseContext.parseFieldMatcher();
  XContentParser.Token token;
  String fieldName=null;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      fieldName=parser.currentName();
    }
 else     if (token.isValue()) {
      if (parseFieldMatcher.match(fieldName,SuggestionBuilder.ANALYZER_FIELD)) {
        suggestion.analyzer(parser.text());
      }
 else       if (parseFieldMatcher.match(fieldName,SuggestionBuilder.FIELDNAME_FIELD)) {
        suggestion.field(parser.text());
      }
 else       if (parseFieldMatcher.match(fieldName,SuggestionBuilder.SIZE_FIELD)) {
        suggestion.size(parser.intValue());
      }
 else       if (parseFieldMatcher.match(fieldName,SuggestionBuilder.SHARDSIZE_FIELD)) {
        suggestion.shardSize(parser.intValue());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.RWE_LIKELIHOOD_FIELD)) {
        suggestion.realWordErrorLikelihood(parser.floatValue());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.CONFIDENCE_FIELD)) {
        suggestion.confidence(parser.floatValue());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.SEPARATOR_FIELD)) {
        suggestion.separator(parser.text());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.MAXERRORS_FIELD)) {
        suggestion.maxErrors(parser.floatValue());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.GRAMSIZE_FIELD)) {
        suggestion.gramSize(parser.intValue());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.FORCE_UNIGRAM_FIELD)) {
        suggestion.forceUnigrams(parser.booleanValue());
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.TOKEN_LIMIT_FIELD)) {
        suggestion.tokenLimit(parser.intValue());
      }
 else {
        throw new IllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
      }
    }
 else     if (token == Token.START_ARRAY) {
      if (parseFieldMatcher.match(fieldName,DirectCandidateGeneratorBuilder.DIRECT_GENERATOR_FIELD)) {
        while ((token=parser.nextToken()) == Token.START_OBJECT) {
          suggestion.addCandidateGenerator(DirectCandidateGeneratorBuilder.PROTOTYPE.fromXContent(parseContext));
        }
      }
 else {
        throw new IllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
      }
    }
 else     if (token == Token.START_OBJECT) {
      if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.SMOOTHING_MODEL_FIELD)) {
        ensureNoSmoothing(suggestion);
        suggestion.smoothingModel(SmoothingModel.fromXContent(parseContext));
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.HIGHLIGHT_FIELD)) {
        String preTag=null;
        String postTag=null;
        while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
 else           if (token.isValue()) {
            if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.PRE_TAG_FIELD)) {
              preTag=parser.text();
            }
 else             if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.POST_TAG_FIELD)) {
              postTag=parser.text();
            }
 else {
              throw new IllegalArgumentException("suggester[phrase][highlight] doesn't support field [" + fieldName + "]");
            }
          }
        }
        suggestion.highlight(preTag,postTag);
      }
 else       if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.COLLATE_FIELD)) {
        while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            fieldName=parser.currentName();
          }
 else           if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.COLLATE_QUERY_FIELD)) {
            if (suggestion.collateQuery() != null) {
              throw new IllegalArgumentException("suggester[phrase][collate] query already set, doesn't support additional [" + fieldName + "]");
            }
            Template template=Template.parse(parser,parseFieldMatcher);
            suggestion.collateQuery(template);
          }
 else           if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.COLLATE_QUERY_PARAMS)) {
            suggestion.collateParams(parser.map());
          }
 else           if (parseFieldMatcher.match(fieldName,PhraseSuggestionBuilder.COLLATE_QUERY_PRUNE)) {
            if (parser.isBooleanValue()) {
              suggestion.collatePrune(parser.booleanValue());
            }
 else {
              throw new IllegalArgumentException("suggester[phrase][collate] prune must be either 'true' or 'false'");
            }
          }
 else {
            throw new IllegalArgumentException("suggester[phrase][collate] doesn't support field [" + fieldName + "]");
          }
        }
      }
 else {
        throw new IllegalArgumentException("suggester[phrase]  doesn't support array field [" + fieldName + "]");
      }
    }
 else {
      throw new IllegalArgumentException("suggester[phrase] doesn't support field [" + fieldName + "]");
    }
  }
  return suggestion;
}
