{
  Preconditions.checkArgument(locations != null,"Locations must not be null");
  Preconditions.checkArgument(locations.length > 0,"One or more locations required");
  String fileName=prefix + version + STATE_FILE_EXTENSION;
  Path stateLocation=Paths.get(locations[0].getPath(),STATE_DIR_NAME);
  Files.createDirectories(stateLocation);
  final Path tmpStatePath=stateLocation.resolve(fileName + ".tmp");
  final Path finalStatePath=stateLocation.resolve(fileName);
  try {
    try (OutputStreamIndexOutput out=new OutputStreamIndexOutput(Files.newOutputStream(tmpStatePath),BUFFER_SIZE)){
      CodecUtil.writeHeader(out,STATE_FILE_CODEC,STATE_FILE_VERSION);
      out.writeInt(format.index());
      out.writeLong(version);
      try (XContentBuilder builder=newXContentBuilder(format,new org.elasticsearch.common.lucene.store.OutputStreamIndexOutput(out){
        @Override public void close() throws IOException {
        }
      }
)){
        builder.startObject();
{
          toXContent(builder,state);
        }
        builder.endObject();
      }
       CodecUtil.writeFooter(out);
    }
     IOUtils.fsync(tmpStatePath,false);
    Files.move(tmpStatePath,finalStatePath,StandardCopyOption.ATOMIC_MOVE);
    IOUtils.fsync(stateLocation,true);
    for (int i=1; i < locations.length; i++) {
      stateLocation=Paths.get(locations[i].getPath(),STATE_DIR_NAME);
      Files.createDirectories(stateLocation);
      Path tmpPath=stateLocation.resolve(fileName + ".tmp");
      Path finalPath=stateLocation.resolve(fileName);
      try {
        Files.copy(finalStatePath,tmpPath);
        Files.move(tmpPath,finalPath,StandardCopyOption.ATOMIC_MOVE);
        IOUtils.fsync(stateLocation,true);
      }
  finally {
        Files.deleteIfExists(tmpPath);
      }
    }
  }
  finally {
    Files.deleteIfExists(tmpStatePath);
  }
  if (deleteOldFiles) {
    cleanupOldFiles(prefix,fileName,locations);
  }
}
