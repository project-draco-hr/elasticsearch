{
  int numDocs=scaledRandomIntBetween(100,1000);
  internalCluster().ensureAtLeastNumDataNodes(3);
  if (cluster().numDataNodes() == 3) {
    logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten");
  }
  assertThat(cluster().numDataNodes(),greaterThanOrEqualTo(3));
  assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,"1").put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,"1").put(MergePolicyModule.MERGE_POLICY_TYPE_KEY,NoMergePolicyProvider.class).put(MockFSDirectoryService.CHECK_INDEX_ON_CLOSE,false).put(TranslogService.INDEX_TRANSLOG_DISABLE_FLUSH,true).put("indices.recovery.concurrent_streams",10)));
  ensureGreen();
  disableAllocation("test");
  IndexRequestBuilder[] builders=new IndexRequestBuilder[numDocs];
  for (int i=0; i < builders.length; i++) {
    builders[i]=client().prepareIndex("test","type").setSource("field","value");
  }
  indexRandom(true,builders);
  ensureGreen();
  assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).setWaitIfOngoing(true).execute().actionGet());
  CountResponse countResponse=client().prepareCount().get();
  assertHitCount(countResponse,numDocs);
  final int numShards=numShards("test");
  ShardRouting corruptedShardRouting=corruptRandomPrimaryFile();
  logger.info("--> {} corrupted",corruptedShardRouting);
  enableAllocation("test");
  Settings build=ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,"2").build();
  client().admin().indices().prepareUpdateSettings("test").setSettings(build).get();
  ClusterHealthResponse health=client().admin().cluster().health(Requests.clusterHealthRequest("test").waitForGreenStatus().timeout("5m").waitForRelocatingShards(0)).actionGet();
  if (health.isTimedOut()) {
    logger.info("cluster state:\n{}\n{}",client().admin().cluster().prepareState().get().getState().prettyPrint(),client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());
    assertThat("timed out waiting for green state",health.isTimedOut(),equalTo(false));
  }
  assertThat(health.getStatus(),equalTo(ClusterHealthStatus.GREEN));
  final int numIterations=scaledRandomIntBetween(5,20);
  for (int i=0; i < numIterations; i++) {
    SearchResponse response=client().prepareSearch().setSize(numDocs).get();
    assertHitCount(response,numDocs);
  }
  final CountDownLatch latch=new CountDownLatch(numShards * 3);
  final CopyOnWriteArrayList<Throwable> exception=new CopyOnWriteArrayList<>();
  final IndicesLifecycle.Listener listener=new IndicesLifecycle.Listener(){
    @Override public void afterIndexShardClosed(    ShardId sid,    @Nullable IndexShard indexShard,    @IndexSettings Settings indexSettings){
      if (indexShard != null) {
        Store store=((IndexShard)indexShard).store();
        store.incRef();
        try {
          if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {
            return;
          }
          try (CheckIndex checkIndex=new CheckIndex(store.directory())){
            BytesStreamOutput os=new BytesStreamOutput();
            PrintStream out=new PrintStream(os,false,Charsets.UTF_8.name());
            checkIndex.setInfoStream(out);
            out.flush();
            CheckIndex.Status status=checkIndex.checkIndex();
            if (!status.clean) {
              logger.warn("check index [failure]\n{}",new String(os.bytes().toBytes(),Charsets.UTF_8));
              throw new IndexShardException(sid,"index check failure");
            }
          }
         }
 catch (        Throwable t) {
          exception.add(t);
        }
 finally {
          store.decRef();
          latch.countDown();
        }
      }
    }
  }
;
  for (  IndicesService service : internalCluster().getDataNodeInstances(IndicesService.class)) {
    service.indicesLifecycle().addListener(listener);
  }
  try {
    client().admin().indices().prepareDelete("test").get();
    latch.await();
    assertThat(exception,empty());
  }
  finally {
    for (    IndicesService service : internalCluster().getDataNodeInstances(IndicesService.class)) {
      service.indicesLifecycle().removeListener(listener);
    }
  }
}
