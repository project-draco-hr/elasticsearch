{
  ClusterState state=client().admin().cluster().prepareState().get().getState();
  GroupShardsIterator shardIterators=state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"},false);
  ShardIterator shardIterator=RandomPicks.randomFrom(getRandom(),shardIterators.iterators());
  ShardRouting shardRouting=shardIterator.nextOrNull();
  assertNotNull(shardRouting);
  assertTrue(shardRouting.primary());
  assertTrue(shardRouting.assignedToNode());
  String nodeId=shardRouting.currentNodeId();
  NodesStatsResponse nodeStatses=client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get();
  Set<File> files=new TreeSet<>();
  for (  FsStats.Info info : nodeStatses.getNodes()[0].getFs()) {
    String path=info.getPath();
    final String relativeDataLocationPath="indices/test/" + Integer.toString(shardRouting.getId()) + "/index";
    File file=new File(path,relativeDataLocationPath);
    files.addAll(Arrays.asList(file.listFiles(new FileFilter(){
      @Override public boolean accept(      File pathname){
        if (pathname.isFile() && "write.lock".equals(pathname.getName()) == false) {
          return (includePerCommitFiles || isPerSegmentFile(pathname.getName()));
        }
        return false;
      }
    }
)));
  }
  pruneOldDeleteGenerations(files);
  File fileToCorrupt=null;
  if (!files.isEmpty()) {
    fileToCorrupt=RandomPicks.randomFrom(getRandom(),files);
    try (Directory dir=FSDirectory.open(fileToCorrupt.getParentFile())){
      long checksumBeforeCorruption;
      try (IndexInput input=dir.openInput(fileToCorrupt.getName(),IOContext.DEFAULT)){
        checksumBeforeCorruption=CodecUtil.retrieveChecksum(input);
      }
       try (RandomAccessFile raf=new RandomAccessFile(fileToCorrupt,"rw")){
        raf.seek(randomIntBetween(0,(int)Math.min(Integer.MAX_VALUE,raf.length() - 1)));
        long filePointer=raf.getFilePointer();
        byte b=raf.readByte();
        raf.seek(filePointer);
        raf.writeByte(~b);
        raf.getFD().sync();
        logger.info("Corrupting file for shard {} --  flipping at position {} from {} to {} file: {}",shardRouting,filePointer,Integer.toHexString(b),Integer.toHexString(~b),fileToCorrupt.getName());
      }
       long checksumAfterCorruption;
      long actualChecksumAfterCorruption;
      try (ChecksumIndexInput input=dir.openChecksumInput(fileToCorrupt.getName(),IOContext.DEFAULT)){
        assertThat(input.getFilePointer(),is(0l));
        input.seek(input.length() - 8);
        checksumAfterCorruption=input.getChecksum();
        actualChecksumAfterCorruption=input.readLong();
      }
       StringBuilder msg=new StringBuilder();
      msg.append("Checksum before: [").append(checksumBeforeCorruption).append("]");
      msg.append(" after: [").append(checksumAfterCorruption).append("]");
      msg.append(" checksum value after corruption: ").append(actualChecksumAfterCorruption).append("]");
      msg.append(" file: ").append(fileToCorrupt.getName()).append(" length: ").append(dir.fileLength(fileToCorrupt.getName()));
      logger.info(msg.toString());
      assumeTrue("Checksum collision - " + msg.toString(),checksumAfterCorruption != checksumBeforeCorruption || actualChecksumAfterCorruption != checksumBeforeCorruption);
    }
   }
  assertThat("no file corrupted",fileToCorrupt,notNullValue());
  return shardRouting;
}
