{
  ClusterState state=client().admin().cluster().prepareState().get().getState();
  GroupShardsIterator shardIterators=state.getRoutingNodes().getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"},false);
  List<ShardIterator> iterators=iterableAsArrayList(shardIterators);
  ShardIterator shardIterator=RandomPicks.randomFrom(getRandom(),iterators);
  ShardRouting shardRouting=shardIterator.nextOrNull();
  assertNotNull(shardRouting);
  assertTrue(shardRouting.primary());
  assertTrue(shardRouting.assignedToNode());
  String nodeId=shardRouting.currentNodeId();
  NodesStatsResponse nodeStatses=client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get();
  Set<Path> files=new TreeSet<>();
  for (  FsInfo.Path info : nodeStatses.getNodes()[0].getFs()) {
    String path=info.getPath();
    final String relativeDataLocationPath="indices/test/" + Integer.toString(shardRouting.getId()) + "/index";
    Path file=PathUtils.get(path).resolve(relativeDataLocationPath);
    if (Files.exists(file)) {
      try (DirectoryStream<Path> stream=Files.newDirectoryStream(file)){
        for (        Path item : stream) {
          if (Files.isRegularFile(item) && "write.lock".equals(item.getFileName().toString()) == false) {
            if (includePerCommitFiles || isPerSegmentFile(item.getFileName().toString())) {
              files.add(item);
            }
          }
        }
      }
     }
  }
  pruneOldDeleteGenerations(files);
  CorruptionUtils.corruptFile(getRandom(),files.toArray(new Path[0]));
  return shardRouting;
}
