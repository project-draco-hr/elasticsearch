{
  Pattern pattern=null;
  if (regex != null) {
    pattern=Regex.compile(regex,null);
  }
  List<Tuple<Text,Integer>> entries=new ArrayList<Tuple<Text,Integer>>();
  for (  Map.Entry<String,Integer> e : controlFacets.entrySet()) {
    if (excludes.contains(e.getKey())) {
      continue;
    }
    if (pattern != null && !pattern.matcher(e.getKey()).matches()) {
      continue;
    }
    entries.add(new Tuple<Text,Integer>(new StringText(e.getKey()),e.getValue()));
  }
  if (allTerms) {
    for (    String field1Value : field1Values) {
      if (!controlFacets.containsKey(field1Value)) {
        if (excludes.contains(field1Value)) {
          continue;
        }
        if (pattern != null && !pattern.matcher(field1Value).matches()) {
          continue;
        }
        entries.add(new Tuple<Text,Integer>(new StringText(field1Value),0));
      }
    }
  }
switch (sort) {
case COUNT:
    Collections.sort(entries,count);
  break;
case REVERSE_COUNT:
Collections.sort(entries,count_reverse);
break;
case TERM:
Collections.sort(entries,term);
break;
case REVERSE_TERM:
Collections.sort(entries,term_reverse);
break;
}
return size >= entries.size() ? entries : entries.subList(0,size);
}
