{
  indexShard.prepareForIndexRecovery();
  long version=-1;
  final Set<String> typesToUpdate;
  SegmentInfos si=null;
  indexShard.store().incRef();
  try {
    try {
      indexShard.store().failIfCorrupted();
      try {
        si=Lucene.readSegmentInfos(indexShard.store().directory());
      }
 catch (      Throwable e) {
        String files="_unknown_";
        try {
          files=Arrays.toString(indexShard.store().directory().listAll());
        }
 catch (        Throwable e1) {
          files+=" (failure=" + ExceptionsHelper.detailedMessage(e1) + ")";
        }
        if (indexShouldExists) {
          throw new IndexShardGatewayRecoveryException(shardId(),"shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files,e);
        }
      }
      if (si != null) {
        if (indexShouldExists) {
          version=si.getVersion();
        }
 else {
          logger.trace("cleaning existing shard, shouldn't exists");
          IndexWriter writer=new IndexWriter(indexShard.store().directory(),new IndexWriterConfig(Lucene.STANDARD_ANALYZER).setOpenMode(IndexWriterConfig.OpenMode.CREATE));
          writer.close();
          recoveryState.getTranslog().totalOperations(0);
        }
      }
    }
 catch (    Throwable e) {
      throw new IndexShardGatewayRecoveryException(shardId(),"failed to fetch index version after copying it over",e);
    }
    recoveryState.getIndex().updateVersion(version);
    try {
      final RecoveryState.Index index=recoveryState.getIndex();
      if (si != null) {
        final Directory directory=indexShard.store().directory();
        for (        String name : Lucene.files(si)) {
          long length=directory.fileLength(name);
          index.addFileDetail(name,length,true);
        }
      }
    }
 catch (    IOException e) {
      logger.debug("failed to list file details",e);
    }
    if (indexShouldExists == false) {
      recoveryState.getTranslog().totalOperations(0);
      recoveryState.getTranslog().totalOperationsOnStart(0);
    }
    typesToUpdate=indexShard.performTranslogRecovery();
    indexShard.finalizeRecovery();
    indexShard.postRecovery("post recovery from gateway");
  }
 catch (  EngineException e) {
    throw new IndexShardGatewayRecoveryException(shardId,"failed to recovery from gateway",e);
  }
 finally {
    indexShard.store().decRef();
  }
  for (  final String type : typesToUpdate) {
    final CountDownLatch latch=new CountDownLatch(1);
    mappingUpdatedAction.updateMappingOnMaster(indexService.index().name(),indexService.mapperService().documentMapper(type),indexService.indexUUID(),new MappingUpdatedAction.MappingUpdateListener(){
      @Override public void onMappingUpdate(){
        latch.countDown();
      }
      @Override public void onFailure(      Throwable t){
        latch.countDown();
        logger.debug("failed to send mapping update post recovery to master for [{}]",t,type);
      }
    }
);
    cancellableThreads.execute(new CancellableThreads.Interruptable(){
      @Override public void run() throws InterruptedException {
        try {
          if (latch.await(waitForMappingUpdatePostRecovery.millis(),TimeUnit.MILLISECONDS) == false) {
            logger.debug("waited for mapping update on master for [{}], yet timed out",type);
          }
        }
 catch (        InterruptedException e) {
          logger.debug("interrupted while waiting for mapping update");
          throw e;
        }
      }
    }
);
  }
}
