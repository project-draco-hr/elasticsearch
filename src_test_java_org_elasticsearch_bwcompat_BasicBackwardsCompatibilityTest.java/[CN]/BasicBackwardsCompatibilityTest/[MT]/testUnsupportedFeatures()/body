{
  if (compatibilityVersion().before(Version.V_1_3_0)) {
    XContentBuilder mapping=XContentBuilder.builder(JsonXContent.jsonXContent).startObject().startObject("type").startObject(FieldNamesFieldMapper.NAME).field("index",randomFrom("no","not_analyzed")).field("store",randomFrom("no","yes")).endObject().endObject().endObject();
    try {
      assertAcked(prepareCreate("test").setSettings(ImmutableSettings.builder().put("index.routing.allocation.exclude._name",backwardsCluster().newNodePattern()).put(indexSettings())).addMapping("type",mapping));
    }
 catch (    MapperParsingException ex) {
      if (getMasterVersion().onOrAfter(Version.V_1_3_0)) {
        assertThat(ex.getCause(),instanceOf(ElasticsearchIllegalArgumentException.class));
        assertThat(ex.getCause().getMessage(),equalTo("type=_field_names is not supported on indices created before version 1.3.0 is your cluster running multiple datanode versions?"));
      }
 else {
        assertThat(ex.getCause(),instanceOf(MapperParsingException.class));
        assertThat(ex.getCause().getMessage(),startsWith("Root type mapping not empty after parsing!"));
      }
    }
  }
}
