{
  if (nodesIds.length == 0) {
    threadPool.generic().execute(new Runnable(){
      @Override public void run(){
        listener.onResponse(newResponse(request,responses));
      }
    }
);
    return;
  }
  TransportRequestOptions transportRequestOptions=TransportRequestOptions.options();
  if (request.timeout() != null) {
    transportRequestOptions.withTimeout(request.timeout());
  }
  transportRequestOptions.withCompress(transportCompress());
  for (int i=0; i < nodesIds.length; i++) {
    final String nodeId=nodesIds[i];
    final int idx=i;
    final DiscoveryNode node=clusterState.nodes().nodes().get(nodeId);
    try {
      if (node == null) {
        onFailure(idx,nodeId,new NoSuchNodeException(nodeId));
      }
 else       if (!clusterService.localNode().shouldConnectTo(node) && !clusterService.localNode().equals(node)) {
        onFailure(idx,nodeId,new NodeShouldNotConnectException(clusterService.localNode(),node));
      }
 else {
        NodeRequest nodeRequest=newNodeRequest(nodeId,request);
        transportService.sendRequest(node,transportNodeAction,nodeRequest,transportRequestOptions,new BaseTransportResponseHandler<NodeResponse>(){
          @Override public NodeResponse newInstance(){
            return newNodeResponse();
          }
          @Override public void handleResponse(          NodeResponse response){
            onOperation(idx,response);
          }
          @Override public void handleException(          TransportException exp){
            onFailure(idx,node.id(),exp);
          }
          @Override public String executor(){
            return ThreadPool.Names.SAME;
          }
        }
);
      }
    }
 catch (    Throwable t) {
      onFailure(idx,nodeId,t);
    }
  }
}
