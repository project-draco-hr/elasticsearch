{
  try {
switch (operation.opType()) {
case INDEX:
      Translog.Index index=(Translog.Index)operation;
    Engine.Index engineIndex=IndexShard.prepareIndex(docMapper(index.type()),source(shardId.getIndexName(),index.type(),index.id(),index.source()).routing(index.routing()).parent(index.parent()).timestamp(index.timestamp()).ttl(index.ttl()),index.version(),index.versionType().versionTypeForReplicationAndRecovery(),Engine.Operation.Origin.RECOVERY);
  maybeAddMappingUpdate(engineIndex.type(),engineIndex.parsedDoc().dynamicMappingsUpdate(),engineIndex.id(),allowMappingUpdates);
if (logger.isTraceEnabled()) {
  logger.trace("[translog] recover [index] op of [{}][{}]",index.type(),index.id());
}
index(engine,engineIndex);
break;
case DELETE:
Translog.Delete delete=(Translog.Delete)operation;
Uid uid=Uid.createUid(delete.uid().text());
if (logger.isTraceEnabled()) {
logger.trace("[translog] recover [delete] op of [{}][{}]",uid.type(),uid.id());
}
final Engine.Delete engineDelete=new Engine.Delete(uid.type(),uid.id(),delete.uid(),delete.version(),delete.versionType().versionTypeForReplicationAndRecovery(),Engine.Operation.Origin.RECOVERY,System.nanoTime(),false);
delete(engine,engineDelete);
break;
default :
throw new IllegalStateException("No operation defined for [" + operation + "]");
}
}
 catch (ElasticsearchException e) {
boolean hasIgnoreOnRecoveryException=false;
ElasticsearchException current=e;
while (true) {
if (current instanceof IgnoreOnRecoveryEngineException) {
hasIgnoreOnRecoveryException=true;
break;
}
if (current.getCause() instanceof ElasticsearchException) {
current=(ElasticsearchException)current.getCause();
}
 else {
break;
}
}
if (!hasIgnoreOnRecoveryException) {
throw e;
}
}
operationProcessed();
}
