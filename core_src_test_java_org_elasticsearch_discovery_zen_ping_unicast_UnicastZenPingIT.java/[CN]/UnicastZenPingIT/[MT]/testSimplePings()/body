{
  Settings settings=Settings.EMPTY;
  int startPort=11000 + randomIntBetween(0,1000);
  int endPort=startPort + 10;
  settings=Settings.builder().put(settings).put(TransportSettings.PORT.getKey(),startPort + "-" + endPort).build();
  ThreadPool threadPool=new ThreadPool(getClass().getName());
  ClusterName clusterName=new ClusterName("test");
  NetworkService networkService=new NetworkService(settings);
  ElectMasterService electMasterService=new ElectMasterService(settings,Version.CURRENT);
  NettyTransport transportA=new NettyTransport(settings,threadPool,networkService,BigArrays.NON_RECYCLING_INSTANCE,Version.CURRENT,new NamedWriteableRegistry(),new NoneCircuitBreakerService());
  final TransportService transportServiceA=new TransportService(transportA,threadPool).start();
  transportServiceA.acceptIncomingRequests();
  final DiscoveryNode nodeA=new DiscoveryNode("UZP_A",transportServiceA.boundAddress().publishAddress(),emptyMap(),emptySet(),Version.CURRENT);
  InetSocketTransportAddress addressA=(InetSocketTransportAddress)transportA.boundAddress().publishAddress();
  NettyTransport transportB=new NettyTransport(settings,threadPool,networkService,BigArrays.NON_RECYCLING_INSTANCE,Version.CURRENT,new NamedWriteableRegistry(),new NoneCircuitBreakerService());
  final TransportService transportServiceB=new TransportService(transportB,threadPool).start();
  transportServiceB.acceptIncomingRequests();
  final DiscoveryNode nodeB=new DiscoveryNode("UZP_B",transportServiceA.boundAddress().publishAddress(),emptyMap(),emptySet(),Version.CURRENT);
  InetSocketTransportAddress addressB=(InetSocketTransportAddress)transportB.boundAddress().publishAddress();
  Settings hostsSettings=Settings.builder().putArray("discovery.zen.ping.unicast.hosts",NetworkAddress.format(new InetSocketAddress(addressA.address().getAddress(),addressA.address().getPort())),NetworkAddress.format(new InetSocketAddress(addressB.address().getAddress(),addressB.address().getPort()))).build();
  UnicastZenPing zenPingA=new UnicastZenPing(hostsSettings,threadPool,transportServiceA,clusterName,Version.CURRENT,electMasterService,null);
  zenPingA.setPingContextProvider(new PingContextProvider(){
    @Override public DiscoveryNodes nodes(){
      return DiscoveryNodes.builder().put(nodeA).localNodeId("UZP_A").build();
    }
    @Override public boolean nodeHasJoinedClusterOnce(){
      return false;
    }
  }
);
  zenPingA.start();
  UnicastZenPing zenPingB=new UnicastZenPing(hostsSettings,threadPool,transportServiceB,clusterName,Version.CURRENT,electMasterService,null);
  zenPingB.setPingContextProvider(new PingContextProvider(){
    @Override public DiscoveryNodes nodes(){
      return DiscoveryNodes.builder().put(nodeB).localNodeId("UZP_B").build();
    }
    @Override public boolean nodeHasJoinedClusterOnce(){
      return true;
    }
  }
);
  zenPingB.start();
  try {
    logger.info("ping from UZP_A");
    ZenPing.PingResponse[] pingResponses=zenPingA.pingAndWait(TimeValue.timeValueSeconds(10));
    assertThat(pingResponses.length,equalTo(1));
    assertThat(pingResponses[0].node().getId(),equalTo("UZP_B"));
    assertTrue(pingResponses[0].hasJoinedOnce());
    logger.info("ping from UZP_B");
    pingResponses=zenPingB.pingAndWait(TimeValue.timeValueSeconds(10));
    assertThat(pingResponses.length,equalTo(1));
    assertThat(pingResponses[0].node().getId(),equalTo("UZP_A"));
    assertFalse(pingResponses[0].hasJoinedOnce());
  }
  finally {
    zenPingA.close();
    zenPingB.close();
    transportServiceA.close();
    transportServiceB.close();
    terminate(threadPool);
  }
}
