{
  final CountDownLatch latch=new CountDownLatch(1);
  final Gateway.GatewayStateRecoveredListener recoveryListener=new GatewayRecoveryListener(latch);
  if (!ignoreTimeout && recoverAfterTime != null) {
    if (scheduledRecovery.compareAndSet(false,true)) {
      logger.debug("delaying initial state recovery for [{}]",recoverAfterTime);
      threadPool.schedule(new Runnable(){
        @Override public void run(){
          if (recovered.compareAndSet(false,true)) {
            gateway.performStateRecovery(recoveryListener);
          }
        }
      }
,recoverAfterTime);
    }
  }
 else {
    if (recovered.compareAndSet(false,true)) {
      gateway.performStateRecovery(recoveryListener);
    }
  }
  if (timeout != null) {
    try {
      latch.await(timeout.millis(),TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new ElasticSearchInterruptedException(e.getMessage(),e);
    }
  }
}
