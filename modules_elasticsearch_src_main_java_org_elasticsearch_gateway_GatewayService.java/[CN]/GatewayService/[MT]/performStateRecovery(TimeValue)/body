{
  final CountDownLatch latch=new CountDownLatch(1);
  final Gateway.GatewayStateRecoveredListener recoveryListener=new Gateway.GatewayStateRecoveredListener(){
    @Override public void onSuccess(){
      markMetaDataAsReadFromGateway("success");
      latch.countDown();
    }
    @Override public void onFailure(    Throwable t){
      markMetaDataAsReadFromGateway("failure [" + t.getMessage() + "]");
      latch.countDown();
    }
  }
;
  if (recoverAfterTime != null) {
    updateClusterStateBlockedOnNotRecovered();
    logger.debug("delaying initial state recovery for [{}]",recoverAfterTime);
    threadPool.schedule(new Runnable(){
      @Override public void run(){
        gateway.performStateRecovery(recoveryListener);
      }
    }
,recoverAfterTime);
  }
 else {
    gateway.performStateRecovery(recoveryListener);
  }
  if (timeout != null) {
    try {
      latch.await(timeout.millis(),TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new ElasticSearchInterruptedException(e.getMessage(),e);
    }
  }
}
