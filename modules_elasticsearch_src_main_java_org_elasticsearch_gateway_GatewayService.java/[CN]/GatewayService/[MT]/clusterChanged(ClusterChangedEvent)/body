{
  if (!lifecycle.started()) {
    return;
  }
  if (event.localNodeMaster()) {
    if (!event.state().metaData().recoveredFromGateway()) {
      ClusterState clusterState=event.state();
      DiscoveryNodes nodes=clusterState.nodes();
      if (recoverAfterNodes != -1 && (nodes.masterAndDataNodes().size()) < recoverAfterNodes) {
        logger.debug("not recovering from gateway, nodes_size (data+master) [" + nodes.masterAndDataNodes().size() + "] < recover_after_nodes ["+ recoverAfterNodes+ "]");
      }
 else       if (recoverAfterDataNodes != -1 && nodes.dataNodes().size() < recoverAfterDataNodes) {
        logger.debug("not recovering from gateway, nodes_size (data) [" + nodes.dataNodes().size() + "] < recover_after_data_nodes ["+ recoverAfterDataNodes+ "]");
      }
 else       if (recoverAfterMasterNodes != -1 && nodes.masterNodes().size() < recoverAfterMasterNodes) {
        logger.debug("not recovering from gateway, nodes_size (master) [" + nodes.masterNodes().size() + "] < recover_after_master_nodes ["+ recoverAfterMasterNodes+ "]");
      }
 else {
        boolean ignoreTimeout;
        if (expectedNodes == -1 && expectedMasterNodes == -1 && expectedDataNodes == -1) {
          ignoreTimeout=false;
        }
 else {
          ignoreTimeout=true;
          if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) {
            ignoreTimeout=false;
          }
          if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) {
            ignoreTimeout=false;
          }
          if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) {
            ignoreTimeout=false;
          }
        }
        final boolean fIgnoreTimeout=ignoreTimeout;
        threadPool.cached().execute(new Runnable(){
          @Override public void run(){
            performStateRecovery(null,fIgnoreTimeout);
          }
        }
);
      }
    }
 else {
      for (      Map.Entry<String,ImmutableSet<ClusterBlock>> entry : event.state().blocks().indices().entrySet()) {
        final String index=entry.getKey();
        ImmutableSet<ClusterBlock> indexBlocks=entry.getValue();
        if (indexBlocks.contains(GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {
          IndexRoutingTable indexRoutingTable=event.state().routingTable().index(index);
          if (indexRoutingTable != null && indexRoutingTable.allPrimaryShardsActive()) {
            clusterService.submitStateUpdateTask("remove-index-block (all primary shards active for [" + index + "])",new ClusterStateUpdateTask(){
              @Override public ClusterState execute(              ClusterState currentState){
                if (!currentState.blocks().hasIndexBlock(index,GatewayService.INDEX_NOT_RECOVERED_BLOCK)) {
                  return currentState;
                }
                ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
                blocks.removeIndexBlock(index,GatewayService.INDEX_NOT_RECOVERED_BLOCK);
                return ClusterState.builder().state(currentState).blocks(blocks).build();
              }
            }
);
          }
        }
      }
    }
  }
}
