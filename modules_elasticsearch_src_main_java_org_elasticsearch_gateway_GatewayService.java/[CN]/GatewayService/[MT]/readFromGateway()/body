{
  logger.debug("First master in the cluster, reading state from gateway");
  executor.execute(new Runnable(){
    @Override public void run(){
      MetaData metaData;
      try {
        metaData=gateway.read();
      }
 catch (      Exception e) {
        logger.error("Failed to read from gateway",e);
        return;
      }
      if (metaData == null) {
        logger.debug("No state read from gateway");
        return;
      }
      final MetaData fMetaData=metaData;
      clusterService.submitStateUpdateTask("gateway (recovered meta-data)",new ClusterStateUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState){
          MetaData.Builder metaDataBuilder=newMetaDataBuilder().metaData(currentState.metaData()).maxNumberOfShardsPerNode(fMetaData.maxNumberOfShardsPerNode());
          for (          final IndexMetaData indexMetaData : fMetaData) {
            threadPool.execute(new Runnable(){
              @Override public void run(){
                final CountDownLatch latch=new CountDownLatch(1);
                ClusterStateListener waitForIndex=new ClusterStateListener(){
                  @Override public void clusterChanged(                  ClusterChangedEvent event){
                    if (event.state().metaData().hasIndex(indexMetaData.index())) {
                      latch.countDown();
                    }
                  }
                }
;
                clusterService.add(waitForIndex);
                try {
                  metaDataService.createIndex(indexMetaData.index(),indexMetaData.settings(),timeValueMillis(10));
                }
 catch (                Exception e) {
                  latch.countDown();
                  logger.error("Failed to create index [" + indexMetaData.index() + "]",e);
                }
                try {
                  latch.await(5,TimeUnit.MINUTES);
                }
 catch (                InterruptedException e) {
                  logger.warn("Interrupted while waiting for index creation in gateway recovery");
                }
                clusterService.remove(waitForIndex);
                for (                Map.Entry<String,String> entry : indexMetaData.mappings().entrySet()) {
                  try {
                    metaDataService.putMapping(new String[]{indexMetaData.index()},entry.getKey(),entry.getValue(),true,timeValueMillis(10));
                  }
 catch (                  Exception e) {
                    logger.error("Failed to put mapping [" + entry.getKey() + "] for index ["+ indexMetaData.index()+ "]",e);
                  }
                }
              }
            }
);
          }
          return newClusterStateBuilder().state(currentState).metaData(metaDataBuilder).build();
        }
      }
);
    }
  }
);
}
