{
  gateway.start();
  this.executor=newSingleThreadExecutor(daemonThreadFactory(settings,"gateway"));
  if (discoveryService.initialStateReceived()) {
    ClusterState clusterState=clusterService.state();
    if (clusterState.nodes().localNodeMaster() && !clusterState.metaData().recoveredFromGateway()) {
      if (recoverAfterNodes != -1 && clusterState.nodes().dataNodes().size() < recoverAfterNodes) {
        updateClusterStateBlockedOnNotRecovered();
        logger.debug("not recovering from gateway, data_nodes_size [" + clusterState.nodes().dataNodes().size() + "] < recover_after_nodes ["+ recoverAfterNodes+ "]");
      }
 else {
        if (readFromGateway.compareAndSet(false,true)) {
          Boolean waited=readFromGateway(initialStateTimeout);
          if (waited != null && !waited) {
            logger.warn("waited for {} for indices to be created from the gateway, and not all have been created",initialStateTimeout);
          }
        }
      }
    }
  }
 else {
    logger.debug("can't wait on start for (possibly) reading state from gateway, will do it asynchronously");
  }
  clusterService.add(this);
}
