{
  final Loading defaultLoading=Loading.parse(indexMetaData.settings().get(NORMS_LOADING_KEY),Loading.LAZY);
  final MapperService mapperService=indexShard.mapperService();
  final ObjectSet<String> warmUp=new ObjectOpenHashSet<>();
  for (  DocumentMapper docMapper : mapperService.docMappers(false)) {
    for (    FieldMapper<?> fieldMapper : docMapper.mappers()) {
      final String indexName=fieldMapper.names().indexName();
      if (fieldMapper.fieldType().indexed() && !fieldMapper.fieldType().omitNorms() && fieldMapper.normsLoading(defaultLoading) == Loading.EAGER) {
        warmUp.add(indexName);
      }
    }
  }
  final CountDownLatch latch=new CountDownLatch(1);
  threadPool.executor(executor()).execute(new Runnable(){
    @Override public void run(){
      try {
        for (Iterator<ObjectCursor<String>> it=warmUp.iterator(); it.hasNext(); ) {
          final String indexName=it.next().value;
          final long start=System.nanoTime();
          for (          final AtomicReaderContext ctx : context.searcher().reader().leaves()) {
            final NumericDocValues values=ctx.reader().getNormValues(indexName);
            if (values != null) {
              values.get(0);
            }
          }
          if (indexShard.warmerService().logger().isTraceEnabled()) {
            indexShard.warmerService().logger().trace("warmed norms for [{}], took [{}]",indexName,TimeValue.timeValueNanos(System.nanoTime() - start));
          }
        }
      }
 catch (      Throwable t) {
        indexShard.warmerService().logger().warn("failed to warm-up norms",t);
      }
 finally {
        latch.countDown();
      }
    }
  }
);
  return new TerminationHandle(){
    @Override public void awaitTermination() throws InterruptedException {
      latch.await();
    }
  }
;
}
