{
  boolean changed=false;
  DiscoveryNodes nodes=allocation.nodes();
  RoutingNodes routingNodes=allocation.routingNodes();
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    if (!shard.primary()) {
      continue;
    }
    if (!routingNodes.routingTable().index(shard.index()).shard(shard.id()).primaryAllocatedPostApi()) {
      continue;
    }
    ObjectLongOpenHashMap<DiscoveryNode> nodesState=buildShardStates(nodes,shard);
    int numberOfAllocationsFound=0;
    long highestVersion=-1;
    Set<DiscoveryNode> nodesWithHighestVersion=Sets.newHashSet();
    final boolean[] states=nodesState.allocated;
    final Object[] keys=nodesState.keys;
    final long[] values=nodesState.values;
    for (int i=0; i < states.length; i++) {
      if (!states[i]) {
        continue;
      }
      DiscoveryNode node=(DiscoveryNode)keys[i];
      long version=values[i];
      if (allocation.shouldIgnoreShardForNode(shard.shardId(),node.id())) {
        continue;
      }
      if (version != -1) {
        numberOfAllocationsFound++;
        if (highestVersion == -1) {
          nodesWithHighestVersion.add(node);
          highestVersion=version;
        }
 else {
          if (version > highestVersion) {
            nodesWithHighestVersion.clear();
            nodesWithHighestVersion.add(node);
            highestVersion=version;
          }
 else           if (version == highestVersion) {
            nodesWithHighestVersion.add(node);
          }
        }
      }
    }
    int requiredAllocation=1;
    try {
      IndexMetaData indexMetaData=routingNodes.metaData().index(shard.index());
      String initialShards=indexMetaData.settings().get(INDEX_RECOVERY_INITIAL_SHARDS,settings.get(INDEX_RECOVERY_INITIAL_SHARDS,this.initialShards));
      if ("quorum".equals(initialShards)) {
        if (indexMetaData.numberOfReplicas() > 1) {
          requiredAllocation=((1 + indexMetaData.numberOfReplicas()) / 2) + 1;
        }
      }
 else       if ("quorum-1".equals(initialShards) || "half".equals(initialShards)) {
        if (indexMetaData.numberOfReplicas() > 2) {
          requiredAllocation=((1 + indexMetaData.numberOfReplicas()) / 2);
        }
      }
 else       if ("one".equals(initialShards)) {
        requiredAllocation=1;
      }
 else       if ("full".equals(initialShards) || "all".equals(initialShards)) {
        requiredAllocation=indexMetaData.numberOfReplicas() + 1;
      }
 else       if ("full-1".equals(initialShards) || "all-1".equals(initialShards)) {
        if (indexMetaData.numberOfReplicas() > 1) {
          requiredAllocation=indexMetaData.numberOfReplicas();
        }
      }
 else {
        requiredAllocation=Integer.parseInt(initialShards);
      }
    }
 catch (    Exception e) {
      logger.warn("[{}][{}] failed to derived initial_shards from value {}, ignore allocation for {}",shard.index(),shard.id(),initialShards,shard);
    }
    if (numberOfAllocationsFound < requiredAllocation) {
      unassignedIterator.remove();
      routingNodes.ignoredUnassigned().add(shard);
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}]: not allocating, number_of_allocated_shards_found [{}], required_number [{}]",shard.index(),shard.id(),numberOfAllocationsFound,requiredAllocation);
      }
      continue;
    }
    Set<DiscoveryNode> throttledNodes=Sets.newHashSet();
    Set<DiscoveryNode> noNodes=Sets.newHashSet();
    for (    DiscoveryNode discoNode : nodesWithHighestVersion) {
      RoutingNode node=routingNodes.node(discoNode.id());
      Decision decision=allocation.deciders().canAllocate(shard,node,allocation);
      if (decision.type() == Decision.Type.THROTTLE) {
        throttledNodes.add(discoNode);
      }
 else       if (decision.type() == Decision.Type.NO) {
        noNodes.add(discoNode);
      }
 else {
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}]: allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,discoNode);
        }
        changed=true;
        node.add(new MutableShardRouting(shard,highestVersion));
        unassignedIterator.remove();
        throttledNodes.clear();
        noNodes.clear();
        break;
      }
    }
    if (throttledNodes.isEmpty()) {
      if (!noNodes.isEmpty()) {
        DiscoveryNode discoNode=noNodes.iterator().next();
        RoutingNode node=routingNodes.node(discoNode.id());
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}]: forcing allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,discoNode);
        }
        changed=true;
        node.add(new MutableShardRouting(shard,highestVersion));
        unassignedIterator.remove();
      }
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}]: throttling allocation [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,throttledNodes);
      }
      unassignedIterator.remove();
      routingNodes.ignoredUnassigned().add(shard);
    }
  }
  if (!routingNodes.hasUnassigned()) {
    return changed;
  }
  unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    boolean canBeAllocatedToAtLeastOneNode=false;
    for (    ObjectCursor<DiscoveryNode> cursor : nodes.dataNodes().values()) {
      RoutingNode node=routingNodes.node(cursor.value.id());
      if (node == null) {
        continue;
      }
      Decision decision=allocation.deciders().canAllocate(shard,node,allocation);
      if (decision.type() == Decision.Type.YES) {
        canBeAllocatedToAtLeastOneNode=true;
        break;
      }
    }
    if (!canBeAllocatedToAtLeastOneNode) {
      continue;
    }
    Map<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> shardStores=buildShardStores(nodes,shard);
    long lastSizeMatched=0;
    DiscoveryNode lastDiscoNodeMatched=null;
    RoutingNode lastNodeMatched=null;
    for (    Map.Entry<DiscoveryNode,TransportNodesListShardStoreMetaData.StoreFilesMetaData> nodeStoreEntry : shardStores.entrySet()) {
      DiscoveryNode discoNode=nodeStoreEntry.getKey();
      TransportNodesListShardStoreMetaData.StoreFilesMetaData storeFilesMetaData=nodeStoreEntry.getValue();
      logger.trace("{}: checking node [{}]",shard,discoNode);
      if (storeFilesMetaData == null) {
        continue;
      }
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      Decision decision=allocation.deciders().canAllocate(shard,node,allocation);
      if (decision.type() == Decision.Type.NO) {
        continue;
      }
      if (storeFilesMetaData.allocated()) {
        continue;
      }
      if (!shard.primary()) {
        MutableShardRouting primaryShard=routingNodes.findPrimaryForReplica(shard);
        if (primaryShard != null && primaryShard.active()) {
          DiscoveryNode primaryNode=nodes.get(primaryShard.currentNodeId());
          if (primaryNode != null) {
            TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryNodeStore=shardStores.get(primaryNode);
            if (primaryNodeStore != null && primaryNodeStore.allocated()) {
              long sizeMatched=0;
              for (              StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
                if (primaryNodeStore.fileExists(storeFileMetaData.name()) && primaryNodeStore.file(storeFileMetaData.name()).isSame(storeFileMetaData)) {
                  sizeMatched+=storeFileMetaData.length();
                }
              }
              if (sizeMatched > lastSizeMatched) {
                lastSizeMatched=sizeMatched;
                lastDiscoNodeMatched=discoNode;
                lastNodeMatched=node;
              }
            }
          }
        }
      }
    }
    if (lastNodeMatched != null) {
      Decision decision=allocation.deciders().canAllocate(shard,lastNodeMatched,allocation);
      if (decision.type() == Decision.Type.THROTTLE) {
        if (logger.isTraceEnabled()) {
          logger.debug("[{}][{}]: throttling allocation [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        unassignedIterator.remove();
        routingNodes.ignoredUnassigned().add(shard);
      }
 else {
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
        }
        changed=true;
        lastNodeMatched.add(shard);
        unassignedIterator.remove();
      }
    }
  }
  return changed;
}
