{
  this.logger=logger;
  this.searchTransportService=searchTransportService;
  this.indexNameExpressionResolver=indexNameExpressionResolver;
  this.searchPhaseController=searchPhaseController;
  this.threadPool=threadPool;
  this.request=request;
  this.listener=listener;
  this.clusterState=clusterService.state();
  nodes=clusterState.nodes();
  clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.READ);
  String[] concreteIndices=indexNameExpressionResolver.concreteIndexNames(clusterState,request.indicesOptions(),startTime(),request.indices());
  for (  String index : concreteIndices) {
    clusterState.blocks().indexBlockedRaiseException(ClusterBlockLevel.READ,index);
  }
  Map<String,Set<String>> routingMap=indexNameExpressionResolver.resolveSearchRouting(clusterState,request.routing(),request.indices());
  shardsIts=clusterService.operationRouting().searchShards(clusterState,concreteIndices,routingMap,request.preference());
  final int shardCount=shardsIts.size();
  final long shardCountLimit=clusterService.getClusterSettings().get(TransportSearchAction.SHARD_COUNT_LIMIT_SETTING);
  if (shardCount > shardCountLimit) {
    throw new IllegalArgumentException("Trying to query " + shardCount + " shards, which is over the limit of "+ shardCountLimit+ ". This limit exists because querying many shards at the same time can make the "+ "job of the coordinating node very CPU and/or memory intensive. It is usually a better idea to "+ "have a smaller number of larger shards. Update ["+ TransportSearchAction.SHARD_COUNT_LIMIT_SETTING.getKey()+ "] to a greater value if you really want to query that many shards at the same time.");
  }
  expectedSuccessfulOps=shardCount;
  expectedTotalOps=shardsIts.totalSizeWith1ForEmpty();
  firstResults=new AtomicArray<>(shardsIts.size());
}
