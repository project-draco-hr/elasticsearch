{
  PoolingHttpClientConnectionManager connectionManager;
  String keystorePath=settings.get(TRUSTSTORE_PATH);
  if (keystorePath != null) {
    final String keystorePass=settings.get(TRUSTSTORE_PASSWORD);
    if (keystorePass == null) {
      throw new IllegalStateException(TRUSTSTORE_PATH + " is provided but not " + TRUSTSTORE_PASSWORD);
    }
    Path path=PathUtils.get(keystorePath);
    if (!Files.exists(path)) {
      throw new IllegalStateException(TRUSTSTORE_PATH + " is set but points to a non-existing file");
    }
    try {
      KeyStore keyStore=KeyStore.getInstance("jks");
      try (InputStream is=Files.newInputStream(path)){
        keyStore.load(is,keystorePass.toCharArray());
      }
       SSLContext sslcontext=SSLContexts.custom().loadTrustMaterial(keyStore,null).build();
      Registry<ConnectionSocketFactory> socketFactoryRegistry=RegistryBuilder.<ConnectionSocketFactory>create().register("https",new SSLConnectionSocketFactory(sslcontext)).build();
      connectionManager=new PoolingHttpClientConnectionManager(socketFactoryRegistry);
    }
 catch (    KeyStoreException|NoSuchAlgorithmException|KeyManagementException|CertificateException e) {
      throw new RuntimeException(e);
    }
  }
 else {
    connectionManager=new PoolingHttpClientConnectionManager();
  }
  connectionManager.setDefaultMaxPerRoute(10);
  connectionManager.setMaxTotal(30);
  String protocol=settings.get(PROTOCOL,"http");
  HttpHost[] hosts=new HttpHost[urls.length];
  for (int i=0; i < hosts.length; i++) {
    URL url=urls[i];
    hosts[i]=new HttpHost(url.getHost(),url.getPort(),protocol);
  }
  RestClient.Builder builder=RestClient.builder(hosts).setMaxRetryTimeoutMillis(30000).setHttpClientConfigCallback(new RestClient.HttpClientConfigCallback(){
    @Override public void customizeDefaultRequestConfig(    RequestConfig.Builder requestConfigBuilder){
      requestConfigBuilder.setSocketTimeout(30000);
    }
    @Override public void customizeHttpClient(    HttpClientBuilder httpClientBuilder){
      httpClientBuilder.setConnectionManager(connectionManager);
    }
  }
);
  try (ThreadContext threadContext=new ThreadContext(settings)){
    Header[] defaultHeaders=new Header[threadContext.getHeaders().size()];
    int i=0;
    for (    Map.Entry<String,String> entry : threadContext.getHeaders().entrySet()) {
      defaultHeaders[i++]=new BasicHeader(entry.getKey(),entry.getValue());
    }
    builder.setDefaultHeaders(defaultHeaders);
  }
   return builder.build();
}
