{
  client().admin().indices().prepareCreate("test").setSettings("index.number_of_shards",1,"index.number_of_replicas",1).get();
  ClusterAllocationExplainResponse resp=client().admin().cluster().prepareAllocationExplain().setIndex("test").setShard(0).setPrimary(false).get();
  ClusterAllocationExplanation cae=resp.getExplanation();
  assertNotNull("should always have an explanation",cae);
  assertEquals("test",cae.getShard().getIndexName());
  assertEquals(0,cae.getShard().getId());
  assertEquals(false,cae.isPrimary());
  assertNull(cae.getAssignedNodeId());
  assertFalse(cae.isStillFetchingShardData());
  assertNotNull(cae.getUnassignedInfo());
  NodeExplanation explanation=cae.getNodeExplanations().values().iterator().next();
  ClusterAllocationExplanation.FinalDecision fd=explanation.getFinalDecision();
  ClusterAllocationExplanation.StoreCopy storeCopy=explanation.getStoreCopy();
  Decision d=explanation.getDecision();
  assertNotNull("should have a decision",d);
  assertEquals(Decision.Type.NO,d.type());
  assertEquals(ClusterAllocationExplanation.FinalDecision.NO,fd);
  assertEquals(ClusterAllocationExplanation.StoreCopy.AVAILABLE,storeCopy);
  assertTrue(d.toString(),d.toString().contains("NO(the shard cannot be allocated on the same node id"));
  assertTrue(d instanceof Decision.Multi);
  Decision.Multi md=(Decision.Multi)d;
  Decision ssd=md.getDecisions().get(0);
  assertEquals(Decision.Type.NO,ssd.type());
  assertTrue(ssd.toString(),ssd.toString().contains("NO(the shard cannot be allocated on the same node id"));
  Float weight=explanation.getWeight();
  assertNotNull("should have a weight",weight);
  resp=client().admin().cluster().prepareAllocationExplain().setIndex("test").setShard(0).setPrimary(true).get();
  cae=resp.getExplanation();
  assertNotNull("should always have an explanation",cae);
  assertEquals("test",cae.getShard().getIndexName());
  assertEquals(0,cae.getShard().getId());
  assertEquals(true,cae.isPrimary());
  assertFalse(cae.isStillFetchingShardData());
  assertNotNull("shard should have assigned node id",cae.getAssignedNodeId());
  assertNull("assigned shard should not have unassigned info",cae.getUnassignedInfo());
  explanation=cae.getNodeExplanations().values().iterator().next();
  d=explanation.getDecision();
  fd=explanation.getFinalDecision();
  storeCopy=explanation.getStoreCopy();
  assertNotNull("should have a decision",d);
  assertEquals(Decision.Type.NO,d.type());
  assertEquals(ClusterAllocationExplanation.FinalDecision.ALREADY_ASSIGNED,fd);
  assertEquals(ClusterAllocationExplanation.StoreCopy.AVAILABLE,storeCopy);
  assertTrue(d.toString(),d.toString().contains("NO(the shard cannot be allocated on the same node id"));
  assertTrue(d instanceof Decision.Multi);
  md=(Decision.Multi)d;
  ssd=md.getDecisions().get(0);
  assertEquals(Decision.Type.NO,ssd.type());
  assertTrue(ssd.toString(),ssd.toString().contains("NO(the shard cannot be allocated on the same node id"));
  weight=explanation.getWeight();
  assertNotNull("should have a weight",weight);
  resp=client().admin().cluster().prepareAllocationExplain().useAnyUnassignedShard().get();
  cae=resp.getExplanation();
  assertNotNull("should always have an explanation",cae);
  assertEquals("test",cae.getShard().getIndexName());
  assertEquals(0,cae.getShard().getId());
  assertEquals(false,cae.isPrimary());
}
