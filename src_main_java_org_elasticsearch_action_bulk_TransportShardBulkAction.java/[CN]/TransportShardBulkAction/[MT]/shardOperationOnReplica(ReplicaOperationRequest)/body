{
  IndexService indexService=indicesService.indexServiceSafe(shardRequest.shardId.getIndex());
  IndexShard indexShard=indexService.shardSafe(shardRequest.shardId.id());
  final BulkShardRequest request=shardRequest.request;
  for (int i=0; i < request.items().length; i++) {
    BulkItemRequest item=request.items()[i];
    if (item == null || item.isIgnoreOnReplica()) {
      continue;
    }
    if (item.request() instanceof IndexRequest) {
      IndexRequest indexRequest=(IndexRequest)item.request();
      try {
        SourceToParse sourceToParse=SourceToParse.source(SourceToParse.Origin.REPLICA,indexRequest.source()).type(indexRequest.type()).id(indexRequest.id()).routing(indexRequest.routing()).parent(indexRequest.parent()).timestamp(indexRequest.timestamp()).ttl(indexRequest.ttl());
        if (indexRequest.opType() == IndexRequest.OpType.INDEX) {
          Engine.Index index=indexShard.prepareIndex(sourceToParse,indexRequest.version(),indexRequest.versionType(),Engine.Operation.Origin.REPLICA,request.canHaveDuplicates() || indexRequest.canHaveDuplicates());
          if (index.parsedDoc().dynamicMappingsUpdate() != null) {
            if (indexService.index().name().equals(RiverIndexName.Conf.indexName(settings))) {
              indexService.mapperService().merge(indexRequest.type(),new CompressedString(index.parsedDoc().dynamicMappingsUpdate().toBytes()),true);
            }
 else {
              throw new ElasticsearchIllegalStateException("Index operations on replicas should not trigger dynamic mappings updates: [" + index.parsedDoc().dynamicMappingsUpdate() + "]");
            }
          }
          indexShard.index(index);
        }
 else {
          Engine.Create create=indexShard.prepareCreate(sourceToParse,indexRequest.version(),indexRequest.versionType(),Engine.Operation.Origin.REPLICA,request.canHaveDuplicates() || indexRequest.canHaveDuplicates(),indexRequest.autoGeneratedId());
          if (create.parsedDoc().dynamicMappingsUpdate() != null) {
            if (indexService.index().name().equals(RiverIndexName.Conf.indexName(settings))) {
              indexService.mapperService().merge(indexRequest.type(),new CompressedString(create.parsedDoc().dynamicMappingsUpdate().toBytes()),true);
            }
 else {
              throw new ElasticsearchIllegalStateException("Index operations on replicas should not trigger dynamic mappings updates: [" + create.parsedDoc().dynamicMappingsUpdate() + "]");
            }
          }
          indexShard.create(create);
        }
      }
 catch (      Throwable e) {
        if (!ignoreReplicaException(e)) {
          throw e;
        }
      }
    }
 else     if (item.request() instanceof DeleteRequest) {
      DeleteRequest deleteRequest=(DeleteRequest)item.request();
      try {
        Engine.Delete delete=indexShard.prepareDelete(deleteRequest.type(),deleteRequest.id(),deleteRequest.version(),deleteRequest.versionType(),Engine.Operation.Origin.REPLICA);
        indexShard.delete(delete);
      }
 catch (      Throwable e) {
        if (!ignoreReplicaException(e)) {
          throw e;
        }
      }
    }
  }
  if (request.refresh()) {
    try {
      indexShard.refresh("refresh_flag_bulk");
    }
 catch (    Throwable e) {
    }
  }
}
