{
  TByteIntHashMap facets=aggregator.facets();
  if (facets.isEmpty()) {
    pushFacets(facets);
    return new InternalByteTermsFacet(facetName,fieldName,comparatorType,size,ImmutableList.<InternalByteTermsFacet.ByteEntry>of());
  }
 else {
    BoundedTreeSet<InternalByteTermsFacet.ByteEntry> ordered=new BoundedTreeSet<InternalByteTermsFacet.ByteEntry>(comparatorType.comparator(),size * numberOfShards);
    for (TByteIntIterator it=facets.iterator(); it.hasNext(); ) {
      it.advance();
      ordered.add(new InternalByteTermsFacet.ByteEntry(it.key(),it.value()));
    }
    pushFacets(facets);
    return new InternalByteTermsFacet(facetName,fieldName,comparatorType,size,ordered);
  }
}
