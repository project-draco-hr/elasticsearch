{
  if (blockingClient) {
    clientBootstrap=new ClientBootstrap(new OioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_client_worker"))));
  }
 else {
    clientBootstrap=new ClientBootstrap(new NioClientSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_client_boss")),bossCount,new NioWorkerPool(Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_client_worker")),workerCount),new HashedWheelTimer(daemonThreadFactory(settings,"transport_client_timer"))));
  }
  ChannelPipelineFactory clientPipelineFactory=new ChannelPipelineFactory(){
    @Override public ChannelPipeline getPipeline() throws Exception {
      ChannelPipeline pipeline=Channels.pipeline();
      SizeHeaderFrameDecoder sizeHeader=new SizeHeaderFrameDecoder();
      if (maxCumulationBufferCapacity != null) {
        if (maxCumulationBufferCapacity.bytes() > Integer.MAX_VALUE) {
          sizeHeader.setMaxCumulationBufferCapacity(Integer.MAX_VALUE);
        }
 else {
          sizeHeader.setMaxCumulationBufferCapacity((int)maxCumulationBufferCapacity.bytes());
        }
      }
      if (maxCompositeBufferComponents != -1) {
        sizeHeader.setMaxCumulationBufferComponents(maxCompositeBufferComponents);
      }
      pipeline.addLast("size",sizeHeader);
      pipeline.addLast("dispatcher",new MessageChannelHandler(NettyTransport.this,logger));
      return pipeline;
    }
  }
;
  clientBootstrap.setPipelineFactory(clientPipelineFactory);
  clientBootstrap.setOption("connectTimeoutMillis",connectTimeout.millis());
  if (tcpNoDelay != null) {
    clientBootstrap.setOption("tcpNoDelay",tcpNoDelay);
  }
  if (tcpKeepAlive != null) {
    clientBootstrap.setOption("keepAlive",tcpKeepAlive);
  }
  if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {
    clientBootstrap.setOption("sendBufferSize",tcpSendBufferSize.bytes());
  }
  if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {
    clientBootstrap.setOption("receiveBufferSize",tcpReceiveBufferSize.bytes());
  }
  clientBootstrap.setOption("receiveBufferSizePredictorFactory",receiveBufferSizePredictorFactory);
  if (reuseAddress != null) {
    clientBootstrap.setOption("reuseAddress",reuseAddress);
  }
  if (!settings.getAsBoolean("network.server",true)) {
    return;
  }
  serverOpenChannels=new OpenChannelsHandler(logger);
  if (blockingServer) {
    serverBootstrap=new ServerBootstrap(new OioServerSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_server_boss")),Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_server_worker"))));
  }
 else {
    serverBootstrap=new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_server_boss")),Executors.newCachedThreadPool(daemonThreadFactory(settings,"transport_server_worker")),workerCount));
  }
  ChannelPipelineFactory serverPipelineFactory=new ChannelPipelineFactory(){
    @Override public ChannelPipeline getPipeline() throws Exception {
      ChannelPipeline pipeline=Channels.pipeline();
      pipeline.addLast("openChannels",serverOpenChannels);
      SizeHeaderFrameDecoder sizeHeader=new SizeHeaderFrameDecoder();
      if (maxCumulationBufferCapacity != null) {
        if (maxCumulationBufferCapacity.bytes() > Integer.MAX_VALUE) {
          sizeHeader.setMaxCumulationBufferCapacity(Integer.MAX_VALUE);
        }
 else {
          sizeHeader.setMaxCumulationBufferCapacity((int)maxCumulationBufferCapacity.bytes());
        }
      }
      if (maxCompositeBufferComponents != -1) {
        sizeHeader.setMaxCumulationBufferComponents(maxCompositeBufferComponents);
      }
      pipeline.addLast("size",sizeHeader);
      pipeline.addLast("dispatcher",new MessageChannelHandler(NettyTransport.this,logger));
      return pipeline;
    }
  }
;
  serverBootstrap.setPipelineFactory(serverPipelineFactory);
  if (tcpNoDelay != null) {
    serverBootstrap.setOption("child.tcpNoDelay",tcpNoDelay);
  }
  if (tcpKeepAlive != null) {
    serverBootstrap.setOption("child.keepAlive",tcpKeepAlive);
  }
  if (tcpSendBufferSize != null && tcpSendBufferSize.bytes() > 0) {
    serverBootstrap.setOption("child.sendBufferSize",tcpSendBufferSize.bytes());
  }
  if (tcpReceiveBufferSize != null && tcpReceiveBufferSize.bytes() > 0) {
    serverBootstrap.setOption("child.receiveBufferSize",tcpReceiveBufferSize.bytes());
  }
  serverBootstrap.setOption("receiveBufferSizePredictorFactory",receiveBufferSizePredictorFactory);
  serverBootstrap.setOption("child.receiveBufferSizePredictorFactory",receiveBufferSizePredictorFactory);
  if (reuseAddress != null) {
    serverBootstrap.setOption("reuseAddress",reuseAddress);
    serverBootstrap.setOption("child.reuseAddress",reuseAddress);
  }
  InetAddress hostAddressX;
  try {
    hostAddressX=networkService.resolveBindHostAddress(bindHost);
  }
 catch (  IOException e) {
    throw new BindTransportException("Failed to resolve host [" + bindHost + "]",e);
  }
  final InetAddress hostAddress=hostAddressX;
  PortsRange portsRange=new PortsRange(port);
  final AtomicReference<Exception> lastException=new AtomicReference<>();
  boolean success=portsRange.iterate(new PortsRange.PortCallback(){
    @Override public boolean onPortNumber(    int portNumber){
      try {
        serverChannel=serverBootstrap.bind(new InetSocketAddress(hostAddress,portNumber));
      }
 catch (      Exception e) {
        lastException.set(e);
        return false;
      }
      return true;
    }
  }
);
  if (!success) {
    throw new BindTransportException("Failed to bind to [" + port + "]",lastException.get());
  }
  logger.debug("Bound to address [{}]",serverChannel.getLocalAddress());
  InetSocketAddress boundAddress=(InetSocketAddress)serverChannel.getLocalAddress();
  InetSocketAddress publishAddress;
  int publishPort=this.publishPort;
  if (0 == publishPort) {
    publishPort=boundAddress.getPort();
  }
  try {
    publishAddress=new InetSocketAddress(networkService.resolvePublishHostAddress(publishHost),publishPort);
  }
 catch (  Exception e) {
    throw new BindTransportException("Failed to resolve publish address",e);
  }
  this.boundAddress=new BoundTransportAddress(new InetSocketTransportAddress(boundAddress),new InetSocketTransportAddress(publishAddress));
}
