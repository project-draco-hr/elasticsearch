{
  final ShardId shardId=primary.routingEntry().shardId();
  final String indexName=shardId.getIndexName();
  final ClusterState state=clusterStateSupplier.get();
  final ActiveShardCount waitForActiveShards=request.waitForActiveShards();
  if (waitForActiveShards == ActiveShardCount.NONE) {
    return null;
  }
  IndexRoutingTable indexRoutingTable=state.getRoutingTable().index(indexName);
  if (indexRoutingTable == null) {
    logger.trace("[{}] index not found in the routing table",shardId);
    return "Index " + indexName + " not found in the routing table";
  }
  IndexShardRoutingTable shardRoutingTable=indexRoutingTable.shard(shardId.getId());
  if (shardRoutingTable == null) {
    logger.trace("[{}] shard not found in the routing table",shardId);
    return "Shard " + shardId + " not found in the routing table";
  }
  if (waitForActiveShards.enoughShardsActive(shardRoutingTable)) {
    return null;
  }
 else {
    final String resolvedShards=waitForActiveShards == ActiveShardCount.ALL ? Integer.toString(shardRoutingTable.shards().size()) : waitForActiveShards.toString();
    logger.trace("[{}] not enough active copies to meet shard count of [{}] (have {}, needed {}), scheduling a retry. op [{}], " + "request [{}]",shardId,waitForActiveShards,shardRoutingTable.activeShards().size(),resolvedShards,opType,request);
    return "Not enough active copies to meet shard count of [" + waitForActiveShards + "] (have "+ shardRoutingTable.activeShards().size()+ ", needed "+ resolvedShards+ ").";
  }
}
