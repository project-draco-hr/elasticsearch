{
  if (rerouting.compareAndSet(false,true) == false) {
    logger.trace("{} already has pending reroute, ignoring {}",shardId,reason);
    return;
  }
  clusterService.submitStateUpdateTask("async_shard_fetch",Priority.HIGH,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      rerouting.set(false);
      if (currentState.nodes().masterNode() == null) {
        return currentState;
      }
      RoutingAllocation.Result routingResult=allocationService.reroute(currentState);
      if (!routingResult.changed()) {
        return currentState;
      }
      return ClusterState.builder(currentState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      rerouting.set(false);
      logger.warn("failed to perform reroute post async fetch for {}",t,source);
    }
  }
);
}
