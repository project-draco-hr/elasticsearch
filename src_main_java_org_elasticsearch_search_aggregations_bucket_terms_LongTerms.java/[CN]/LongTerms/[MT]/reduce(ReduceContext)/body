{
  List<InternalAggregation> aggregations=reduceContext.aggregations();
  if (aggregations.size() == 1) {
    InternalTerms terms=(InternalTerms)aggregations.get(0);
    terms.trimExcessEntries(reduceContext.bigArrays());
    return terms;
  }
  InternalTerms reduced=null;
  LongObjectPagedHashMap<List<Bucket>> buckets=null;
  for (  InternalAggregation aggregation : aggregations) {
    InternalTerms terms=(InternalTerms)aggregation;
    if (terms instanceof UnmappedTerms) {
      continue;
    }
    if (reduced == null) {
      reduced=terms;
    }
    if (buckets == null) {
      buckets=new LongObjectPagedHashMap<List<Bucket>>(terms.buckets.size(),reduceContext.bigArrays());
    }
    for (    Terms.Bucket bucket : terms.buckets) {
      List<Bucket> existingBuckets=buckets.get(((Bucket)bucket).term);
      if (existingBuckets == null) {
        existingBuckets=new ArrayList<Bucket>(aggregations.size());
        buckets.put(((Bucket)bucket).term,existingBuckets);
      }
      existingBuckets.add((Bucket)bucket);
    }
  }
  if (reduced == null) {
    return (UnmappedTerms)aggregations.get(0);
  }
  final int size=(int)Math.min(requiredSize,buckets.size());
  BucketPriorityQueue ordered=new BucketPriorityQueue(size,order.comparator(null));
  for (  LongObjectPagedHashMap.Cursor<List<LongTerms.Bucket>> cursor : buckets) {
    List<LongTerms.Bucket> sameTermBuckets=cursor.value;
    final InternalTerms.Bucket b=sameTermBuckets.get(0).reduce(sameTermBuckets,reduceContext.bigArrays());
    if (b.getDocCount() >= minDocCount) {
      ordered.insertWithOverflow(b);
    }
  }
  buckets.release();
  InternalTerms.Bucket[] list=new InternalTerms.Bucket[ordered.size()];
  for (int i=ordered.size() - 1; i >= 0; i--) {
    list[i]=(Bucket)ordered.pop();
  }
  reduced.buckets=Arrays.asList(list);
  return reduced;
}
