{
  final Cast cast=new Cast(actual,expected);
  if (actual.equals(expected)) {
    return null;
  }
  if (actual.sort == Sort.DEF && expected.sort != Sort.VOID || actual.sort != Sort.VOID && expected.sort == Sort.DEF) {
    final Transform transform=definition.transformsMap.get(cast);
    if (transform != null) {
      return transform;
    }
    return cast;
  }
switch (actual.sort) {
case BOOL:
switch (expected.sort) {
case OBJECT:
case BOOL_OBJ:
      return checkTransform(definition,location,cast);
  }
break;
case BYTE:
switch (expected.sort) {
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case CHAR:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case BYTE_OBJ:
case SHORT_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case SHORT:
switch (expected.sort) {
case INT:
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case CHAR:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case SHORT_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case CHAR:
switch (expected.sort) {
case INT:
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case SHORT:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case STRING:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case INT:
switch (expected.sort) {
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case SHORT:
case CHAR:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case LONG:
switch (expected.sort) {
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case SHORT:
case CHAR:
case INT:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case FLOAT:
switch (expected.sort) {
case DOUBLE:
return cast;
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case DOUBLE:
switch (expected.sort) {
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case FLOAT:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case OBJECT:
case NUMBER:
switch (expected.sort) {
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case BOOL_OBJ:
switch (expected.sort) {
case BOOL:
return checkTransform(definition,location,cast);
}
break;
case BYTE_OBJ:
switch (expected.sort) {
case BYTE:
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case SHORT_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case CHAR:
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case SHORT_OBJ:
switch (expected.sort) {
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE:
case CHAR:
case BYTE_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case CHAR_OBJ:
switch (expected.sort) {
case CHAR:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE:
case SHORT:
case BYTE_OBJ:
case SHORT_OBJ:
case STRING:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case INT_OBJ:
switch (expected.sort) {
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE:
case SHORT:
case CHAR:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case LONG_OBJ:
switch (expected.sort) {
case LONG:
case FLOAT:
case DOUBLE:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE:
case SHORT:
case CHAR:
case INT:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case FLOAT_OBJ:
switch (expected.sort) {
case FLOAT:
case DOUBLE:
case DOUBLE_OBJ:
return checkTransform(definition,location,cast);
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case DOUBLE_OBJ:
switch (expected.sort) {
case DOUBLE:
return checkTransform(definition,location,cast);
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case FLOAT:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
break;
case STRING:
switch (expected.sort) {
case CHAR:
case CHAR_OBJ:
if (explicit) return checkTransform(definition,location,cast);
break;
}
}
if (expected.clazz.isAssignableFrom(actual.clazz) || (explicit && actual.clazz.isAssignableFrom(expected.clazz))) {
return cast;
}
 else {
throw new ClassCastException("Error" + location + ": Cannot cast from ["+ actual.name+ "] to ["+ expected.name+ "].");
}
}
