{
  fetchSourceContext=normalizeFetchSourceContent(fetchSourceContext,gFields);
  Engine.GetResult get=null;
  if (type == null || type.equals("_all")) {
    for (    String typeX : mapperService.types()) {
      get=indexShard.get(new Engine.Get(realtime,new Term(UidFieldMapper.NAME,Uid.createUidAsBytes(typeX,id))).version(version).versionType(versionType));
      if (get.exists()) {
        type=typeX;
        break;
      }
 else {
        get.release();
      }
    }
    if (get == null) {
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
    if (!get.exists()) {
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
  }
 else {
    get=indexShard.get(new Engine.Get(realtime,new Term(UidFieldMapper.NAME,Uid.createUidAsBytes(type,id))).version(version).versionType(versionType));
    if (!get.exists()) {
      get.release();
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
  }
  DocumentMapper docMapper=mapperService.documentMapper(type);
  if (docMapper == null) {
    get.release();
    return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
  }
  try {
    if (get.docIdAndVersion() != null) {
      return innerGetLoadFromStoredFields(type,id,gFields,fetchSourceContext,get,docMapper,ignoreErrorsOnGeneratedFields);
    }
 else {
      Translog.Source source=get.source();
      Map<String,GetField> fields=null;
      SearchLookup searchLookup=null;
      Set<String> neededFields=new HashSet<>();
      neededFields.add(RoutingFieldMapper.NAME);
      if (docMapper.parentFieldMapper().active()) {
        neededFields.add(ParentFieldMapper.NAME);
      }
      if (docMapper.timestampFieldMapper().enabled()) {
        neededFields.add(TimestampFieldMapper.NAME);
      }
      if (docMapper.TTLFieldMapper().enabled()) {
        neededFields.add(TTLFieldMapper.NAME);
      }
      if (gFields != null) {
        neededFields.addAll(Arrays.asList(gFields));
      }
      for (      String field : neededFields) {
        if (SourceFieldMapper.NAME.equals(field)) {
          continue;
        }
        Object value=null;
        if (field.equals(RoutingFieldMapper.NAME)) {
          value=source.routing;
        }
 else         if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active()) {
          value=source.parent;
        }
 else         if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().enabled()) {
          value=source.timestamp;
        }
 else         if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().enabled()) {
          if (source.ttl > 0) {
            value=docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl);
          }
        }
 else         if (field.equals(SizeFieldMapper.NAME) && docMapper.rootMapper(SizeFieldMapper.class).fieldType().stored()) {
          value=source.source.length();
        }
 else {
          if (searchLookup == null) {
            searchLookup=new SearchLookup(mapperService,null,new String[]{type});
            searchLookup.source().setSource(source.source);
          }
          FieldMapper fieldMapper=docMapper.mappers().smartNameFieldMapper(field);
          if (fieldMapper == null) {
            if (docMapper.objectMappers().get(field) != null) {
              throw new IllegalArgumentException("field [" + field + "] isn't a leaf field");
            }
          }
 else           if (shouldGetFromSource(ignoreErrorsOnGeneratedFields,docMapper,fieldMapper)) {
            List<Object> values=searchLookup.source().extractRawValues(field);
            if (!values.isEmpty()) {
              for (int i=0; i < values.size(); i++) {
                values.set(i,fieldMapper.fieldType().valueForSearch(values.get(i)));
              }
              value=values;
            }
          }
        }
        if (value != null) {
          if (fields == null) {
            fields=newHashMapWithExpectedSize(2);
          }
          if (value instanceof List) {
            fields.put(field,new GetField(field,(List)value));
          }
 else {
            fields.put(field,new GetField(field,ImmutableList.of(value)));
          }
        }
      }
      BytesReference sourceToBeReturned=null;
      SourceFieldMapper sourceFieldMapper=docMapper.sourceMapper();
      if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) {
        sourceToBeReturned=source.source;
        boolean sourceFieldFiltering=sourceFieldMapper.includes().length > 0 || sourceFieldMapper.excludes().length > 0;
        boolean sourceFetchFiltering=fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0;
        if (fetchSourceContext.transformSource() || sourceFieldFiltering || sourceFetchFiltering) {
          Tuple<XContentType,Map<String,Object>> typeMapTuple=XContentHelper.convertToMap(source.source,true);
          XContentType sourceContentType=typeMapTuple.v1();
          Map<String,Object> sourceAsMap=typeMapTuple.v2();
          if (fetchSourceContext.transformSource()) {
            sourceAsMap=docMapper.transformSourceAsMap(sourceAsMap);
          }
          if (sourceFieldFiltering) {
            sourceAsMap=XContentMapValues.filter(sourceAsMap,sourceFieldMapper.includes(),sourceFieldMapper.excludes());
          }
          if (sourceFetchFiltering) {
            sourceAsMap=XContentMapValues.filter(sourceAsMap,fetchSourceContext.includes(),fetchSourceContext.excludes());
          }
          try {
            sourceToBeReturned=XContentFactory.contentBuilder(sourceContentType).map(sourceAsMap).bytes();
          }
 catch (          IOException e) {
            throw new ElasticsearchException("Failed to get type [" + type + "] and id ["+ id+ "] with includes/excludes set",e);
          }
        }
      }
      return new GetResult(shardId.index().name(),type,id,get.version(),get.exists(),sourceToBeReturned,fields);
    }
  }
  finally {
    get.release();
  }
}
