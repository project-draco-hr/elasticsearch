{
  DiscoveryNode discoNode=allocation.nodes().resolveNode(node);
  boolean found=false;
  for (RoutingNodes.RoutingNodeIterator it=allocation.routingNodes().routingNodeIter(discoNode.getId()); it.hasNext(); ) {
    ShardRouting shardRouting=it.next();
    if (!shardRouting.shardId().getIndex().getName().equals(index)) {
      continue;
    }
    if (shardRouting.shardId().id() != shardId) {
      continue;
    }
    found=true;
    if (shardRouting.relocatingNodeId() != null) {
      if (shardRouting.initializing()) {
        it.remove();
        RoutingNode relocatingFromNode=allocation.routingNodes().node(shardRouting.relocatingNodeId());
        if (relocatingFromNode != null) {
          for (          ShardRouting fromShardRouting : relocatingFromNode) {
            if (fromShardRouting.isSameShard(shardRouting) && fromShardRouting.state() == RELOCATING) {
              allocation.routingNodes().cancelRelocation(fromShardRouting);
              break;
            }
          }
        }
      }
 else       if (shardRouting.relocating()) {
        if (!allowPrimary && shardRouting.primary()) {
          if (explain) {
            return new RerouteExplanation(this,allocation.decision(Decision.NO,"cancel_allocation_command","can't cancel " + shardId + " on node "+ discoNode+ ", shard is primary and initializing its state"));
          }
          throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node "+ discoNode+ ", shard is primary and initializing its state");
        }
        it.remove();
        boolean addAsUnassigned=true;
        RoutingNodes.RoutingNodeIterator initializingNode=allocation.routingNodes().routingNodeIter(shardRouting.relocatingNodeId());
        if (initializingNode != null) {
          while (initializingNode.hasNext()) {
            ShardRouting initializingShardRouting=initializingNode.next();
            if (initializingShardRouting.isRelocationTargetOf(shardRouting)) {
              if (shardRouting.primary()) {
                initializingNode.remove();
              }
 else {
                initializingNode.removeRelocationSource();
                addAsUnassigned=false;
              }
              break;
            }
          }
        }
        if (addAsUnassigned) {
          it.moveToUnassigned(new UnassignedInfo(UnassignedInfo.Reason.REROUTE_CANCELLED,null));
        }
      }
    }
 else {
      if (!allowPrimary && shardRouting.primary()) {
        if (explain) {
          return new RerouteExplanation(this,allocation.decision(Decision.NO,"cancel_allocation_command","can't cancel " + shardId + " on node "+ discoNode+ ", shard is primary and started"));
        }
        throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node "+ discoNode+ ", shard is primary and started");
      }
      it.moveToUnassigned(new UnassignedInfo(UnassignedInfo.Reason.REROUTE_CANCELLED,null));
    }
  }
  if (!found) {
    if (explain) {
      return new RerouteExplanation(this,allocation.decision(Decision.NO,"cancel_allocation_command","can't cancel " + shardId + ", failed to find it on node "+ discoNode));
    }
    throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + ", failed to find it on node "+ discoNode);
  }
  return new RerouteExplanation(this,allocation.decision(Decision.YES,"cancel_allocation_command","shard " + shardId + " on node "+ discoNode+ " can be cancelled"));
}
