{
  File[] files=locationIndex.listFiles();
  final CountDownLatch latch=new CountDownLatch(files.length);
  final AtomicReference<Exception> lastException=new AtomicReference<Exception>();
  final AtomicLong throttlingWaitTime=new AtomicLong();
  for (  final File file : files) {
    threadPool.execute(new Runnable(){
      @Override public void run(){
        try {
          long throttlingStartTime=System.currentTimeMillis();
          while (!recoveryThrottler.tryStream(shardId,file.getName())) {
            Thread.sleep(recoveryThrottler.throttleInterval().millis());
          }
          throttlingWaitTime.addAndGet(System.currentTimeMillis() - throttlingStartTime);
          copyToDirectory(file,store.directory(),file.getName());
        }
 catch (        Exception e) {
          logger.debug("Failed to read [" + file + "] into ["+ store+ "]",e);
          lastException.set(e);
        }
 finally {
          recoveryThrottler.streamDone(shardId,file.getName());
          latch.countDown();
        }
      }
    }
);
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    lastException.set(e);
  }
  if (lastException.get() != null) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to recover index files",lastException.get());
  }
  long totalSize=0;
  for (  File file : files) {
    totalSize+=file.length();
  }
  long version=-1;
  try {
    if (IndexReader.indexExists(store.directory())) {
      version=IndexReader.getCurrentVersion(store.directory());
    }
  }
 catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to fetch index version after copying it over",e);
  }
  return new RecoveryStatus.Index(version,files.length,new SizeValue(totalSize,SizeUnit.BYTES),TimeValue.timeValueMillis(throttlingWaitTime.get()));
}
