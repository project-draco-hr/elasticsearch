{
  final ClusterState clusterState=clusterService.state();
  nodes=clusterState.nodes();
  if (!clusterState.routingTable().hasIndex(request.index())) {
    retry(fromClusterEvent,null);
    return false;
  }
  try {
    shardIt=shards(clusterState,request);
  }
 catch (  Exception e) {
    listener.onFailure(e);
    return true;
  }
  if (shardIt.size() == 0) {
    retry(fromClusterEvent,shardIt.shardId());
    return false;
  }
  boolean foundPrimary=false;
  for (  final ShardRouting shard : shardIt) {
    if (!shard.primary()) {
      continue;
    }
    if (!shard.active() || !nodes.nodeExists(shard.currentNodeId())) {
      retry(fromClusterEvent,shard.shardId());
      return false;
    }
    if (checkWriteConsistency) {
      WriteConsistencyLevel consistencyLevel=defaultWriteConsistencyLevel;
      if (request.consistencyLevel() != WriteConsistencyLevel.DEFAULT) {
        consistencyLevel=request.consistencyLevel();
      }
      int requiredNumber=1;
      if (consistencyLevel == WriteConsistencyLevel.QUORUM && shardIt.size() > 2) {
        requiredNumber=(shardIt.size() / 2) + 1;
      }
 else       if (consistencyLevel == WriteConsistencyLevel.ALL) {
        requiredNumber=shardIt.size();
      }
      if (shardIt.sizeActive() < requiredNumber) {
        retry(fromClusterEvent,shard.shardId());
        return false;
      }
    }
    if (!primaryOperationStarted.compareAndSet(false,true)) {
      return true;
    }
    foundPrimary=true;
    if (shard.currentNodeId().equals(nodes.localNodeId())) {
      if (request.operationThreaded()) {
        request.beforeLocalFork();
        threadPool.executor(executor).execute(new Runnable(){
          @Override public void run(){
            performOnPrimary(shard.id(),fromClusterEvent,true,shard,clusterState);
          }
        }
);
      }
 else {
        performOnPrimary(shard.id(),fromClusterEvent,false,shard,clusterState);
      }
    }
 else {
      DiscoveryNode node=nodes.get(shard.currentNodeId());
      transportService.sendRequest(node,transportAction,request,transportOptions(),new BaseTransportResponseHandler<Response>(){
        @Override public Response newInstance(){
          return newResponseInstance();
        }
        @Override public String executor(){
          return ThreadPool.Names.SAME;
        }
        @Override public void handleResponse(        Response response){
          listener.onResponse(response);
        }
        @Override public void handleException(        TransportException exp){
          if (exp.unwrapCause() instanceof ConnectTransportException || exp.unwrapCause() instanceof NodeClosedException || exp.unwrapCause() instanceof IllegalIndexShardStateException) {
            primaryOperationStarted.set(false);
            retry(false,shard.shardId());
          }
 else {
            listener.onFailure(exp);
          }
        }
      }
);
    }
    break;
  }
  if (!foundPrimary) {
    final UnavailableShardsException failure=new UnavailableShardsException(shardIt.shardId(),request.toString());
    if (request.listenerThreaded()) {
      threadPool.cached().execute(new Runnable(){
        @Override public void run(){
          listener.onFailure(failure);
        }
      }
);
    }
 else {
      listener.onFailure(failure);
    }
  }
  return true;
}
