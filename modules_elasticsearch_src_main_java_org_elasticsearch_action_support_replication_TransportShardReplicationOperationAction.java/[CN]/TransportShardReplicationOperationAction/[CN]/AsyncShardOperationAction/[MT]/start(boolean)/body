{
  ClusterState clusterState=clusterService.state();
  nodes=clusterState.nodes();
  if (!clusterState.routingTable().hasIndex(request.index())) {
    retry(fromClusterEvent,null);
    return false;
  }
  try {
    shards=shards(clusterState,request);
  }
 catch (  Exception e) {
    listener.onFailure(e);
    return true;
  }
  boolean foundPrimary=false;
  for (  final ShardRouting shard : shards) {
    if (!shard.primary()) {
      continue;
    }
    if (!shard.active() || !nodes.nodeExists(shard.currentNodeId())) {
      retry(fromClusterEvent,shard.shardId());
      return false;
    }
    if (checkWriteConsistency()) {
      WriteConsistencyLevel consistencyLevel=defaultWriteConsistencyLevel;
      if (request.consistencyLevel() != WriteConsistencyLevel.DEFAULT) {
        consistencyLevel=request.consistencyLevel();
      }
      int requiredNumber=1;
      if (consistencyLevel == WriteConsistencyLevel.QUORUM && shards.size() > 2) {
        requiredNumber=(shards.size() / 2) + 1;
      }
 else       if (consistencyLevel == WriteConsistencyLevel.ALL) {
        requiredNumber=shards.size();
      }
      if (shards.sizeActive() < requiredNumber) {
        retry(fromClusterEvent,shard.shardId());
        return false;
      }
    }
    if (!primaryOperationStarted.compareAndSet(false,true)) {
      return false;
    }
    foundPrimary=true;
    if (shard.currentNodeId().equals(nodes.localNodeId())) {
      if (request.operationThreaded()) {
        request.beforeLocalFork();
        threadPool.execute(new Runnable(){
          @Override public void run(){
            performOnPrimary(shard.id(),fromClusterEvent,true,shard);
          }
        }
);
      }
 else {
        performOnPrimary(shard.id(),fromClusterEvent,false,shard);
      }
    }
 else {
      DiscoveryNode node=nodes.get(shard.currentNodeId());
      transportService.sendRequest(node,transportAction(),request,transportOptions(),new BaseTransportResponseHandler<Response>(){
        @Override public Response newInstance(){
          return newResponseInstance();
        }
        @Override public void handleResponse(        Response response){
          listener.onResponse(response);
        }
        @Override public void handleException(        RemoteTransportException exp){
          if (exp.unwrapCause() instanceof ConnectTransportException || exp.unwrapCause() instanceof NodeClosedException || exp.unwrapCause() instanceof IllegalIndexShardStateException) {
            primaryOperationStarted.set(false);
            retry(false,shard.shardId());
          }
 else {
            listener.onFailure(exp);
          }
        }
        @Override public boolean spawn(){
          return request.listenerThreaded();
        }
      }
);
    }
    break;
  }
  if (!foundPrimary) {
    final UnavailableShardsException failure=new UnavailableShardsException(shards.shardId(),request.toString());
    if (request.listenerThreaded()) {
      threadPool.execute(new Runnable(){
        @Override public void run(){
          listener.onFailure(failure);
        }
      }
);
    }
 else {
      listener.onFailure(failure);
    }
  }
  return true;
}
