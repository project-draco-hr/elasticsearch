{
  if (ignoreReplicas() || shardIt.size() == 1) {
    postPrimaryOperation(request,response);
    if (alreadyThreaded || !request.listenerThreaded()) {
      listener.onResponse(response.response());
    }
 else {
      threadPool.execute(new Runnable(){
        @Override public void run(){
          listener.onResponse(response.response());
        }
      }
);
    }
    return;
  }
  int replicaCounter=0;
  for (  final ShardRouting shard : shardIt.reset()) {
    if (shard.unassigned()) {
      continue;
    }
    if (shard.primary()) {
      if (shard.relocating()) {
        replicaCounter++;
      }
    }
 else {
      replicaCounter++;
      if (shard.relocating()) {
        replicaCounter++;
      }
    }
  }
  if (replicaCounter == 0) {
    postPrimaryOperation(request,response);
    if (alreadyThreaded || !request.listenerThreaded()) {
      listener.onResponse(response.response());
    }
 else {
      threadPool.execute(new Runnable(){
        @Override public void run(){
          listener.onResponse(response.response());
        }
      }
);
    }
    return;
  }
  if (replicationType == ReplicationType.ASYNC) {
    postPrimaryOperation(request,response);
    if (alreadyThreaded || !request.listenerThreaded()) {
      listener.onResponse(response.response());
    }
 else {
      threadPool.execute(new Runnable(){
        @Override public void run(){
          listener.onResponse(response.response());
        }
      }
);
    }
    replicaCounter=-100;
  }
  replicaCounter++;
  AtomicInteger counter=new AtomicInteger(replicaCounter);
  for (  final ShardRouting shard : shardIt.reset()) {
    if (shard.unassigned()) {
      continue;
    }
    boolean doOnlyOnRelocating=false;
    if (shard.primary()) {
      if (shard.relocating()) {
        doOnlyOnRelocating=true;
      }
 else {
        continue;
      }
    }
    if (!doOnlyOnRelocating) {
      performOnReplica(response,alreadyThreaded,counter,shard,shard.currentNodeId());
    }
    if (shard.relocating()) {
      performOnReplica(response,alreadyThreaded,counter,shard,shard.relocatingNodeId());
    }
  }
  postPrimaryOperation(request,response);
  if (counter.decrementAndGet() == 0) {
    if (alreadyThreaded || !request.listenerThreaded()) {
      listener.onResponse(response.response());
    }
 else {
      threadPool.execute(new Runnable(){
        @Override public void run(){
          listener.onResponse(response.response());
        }
      }
);
    }
  }
}
