{
  boolean change=false;
synchronized (mutex) {
    if (state() == IndexShardState.CLOSED) {
      return;
    }
    ByteSizeValue flushThresholdSize=settings.getAsBytesSize(INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE,this.flushThresholdSize);
    if (!flushThresholdSize.equals(this.flushThresholdSize)) {
      logger.info("updating flush_threshold_size from [{}] to [{}]",this.flushThresholdSize,flushThresholdSize);
      this.flushThresholdSize=flushThresholdSize;
    }
    final EngineConfig config=engineConfig;
    final boolean flushOnClose=settings.getAsBoolean(INDEX_FLUSH_ON_CLOSE,this.flushOnClose);
    if (flushOnClose != this.flushOnClose) {
      logger.info("updating {} from [{}] to [{}]",INDEX_FLUSH_ON_CLOSE,this.flushOnClose,flushOnClose);
      this.flushOnClose=flushOnClose;
    }
    TimeValue refreshInterval=settings.getAsTime(INDEX_REFRESH_INTERVAL,this.refreshInterval);
    if (!refreshInterval.equals(this.refreshInterval)) {
      logger.info("updating refresh_interval from [{}] to [{}]",this.refreshInterval,refreshInterval);
      if (refreshScheduledFuture != null) {
        FutureUtils.cancel(refreshScheduledFuture);
        refreshScheduledFuture=null;
      }
      this.refreshInterval=refreshInterval;
      if (refreshInterval.millis() > 0) {
        refreshScheduledFuture=threadPool.schedule(refreshInterval,ThreadPool.Names.SAME,new EngineRefresher());
      }
    }
    long gcDeletesInMillis=settings.getAsTime(EngineConfig.INDEX_GC_DELETES_SETTING,TimeValue.timeValueMillis(config.getGcDeletesInMillis())).millis();
    if (gcDeletesInMillis != config.getGcDeletesInMillis()) {
      logger.info("updating {} from [{}] to [{}]",EngineConfig.INDEX_GC_DELETES_SETTING,TimeValue.timeValueMillis(config.getGcDeletesInMillis()),TimeValue.timeValueMillis(gcDeletesInMillis));
      config.setGcDeletesInMillis(gcDeletesInMillis);
      change=true;
    }
    final int maxThreadCount=settings.getAsInt(MergeSchedulerConfig.MAX_THREAD_COUNT,mergeSchedulerConfig.getMaxThreadCount());
    if (maxThreadCount != mergeSchedulerConfig.getMaxThreadCount()) {
      logger.info("updating [{}] from [{}] to [{}]",MergeSchedulerConfig.MAX_THREAD_COUNT,mergeSchedulerConfig.getMaxMergeCount(),maxThreadCount);
      mergeSchedulerConfig.setMaxThreadCount(maxThreadCount);
      change=true;
    }
    final int maxMergeCount=settings.getAsInt(MergeSchedulerConfig.MAX_MERGE_COUNT,mergeSchedulerConfig.getMaxMergeCount());
    if (maxMergeCount != mergeSchedulerConfig.getMaxMergeCount()) {
      logger.info("updating [{}] from [{}] to [{}]",MergeSchedulerConfig.MAX_MERGE_COUNT,mergeSchedulerConfig.getMaxMergeCount(),maxMergeCount);
      mergeSchedulerConfig.setMaxMergeCount(maxMergeCount);
      change=true;
    }
    final boolean autoThrottle=settings.getAsBoolean(MergeSchedulerConfig.AUTO_THROTTLE,mergeSchedulerConfig.isAutoThrottle());
    if (autoThrottle != mergeSchedulerConfig.isAutoThrottle()) {
      logger.info("updating [{}] from [{}] to [{}]",MergeSchedulerConfig.AUTO_THROTTLE,mergeSchedulerConfig.isAutoThrottle(),autoThrottle);
      mergeSchedulerConfig.setAutoThrottle(autoThrottle);
      change=true;
    }
  }
  mergePolicyConfig.onRefreshSettings(settings);
  searchService.onRefreshSettings(settings);
  indexingService.onRefreshSettings(settings);
  if (change) {
    getEngine().onSettingsChanged();
  }
}
