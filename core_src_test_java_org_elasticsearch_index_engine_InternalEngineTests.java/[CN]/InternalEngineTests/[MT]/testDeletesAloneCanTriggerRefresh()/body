{
  Settings settings=Settings.builder().put(defaultSettings).put(IndexingMemoryController.INDEX_BUFFER_SIZE_SETTING,"1kb").build();
  try (Store store=createStore();Engine engine=new InternalEngine(config(settings,store,createTempDir(),new MergeSchedulerConfig(defaultSettings),newMergePolicy()),false)){
    for (int i=0; i < 100; i++) {
      String id=Integer.toString(i);
      ParsedDocument doc=testParsedDocument(id,id,"test",null,-1,-1,testDocument(),B_1,null);
      engine.index(new Engine.Index(newUid(id),doc,2,VersionType.EXTERNAL,Engine.Operation.Origin.PRIMARY,System.nanoTime()));
    }
    engine.forceMerge(true,1,false,false,false);
    IndexingMemoryController imc=new IndexingMemoryController(settings,threadPool,null){
      @Override protected IndexShard getShard(      ShardId shardId){
        return null;
      }
      @Override protected List<ShardId> availableShards(){
        return Collections.singletonList(new ShardId("foo",0));
      }
      @Override protected void refreshShardAsync(      ShardId shardId){
        engine.refresh("memory");
      }
      @Override protected long getIndexBufferRAMBytesUsed(      ShardId shardId){
        System.out.println("BYTES USED: " + engine.indexBufferRAMBytesUsed());
        return engine.indexBufferRAMBytesUsed();
      }
    }
;
    Searcher s=engine.acquireSearcher("test");
    final long version1=((DirectoryReader)s.reader()).getVersion();
    s.close();
    for (int i=0; i < 100; i++) {
      String id=Integer.toString(i);
      engine.delete(new Engine.Delete("test",id,newUid(id),10,VersionType.EXTERNAL,Engine.Operation.Origin.PRIMARY,System.nanoTime(),false));
    }
    imc.forceCheck();
    try (Searcher s2=engine.acquireSearcher("test")){
      assertThat(((DirectoryReader)s2.reader()).getVersion(),greaterThan(version1));
    }
   }
 }
