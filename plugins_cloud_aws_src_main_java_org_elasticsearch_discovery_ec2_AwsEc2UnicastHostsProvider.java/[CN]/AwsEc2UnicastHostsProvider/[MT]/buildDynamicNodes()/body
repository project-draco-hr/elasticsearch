{
  List<DiscoveryNode> discoNodes=Lists.newArrayList();
  DescribeInstancesResult descInstances=client.describeInstances(new DescribeInstancesRequest());
  logger.trace("building dynamic unicast discovery nodes...");
  for (  Reservation reservation : descInstances.getReservations()) {
    if (!groups.isEmpty()) {
      boolean filter=false;
      for (      String group : reservation.getGroupNames()) {
        if (!groups.contains(group)) {
          logger.trace("filtering out reservation {} based on group {}, not part of {}",reservation.getReservationId(),group,groups);
          filter=true;
          break;
        }
      }
      if (filter) {
        continue;
      }
    }
    for (    Instance instance : reservation.getInstances()) {
      if (!availabilityZones.isEmpty()) {
        if (!availabilityZones.contains(instance.getPlacement().getAvailabilityZone())) {
          logger.trace("filtering out instance {} based on availability_zone {}, not part of {}",instance.getInstanceId(),instance.getPlacement().getAvailabilityZone(),availabilityZones);
          continue;
        }
      }
      InstanceState state=instance.getState();
      if (state.getName().equalsIgnoreCase("pending") || state.getName().equalsIgnoreCase("running")) {
        String address=null;
switch (hostType) {
case PRIVATE_DNS:
          address=instance.getPrivateDnsName();
        break;
case PRIVATE_IP:
      address=instance.getPrivateIpAddress();
    break;
case PUBLIC_DNS:
  address=instance.getPublicDnsName();
break;
case PUBLIC_IP:
address=instance.getPublicDnsName();
break;
}
for (int port : new PortsRange(ports).ports()) {
logger.trace("adding {}, address {}",instance.getInstanceId(),address);
discoNodes.add(new DiscoveryNode("#cloud-" + instance.getInstanceId() + "-"+ port,new InetSocketTransportAddress(address,port)));
}
}
}
}
logger.debug("using dynamic discovery nodes {}",discoNodes);
return discoNodes;
}
