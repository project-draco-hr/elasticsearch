{
  client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards",1).put("index.number_of_replicas",0)).execute().actionGet();
  client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();
  int recCount=randomIntBetween(200,600);
  int numberOfTypes=randomIntBetween(1,5);
  List<IndexRequestBuilder> indexRequests=Lists.newArrayList();
  for (int rec=0; rec < recCount; rec++) {
    String type="type" + (rec % numberOfTypes);
    String fieldName="field_" + type + "_"+ rec;
    indexRequests.add(client().prepareIndex("test",type,Integer.toString(rec)).setSource(fieldName,"some_value"));
  }
  indexRandom(true,indexRequests);
  logger.info("checking all the documents are there");
  RefreshResponse refreshResponse=client().admin().indices().prepareRefresh().execute().actionGet();
  assertThat(refreshResponse.getFailedShards(),equalTo(0));
  CountResponse response=client().prepareCount("test").execute().actionGet();
  assertThat(response.getCount(),equalTo((long)recCount));
  logger.info("checking all the fields are in the mappings");
  reRunTest:   while (true) {
    Map<String,String> typeToSource=Maps.newHashMap();
    ClusterState state=client().admin().cluster().prepareState().get().getState();
    for (    ObjectObjectCursor<String,MappingMetaData> cursor : state.getMetaData().getIndices().get("test").getMappings()) {
      typeToSource.put(cursor.key,cursor.value.source().string());
    }
    for (int rec=0; rec < recCount; rec++) {
      String type="type" + (rec % numberOfTypes);
      String fieldName="field_" + type + "_"+ rec;
      fieldName="\"" + fieldName + "\"";
      if (!typeToSource.containsKey(type) || !typeToSource.get(type).contains(fieldName)) {
        awaitBusy(new Predicate<Object>(){
          @Override public boolean apply(          Object input){
            PendingClusterTasksResponse pendingTasks=client().admin().cluster().preparePendingClusterTasks().get();
            return pendingTasks.pendingTasks().isEmpty();
          }
        }
);
        ClusterState state2=client().admin().cluster().prepareState().get().getState();
        if (state.version() != state2.version()) {
          logger.info("not the same version, used for test {}, new one {}, re-running test, first wait for mapping to wait",state.version(),state2.version());
          continue reRunTest;
        }
        logger.info("failing, type {}, field {}, mapping {}",type,fieldName,typeToSource.get(type));
        assertThat(typeToSource.get(type),containsString(fieldName));
      }
    }
    break;
  }
}
