{
  logger.info("--> start node A");
  final String nodeA=internalCluster().startNode();
  logger.info("--> create index on node: {}",nodeA);
  ByteSizeValue shardSize=createAndPopulateIndex(INDEX_NAME,1,SHARD_COUNT,REPLICA_COUNT).getShards()[0].getStats().getStore().size();
  logger.info("--> start node B");
  final String nodeB=internalCluster().startNode();
  ensureGreen();
  logger.info("--> slowing down recoveries");
  slowDownRecovery(shardSize);
  logger.info("--> move shard from: {} to: {}",nodeA,nodeB);
  client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(new ShardId(INDEX_NAME,0),nodeA,nodeB)).execute().actionGet().getState();
  logger.info("--> waiting for recovery to start both on source and target");
  assertBusy(new Runnable(){
    @Override public void run(){
      IndicesService indicesService=internalCluster().getInstance(IndicesService.class,nodeA);
      assertThat(indicesService.indexServiceSafe(INDEX_NAME).shardSafe(0).recoveryStats().currentAsSource(),equalTo(1));
      indicesService=internalCluster().getInstance(IndicesService.class,nodeB);
      assertThat(indicesService.indexServiceSafe(INDEX_NAME).shardSafe(0).recoveryStats().currentAsTarget(),equalTo(1));
    }
  }
);
  logger.info("--> request recoveries");
  RecoveryResponse response=client().admin().indices().prepareRecoveries(INDEX_NAME).execute().actionGet();
  List<ShardRecoveryResponse> shardResponses=response.shardResponses().get(INDEX_NAME);
  List<ShardRecoveryResponse> nodeAResponses=findRecoveriesForTargetNode(nodeA,shardResponses);
  assertThat(nodeAResponses.size(),equalTo(1));
  List<ShardRecoveryResponse> nodeBResponses=findRecoveriesForTargetNode(nodeB,shardResponses);
  assertThat(nodeBResponses.size(),equalTo(1));
  assertRecoveryState(nodeAResponses.get(0).recoveryState(),0,Type.GATEWAY,Stage.DONE,nodeA,nodeA,false);
  validateIndexRecoveryState(nodeAResponses.get(0).recoveryState().getIndex());
  assertOnGoingRecoveryState(nodeBResponses.get(0).recoveryState(),0,Type.RELOCATION,nodeA,nodeB,false);
  validateIndexRecoveryState(nodeBResponses.get(0).recoveryState().getIndex());
  logger.info("--> request node recovery stats");
  NodesStatsResponse statsResponse=client().admin().cluster().prepareNodesStats().clear().setIndices(new CommonStatsFlags(CommonStatsFlags.Flag.Recovery)).get();
  long nodeAThrottling=Long.MAX_VALUE;
  long nodeBThrottling=Long.MAX_VALUE;
  for (  NodeStats nodeStats : statsResponse.getNodes()) {
    final RecoveryStats recoveryStats=nodeStats.getIndices().getRecoveryStats();
    if (nodeStats.getNode().name().equals(nodeA)) {
      assertThat("node A should have ongoing recovery as source",recoveryStats.currentAsSource(),equalTo(1));
      assertThat("node A should not have ongoing recovery as target",recoveryStats.currentAsTarget(),equalTo(0));
      nodeAThrottling=recoveryStats.throttleTime().millis();
    }
    if (nodeStats.getNode().name().equals(nodeB)) {
      assertThat("node B should not have ongoing recovery as source",recoveryStats.currentAsSource(),equalTo(0));
      assertThat("node B should have ongoing recovery as target",recoveryStats.currentAsTarget(),equalTo(1));
      nodeBThrottling=recoveryStats.throttleTime().millis();
    }
  }
  logger.info("--> checking throttling increases");
  final long finalNodeAThrottling=nodeAThrottling;
  final long finalNodeBThrottling=nodeBThrottling;
  assertBusy(new Runnable(){
    @Override public void run(){
      NodesStatsResponse statsResponse=client().admin().cluster().prepareNodesStats().clear().setIndices(new CommonStatsFlags(CommonStatsFlags.Flag.Recovery)).get();
      assertThat(statsResponse.getNodes(),arrayWithSize(2));
      for (      NodeStats nodeStats : statsResponse.getNodes()) {
        final RecoveryStats recoveryStats=nodeStats.getIndices().getRecoveryStats();
        if (nodeStats.getNode().name().equals(nodeA)) {
          assertThat("node A throttling should increase",recoveryStats.throttleTime().millis(),greaterThan(finalNodeAThrottling));
        }
        if (nodeStats.getNode().name().equals(nodeB)) {
          assertThat("node B throttling should increase",recoveryStats.throttleTime().millis(),greaterThan(finalNodeBThrottling));
        }
      }
    }
  }
);
  logger.info("--> speeding up recoveries");
  restoreRecoverySpeed();
  ensureGreen();
  response=client().admin().indices().prepareRecoveries(INDEX_NAME).execute().actionGet();
  shardResponses=response.shardResponses().get(INDEX_NAME);
  assertThat(shardResponses.size(),equalTo(1));
  assertRecoveryState(shardResponses.get(0).recoveryState(),0,Type.RELOCATION,Stage.DONE,nodeA,nodeB,false);
  validateIndexRecoveryState(shardResponses.get(0).recoveryState().getIndex());
  statsResponse=client().admin().cluster().prepareNodesStats().clear().setIndices(new CommonStatsFlags(CommonStatsFlags.Flag.Recovery)).get();
  assertThat(statsResponse.getNodes(),arrayWithSize(2));
  for (  NodeStats nodeStats : statsResponse.getNodes()) {
    final RecoveryStats recoveryStats=nodeStats.getIndices().getRecoveryStats();
    assertThat(recoveryStats.currentAsSource(),equalTo(0));
    assertThat(recoveryStats.currentAsTarget(),equalTo(0));
    if (nodeStats.getNode().name().equals(nodeA)) {
      assertThat("node A throttling should be >0",recoveryStats.throttleTime().millis(),greaterThan(0l));
    }
    if (nodeStats.getNode().name().equals(nodeB)) {
      assertThat("node B throttling should be >0 ",recoveryStats.throttleTime().millis(),greaterThan(0l));
    }
  }
  logger.info("--> bump replica count");
  client().admin().indices().prepareUpdateSettings(INDEX_NAME).setSettings(settingsBuilder().put("number_of_replicas",1)).execute().actionGet();
  ensureGreen();
  statsResponse=client().admin().cluster().prepareNodesStats().clear().setIndices(new CommonStatsFlags(CommonStatsFlags.Flag.Recovery)).get();
  assertThat(statsResponse.getNodes(),arrayWithSize(2));
  for (  NodeStats nodeStats : statsResponse.getNodes()) {
    final RecoveryStats recoveryStats=nodeStats.getIndices().getRecoveryStats();
    assertThat(recoveryStats.currentAsSource(),equalTo(0));
    assertThat(recoveryStats.currentAsTarget(),equalTo(0));
    if (nodeStats.getNode().name().equals(nodeA)) {
      assertThat("node A throttling should be >0",recoveryStats.throttleTime().millis(),greaterThan(0l));
    }
    if (nodeStats.getNode().name().equals(nodeB)) {
      assertThat("node B throttling should be >0 ",recoveryStats.throttleTime().millis(),greaterThan(0l));
    }
  }
  logger.info("--> start node C");
  String nodeC=internalCluster().startNode();
  assertFalse(client().admin().cluster().prepareHealth().setWaitForNodes("3").get().isTimedOut());
  logger.info("--> slowing down recoveries");
  slowDownRecovery(shardSize);
  logger.info("--> move replica shard from: {} to: {}",nodeA,nodeC);
  client().admin().cluster().prepareReroute().add(new MoveAllocationCommand(new ShardId(INDEX_NAME,0),nodeA,nodeC)).execute().actionGet().getState();
  response=client().admin().indices().prepareRecoveries(INDEX_NAME).execute().actionGet();
  shardResponses=response.shardResponses().get(INDEX_NAME);
  nodeAResponses=findRecoveriesForTargetNode(nodeA,shardResponses);
  assertThat(nodeAResponses.size(),equalTo(1));
  nodeBResponses=findRecoveriesForTargetNode(nodeB,shardResponses);
  assertThat(nodeBResponses.size(),equalTo(1));
  List<ShardRecoveryResponse> nodeCResponses=findRecoveriesForTargetNode(nodeC,shardResponses);
  assertThat(nodeCResponses.size(),equalTo(1));
  assertRecoveryState(nodeAResponses.get(0).recoveryState(),0,Type.REPLICA,Stage.DONE,nodeB,nodeA,false);
  validateIndexRecoveryState(nodeAResponses.get(0).recoveryState().getIndex());
  assertRecoveryState(nodeBResponses.get(0).recoveryState(),0,Type.RELOCATION,Stage.DONE,nodeA,nodeB,false);
  validateIndexRecoveryState(nodeBResponses.get(0).recoveryState().getIndex());
  assertOnGoingRecoveryState(nodeCResponses.get(0).recoveryState(),0,Type.REPLICA,nodeB,nodeC,false);
  validateIndexRecoveryState(nodeCResponses.get(0).recoveryState().getIndex());
  logger.info("--> speeding up recoveries");
  restoreRecoverySpeed();
  ensureGreen();
  response=client().admin().indices().prepareRecoveries(INDEX_NAME).execute().actionGet();
  shardResponses=response.shardResponses().get(INDEX_NAME);
  nodeAResponses=findRecoveriesForTargetNode(nodeA,shardResponses);
  assertThat(nodeAResponses.size(),equalTo(0));
  nodeBResponses=findRecoveriesForTargetNode(nodeB,shardResponses);
  assertThat(nodeBResponses.size(),equalTo(1));
  nodeCResponses=findRecoveriesForTargetNode(nodeC,shardResponses);
  assertThat(nodeCResponses.size(),equalTo(1));
  assertRecoveryState(nodeBResponses.get(0).recoveryState(),0,Type.RELOCATION,Stage.DONE,nodeA,nodeB,false);
  validateIndexRecoveryState(nodeBResponses.get(0).recoveryState().getIndex());
  assertRecoveryState(nodeCResponses.get(0).recoveryState(),0,Type.REPLICA,Stage.DONE,nodeB,nodeC,false);
  validateIndexRecoveryState(nodeCResponses.get(0).recoveryState().getIndex());
}
