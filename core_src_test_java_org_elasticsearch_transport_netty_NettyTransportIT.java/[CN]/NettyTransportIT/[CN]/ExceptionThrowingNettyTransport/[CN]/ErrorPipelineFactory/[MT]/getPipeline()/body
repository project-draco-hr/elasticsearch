{
  ChannelPipeline pipeline=super.getPipeline();
  pipeline.replace("dispatcher","dispatcher",new MessageChannelHandler(nettyTransport,logger,NettyTransport.DEFAULT_PROFILE){
    @Override protected String handleRequest(    Channel channel,    StreamInput buffer,    long requestId,    Version version) throws IOException {
      final String action=buffer.readString();
      final NettyTransportChannel transportChannel=new NettyTransportChannel(transport,transportServiceAdapter,action,channel,requestId,version,name);
      try {
        final RequestHandlerRegistry reg=transportServiceAdapter.getRequestHandler(action);
        if (reg == null) {
          throw new ActionNotFoundTransportException(action);
        }
        final TransportRequest request=reg.newRequest();
        request.remoteAddress(new InetSocketTransportAddress((InetSocketAddress)channel.getRemoteAddress()));
        request.readFrom(buffer);
        if (request.hasHeader("ERROR")) {
          throw new ElasticsearchException((String)request.getHeader("ERROR"));
        }
        if (reg.getExecutor() == ThreadPool.Names.SAME) {
          reg.processMessageReceived(request,transportChannel);
        }
 else {
          threadPool.executor(reg.getExecutor()).execute(new RequestHandler(reg,request,transportChannel));
        }
      }
 catch (      Throwable e) {
        try {
          transportChannel.sendResponse(e);
        }
 catch (        IOException e1) {
          logger.warn("Failed to send error message back to client for action [" + action + "]",e);
          logger.warn("Actual Exception",e1);
        }
      }
      channelProfileName=transportChannel.getProfileName();
      return action;
    }
class RequestHandler extends AbstractRunnable {
      private final RequestHandlerRegistry reg;
      private final TransportRequest request;
      private final NettyTransportChannel transportChannel;
      public RequestHandler(      RequestHandlerRegistry reg,      TransportRequest request,      NettyTransportChannel transportChannel){
        this.reg=reg;
        this.request=request;
        this.transportChannel=transportChannel;
      }
      @SuppressWarnings({"unchecked"}) @Override protected void doRun() throws Exception {
        reg.processMessageReceived(request,transportChannel);
      }
      @Override public boolean isForceExecution(){
        return reg.isForceExecution();
      }
      @Override public void onFailure(      Throwable e){
        if (transport.lifecycleState() == Lifecycle.State.STARTED) {
          try {
            transportChannel.sendResponse(e);
          }
 catch (          Throwable e1) {
            logger.warn("Failed to send error message back to client for action [" + reg.getAction() + "]",e1);
            logger.warn("Actual Exception",e);
          }
        }
      }
    }
  }
);
  return pipeline;
}
