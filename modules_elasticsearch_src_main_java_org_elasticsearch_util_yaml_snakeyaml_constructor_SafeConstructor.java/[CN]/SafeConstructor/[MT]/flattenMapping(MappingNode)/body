{
  List<NodeTuple> merge=new ArrayList<NodeTuple>();
  int index=0;
  List<NodeTuple> nodeValue=(List<NodeTuple>)node.getValue();
  while (index < nodeValue.size()) {
    Node keyNode=nodeValue.get(index).getKeyNode();
    Node valueNode=nodeValue.get(index).getValueNode();
    if (keyNode.getTag().equals(Tag.MERGE)) {
      nodeValue.remove(index);
switch (valueNode.getNodeId()) {
case mapping:
        MappingNode mn=(MappingNode)valueNode;
      flattenMapping(mn);
    merge.addAll(mn.getValue());
  break;
case sequence:
List<List<NodeTuple>> submerge=new ArrayList<List<NodeTuple>>();
SequenceNode sn=(SequenceNode)valueNode;
List<Node> vals=sn.getValue();
for (Node subnode : vals) {
if (!(subnode instanceof MappingNode)) {
throw new ConstructorException("while constructing a mapping",node.getStartMark(),"expected a mapping for merging, but found " + subnode.getNodeId(),subnode.getStartMark());
}
MappingNode mnode=(MappingNode)subnode;
flattenMapping(mnode);
submerge.add(mnode.getValue());
}
Collections.reverse(submerge);
for (List<NodeTuple> value : submerge) {
merge.addAll(value);
}
break;
default :
throw new ConstructorException("while constructing a mapping",node.getStartMark(),"expected a mapping or list of mappings for merging, but found " + valueNode.getNodeId(),valueNode.getStartMark());
}
}
 else if (keyNode.getTag().equals(Tag.VALUE)) {
keyNode.setTag(Tag.STR);
index++;
}
 else {
index++;
}
}
if (!merge.isEmpty()) {
merge.addAll(nodeValue);
((MappingNode)node).setValue(merge);
}
}
