{
  boolean compound=randomBoolean();
  assertAcked(client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.builder().put("number_of_replicas",0).put("number_of_shards",1).put(InternalEngine.INDEX_COMPOUND_ON_FLUSH,compound).put(AbstractMergePolicyProvider.INDEX_COMPOUND_FORMAT,compound)));
  final int numDocs=randomIntBetween(10,100);
  IndexRequestBuilder[] builders=new IndexRequestBuilder[numDocs];
  for (int i=0; i < builders.length; i++) {
    builders[i]=client().prepareIndex("test","type").setSource("field","value");
  }
  indexRandom(true,builders);
  ensureGreen();
  flushAndRefresh();
  client().admin().indices().prepareOptimize("test").setMaxNumSegments(1).setWaitForMerge(true).get();
  IndexSegments firstSegments=client().admin().indices().prepareSegments("test").get().getIndices().get("test");
  client().admin().indices().prepareOptimize("test").setMaxNumSegments(1).setWaitForMerge(true).get();
  IndexSegments secondsSegments=client().admin().indices().prepareSegments("test").get().getIndices().get("test");
  assertThat(segments(firstSegments),Matchers.containsInAnyOrder(segments(secondsSegments).toArray()));
  assertThat(segments(firstSegments).size(),Matchers.equalTo(1));
  assertThat(segments(secondsSegments),Matchers.containsInAnyOrder(segments(firstSegments).toArray()));
  assertThat(segments(secondsSegments).size(),Matchers.equalTo(1));
  client().admin().indices().prepareOptimize("test").setMaxNumSegments(1).setWaitForMerge(true).setForce(true).get();
  IndexSegments thirdSegments=client().admin().indices().prepareSegments("test").get().getIndices().get("test");
  assertThat(segments(firstSegments).size(),Matchers.equalTo(1));
  assertThat(segments(thirdSegments).size(),Matchers.equalTo(1));
  assertThat(segments(firstSegments),Matchers.not(Matchers.containsInAnyOrder(segments(thirdSegments).toArray())));
  assertThat(segments(thirdSegments),Matchers.not(Matchers.containsInAnyOrder(segments(firstSegments).toArray())));
}
