{
  clusterService.submitStateUpdateTask("index-aliases",new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT,request,listener){
    @Override protected ClusterStateUpdateResponse newResponse(    boolean acknowledged){
      return new ClusterStateUpdateResponse(acknowledged);
    }
    @Override public ClusterState execute(    final ClusterState currentState){
      List<String> indicesToClose=new ArrayList<>();
      Map<String,IndexService> indices=new HashMap<>();
      try {
        for (        AliasAction aliasAction : request.actions()) {
          aliasValidator.validateAliasAction(aliasAction,currentState.metaData());
          if (!currentState.metaData().hasIndex(aliasAction.index())) {
            throw new IndexNotFoundException(aliasAction.index());
          }
        }
        boolean changed=false;
        MetaData.Builder builder=MetaData.builder(currentState.metaData());
        for (        AliasAction aliasAction : request.actions()) {
          IndexMetaData indexMetaData=builder.get(aliasAction.index());
          if (indexMetaData == null) {
            throw new IndexNotFoundException(aliasAction.index());
          }
          IndexMetaData.Builder indexMetaDataBuilder=IndexMetaData.builder(indexMetaData);
          if (aliasAction.actionType() == AliasAction.Type.ADD) {
            String filter=aliasAction.filter();
            if (Strings.hasLength(filter)) {
              IndexService indexService=indices.get(indexMetaData.getIndex());
              if (indexService == null) {
                indexService=indicesService.indexService(indexMetaData.getIndex());
                if (indexService == null) {
                  try {
                    indexService=indicesService.createIndex(nodeServicesProvider,indexMetaData,Collections.emptyList());
                    for (                    ObjectCursor<MappingMetaData> cursor : indexMetaData.getMappings().values()) {
                      MappingMetaData mappingMetaData=cursor.value;
                      indexService.mapperService().merge(mappingMetaData.type(),mappingMetaData.source(),MapperService.MergeReason.MAPPING_RECOVERY,false);
                    }
                  }
 catch (                  Exception e) {
                    logger.warn("[{}] failed to temporary create in order to apply alias action",e,indexMetaData.getIndex());
                    continue;
                  }
                  indicesToClose.add(indexMetaData.getIndex().getName());
                }
                indices.put(indexMetaData.getIndex().getName(),indexService);
              }
              aliasValidator.validateAliasFilter(aliasAction.alias(),filter,indexService.getQueryShardContext());
            }
            AliasMetaData newAliasMd=AliasMetaData.newAliasMetaDataBuilder(aliasAction.alias()).filter(filter).indexRouting(aliasAction.indexRouting()).searchRouting(aliasAction.searchRouting()).build();
            AliasMetaData aliasMd=indexMetaData.getAliases().get(aliasAction.alias());
            if (aliasMd != null && aliasMd.equals(newAliasMd)) {
              continue;
            }
            indexMetaDataBuilder.putAlias(newAliasMd);
          }
 else           if (aliasAction.actionType() == AliasAction.Type.REMOVE) {
            if (!indexMetaData.getAliases().containsKey(aliasAction.alias())) {
              continue;
            }
            indexMetaDataBuilder.removeAlias(aliasAction.alias());
          }
          changed=true;
          builder.put(indexMetaDataBuilder);
        }
        if (changed) {
          ClusterState updatedState=ClusterState.builder(currentState).metaData(builder).build();
          if (!updatedState.metaData().equalsAliases(currentState.metaData())) {
            return updatedState;
          }
        }
        return currentState;
      }
  finally {
        for (        String index : indicesToClose) {
          indicesService.removeIndex(index,"created for alias processing");
        }
      }
    }
  }
);
}
