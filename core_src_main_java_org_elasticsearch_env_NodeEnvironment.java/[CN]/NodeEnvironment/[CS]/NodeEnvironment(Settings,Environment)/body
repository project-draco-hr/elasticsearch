{
  if (!DiscoveryNode.nodeRequiresLocalStorage(settings)) {
    nodePaths=null;
    sharedDataPath=null;
    locks=null;
    nodeLockId=-1;
    nodeMetaData=new NodeMetaData(generateNodeId(settings));
    logger=Loggers.getLogger(getClass(),Node.addNodeNameIfNeeded(settings,this.nodeMetaData.nodeId()));
    return;
  }
  final NodePath[] nodePaths=new NodePath[environment.dataWithClusterFiles().length];
  final Lock[] locks=new Lock[nodePaths.length];
  boolean success=false;
  Logger startupTraceLogger=Loggers.getLogger(getClass(),settings);
  try {
    sharedDataPath=environment.sharedDataFile();
    int nodeLockId=-1;
    IOException lastException=null;
    int maxLocalStorageNodes=MAX_LOCAL_STORAGE_NODES_SETTING.get(settings);
    for (int possibleLockId=0; possibleLockId < maxLocalStorageNodes; possibleLockId++) {
      for (int dirIndex=0; dirIndex < environment.dataFiles().length; dirIndex++) {
        Path dataDirWithClusterName=environment.dataWithClusterFiles()[dirIndex];
        Path dataDir=environment.dataFiles()[dirIndex];
        if (readFromDataPathWithClusterName(dataDirWithClusterName)) {
          DeprecationLogger deprecationLogger=new DeprecationLogger(startupTraceLogger);
          deprecationLogger.deprecated("ES has detected the [path.data] folder using the cluster name as a folder [{}], " + "Elasticsearch 6.0 will not allow the cluster name as a folder within the data path",dataDir);
          dataDir=dataDirWithClusterName;
        }
        Path dir=dataDir.resolve(NODES_FOLDER).resolve(Integer.toString(possibleLockId));
        Files.createDirectories(dir);
        try (Directory luceneDir=FSDirectory.open(dir,NativeFSLockFactory.INSTANCE)){
          startupTraceLogger.trace("obtaining node lock on {} ...",dir.toAbsolutePath());
          try {
            locks[dirIndex]=luceneDir.obtainLock(NODE_LOCK_FILENAME);
            nodePaths[dirIndex]=new NodePath(dir);
            nodeLockId=possibleLockId;
          }
 catch (          LockObtainFailedException ex) {
            startupTraceLogger.trace("failed to obtain node lock on {}",dir.toAbsolutePath());
            releaseAndNullLocks(locks);
            break;
          }
        }
 catch (        IOException e) {
          startupTraceLogger.trace(new ParameterizedMessage("failed to obtain node lock on {}",dir.toAbsolutePath()),e);
          lastException=new IOException("failed to obtain lock on " + dir.toAbsolutePath(),e);
          releaseAndNullLocks(locks);
          break;
        }
      }
      if (locks[0] != null) {
        break;
      }
    }
    if (locks[0] == null) {
      final String message=String.format(Locale.ROOT,"failed to obtain node locks, tried [%s] with lock id%s;" + " maybe these locations are not writable or multiple nodes were started without increasing [%s] (was [%d])?",Arrays.toString(environment.dataWithClusterFiles()),maxLocalStorageNodes == 1 ? " [0]" : "s [0--" + (maxLocalStorageNodes - 1) + "]",MAX_LOCAL_STORAGE_NODES_SETTING.getKey(),maxLocalStorageNodes);
      throw new IllegalStateException(message,lastException);
    }
    this.nodeMetaData=loadOrCreateNodeMetaData(settings,startupTraceLogger,nodePaths);
    this.logger=Loggers.getLogger(getClass(),Node.addNodeNameIfNeeded(settings,this.nodeMetaData.nodeId()));
    this.nodeLockId=nodeLockId;
    this.locks=locks;
    this.nodePaths=nodePaths;
    if (logger.isDebugEnabled()) {
      logger.debug("using node location [{}], local_lock_id [{}]",nodePaths,nodeLockId);
    }
    maybeLogPathDetails();
    maybeLogHeapDetails();
    applySegmentInfosTrace(settings);
    assertCanWrite();
    success=true;
  }
  finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(locks);
    }
  }
}
