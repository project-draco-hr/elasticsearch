{
  double realWordErrorLikelihood=suggestion.realworldErrorLikelyhood();
  final PhraseSuggestion response=new PhraseSuggestion(name,suggestion.getSize());
  List<PhraseSuggestionContext.DirectCandidateGenerator> generators=suggestion.generators();
  final int numGenerators=generators.size();
  final List<CandidateGenerator> gens=new ArrayList<>(generators.size());
  for (int i=0; i < numGenerators; i++) {
    PhraseSuggestionContext.DirectCandidateGenerator generator=generators.get(i);
    DirectSpellChecker directSpellChecker=SuggestUtils.getDirectSpellChecker(generator);
    Terms terms=MultiFields.getTerms(indexReader,generator.field());
    if (terms != null) {
      gens.add(new DirectCandidateGenerator(directSpellChecker,generator.field(),generator.suggestMode(),indexReader,realWordErrorLikelihood,generator.size(),generator.preFilter(),generator.postFilter(),terms));
    }
  }
  final String suggestField=suggestion.getField();
  final Terms suggestTerms=MultiFields.getTerms(indexReader,suggestField);
  if (gens.size() > 0 && suggestTerms != null) {
    final NoisyChannelSpellChecker checker=new NoisyChannelSpellChecker(realWordErrorLikelihood,suggestion.getRequireUnigram(),suggestion.getTokenLimit());
    final BytesRef separator=suggestion.separator();
    TokenStream stream=checker.tokenStream(suggestion.getAnalyzer(),suggestion.getText(),spare,suggestion.getField());
    WordScorer wordScorer=suggestion.model().newScorer(indexReader,suggestTerms,suggestField,realWordErrorLikelihood,separator);
    Result checkerResult=checker.getCorrections(stream,new MultiCandidateGeneratorWrapper(suggestion.getShardSize(),gens.toArray(new CandidateGenerator[gens.size()])),suggestion.maxErrors(),suggestion.getShardSize(),indexReader,wordScorer,separator,suggestion.confidence(),suggestion.gramSize());
    PhraseSuggestion.Entry resultEntry=buildResultEntry(suggestion,spare,checkerResult.cutoffScore);
    response.addTerm(resultEntry);
    BytesRefBuilder byteSpare=new BytesRefBuilder();
    MultiSearchResponse multiSearchResponse=collate(suggestion,checkerResult,byteSpare,spare);
    final boolean collateEnabled=multiSearchResponse != null;
    final boolean collatePrune=suggestion.collatePrune();
    for (int i=0; i < checkerResult.corrections.length; i++) {
      boolean collateMatch=hasMatchingDocs(multiSearchResponse,i);
      if (!collateMatch && !collatePrune) {
        continue;
      }
      Correction correction=checkerResult.corrections[i];
      spare.copyUTF8Bytes(correction.join(SEPARATOR,byteSpare,null,null));
      Text phrase=new StringText(spare.toString());
      Text highlighted=null;
      if (suggestion.getPreTag() != null) {
        spare.copyUTF8Bytes(correction.join(SEPARATOR,byteSpare,suggestion.getPreTag(),suggestion.getPostTag()));
        highlighted=new StringText(spare.toString());
      }
      if (collateEnabled && collatePrune) {
        resultEntry.addOption(new Suggestion.Entry.Option(phrase,highlighted,(float)(correction.score),collateMatch));
      }
 else {
        resultEntry.addOption(new Suggestion.Entry.Option(phrase,highlighted,(float)(correction.score)));
      }
    }
  }
 else {
    response.addTerm(buildResultEntry(suggestion,spare,Double.MIN_VALUE));
  }
  return response;
}
