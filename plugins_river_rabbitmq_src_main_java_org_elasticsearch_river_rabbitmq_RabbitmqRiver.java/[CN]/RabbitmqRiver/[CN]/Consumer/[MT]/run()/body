{
  while (true) {
    if (closed) {
      return;
    }
    try {
      connection=connectionFactory.newConnection();
      channel=connection.createChannel();
    }
 catch (    Exception e) {
      if (!closed) {
        logger.warn("failed to created a connection / channel",e);
      }
 else {
        continue;
      }
      cleanup(0,"failed to connect");
      try {
        Thread.sleep(5000);
      }
 catch (      InterruptedException e1) {
      }
    }
    int bulkSize=XContentMapValues.nodeIntegerValue(settings.settings().get("bulk_size"),100);
    long bulkTimeout=XContentMapValues.nodeIntegerValue(settings.settings().get("bulk_timeout"),10);
    String queue=XContentMapValues.nodeStringValue(settings.settings().get("queue"),"elasticsearch");
    String exchange=XContentMapValues.nodeStringValue(settings.settings().get("exchange"),"elasticsearch");
    String routingKey=XContentMapValues.nodeStringValue(settings.settings().get("routing_key"),"elasticsearch");
    QueueingConsumer consumer=new QueueingConsumer(channel);
    try {
      channel.exchangeDeclare(exchange,"direct",true);
      channel.queueDeclare(queue,true,false,false,null);
      channel.queueBind(queue,exchange,routingKey);
      channel.basicConsume(queue,false,consumer);
    }
 catch (    Exception e) {
      if (!closed) {
        logger.warn("failed to create queue [{}]",e,queue);
      }
      cleanup(0,"failed to create queue");
      continue;
    }
    while (true) {
      if (closed) {
        break;
      }
      QueueingConsumer.Delivery task;
      try {
        task=consumer.nextDelivery();
      }
 catch (      Exception e) {
        if (!closed) {
          logger.error("failed to get next message, reconnecting...",e);
        }
        cleanup(0,"failed to get message");
        break;
      }
      if (task != null && task.getBody() != null) {
        final List<Long> deliveryTags=Lists.newArrayList();
        BulkRequestBuilder bulkRequestBuilder=client.prepareBulk();
        try {
          bulkRequestBuilder.add(task.getBody(),0,task.getBody().length,false);
        }
 catch (        Exception e) {
          logger.warn("failed to parse request for delivery tag [{}], ack'ing...",e,task.getEnvelope().getDeliveryTag());
          try {
            channel.basicAck(task.getEnvelope().getDeliveryTag(),false);
          }
 catch (          IOException e1) {
            logger.warn("failed to ack [{}]",e1,task.getEnvelope().getDeliveryTag());
          }
          continue;
        }
        deliveryTags.add(task.getEnvelope().getDeliveryTag());
        if (bulkRequestBuilder.numberOfActions() < bulkSize) {
          try {
            while ((task=consumer.nextDelivery(bulkTimeout)) != null) {
              try {
                bulkRequestBuilder.add(task.getBody(),0,task.getBody().length,false);
              }
 catch (              Exception e) {
                logger.warn("failed to parse request for delivery tag [{}], ack'ing...",e,task.getEnvelope().getDeliveryTag());
                try {
                  channel.basicAck(task.getEnvelope().getDeliveryTag(),false);
                }
 catch (                IOException e1) {
                  logger.warn("failed to ack on failure [{}]",e1,task.getEnvelope().getDeliveryTag());
                }
              }
              deliveryTags.add(task.getEnvelope().getDeliveryTag());
              if (bulkRequestBuilder.numberOfActions() >= bulkSize) {
                break;
              }
            }
          }
 catch (          InterruptedException e) {
            if (closed) {
              break;
            }
          }
        }
        if (logger.isTraceEnabled()) {
          logger.trace("executing bulk with [{}] actions",bulkRequestBuilder.numberOfActions());
        }
        bulkRequestBuilder.execute(new ActionListener<BulkResponse>(){
          @Override public void onResponse(          BulkResponse response){
            if (response.hasFailures()) {
              logger.warn("failed to execute" + response.buildFailureMessage());
            }
            for (            Long deliveryTag : deliveryTags) {
              try {
                channel.basicAck(deliveryTag,false);
              }
 catch (              IOException e1) {
                logger.warn("failed to ack [{}]",e1,deliveryTag);
              }
            }
          }
          @Override public void onFailure(          Throwable e){
            logger.warn("failed to execute bulk for delivery tags , not ack'ing",e,deliveryTags);
          }
        }
);
      }
    }
  }
}
