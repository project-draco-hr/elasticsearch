{
  byte[] result=targetBuffer;
  int outPtr=0;
  int blockNr=0;
  final int end=inPtr + inLength - 1;
  while (inPtr < end) {
    if (sourceBuffer[inPtr] != LZFChunk.BYTE_Z || sourceBuffer[inPtr + 1] != LZFChunk.BYTE_V) {
      throw new IOException("Corrupt input data, block #" + blockNr + " (at offset "+ inPtr+ "): did not start with 'ZV' signature bytes");
    }
    inPtr+=2;
    int type=sourceBuffer[inPtr++];
    int len=uint16(sourceBuffer,inPtr);
    inPtr+=2;
    if (type == LZFChunk.BLOCK_TYPE_NON_COMPRESSED) {
      System.arraycopy(sourceBuffer,inPtr,result,outPtr,len);
      outPtr+=len;
    }
 else {
      int uncompLen=uint16(sourceBuffer,inPtr);
      inPtr+=2;
      decodeChunk(sourceBuffer,inPtr,result,outPtr,outPtr + uncompLen);
      outPtr+=uncompLen;
    }
    inPtr+=len;
    ++blockNr;
  }
  return outPtr;
}
