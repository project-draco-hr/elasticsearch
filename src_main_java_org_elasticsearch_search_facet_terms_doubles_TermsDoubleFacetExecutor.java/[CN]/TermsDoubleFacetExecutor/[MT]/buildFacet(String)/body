{
  if (facets.v().isEmpty()) {
    facets.release();
    return new InternalDoubleTermsFacet(facetName,comparatorType,size,ImmutableList.<InternalDoubleTermsFacet.DoubleEntry>of(),missing,total);
  }
 else {
    final boolean[] states=facets.v().allocated;
    final double[] keys=facets.v().keys;
    final int[] values=facets.v().values;
    if (size < EntryPriorityQueue.LIMIT) {
      EntryPriorityQueue ordered=new EntryPriorityQueue(shardSize,comparatorType.comparator());
      for (int i=0; i < states.length; i++) {
        if (states[i]) {
          ordered.insertWithOverflow(new InternalDoubleTermsFacet.DoubleEntry(keys[i],values[i]));
        }
      }
      InternalDoubleTermsFacet.DoubleEntry[] list=new InternalDoubleTermsFacet.DoubleEntry[ordered.size()];
      for (int i=ordered.size() - 1; i >= 0; i--) {
        list[i]=(InternalDoubleTermsFacet.DoubleEntry)ordered.pop();
      }
      facets.release();
      return new InternalDoubleTermsFacet(facetName,comparatorType,size,Arrays.asList(list),missing,total);
    }
 else {
      BoundedTreeSet<InternalDoubleTermsFacet.DoubleEntry> ordered=new BoundedTreeSet<>(comparatorType.comparator(),shardSize);
      for (int i=0; i < states.length; i++) {
        if (states[i]) {
          ordered.add(new InternalDoubleTermsFacet.DoubleEntry(keys[i],values[i]));
        }
      }
      facets.release();
      return new InternalDoubleTermsFacet(facetName,comparatorType,size,ordered,missing,total);
    }
  }
}
