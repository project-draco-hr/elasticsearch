{
  long totalTimeStart=System.currentTimeMillis();
  boolean indexDirty=false;
  boolean translogDirty=false;
  final SnapshotIndexCommit snapshotIndexCommit=snapshot.indexCommit();
  final Translog.Snapshot translogSnapshot=snapshot.translogSnapshot();
  int indexNumberOfFiles=0;
  long indexTotalFilesSize=0;
  long indexTime=0;
  if (snapshot.indexChanged()) {
    long time=System.currentTimeMillis();
    indexDirty=true;
    final CountDownLatch latch=new CountDownLatch(snapshotIndexCommit.getFiles().length);
    final AtomicReference<Exception> lastException=new AtomicReference<Exception>();
    for (    final String fileName : snapshotIndexCommit.getFiles()) {
      if (fileName.equals(snapshotIndexCommit.getSegmentsFileName())) {
        latch.countDown();
        continue;
      }
      IndexInput indexInput=null;
      try {
        indexInput=snapshotIndexCommit.getDirectory().openInput(fileName);
        FileStatus fileStatus=fileSystem.getFileStatus(new Path(indexPath,fileName));
        if (fileStatus.getLen() == indexInput.length()) {
          latch.countDown();
          continue;
        }
      }
 catch (      FileNotFoundException e) {
      }
catch (      Exception e) {
        logger.debug("Failed to verify file equality based on length, copying...",e);
      }
 finally {
        if (indexInput != null) {
          try {
            indexInput.close();
          }
 catch (          IOException e) {
          }
        }
      }
      indexNumberOfFiles++;
      try {
        indexTotalFilesSize+=snapshotIndexCommit.getDirectory().fileLength(fileName);
      }
 catch (      IOException e) {
      }
      threadPool.execute(new Runnable(){
        @Override public void run(){
          Path copyTo=new Path(indexPath,fileName);
          FSDataOutputStream fileStream;
          try {
            fileStream=fileSystem.create(copyTo,true);
            copyFromDirectory(snapshotIndexCommit.getDirectory(),fileName,fileStream);
          }
 catch (          Exception e) {
            lastException.set(new IndexShardGatewaySnapshotFailedException(shardId,"Failed to copy to [" + copyTo + "], from dir ["+ snapshotIndexCommit.getDirectory()+ "] and file ["+ fileName+ "]",e));
          }
 finally {
            latch.countDown();
          }
        }
      }
);
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      lastException.set(e);
    }
    if (lastException.get() != null) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to perform snapshot (index files)",lastException.get());
    }
    indexTime=System.currentTimeMillis() - time;
  }
  int translogNumberOfOperations=0;
  long translogTime=0;
  if (snapshot.newTranslogCreated() || currentTranslogStream == null) {
    translogDirty=true;
    long time=System.currentTimeMillis();
    if (currentTranslogStream != null) {
      try {
        currentTranslogStream.close();
      }
 catch (      IOException e) {
      }
    }
    Path currentTranslogPath=new Path(translogPath,"translog-" + translogSnapshot.translogId());
    try {
      currentTranslogStream=fileSystem.create(currentTranslogPath,true);
      StreamOutput out=new DataOutputStreamOutput(currentTranslogStream);
      for (      Translog.Operation operation : translogSnapshot) {
        translogNumberOfOperations++;
        writeTranslogOperation(out,operation);
      }
      currentTranslogStream.flush();
      currentTranslogStream.sync();
    }
 catch (    Exception e) {
      currentTranslogPath=null;
      if (currentTranslogStream != null) {
        try {
          currentTranslogStream.close();
        }
 catch (        IOException e1) {
        }
 finally {
          currentTranslogStream=null;
        }
      }
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to snapshot translog into [" + currentTranslogPath + "]",e);
    }
    translogTime=System.currentTimeMillis() - time;
  }
 else   if (snapshot.sameTranslogNewOperations()) {
    translogDirty=true;
    long time=System.currentTimeMillis();
    try {
      StreamOutput out=new DataOutputStreamOutput(currentTranslogStream);
      for (      Translog.Operation operation : translogSnapshot.skipTo(snapshot.lastTranslogSize())) {
        translogNumberOfOperations++;
        writeTranslogOperation(out,operation);
      }
    }
 catch (    Exception e) {
      try {
        currentTranslogStream.close();
      }
 catch (      IOException e1) {
      }
 finally {
        currentTranslogStream=null;
      }
    }
    translogTime=System.currentTimeMillis() - time;
  }
  if (indexDirty) {
    Path segmentsPath=new Path(indexPath,snapshotIndexCommit.getSegmentsFileName());
    try {
      indexNumberOfFiles++;
      indexTotalFilesSize+=snapshotIndexCommit.getDirectory().fileLength(snapshotIndexCommit.getSegmentsFileName());
      long time=System.currentTimeMillis();
      FSDataOutputStream fileStream;
      fileStream=fileSystem.create(segmentsPath,true);
      copyFromDirectory(snapshotIndexCommit.getDirectory(),snapshotIndexCommit.getSegmentsFileName(),fileStream);
      indexTime+=(System.currentTimeMillis() - time);
    }
 catch (    Exception e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to finalize index snapshot into [" + segmentsPath + "]",e);
    }
  }
  if (snapshot.newTranslogCreated()) {
    try {
      fileSystem.delete(new Path(translogPath,"translog-" + snapshot.lastTranslogId()),false);
    }
 catch (    IOException e) {
    }
  }
  if (indexDirty) {
    try {
      FileStatus[] existingFiles=fileSystem.listStatus(indexPath);
      if (existingFiles != null) {
        for (        FileStatus existingFile : existingFiles) {
          boolean found=false;
          for (          final String fileName : snapshotIndexCommit.getFiles()) {
            if (existingFile.getPath().getName().equals(fileName)) {
              found=true;
              break;
            }
          }
          if (!found) {
            fileSystem.delete(existingFile.getPath(),false);
          }
        }
      }
    }
 catch (    Exception e) {
    }
  }
  return new SnapshotStatus(new TimeValue(System.currentTimeMillis() - totalTimeStart),new SnapshotStatus.Index(indexNumberOfFiles,new ByteSizeValue(indexTotalFilesSize),new TimeValue(indexTime)),new SnapshotStatus.Translog(translogNumberOfOperations,new TimeValue(translogTime)));
}
