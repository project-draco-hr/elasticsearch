{
  Settings.Builder builder=Settings.builder();
  builder.put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE,100);
  client().admin().cluster().prepareUpdateSettings().setPersistentSettings(builder).get();
  int numIndexes=randomIntBetween(2,4);
  String[] indexNames=new String[numIndexes];
  for (int i=0; i < numIndexes; ++i) {
    final String indexName="test" + i;
    indexNames[i]=indexName;
    Settings settings=Settings.builder().put("index.routing.allocation.exclude._name",backwardsCluster().newNodePattern()).put("index.merge.policy.segments_per_tier",1000000f).put(indexSettings()).build();
    assertAcked(prepareCreate(indexName).setSettings(settings));
    ensureGreen(indexName);
    assertAllShardsOnNodes(indexName,backwardsCluster().backwardsNodePattern());
    int numDocs=scaledRandomIntBetween(100,1000);
    List<IndexRequestBuilder> docs=new ArrayList<>();
    for (int j=0; j < numDocs; ++j) {
      String id=Integer.toString(j);
      docs.add(client().prepareIndex(indexName,"type1",id).setSource("text","sometext"));
    }
    indexRandom(true,docs);
    ensureGreen(indexName);
    if (globalCompatibilityVersion().before(Version.V_1_4_0_Beta1)) {
      assertTrue(awaitBusy(new Predicate<Object>(){
        @Override public boolean apply(        Object o){
          return flush(indexName).getFailedShards() == 0;
        }
      }
));
    }
 else {
      assertEquals(0,flush(indexName).getFailedShards());
    }
    numDocs=scaledRandomIntBetween(100,1000);
    docs=new ArrayList<>();
    for (int j=0; j < numDocs; ++j) {
      String id=Integer.toString(j);
      docs.add(client().prepareIndex(indexName,"type2",id).setSource("text","someothertext"));
    }
    indexRandom(true,docs);
    ensureGreen(indexName);
  }
  logger.debug("--> Upgrading nodes");
  backwardsCluster().allowOnAllNodes(indexNames);
  ensureGreen();
  builder=Settings.builder();
  builder.put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE,EnableAllocationDecider.Allocation.NONE);
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(builder).get();
  backwardsCluster().upgradeAllNodes();
  builder=Settings.builder();
  builder.put(EnableAllocationDecider.CLUSTER_ROUTING_REBALANCE_ENABLE,EnableAllocationDecider.Rebalance.NONE);
  builder.put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE,EnableAllocationDecider.Allocation.ALL);
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(builder).get();
  ensureGreen();
  logger.info("--> Nodes upgrade complete");
  logSegmentsState();
  assertNotUpgraded(httpClient(),null);
  final String indexToUpgrade="test" + randomInt(numIndexes - 1);
  assertFalse(hasAncientSegments(httpClient(),indexToUpgrade));
  logger.info("--> Running upgrade on index " + indexToUpgrade);
  runUpgrade(httpClient(),indexToUpgrade);
  awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object o){
      try {
        return isUpgraded(httpClient(),indexToUpgrade);
      }
 catch (      Exception e) {
        throw ExceptionsHelper.convertToRuntime(e);
      }
    }
  }
);
  logger.info("--> Single index upgrade complete");
  logger.info("--> Running upgrade on the rest of the indexes");
  runUpgrade(httpClient(),null);
  logSegmentsState();
  logger.info("--> Full upgrade complete");
  assertUpgraded(httpClient(),null);
}
