{
  final List<String> nodes=startCluster(3,2);
  final String oldMasterNode=internalCluster().getMasterName();
  for (  String node : nodes) {
    ensureStableCluster(3,node);
  }
  assertMaster(oldMasterNode,nodes);
  SingleNodeDisruption masterNodeDisruption=new LongGCDisruption(random(),oldMasterNode);
  final List<String> majoritySide=new ArrayList<>(nodes);
  majoritySide.remove(oldMasterNode);
  final Map<String,List<Tuple<String,String>>> masters=Collections.synchronizedMap(new HashMap<String,List<Tuple<String,String>>>());
  for (  final String node : majoritySide) {
    masters.put(node,new ArrayList<Tuple<String,String>>());
    internalCluster().getInstance(ClusterService.class,node).add(new ClusterStateListener(){
      @Override public void clusterChanged(      ClusterChangedEvent event){
        DiscoveryNode previousMaster=event.previousState().nodes().getMasterNode();
        DiscoveryNode currentMaster=event.state().nodes().getMasterNode();
        if (!Objects.equals(previousMaster,currentMaster)) {
          logger.info("node {} received new cluster state: {} \n and had previous cluster state: {}",node,event.state(),event.previousState());
          String previousMasterNodeName=previousMaster != null ? previousMaster.getName() : null;
          String currentMasterNodeName=currentMaster != null ? currentMaster.getName() : null;
          masters.get(node).add(new Tuple<>(previousMasterNodeName,currentMasterNodeName));
        }
      }
    }
);
  }
  final CountDownLatch oldMasterNodeSteppedDown=new CountDownLatch(1);
  internalCluster().getInstance(ClusterService.class,oldMasterNode).add(new ClusterStateListener(){
    @Override public void clusterChanged(    ClusterChangedEvent event){
      if (event.state().nodes().getMasterNodeId() == null) {
        oldMasterNodeSteppedDown.countDown();
      }
    }
  }
);
  internalCluster().setDisruptionScheme(masterNodeDisruption);
  logger.info("freezing node [{}]",oldMasterNode);
  masterNodeDisruption.startDisrupting();
  assertDifferentMaster(majoritySide.get(0),oldMasterNode);
  assertDifferentMaster(majoritySide.get(1),oldMasterNode);
  boolean failed=true;
  try {
    assertDiscoveryCompleted(majoritySide);
    failed=false;
  }
  finally {
    if (failed) {
      logger.error("discovery failed to complete, probably caused by a blocked thread: {}",new HotThreads().busiestThreads(Integer.MAX_VALUE).ignoreIdleThreads(false).detect());
    }
  }
  internalCluster().getInstance(ClusterService.class,oldMasterNode).submitStateUpdateTask("sneaky-update",new ClusterStateUpdateTask(Priority.IMMEDIATE){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      return ClusterState.builder(currentState).build();
    }
    @Override public void onFailure(    String source,    Exception e){
      logger.warn("failure [{}]",e,source);
    }
  }
);
  final String newMasterNode=internalCluster().getMasterName(majoritySide.get(0));
  logger.info("new detected master node [{}]",newMasterNode);
  logger.info("Unfreeze node [{}]",oldMasterNode);
  masterNodeDisruption.stopDisrupting();
  oldMasterNodeSteppedDown.await(30,TimeUnit.SECONDS);
  assertDiscoveryCompleted(nodes);
  assertBusy(new Runnable(){
    @Override public void run(){
      assertMaster(newMasterNode,nodes);
    }
  }
);
  assertThat(masters.size(),equalTo(2));
  for (  Map.Entry<String,List<Tuple<String,String>>> entry : masters.entrySet()) {
    String nodeName=entry.getKey();
    List<Tuple<String,String>> recordedMasterTransition=entry.getValue();
    assertThat("[" + nodeName + "] Each node should only record two master node transitions",recordedMasterTransition.size(),equalTo(2));
    assertThat("[" + nodeName + "] First transition's previous master should be [null]",recordedMasterTransition.get(0).v1(),equalTo(oldMasterNode));
    assertThat("[" + nodeName + "] First transition's current master should be ["+ newMasterNode+ "]",recordedMasterTransition.get(0).v2(),nullValue());
    assertThat("[" + nodeName + "] Second transition's previous master should be [null]",recordedMasterTransition.get(1).v1(),nullValue());
    assertThat("[" + nodeName + "] Second transition's current master should be ["+ newMasterNode+ "]",recordedMasterTransition.get(1).v2(),equalTo(newMasterNode));
  }
}
