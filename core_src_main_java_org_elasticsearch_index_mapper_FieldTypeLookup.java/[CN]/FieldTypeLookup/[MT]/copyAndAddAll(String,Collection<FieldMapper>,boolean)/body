{
  Objects.requireNonNull(type,"type must not be null");
  if (MapperService.DEFAULT_MAPPING.equals(type)) {
    throw new IllegalArgumentException("Default mappings should not be added to the lookup");
  }
  CopyOnWriteHashMap<String,MappedFieldType> fullName=this.fullNameToFieldType;
  CopyOnWriteHashMap<String,Set<String>> fullNameToTypes=this.fullNameToTypes;
  CopyOnWriteHashMap<String,MappedFieldType> indexName=this.indexNameToFieldType;
  CopyOnWriteHashMap<String,Set<String>> indexNameToTypes=this.indexNameToTypes;
  for (  FieldMapper fieldMapper : fieldMappers) {
    MappedFieldType fieldType=fieldMapper.fieldType();
    MappedFieldType fullNameFieldType=fullName.get(fieldType.names().fullName());
    MappedFieldType indexNameFieldType=indexName.get(fieldType.names().indexName());
    if (fullNameFieldType != null && indexNameFieldType != null && fullNameFieldType != indexNameFieldType) {
      throw new IllegalStateException("insane mappings found. field " + fieldType.names().fullName() + " maps across types to field "+ fieldType.names().indexName());
    }
    checkCompatibility(type,fieldMapper,updateAllTypes);
    if (fieldType != fullNameFieldType || fieldType != indexNameFieldType) {
      fullName=fullName.copyAndPut(fieldType.names().fullName(),fieldMapper.fieldType());
      indexName=indexName.copyAndPut(fieldType.names().indexName(),fieldMapper.fieldType());
    }
    fullNameToTypes=addType(fullNameToTypes,fieldType.names().fullName(),type);
    indexNameToTypes=addType(indexNameToTypes,fieldType.names().indexName(),type);
  }
  return new FieldTypeLookup(fullName,fullNameToTypes,indexName,indexNameToTypes);
}
