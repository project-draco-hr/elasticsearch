{
  for (  FieldMapper fieldMapper : newFieldMappers) {
    MappedFieldTypeReference ref=fullNameToFieldType.get(fieldMapper.fieldType().names().fullName());
    if (ref != null) {
      List<String> conflicts=new ArrayList<>();
      ref.get().checkTypeName(fieldMapper.fieldType(),conflicts);
      if (conflicts.isEmpty()) {
        boolean strict=ref.getNumAssociatedMappers() > 1 && updateAllTypes == false;
        ref.get().checkCompatibility(fieldMapper.fieldType(),conflicts,strict);
      }
      if (conflicts.isEmpty() == false) {
        throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with existing mapping in other types"+ conflicts.toString());
      }
    }
    MappedFieldTypeReference indexNameRef=fullNameToFieldType.get(fieldMapper.fieldType().names().indexName());
    if (indexNameRef != null) {
      List<String> conflicts=new ArrayList<>();
      ref.get().checkTypeName(fieldMapper.fieldType(),conflicts);
      if (conflicts.isEmpty()) {
        boolean strict=indexNameRef.getNumAssociatedMappers() > 1 && updateAllTypes == false;
        indexNameRef.get().checkCompatibility(fieldMapper.fieldType(),conflicts,strict);
      }
      if (conflicts.isEmpty() == false) {
        throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with mapping with the same index name in other types"+ conflicts.toString());
      }
    }
  }
}
