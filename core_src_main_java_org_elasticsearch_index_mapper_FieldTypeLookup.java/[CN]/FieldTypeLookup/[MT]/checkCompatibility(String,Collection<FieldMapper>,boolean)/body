{
  for (  FieldMapper fieldMapper : fieldMappers) {
    MappedFieldTypeReference ref=fullNameToFieldType.get(fieldMapper.fieldType().names().fullName());
    if (ref != null) {
      List<String> conflicts=new ArrayList<>();
      final Set<String> types=fullNameToTypes.get(fieldMapper.fieldType().names().fullName());
      boolean strict=beStrict(type,types,updateAllTypes);
      ref.get().checkCompatibility(fieldMapper.fieldType(),conflicts,strict);
      if (conflicts.isEmpty() == false) {
        throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with existing mapping in other types:\n"+ conflicts.toString());
      }
    }
    MappedFieldTypeReference indexNameRef=indexNameToFieldType.get(fieldMapper.fieldType().names().indexName());
    if (indexNameRef != null) {
      List<String> conflicts=new ArrayList<>();
      final Set<String> types=indexNameToTypes.get(fieldMapper.fieldType().names().indexName());
      boolean strict=beStrict(type,types,updateAllTypes);
      indexNameRef.get().checkCompatibility(fieldMapper.fieldType(),conflicts,strict);
      if (conflicts.isEmpty() == false) {
        throw new IllegalArgumentException("Mapper for [" + fieldMapper.fieldType().names().fullName() + "] conflicts with mapping with the same index name in other types"+ conflicts.toString());
      }
    }
  }
}
