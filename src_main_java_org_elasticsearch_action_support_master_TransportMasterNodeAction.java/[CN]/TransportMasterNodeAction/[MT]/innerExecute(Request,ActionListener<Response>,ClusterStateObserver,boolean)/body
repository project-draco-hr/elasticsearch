{
  final ClusterState clusterState=observer.observedState();
  final DiscoveryNodes nodes=clusterState.nodes();
  if (nodes.localNodeMaster() || localExecute(request)) {
    final ClusterBlockException blockException=checkBlock(request,clusterState);
    if (blockException != null) {
      if (!blockException.retryable()) {
        listener.onFailure(blockException);
        return;
      }
      logger.trace("can't execute due to a cluster block: [{}], retrying",blockException);
      observer.waitForNextChange(new ClusterStateObserver.Listener(){
        @Override public void onNewClusterState(        ClusterState state){
          innerExecute(request,listener,observer,false);
        }
        @Override public void onClusterServiceClose(){
          listener.onFailure(blockException);
        }
        @Override public void onTimeout(        TimeValue timeout){
          listener.onFailure(blockException);
        }
      }
,new ClusterStateObserver.ValidationPredicate(){
        @Override protected boolean validate(        ClusterState newState){
          ClusterBlockException blockException=checkBlock(request,newState);
          return (blockException == null || !blockException.retryable());
        }
      }
);
    }
 else {
      threadPool.executor(executor).execute(new ActionRunnable(listener){
        @Override protected void doRun() throws Exception {
          masterOperation(request,clusterService.state(),listener);
        }
      }
);
    }
  }
 else {
    if (nodes.masterNode() == null) {
      if (retrying) {
        listener.onFailure(new MasterNotDiscoveredException());
      }
 else {
        logger.debug("no known master node, scheduling a retry");
        observer.waitForNextChange(new ClusterStateObserver.Listener(){
          @Override public void onNewClusterState(          ClusterState state){
            innerExecute(request,listener,observer,true);
          }
          @Override public void onClusterServiceClose(){
            listener.onFailure(new NodeClosedException(clusterService.localNode()));
          }
          @Override public void onTimeout(          TimeValue timeout){
            listener.onFailure(new MasterNotDiscoveredException("waited for [" + timeout + "]"));
          }
        }
,new ClusterStateObserver.ChangePredicate(){
          @Override public boolean apply(          ClusterState previousState,          ClusterState.ClusterStateStatus previousStatus,          ClusterState newState,          ClusterState.ClusterStateStatus newStatus){
            return newState.nodes().masterNodeId() != null;
          }
          @Override public boolean apply(          ClusterChangedEvent event){
            return event.nodesDelta().masterNodeChanged();
          }
        }
);
      }
      return;
    }
    processBeforeDelegationToMaster(request,clusterState);
    transportService.sendRequest(nodes.masterNode(),actionName,request,new BaseTransportResponseHandler<Response>(){
      @Override public Response newInstance(){
        return newResponse();
      }
      @Override public void handleResponse(      Response response){
        listener.onResponse(response);
      }
      @Override public String executor(){
        return ThreadPool.Names.SAME;
      }
      @Override public void handleException(      final TransportException exp){
        if (exp.unwrapCause() instanceof ConnectTransportException) {
          logger.debug("connection exception while trying to forward request to master node [{}], scheduling a retry. Error: [{}]",nodes.masterNode(),exp.getDetailedMessage());
          observer.waitForNextChange(new ClusterStateObserver.Listener(){
            @Override public void onNewClusterState(            ClusterState state){
              innerExecute(request,listener,observer,false);
            }
            @Override public void onClusterServiceClose(){
              listener.onFailure(new NodeClosedException(clusterService.localNode()));
            }
            @Override public void onTimeout(            TimeValue timeout){
              listener.onFailure(new MasterNotDiscoveredException());
            }
          }
,new ClusterStateObserver.EventPredicate(){
            @Override public boolean apply(            ClusterChangedEvent event){
              return event.nodesDelta().masterNodeChanged();
            }
          }
);
        }
 else {
          listener.onFailure(exp);
        }
      }
    }
);
  }
}
