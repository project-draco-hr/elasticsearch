{
  CachedStreamOutput.Entry cachedEntry=CachedStreamOutput.popEntry();
  try {
    StreamOutput streamOutput;
    try {
      if (compress) {
        streamOutput=cachedEntry.cachedLZFBytes();
      }
 else {
        streamOutput=cachedEntry.cachedBytes();
      }
      XContentBuilder xContentBuilder=XContentFactory.contentBuilder(XContentType.JSON,streamOutput);
      if (prettyPrint) {
        xContentBuilder.prettyPrint();
      }
      xContentBuilder.startObject();
      LocalGatewayStartedShards.Builder.toXContent(stateToWrite,xContentBuilder,ToXContent.EMPTY_PARAMS);
      xContentBuilder.endObject();
      xContentBuilder.close();
    }
 catch (    Exception e) {
      logger.warn("failed to serialize local gateway shard states",e);
      return;
    }
    boolean serializedAtLeastOnce=false;
    for (    File dataLocation : nodeEnv.nodeDataLocations()) {
      File stateLocation=new File(dataLocation,"_state");
      if (!stateLocation.exists()) {
        FileSystemUtils.mkdirs(stateLocation);
      }
      File stateFile=new File(stateLocation,"shards-" + event.state().version());
      FileOutputStream fos=null;
      try {
        fos=new FileOutputStream(stateFile);
        fos.write(cachedEntry.bytes().underlyingBytes(),0,cachedEntry.bytes().size());
        fos.getChannel().force(true);
        serializedAtLeastOnce=true;
      }
 catch (      Exception e) {
        logger.warn("failed to write local gateway shards state to {}",e,stateFile);
      }
 finally {
        Closeables.closeQuietly(fos);
      }
    }
    if (serializedAtLeastOnce) {
      currentStartedShards=stateToWrite;
      for (      File dataLocation : nodeEnv.nodeDataLocations()) {
        File stateLocation=new File(dataLocation,"_state");
        if (!stateLocation.exists()) {
          continue;
        }
        File[] files=stateLocation.listFiles(new FilenameFilter(){
          @Override public boolean accept(          File dir,          String name){
            return name.startsWith("shards-") && !name.equals("shards-" + event.state().version());
          }
        }
);
        if (files != null) {
          for (          File file : files) {
            file.delete();
          }
        }
      }
    }
  }
  finally {
    CachedStreamOutput.pushEntry(cachedEntry);
  }
}
