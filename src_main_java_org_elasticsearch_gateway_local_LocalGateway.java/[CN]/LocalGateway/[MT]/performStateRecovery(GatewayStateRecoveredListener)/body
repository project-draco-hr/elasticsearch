{
  Set<String> nodesIds=Sets.newHashSet();
  nodesIds.addAll(clusterService.state().nodes().masterNodes().keySet());
  TransportNodesListGatewayMetaState.NodesLocalGatewayMetaState nodesState=listGatewayMetaState.list(nodesIds,null).actionGet();
  int requiredAllocation=1;
  try {
    if ("quorum".equals(initialMeta)) {
      if (nodesIds.size() > 2) {
        requiredAllocation=(nodesIds.size() / 2) + 1;
      }
    }
 else     if ("quorum-1".equals(initialMeta) || "half".equals(initialMeta)) {
      if (nodesIds.size() > 2) {
        requiredAllocation=((1 + nodesIds.size()) / 2);
      }
    }
 else     if ("one".equals(initialMeta)) {
      requiredAllocation=1;
    }
 else     if ("full".equals(initialMeta) || "all".equals(initialMeta)) {
      requiredAllocation=nodesIds.size();
    }
 else     if ("full-1".equals(initialMeta) || "all-1".equals(initialMeta)) {
      if (nodesIds.size() > 1) {
        requiredAllocation=nodesIds.size() - 1;
      }
    }
 else {
      requiredAllocation=Integer.parseInt(initialMeta);
    }
  }
 catch (  Exception e) {
    logger.warn("failed to derived initial_meta from value {}",initialMeta);
  }
  if (nodesState.failures().length > 0) {
    for (    FailedNodeException failedNodeException : nodesState.failures()) {
      logger.warn("failed to fetch state from node",failedNodeException);
    }
  }
  MetaData.Builder metaDataBuilder=MetaData.builder();
  TObjectIntHashMap<String> indices=new TObjectIntHashMap<String>();
  MetaData electedGlobalState=null;
  int found=0;
  for (  TransportNodesListGatewayMetaState.NodeLocalGatewayMetaState nodeState : nodesState) {
    if (nodeState.metaData() == null) {
      continue;
    }
    found++;
    if (electedGlobalState == null) {
      electedGlobalState=nodeState.metaData();
    }
 else     if (nodeState.metaData().version() > electedGlobalState.version()) {
      electedGlobalState=nodeState.metaData();
    }
    for (    IndexMetaData indexMetaData : nodeState.metaData().indices().values()) {
      indices.adjustOrPutValue(indexMetaData.index(),1,1);
    }
  }
  if (found < requiredAllocation) {
    listener.onFailure("found [" + found + "] metadata states, required ["+ requiredAllocation+ "]");
    return;
  }
  metaDataBuilder.metaData(electedGlobalState).removeAllIndices();
  for (  String index : indices.keySet()) {
    IndexMetaData electedIndexMetaData=null;
    int indexMetaDataCount=0;
    for (    TransportNodesListGatewayMetaState.NodeLocalGatewayMetaState nodeState : nodesState) {
      if (nodeState.metaData() == null) {
        continue;
      }
      IndexMetaData indexMetaData=nodeState.metaData().index(index);
      if (indexMetaData == null) {
        continue;
      }
      if (electedIndexMetaData == null) {
        electedIndexMetaData=indexMetaData;
      }
 else       if (indexMetaData.version() > electedIndexMetaData.version()) {
        electedIndexMetaData=indexMetaData;
      }
      indexMetaDataCount++;
    }
    if (electedIndexMetaData != null) {
      if (indexMetaDataCount < requiredAllocation) {
        logger.debug("[{}] found [{}], required [{}], not adding",index,indexMetaDataCount,requiredAllocation);
      }
      metaDataBuilder.put(electedIndexMetaData,false);
    }
  }
  ClusterState.Builder builder=ClusterState.builder();
  builder.metaData(metaDataBuilder);
  listener.onSuccess(builder.build());
}
