{
  final int min=between(1,3);
  final int max=between(min + 1,6);
  final long waitTime=between(1000,2000);
  final ThreadBarrier barrier=new ThreadBarrier(max + 1);
  ThreadPoolExecutor pool=EsExecutors.newBlockingExecutorService(min,max,between(1,100),randomTimeUnit(),EsExecutors.daemonThreadFactory("test"),1,waitTime,TimeUnit.MILLISECONDS);
  assertThat("Min property",pool.getCorePoolSize(),equalTo(min));
  assertThat("Max property",pool.getMaximumPoolSize(),equalTo(max));
  for (int i=0; i < max; ++i) {
    final CountDownLatch latch=new CountDownLatch(1);
    pool.execute(new Runnable(){
      public void run(){
        latch.countDown();
        try {
          barrier.await();
          barrier.await();
        }
 catch (        Throwable e) {
          barrier.reset(e);
        }
      }
    }
);
    latch.await();
  }
  barrier.await();
  assertThat("wrong pool size",pool.getPoolSize(),equalTo(max));
  assertThat("wrong active size",pool.getActiveCount(),equalTo(max));
  assertThat("queue isn't empty",pool.getQueue().size(),equalTo(0));
  pool.execute(new Runnable(){
    public void run(){
    }
  }
);
  assertThat("queue isn't full",pool.getQueue().size(),equalTo(1));
  try {
    pool.execute(new Runnable(){
      public void run(){
      }
    }
);
    assertThat("Should have thrown RejectedExecutionException",false,equalTo(true));
  }
 catch (  EsRejectedExecutionException e) {
  }
  barrier.await();
  pool.shutdown();
}
