{
  boolean changed=false;
  final RoutingNodes routingNodes=allocation.routingNodes();
  final MetaData metaData=routingNodes.metaData();
  final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    ShardRouting shard=unassignedIterator.next();
    if (needToFindPrimaryCopy(shard) == false) {
      continue;
    }
    AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState=fetchData(shard,allocation);
    if (shardState.hasData() == false) {
      logger.trace("{}: ignoring allocation, still fetching shard started state",shard);
      unassignedIterator.removeAndIgnore();
      continue;
    }
    IndexMetaData indexMetaData=metaData.index(shard.getIndex());
    Settings indexSettings=Settings.builder().put(settings).put(indexMetaData.getSettings()).build();
    NodesAndVersions nodesAndVersions=buildNodesAndVersions(shard,recoverOnAnyNode(indexSettings),allocation.getIgnoreNodes(shard.shardId()),shardState);
    logger.debug("[{}][{}] found {} allocations of {}, highest version: [{}]",shard.index(),shard.id(),nodesAndVersions.allocationsFound,shard,nodesAndVersions.highestVersion);
    if (isEnoughAllocationsFound(shard,indexMetaData,nodesAndVersions) == false) {
      if (shard.restoreSource() == null) {
        unassignedIterator.removeAndIgnore();
        logger.debug("[{}][{}]: not allocating, number_of_allocated_shards_found [{}]",shard.index(),shard.id(),nodesAndVersions.allocationsFound);
      }
 else {
        logger.debug("[{}][{}]: missing local data, will restore from [{}]",shard.index(),shard.id(),shard.restoreSource());
      }
      continue;
    }
    NodesToAllocate nodesToAllocate=buildNodesToAllocate(shard,allocation,nodesAndVersions);
    if (nodesToAllocate.yesNodes.isEmpty() == false) {
      DiscoveryNode node=nodesToAllocate.yesNodes.get(0);
      logger.debug("[{}][{}]: allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,node);
      changed=true;
      unassignedIterator.initialize(node.id(),nodesAndVersions.highestVersion,ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);
    }
 else     if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) {
      DiscoveryNode node=nodesToAllocate.noNodes.get(0);
      logger.debug("[{}][{}]: forcing allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,node);
      changed=true;
      unassignedIterator.initialize(node.id(),nodesAndVersions.highestVersion,ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE);
    }
 else {
      logger.debug("[{}][{}]: throttling allocation [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,nodesToAllocate.throttleNodes);
      unassignedIterator.removeAndIgnore();
    }
  }
  return changed;
}
