{
  boolean changed=false;
  final RoutingNodes routingNodes=allocation.routingNodes();
  final MetaData metaData=routingNodes.metaData();
  final Iterator<ShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    ShardRouting shard=unassignedIterator.next();
    if (needToFindPrimaryCopy(shard,routingNodes.routingTable().index(shard.index()).shard(shard.id())) == false) {
      continue;
    }
    AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState=fetchData(shard,allocation);
    if (shardState.hasData() == false) {
      logger.trace("{}: ignoring allocation, still fetching shard started state",shard);
      unassignedIterator.remove();
      routingNodes.ignoredUnassigned().add(shard);
      continue;
    }
    IndexMetaData indexMetaData=metaData.index(shard.getIndex());
    NodesAndVersions nodesAndVersions=buildNodesAndVersions(shard,recoverOnAnyNode(indexMetaData.settings()),allocation.getIgnoreNodes(shard.shardId()),shardState);
    logger.debug("[{}][{}] found {} allocations of {}, highest version: [{}]",shard.index(),shard.id(),nodesAndVersions.allocationsFound,shard,nodesAndVersions.highestVersion);
    if (isEnoughAllocationsFound(shard,indexMetaData,nodesAndVersions) == false) {
      if (shard.restoreSource() == null) {
        unassignedIterator.remove();
        routingNodes.ignoredUnassigned().add(shard);
        logger.debug("[{}][{}]: not allocating, number_of_allocated_shards_found [{}]",shard.index(),shard.id(),nodesAndVersions.allocationsFound);
      }
 else {
        logger.debug("[{}][{}]: missing local data, will restore from [{}]",shard.index(),shard.id(),shard.restoreSource());
      }
      continue;
    }
    NodesToAllocate nodesToAllocate=buildNodesToAllocate(shard,allocation,nodesAndVersions);
    if (nodesToAllocate.yesNodes.isEmpty() == false) {
      DiscoveryNode node=nodesToAllocate.yesNodes.get(0);
      logger.debug("[{}][{}]: allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,node);
      changed=true;
      routingNodes.initialize(new ShardRouting(shard,nodesAndVersions.highestVersion),node.id());
      unassignedIterator.remove();
    }
 else     if (nodesToAllocate.throttleNodes.isEmpty() == true && nodesToAllocate.noNodes.isEmpty() == false) {
      DiscoveryNode node=nodesToAllocate.noNodes.get(0);
      logger.debug("[{}][{}]: forcing allocating [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,node);
      changed=true;
      routingNodes.initialize(new ShardRouting(shard,nodesAndVersions.highestVersion),node.id());
      unassignedIterator.remove();
    }
 else {
      logger.debug("[{}][{}]: throttling allocation [{}] to [{}] on primary allocation",shard.index(),shard.id(),shard,nodesToAllocate.throttleNodes);
      unassignedIterator.remove();
      routingNodes.ignoredUnassigned().add(shard);
    }
  }
  return changed;
}
