{
  ParseContext context=cache.get();
  if (source.type() != null && !source.type().equals(this.type)) {
    throw new MapperParsingException("Type mismatch, provide type [" + source.type() + "] but mapper is of type ["+ this.type+ "]");
  }
  source.type(this.type);
  XContentParser parser=source.parser();
  try {
    if (parser == null) {
      parser=XContentHelper.createParser(source.source());
    }
    context.reset(parser,new Document(),source,listener);
    if (initMappersAdded) {
      context.setMappingsModified();
      initMappersAdded=false;
    }
    int countDownTokens=0;
    XContentParser.Token token=parser.nextToken();
    if (token != XContentParser.Token.START_OBJECT) {
      throw new MapperParsingException("Malformed content, must start with an object");
    }
    boolean emptyDoc=false;
    token=parser.nextToken();
    if (token == XContentParser.Token.END_OBJECT) {
      emptyDoc=true;
    }
 else     if (token != XContentParser.Token.FIELD_NAME) {
      throw new MapperParsingException("Malformed content, after first object, either the type field or the actual properties should exist");
    }
    if (type.equals(parser.currentName())) {
      token=parser.nextToken();
      countDownTokens++;
    }
    for (    RootMapper rootMapper : rootMappersOrdered) {
      rootMapper.preParse(context);
    }
    if (!emptyDoc) {
      rootObjectMapper.parse(context);
    }
    for (int i=0; i < countDownTokens; i++) {
      parser.nextToken();
    }
    if (!context.newFieldMappers().mappers.isEmpty()) {
      addFieldMappers(context.newFieldMappers().mappers);
      context.newFieldMappers().mappers.clear();
    }
    if (!context.newObjectMappers().mappers.isEmpty()) {
      addObjectMappers(context.newObjectMappers().mappers);
      context.newObjectMappers().mappers.clear();
    }
    for (    RootMapper rootMapper : rootMappersOrdered) {
      rootMapper.postParse(context);
    }
    for (    RootMapper rootMapper : rootMappersOrdered) {
      rootMapper.validate(context);
    }
  }
 catch (  Throwable e) {
    if (!context.newFieldMappers().mappers.isEmpty()) {
      addFieldMappers(context.newFieldMappers().mappers);
      context.newFieldMappers().mappers.clear();
    }
    if (!context.newObjectMappers().mappers.isEmpty()) {
      addObjectMappers(context.newObjectMappers().mappers);
      context.newObjectMappers().mappers.clear();
    }
    throw new MapperParsingException("failed to parse",e);
  }
 finally {
    if (source.parser() == null && parser != null) {
      parser.close();
    }
  }
  if (context.docs().size() > 1) {
    Collections.reverse(context.docs());
  }
  if (context.docBoost() != 1.0f) {
    Set<String> encounteredFields=Sets.newHashSet();
    for (    Document doc : context.docs()) {
      encounteredFields.clear();
      for (      IndexableField field : doc) {
        if (field.fieldType().indexed() && !field.fieldType().omitNorms()) {
          if (!encounteredFields.contains(field.name())) {
            ((Field)field).setBoost(context.docBoost() * field.boost());
            encounteredFields.add(field.name());
          }
        }
      }
    }
  }
  ParsedDocument doc=new ParsedDocument(context.uid(),context.id(),context.type(),source.routing(),source.timestamp(),source.ttl(),context.docs(),context.analyzer(),context.source(),context.mappingsModified()).parent(source.parent());
  context.reset(null,null,null,null);
  return doc;
}
