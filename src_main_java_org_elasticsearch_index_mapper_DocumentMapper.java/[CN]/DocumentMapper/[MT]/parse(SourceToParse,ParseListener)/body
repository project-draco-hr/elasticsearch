{
  ParseContext context=cache.get();
  if (source.type() != null && !source.type().equals(this.type)) {
    throw new MapperParsingException("Type mismatch, provide type [" + source.type() + "] but mapper is of type ["+ this.type+ "]");
  }
  source.type(this.type);
  XContentParser parser=source.parser();
  try {
    if (parser == null) {
      parser=XContentHelper.createParser(source.source());
    }
    context.reset(parser,new Document(),source,listener);
    if (initMappersAdded) {
      context.addedMapper();
      initMappersAdded=false;
    }
    int countDownTokens=0;
    XContentParser.Token token=parser.nextToken();
    if (token != XContentParser.Token.START_OBJECT) {
      throw new MapperParsingException("Malformed content, must start with an object");
    }
    boolean emptyDoc=false;
    token=parser.nextToken();
    if (token == XContentParser.Token.END_OBJECT) {
      emptyDoc=true;
    }
 else     if (token != XContentParser.Token.FIELD_NAME) {
      throw new MapperParsingException("Malformed content, after first object, either the type field or the actual properties should exist");
    }
    if (type.equals(parser.currentName())) {
      token=parser.nextToken();
      countDownTokens++;
    }
    for (    RootMapper rootMapper : rootMappersOrdered) {
      rootMapper.preParse(context);
    }
    if (!emptyDoc) {
      rootObjectMapper.parse(context);
    }
    for (int i=0; i < countDownTokens; i++) {
      parser.nextToken();
    }
    for (    RootMapper rootMapper : rootMappersOrdered) {
      rootMapper.postParse(context);
    }
    for (    RootMapper rootMapper : rootMappersOrdered) {
      rootMapper.validate(context);
    }
  }
 catch (  IOException e) {
    throw new MapperParsingException("Failed to parse",e);
  }
 finally {
    if (source.parser() == null && parser != null) {
      parser.close();
    }
  }
  if (context.docs().size() > 1) {
    Collections.reverse(context.docs());
  }
  ParsedDocument doc=new ParsedDocument(context.uid(),context.id(),context.type(),source.routing(),source.timestamp(),source.ttl(),context.docs(),context.analyzer(),context.source(),context.mappersAdded()).parent(source.parent());
  context.reset(null,null,null,null);
  return doc;
}
