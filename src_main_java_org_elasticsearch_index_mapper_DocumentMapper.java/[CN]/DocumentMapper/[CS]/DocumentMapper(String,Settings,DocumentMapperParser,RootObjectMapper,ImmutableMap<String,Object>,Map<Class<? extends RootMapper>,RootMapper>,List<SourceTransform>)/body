{
  this.index=index;
  this.indexSettings=indexSettings;
  this.type=rootObjectMapper.name();
  this.typeText=new StringAndBytesText(this.type);
  this.docMapperParser=docMapperParser;
  this.mapping=new Mapping(rootObjectMapper,rootMappers.values().toArray(new RootMapper[rootMappers.values().size()]),sourceTransforms.toArray(new SourceTransform[sourceTransforms.size()]),meta);
  this.typeFilter=typeMapper().termFilter(type,null);
  if (rootMapper(ParentFieldMapper.class).active()) {
    rootMapper(RoutingFieldMapper.class).markAsRequired();
  }
  FieldMapperListener.Aggregator fieldMappersAgg=new FieldMapperListener.Aggregator();
  for (  RootMapper rootMapper : this.mapping.rootMappers) {
    if (rootMapper instanceof FieldMapper) {
      fieldMappersAgg.mappers.add((FieldMapper)rootMapper);
    }
  }
  rootObjectMapper.traverse(fieldMappersAgg);
  this.fieldMappers=new DocumentFieldMappers(docMapperParser.analysisService).copyAndAllAll(fieldMappersAgg.mappers);
  final Map<String,ObjectMapper> objectMappers=Maps.newHashMap();
  rootObjectMapper.traverse(new ObjectMapperListener(){
    @Override public void objectMapper(    ObjectMapper objectMapper){
      objectMappers.put(objectMapper.fullPath(),objectMapper);
    }
  }
);
  this.objectMappers=ImmutableMap.copyOf(objectMappers);
  for (  ObjectMapper objectMapper : objectMappers.values()) {
    if (objectMapper.nested().isNested()) {
      hasNestedObjects=true;
    }
  }
  refreshSource();
}
