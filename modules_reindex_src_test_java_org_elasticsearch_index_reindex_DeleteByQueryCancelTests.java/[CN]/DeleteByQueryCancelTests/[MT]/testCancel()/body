{
  createIndex(INDEX);
  int totalNumShards=getNumShards(INDEX).totalNumShards;
  final int nbDocsToDelete=totalNumShards * MAX_DELETIONS;
  final int nbDocs=nbDocsToDelete * randomIntBetween(1,5);
  for (int i=0; i < nbDocs; i++) {
    indexRandom(false,client().prepareIndex(INDEX,TYPE,String.valueOf(i)).setSource("n",i));
  }
  refresh(INDEX);
  assertHitCount(client().prepareSearch(INDEX).setSize(0).get(),nbDocs);
  DeleteByQueryRequestBuilder deleteByQuery=deleteByQuery().source("_all");
  deleteByQuery.source().setSize(1);
  ListenableActionFuture<BulkIndexByScrollResponse> future=deleteByQuery.execute();
  barrier.await(30,TimeUnit.SECONDS);
  ListTasksResponse tasksList=client().admin().cluster().prepareListTasks().setActions(DeleteByQueryAction.NAME).setDetailed(true).get();
  assertThat(tasksList.getNodeFailures(),empty());
  assertThat(tasksList.getTaskFailures(),empty());
  assertThat(tasksList.getTasks(),hasSize(1));
  BulkByScrollTask.Status status=(BulkByScrollTask.Status)tasksList.getTasks().get(0).getStatus();
  assertNull(status.getReasonCancelled());
  List<TaskInfo> cancelledTasks=client().admin().cluster().prepareCancelTasks().setActions(DeleteByQueryAction.NAME).get().getTasks();
  assertThat(cancelledTasks,hasSize(1));
  tasksList=client().admin().cluster().prepareListTasks().setActions(DeleteByQueryAction.NAME).setDetailed(true).get();
  assertThat(tasksList.getNodeFailures(),empty());
  assertThat(tasksList.getTaskFailures(),empty());
  assertThat(tasksList.getTasks(),hasSize(1));
  status=(BulkByScrollTask.Status)tasksList.getTasks().get(0).getStatus();
  assertEquals(CancelTasksRequest.DEFAULT_REASON,status.getReasonCancelled());
  barrier.await();
  BulkIndexByScrollResponse response=future.get();
  assertThat(response,matcher().deleted(lessThanOrEqualTo((long)MAX_DELETIONS)).batches(MAX_DELETIONS).reasonCancelled(equalTo("by user request")));
}
