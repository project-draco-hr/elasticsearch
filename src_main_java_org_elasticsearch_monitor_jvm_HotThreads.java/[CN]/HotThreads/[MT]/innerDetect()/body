{
  StringBuilder sb=new StringBuilder();
  ThreadMXBean threadBean=ManagementFactory.getThreadMXBean();
  boolean enabledCpu=false;
  try {
    if (threadBean.isThreadCpuTimeSupported()) {
      if (!threadBean.isThreadCpuTimeEnabled()) {
        enabledCpu=true;
        threadBean.setThreadCpuTimeEnabled(true);
      }
    }
 else {
      throw new IllegalStateException("MBean doesn't support thread CPU Time");
    }
    Map<Long,MyThreadInfo> threadInfos=new HashMap<Long,MyThreadInfo>();
    for (    long threadId : threadBean.getAllThreadIds()) {
      if (Thread.currentThread().getId() == threadId) {
        continue;
      }
      long cpu=threadBean.getThreadCpuTime(threadId);
      if (cpu == -1) {
        continue;
      }
      ThreadInfo info=threadBean.getThreadInfo(threadId,0);
      if (info == null) {
        continue;
      }
      threadInfos.put(threadId,new MyThreadInfo(cpu,info));
    }
    Thread.sleep(interval.millis());
    for (    long threadId : threadBean.getAllThreadIds()) {
      if (Thread.currentThread().getId() == threadId) {
        continue;
      }
      long cpu=threadBean.getThreadCpuTime(threadId);
      if (cpu == -1) {
        threadInfos.remove(threadId);
        continue;
      }
      ThreadInfo info=threadBean.getThreadInfo(threadId,0);
      if (info == null) {
        threadInfos.remove(threadId);
        continue;
      }
      MyThreadInfo data=threadInfos.get(threadId);
      if (data != null) {
        data.setDelta(cpu,info);
      }
 else {
        threadInfos.remove(threadId);
      }
    }
    List<MyThreadInfo> hotties=new ArrayList<MyThreadInfo>(threadInfos.values());
    Collections.sort(hotties,new Comparator<MyThreadInfo>(){
      public int compare(      MyThreadInfo o1,      MyThreadInfo o2){
        if ("cpu".equals(type)) {
          return (int)(o2.cpuTime - o1.cpuTime);
        }
 else         if ("wait".equals(type)) {
          return (int)(o2.waitedTime - o1.waitedTime);
        }
 else         if ("block".equals(type)) {
          return (int)(o2.blockedTime - o1.blockedTime);
        }
        throw new IllegalArgumentException();
      }
    }
);
    long[] ids=new long[busiestThreads];
    for (int i=0; i < busiestThreads; i++) {
      MyThreadInfo info=hotties.get(i);
      ids[i]=info.info.getThreadId();
    }
    ThreadInfo[][] allInfos=new ThreadInfo[threadElementsSnapshotCount][];
    for (int j=0; j < threadElementsSnapshotCount; j++) {
      allInfos[j]=threadBean.getThreadInfo(ids,Integer.MAX_VALUE);
      Thread.sleep(threadElementsSnapshotDelay.millis());
    }
    for (int t=0; t < busiestThreads; t++) {
      long time=0;
      if ("cpu".equals(type)) {
        time=hotties.get(t).cpuTime;
      }
 else       if ("wait".equals(type)) {
        time=hotties.get(t).waitedTime;
      }
 else       if ("block".equals(type)) {
        time=hotties.get(t).blockedTime;
      }
      double percent=(((double)time) / interval.nanos()) * 100;
      sb.append(String.format("%n%4.1f%% (%s out of %s) %s usage by thread '%s'%n",percent,TimeValue.timeValueNanos(time),interval,type,allInfos[0][t].getThreadName()));
      boolean[] done=new boolean[threadElementsSnapshotCount];
      for (int i=0; i < threadElementsSnapshotCount; i++) {
        if (done[i])         continue;
        int maxSim=1;
        boolean[] similars=new boolean[threadElementsSnapshotCount];
        for (int j=i + 1; j < threadElementsSnapshotCount; j++) {
          if (done[j])           continue;
          int similarity=similarity(allInfos[i][t],allInfos[j][t]);
          if (similarity > maxSim) {
            maxSim=similarity;
            similars=new boolean[threadElementsSnapshotCount];
          }
          if (similarity == maxSim)           similars[j]=true;
        }
        int count=1;
        for (int j=i + 1; j < threadElementsSnapshotCount; j++) {
          if (similars[j]) {
            done[j]=true;
            count++;
          }
        }
        StackTraceElement[] show=allInfos[i][t].getStackTrace();
        if (count == 1) {
          sb.append(String.format("  unique snapshot%n"));
          for (int l=0; l < show.length; l++) {
            sb.append(String.format("    %s%n",show[l]));
          }
        }
 else {
          sb.append(String.format("  %d/%d snapshots sharing following %d elements%n",count,threadElementsSnapshotCount,maxSim));
          for (int l=show.length - maxSim; l < show.length; l++) {
            sb.append(String.format("    %s%n",show[l]));
          }
        }
      }
    }
    return sb.toString();
  }
  finally {
    if (enabledCpu) {
      threadBean.setThreadCpuTimeEnabled(false);
    }
  }
}
