{
  final String action=stream.readString();
  transportServiceAdapter.onRequestReceived(requestId,action);
  final LocalTransportChannel transportChannel=new LocalTransportChannel(this,transportServiceAdapter,sourceTransport,action,requestId,version);
  try {
    final RequestHandlerRegistry reg=transportServiceAdapter.getRequestHandler(action);
    if (reg == null) {
      throw new ActionNotFoundTransportException("Action [" + action + "] not found");
    }
    final TransportRequest request=reg.newRequest();
    request.remoteAddress(sourceTransport.boundAddress.publishAddress());
    request.readFrom(stream);
    if (ThreadPool.Names.SAME.equals(reg.getExecutor())) {
      reg.getHandler().messageReceived(request,transportChannel);
    }
 else {
      threadPool.executor(reg.getExecutor()).execute(new AbstractRunnable(){
        @Override protected void doRun() throws Exception {
          reg.getHandler().messageReceived(request,transportChannel);
        }
        @Override public boolean isForceExecution(){
          return reg.isForceExecution();
        }
        @Override public void onFailure(        Throwable e){
          if (lifecycleState() == Lifecycle.State.STARTED) {
            try {
              transportChannel.sendResponse(e);
            }
 catch (            Throwable e1) {
              logger.warn("Failed to send error message back to client for action [" + action + "]",e1);
              logger.warn("Actual Exception",e);
            }
          }
        }
      }
);
    }
  }
 catch (  Throwable e) {
    try {
      transportChannel.sendResponse(e);
    }
 catch (    Throwable e1) {
      logger.warn("Failed to send error message back to client for action [" + action + "]",e);
      logger.warn("Actual Exception",e1);
    }
  }
}
