{
  final String index="test";
  final ShardId shardId=new ShardId(index,"_na_",0);
  ClusterState state=stateWithActivePrimary(index,true,randomInt(5));
  clusterService.setState(state);
  Request request=new Request(shardId).timeout("1ms");
  PlainActionFuture<Response> listener=new PlainActionFuture<>();
  AtomicBoolean movedToReplication=new AtomicBoolean();
  TransportReplicationAction.PrimaryPhase primaryPhase=action.new PrimaryPhase(request,createTransportChannel(listener)){
    @Override void finishAndMoveToReplication(    TransportReplicationAction.ReplicationPhase replicationPhase){
      super.finishAndMoveToReplication(replicationPhase);
      movedToReplication.set(true);
    }
  }
;
  ShardRouting primaryShard=state.getRoutingTable().shardRoutingTable(shardId).primaryShard();
  boolean executeOnPrimary=true;
  if (primaryShard.relocating() && randomBoolean()) {
    isRelocated.set(true);
    indexShardRouting.set(primaryShard);
    executeOnPrimary=false;
  }
  primaryPhase.run();
  assertThat(request.processedOnPrimary.get(),equalTo(executeOnPrimary));
  assertThat(movedToReplication.get(),equalTo(executeOnPrimary));
  if (executeOnPrimary == false) {
    final List<CapturingTransport.CapturedRequest> requests=transport.capturedRequestsByTargetNode().get(primaryShard.relocatingNodeId());
    assertThat(requests,notNullValue());
    assertThat(requests.size(),equalTo(1));
    assertThat("primary request was not delegated to relocation target",requests.get(0).action,equalTo("testAction[p]"));
  }
}
