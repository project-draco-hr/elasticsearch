{
  final ShardIterator shardIt=shardRoutingTable.shardsIt();
  final ShardId shardId=shardIt.shardId();
  final Request request=new Request(shardId);
  final PlainActionFuture<Response> listener=new PlainActionFuture<>();
  logger.debug("expecting [{}] assigned replicas, [{}] total shards. using state: \n{}",assignedReplicas,totalShards,clusterService.state().prettyPrint());
  Releasable reference=getOrCreateIndexShardOperationsCounter();
  assertIndexShardCounter(2);
  TransportReplicationAction<Request,Request,Response>.ReplicationPhase replicationPhase=action.new ReplicationPhase(request,new Response(),request.shardId(),createTransportChannel(listener),reference,null);
  assertThat(replicationPhase.totalShards(),equalTo(totalShards));
  assertThat(replicationPhase.pending(),equalTo(assignedReplicas));
  replicationPhase.run();
  final CapturingTransport.CapturedRequest[] capturedRequests=transport.getCapturedRequestsAndClear();
  HashMap<String,Request> nodesSentTo=new HashMap<>();
  boolean executeOnReplica=action.shouldExecuteReplication(clusterService.state().getMetaData().index(shardId.getIndex()).getSettings());
  for (  CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {
    Request replicationRequest=(Request)capturedRequest.request;
    assertNull(nodesSentTo.put(capturedRequest.node.getId(),replicationRequest));
    assertEquals(request.shardId,replicationRequest.shardId);
  }
  assertThat(nodesSentTo.keySet(),not(hasItem(clusterService.state().getNodes().localNodeId())));
  for (  ShardRouting shard : clusterService.state().getRoutingTable().shardRoutingTable(shardId.getIndex(),shardId.id())) {
    if (shard.primary() == false && executeOnReplica == false) {
      continue;
    }
    if (shard.unassigned()) {
      continue;
    }
    if (shard.primary() == false) {
      nodesSentTo.remove(shard.currentNodeId());
    }
    if (shard.relocating()) {
      nodesSentTo.remove(shard.relocatingNodeId());
    }
  }
  assertThat(nodesSentTo.entrySet(),is(empty()));
  if (assignedReplicas > 0) {
    assertThat("listener is done, but there are outstanding replicas",listener.isDone(),equalTo(false));
  }
  int pending=replicationPhase.pending();
  int criticalFailures=0;
  int successful=1;
  List<CapturingTransport.CapturedRequest> failures=new ArrayList<>();
  for (  CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {
    if (randomBoolean()) {
      Throwable t;
      boolean criticalFailure=randomBoolean();
      if (criticalFailure) {
        t=new CorruptIndexException("simulated",(String)null);
        criticalFailures++;
      }
 else {
        t=new IndexShardNotStartedException(shardId,IndexShardState.RECOVERING);
      }
      logger.debug("--> simulating failure on {} with [{}]",capturedRequest.node,t.getClass().getSimpleName());
      transport.handleResponse(capturedRequest.requestId,t);
      if (criticalFailure) {
        CapturingTransport.CapturedRequest[] shardFailedRequests=transport.getCapturedRequestsAndClear();
        assertEquals(1,shardFailedRequests.length);
        CapturingTransport.CapturedRequest shardFailedRequest=shardFailedRequests[0];
        ShardRouting routing=clusterService.state().getRoutingNodes().node(capturedRequest.node.id()).get(request.shardId.id());
        ShardStateAction.ShardRoutingEntry shardRoutingEntry=(ShardStateAction.ShardRoutingEntry)shardFailedRequest.request;
        assertEquals(shardRoutingEntry.getShardRouting(),routing);
        failures.add(shardFailedRequest);
        if (randomBoolean()) {
          int numberOfRetries=randomIntBetween(1,4);
          CapturingTransport.CapturedRequest currentRequest=shardFailedRequest;
          for (int retryNumber=0; retryNumber < numberOfRetries; retryNumber++) {
            clusterService.setState(ClusterState.builder(clusterService.state()));
            transport.handleResponse(currentRequest.requestId,new NotMasterException("shard-failed-test"));
            CapturingTransport.CapturedRequest[] retryRequests=transport.capturedRequests();
            transport.clear();
            assertEquals(1,retryRequests.length);
            currentRequest=retryRequests[0];
          }
          transport.handleResponse(currentRequest.requestId,TransportResponse.Empty.INSTANCE);
        }
 else {
          transport.handleResponse(shardFailedRequest.requestId,TransportResponse.Empty.INSTANCE);
        }
      }
    }
 else {
      successful++;
      transport.handleResponse(capturedRequest.requestId,TransportResponse.Empty.INSTANCE);
    }
    pending--;
    assertThat(replicationPhase.pending(),equalTo(pending));
    assertThat(replicationPhase.successful(),equalTo(successful));
  }
  assertThat(listener.isDone(),equalTo(true));
  Response response=listener.get();
  final ReplicationResponse.ShardInfo shardInfo=response.getShardInfo();
  assertThat(shardInfo.getFailed(),equalTo(criticalFailures));
  assertThat(shardInfo.getFailures(),arrayWithSize(criticalFailures));
  assertThat(shardInfo.getSuccessful(),equalTo(successful));
  assertThat(shardInfo.getTotal(),equalTo(totalShards));
  assertThat("failed to see enough shard failures",failures.size(),equalTo(criticalFailures));
  for (  CapturingTransport.CapturedRequest capturedRequest : transport.capturedRequests()) {
    assertThat(capturedRequest.action,equalTo(ShardStateAction.SHARD_FAILED_ACTION_NAME));
  }
  assertIndexShardCounter(1);
}
