{
  if (indexShard.state() == IndexShardState.CLOSED) {
    listener.onIgnoreRecovery("shard closed");
    return;
  }
  if (!indexShard.routingEntry().primary()) {
    listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"Trying to recover when the shard is in backup state",null));
    return;
  }
  try {
    indexShard.recovering("from gateway");
  }
 catch (  IllegalIndexShardStateException e) {
    listener.onIgnoreRecovery("already in recovering process, " + e.getMessage());
    return;
  }
  threadPool.generic().execute(new Runnable(){
    @Override public void run(){
      recoveryStatus=new RecoveryStatus();
      recoveryStatus.updateStage(RecoveryStatus.Stage.INIT);
      try {
        logger.debug("starting recovery from {} ...",shardGateway);
        shardGateway.recover(indexShouldExists,recoveryStatus);
        lastIndexVersion=recoveryStatus.index().version();
        lastTranslogId=-1;
        lastTranslogLength=0;
        lastTotalTranslogOperations=recoveryStatus.translog().currentTranslogOperations();
        if (indexShard.state() != IndexShardState.STARTED) {
          indexShard.start("post recovery from gateway");
        }
        indexShard.refresh(new Engine.Refresh().force(true).source("post_gateway"));
        recoveryStatus.time(System.currentTimeMillis() - recoveryStatus.startTime());
        recoveryStatus.updateStage(RecoveryStatus.Stage.DONE);
        if (logger.isDebugEnabled()) {
          logger.debug("recovery completed from [{}], took [{}]",shardGateway,timeValueMillis(recoveryStatus.time()));
        }
 else         if (logger.isTraceEnabled()) {
          StringBuilder sb=new StringBuilder();
          sb.append("recovery completed from ").append(shardGateway).append(", took [").append(timeValueMillis(recoveryStatus.time())).append("]\n");
          sb.append("    index    : files           [").append(recoveryStatus.index().numberOfFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().totalSize())).append("], took[").append(TimeValue.timeValueMillis(recoveryStatus.index().time())).append("]\n");
          sb.append("             : recovered_files [").append(recoveryStatus.index().numberOfRecoveredFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().recoveredTotalSize())).append("]\n");
          sb.append("             : reusing_files   [").append(recoveryStatus.index().numberOfReusedFiles()).append("] with total_size [").append(new ByteSizeValue(recoveryStatus.index().reusedTotalSize())).append("]\n");
          sb.append("    start    : took [").append(TimeValue.timeValueMillis(recoveryStatus.start().time())).append("], check_index [").append(timeValueMillis(recoveryStatus.start().checkIndexTime())).append("]\n");
          sb.append("    translog : number_of_operations [").append(recoveryStatus.translog().currentTranslogOperations()).append("], took [").append(TimeValue.timeValueMillis(recoveryStatus.translog().time())).append("]");
          logger.trace(sb.toString());
        }
        listener.onRecoveryDone();
        scheduleSnapshotIfNeeded();
      }
 catch (      IndexShardGatewayRecoveryException e) {
        if (indexShard.state() == IndexShardState.CLOSED) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        listener.onRecoveryFailed(e);
      }
catch (      IndexShardClosedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      IndexShardNotStartedException e) {
        listener.onIgnoreRecovery("shard closed");
      }
catch (      Exception e) {
        if (indexShard.state() == IndexShardState.CLOSED) {
          listener.onIgnoreRecovery("shard closed");
          return;
        }
        listener.onRecoveryFailed(new IndexShardGatewayRecoveryException(shardId,"failed recovery",e));
      }
    }
  }
);
}
