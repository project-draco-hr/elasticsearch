{
  final boolean primary=routing.primary();
  if (closed.get()) {
    throw new IllegalStateException("Can't create shard [" + index.name() + "]["+ sShardId+ "], closed");
  }
  final ShardId shardId=new ShardId(index,sShardId);
  ShardLock lock=null;
  boolean success=false;
  Injector shardInjector=null;
  try {
    lock=nodeEnv.shardLock(shardId,TimeUnit.SECONDS.toMillis(5));
    ShardPath path;
    try {
      path=ShardPath.loadShardPath(logger,nodeEnv,shardId,indexSettings);
    }
 catch (    IllegalStateException ex) {
      logger.warn("{} failed to load shard path, trying to remove leftover",shardId);
      try {
        ShardPath.deleteLeftoverShardDirectory(logger,nodeEnv,lock,indexSettings);
        path=ShardPath.loadShardPath(logger,nodeEnv,shardId,indexSettings);
      }
 catch (      Throwable t) {
        t.addSuppressed(ex);
        throw t;
      }
    }
    if (path == null) {
      path=ShardPath.selectNewPathForShard(nodeEnv,shardId,indexSettings,routing.getExpectedShardSize() == ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes() : routing.getExpectedShardSize(),this);
      logger.debug("{} creating using a new path [{}]",shardId,path);
    }
 else {
      logger.debug("{} creating using an existing path [{}]",shardId,path);
    }
    if (shards.containsKey(shardId.id())) {
      throw new IndexShardAlreadyExistsException(shardId + " already exists");
    }
    indicesLifecycle.beforeIndexShardCreated(shardId,indexSettings);
    logger.debug("creating shard_id {}",shardId);
    final boolean canDeleteShardContent=IndexMetaData.isOnSharedFilesystem(indexSettings) == false || (primary && IndexMetaData.isOnSharedFilesystem(indexSettings));
    ModulesBuilder modules=new ModulesBuilder();
    modules.add(new IndexShardModule(shardId,primary,indexSettings));
    modules.add(new StoreModule(injector.getInstance(IndexStore.class).shardDirectory(),lock,new StoreCloseListener(shardId,canDeleteShardContent,new Closeable(){
      @Override public void close() throws IOException {
        injector.getInstance(IndicesQueryCache.class).onClose(shardId);
      }
    }
),path));
    modules.add(new DeletionPolicyModule());
    for (    Module pluginModule : pluginsService.shardModules(indexSettings)) {
      modules.add(pluginModule);
    }
    pluginsService.processModules(modules);
    try {
      shardInjector=modules.createChildInjector(injector);
    }
 catch (    CreationException e) {
      ElasticsearchException ex=new ElasticsearchException("failed to create shard",Injectors.getFirstErrorFailure(e));
      ex.setShard(shardId);
      throw ex;
    }
catch (    Throwable e) {
      ElasticsearchException ex=new ElasticsearchException("failed to create shard",e);
      ex.setShard(shardId);
      throw ex;
    }
    IndexShard indexShard=shardInjector.getInstance(IndexShard.class);
    indicesLifecycle.indexShardStateChanged(indexShard,null,"shard created");
    indicesLifecycle.afterIndexShardCreated(indexShard);
    shards=newMapBuilder(shards).put(shardId.id(),new Tuple<>(indexShard,shardInjector)).immutableMap();
    success=true;
    return indexShard;
  }
 catch (  IOException e) {
    ElasticsearchException ex=new ElasticsearchException("failed to create shard",e);
    ex.setShard(shardId);
    throw ex;
  }
 finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(lock);
      if (shardInjector != null) {
        IndexShard indexShard=shardInjector.getInstance(IndexShard.class);
        closeShardInjector("initialization failed",shardId,shardInjector,indexShard);
      }
    }
  }
}
