{
  if (globalOrdinals == null) {
    return buildEmptyAggregation();
  }
  final int size;
  if (bucketCountThresholds.getMinDocCount() == 0) {
    size=(int)Math.min(globalOrdinals.getMaxOrd(),bucketCountThresholds.getShardSize());
  }
 else {
    size=(int)Math.min(maxBucketOrd(),bucketCountThresholds.getShardSize());
  }
  BucketPriorityQueue ordered=new BucketPriorityQueue(size,order.comparator(this));
  StringTerms.Bucket spare=null;
  for (long globalTermOrd=Ordinals.MIN_ORDINAL; globalTermOrd < globalOrdinals.getMaxOrd(); ++globalTermOrd) {
    if (includeExclude != null && !acceptedGlobalOrdinals.get(globalTermOrd)) {
      continue;
    }
    final long bucketOrd=getBucketOrd(globalTermOrd);
    final long bucketDocCount=bucketOrd < 0 ? 0 : bucketDocCount(bucketOrd);
    if (bucketCountThresholds.getMinDocCount() > 0 && bucketDocCount == 0) {
      continue;
    }
    if (spare == null) {
      spare=new StringTerms.Bucket(new BytesRef(),0,null);
    }
    spare.bucketOrd=bucketOrd;
    spare.docCount=bucketDocCount;
    copy(globalValues.getValueByOrd(globalTermOrd),spare.termBytes);
    if (bucketCountThresholds.getShardMinDocCount() <= spare.docCount) {
      spare=(StringTerms.Bucket)ordered.insertWithOverflow(spare);
    }
  }
  final InternalTerms.Bucket[] list=new InternalTerms.Bucket[ordered.size()];
  long survivingBucketOrds[]=new long[ordered.size()];
  for (int i=ordered.size() - 1; i >= 0; --i) {
    final StringTerms.Bucket bucket=(StringTerms.Bucket)ordered.pop();
    survivingBucketOrds[i]=bucket.bucketOrd;
    list[i]=bucket;
  }
  runDeferredCollections(survivingBucketOrds);
  for (int i=0; i < list.length; i++) {
    Bucket bucket=list[i];
    bucket.aggregations=bucket.docCount == 0 ? bucketEmptyAggregations() : bucketAggregations(bucket.bucketOrd);
  }
  return new StringTerms(name,order,bucketCountThresholds.getRequiredSize(),bucketCountThresholds.getMinDocCount(),Arrays.asList(list));
}
