{
  logger.info("--> starting 3 nodes");
  String noAttrNode=internalCluster().startNode();
  String barAttrNode=internalCluster().startNode(Settings.builder().put("node.attr.bar","baz"));
  String fooBarAttrNode=internalCluster().startNode(Settings.builder().put("node.attr.foo","bar").put("node.attr.bar","baz"));
  logger.info("--> waiting for 3 nodes to be up");
  client().admin().cluster().health(Requests.clusterHealthRequest().waitForNodes("3")).actionGet();
  client().admin().indices().prepareCreate("anywhere").setSettings(Settings.builder().put("index.number_of_shards",5).put("index.number_of_replicas",1)).get();
  client().admin().indices().prepareCreate("only-baz").setSettings(Settings.builder().put("index.routing.allocation.include.bar","baz").put("index.number_of_shards",5).put("index.number_of_replicas",1)).get();
  client().admin().indices().prepareCreate("only-foo").setSettings(Settings.builder().put("index.routing.allocation.include.foo","bar").put("index.number_of_shards",1).put("index.number_of_replicas",1)).get();
  ensureGreen("anywhere","only-baz");
  ensureYellow("only-foo");
  ClusterAllocationExplainResponse resp=client().admin().cluster().prepareAllocationExplain().setIndex("only-foo").setShard(0).setPrimary(false).get();
  ClusterAllocationExplanation cae=resp.getExplanation();
  assertThat(cae.getShard().getIndexName(),equalTo("only-foo"));
  assertFalse(cae.isPrimary());
  assertFalse(cae.isAssigned());
  assertThat(UnassignedInfo.Reason.INDEX_CREATED,equalTo(cae.getUnassignedInfo().getReason()));
  assertThat("expecting no remaining delay: " + cae.getRemainingDelayNanos(),cae.getRemainingDelayNanos(),equalTo(0L));
  Map<DiscoveryNode,Decision> nodeToDecisions=cae.getNodeDecisions();
  Map<DiscoveryNode,Float> nodeToWeight=cae.getNodeWeights();
  Map<DiscoveryNode,IndicesShardStoresResponse.StoreStatus> nodeToStatus=cae.getNodeStoreStatus();
  Float noAttrWeight=-1f;
  Float barAttrWeight=-1f;
  Float fooBarAttrWeight=-1f;
  for (  Map.Entry<DiscoveryNode,Decision> entry : nodeToDecisions.entrySet()) {
    DiscoveryNode node=entry.getKey();
    String nodeName=node.getName();
    Decision d=entry.getValue();
    float weight=nodeToWeight.get(node);
    IndicesShardStoresResponse.StoreStatus storeStatus=nodeToStatus.get(node);
    assertEquals(d.type(),Decision.Type.NO);
    if (noAttrNode.equals(nodeName)) {
      assertThat(d.toString(),containsString("node does not match index include filters [foo:\"bar\"]"));
      noAttrWeight=weight;
      assertNull(storeStatus);
    }
 else     if (barAttrNode.equals(nodeName)) {
      assertThat(d.toString(),containsString("node does not match index include filters [foo:\"bar\"]"));
      barAttrWeight=weight;
      assertNull(storeStatus);
    }
 else     if (fooBarAttrNode.equals(nodeName)) {
      assertThat(d.toString(),containsString("the shard cannot be allocated on the same node id"));
      fooBarAttrWeight=weight;
      assertEquals(storeStatus.getAllocationStatus(),IndicesShardStoresResponse.StoreStatus.AllocationStatus.PRIMARY);
    }
 else {
      fail("unexpected node with name: " + nodeName + ", I have: "+ noAttrNode+ ", "+ barAttrNode+ ", "+ fooBarAttrNode);
    }
  }
  assertThat(noAttrWeight,greaterThan(barAttrWeight));
  assertThat(noAttrWeight,greaterThan(fooBarAttrWeight));
  assertFalse(barAttrWeight == fooBarAttrWeight);
}
