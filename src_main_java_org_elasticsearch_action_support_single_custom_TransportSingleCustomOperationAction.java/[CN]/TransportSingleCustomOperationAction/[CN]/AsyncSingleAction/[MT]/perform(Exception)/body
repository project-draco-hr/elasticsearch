{
  final ShardRouting shard=shardsIt == null ? null : shardsIt.nextOrNull();
  if (shard == null) {
    Exception failure=lastException;
    if (failure == null) {
      failure=new NoShardAvailableActionException(null,"No shard available for [" + request + "]");
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug("failed to execute [" + request + "]",failure);
      }
    }
    listener.onFailure(failure);
  }
 else {
    if (shard.currentNodeId().equals(nodes.localNodeId())) {
      if (!request.isPreferLocal()) {
        if (request.isOperationThreaded()) {
          request.beforeLocalFork();
          threadPool.executor(executor).execute(new Runnable(){
            @Override public void run(){
              try {
                Response response=shardOperation(request,shard.id());
                listener.onResponse(response);
              }
 catch (              Exception e) {
                onFailure(shard,e);
              }
            }
          }
);
        }
 else {
          try {
            final Response response=shardOperation(request,shard.id());
            listener.onResponse(response);
          }
 catch (          Exception e) {
            onFailure(shard,e);
          }
        }
      }
 else {
        perform(lastException);
      }
    }
 else {
      DiscoveryNode node=nodes.get(shard.currentNodeId());
      transportService.sendRequest(node,transportShardAction,new ShardSingleOperationRequest(request,shard.id()),new BaseTransportResponseHandler<Response>(){
        @Override public Response newInstance(){
          return newResponse();
        }
        @Override public String executor(){
          return ThreadPool.Names.SAME;
        }
        @Override public void handleResponse(        final Response response){
          listener.onResponse(response);
        }
        @Override public void handleException(        TransportException exp){
          onFailure(shard,exp);
        }
      }
);
    }
  }
}
