{
  super.readFrom(in);
  onlyCount=in.readBoolean();
  requestedSize=in.readVInt();
  topDocs=Lucene.readTopDocs(in);
  int size=in.readVInt();
  ids=new HashMap<>(size);
  for (int i=0; i < size; i++) {
    ids.put(in.readVInt(),in.readString());
  }
  size=in.readVInt();
  hls=new HashMap<>(size);
  for (int i=0; i < size; i++) {
    int docId=in.readVInt();
    int mSize=in.readVInt();
    Map<String,HighlightField> fields=new HashMap<>();
    for (int j=0; j < mSize; j++) {
      fields.put(in.readString(),HighlightField.readHighlightField(in));
    }
    hls.put(docId,fields);
  }
  aggregations=InternalAggregations.readOptionalAggregations(in);
  if (in.readBoolean()) {
    int pipelineAggregatorsSize=in.readVInt();
    List<SiblingPipelineAggregator> pipelineAggregators=new ArrayList<>(pipelineAggregatorsSize);
    for (int i=0; i < pipelineAggregatorsSize; i++) {
      BytesReference type=in.readBytesReference();
      PipelineAggregator pipelineAggregator=PipelineAggregatorStreams.stream(type).readResult(in);
      pipelineAggregators.add((SiblingPipelineAggregator)pipelineAggregator);
    }
    this.pipelineAggregators=pipelineAggregators;
  }
}
