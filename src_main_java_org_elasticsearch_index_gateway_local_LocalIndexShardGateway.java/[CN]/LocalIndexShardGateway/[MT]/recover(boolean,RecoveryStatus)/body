{
  recoveryStatus.index().startTime(System.currentTimeMillis());
  recoveryStatus.updateStage(RecoveryStatus.Stage.INDEX);
  long version=-1;
  long translogId=-1;
  try {
    SegmentInfos si=Lucene.readSegmentInfosIfExists(indexShard.store().directory());
    if (si != null) {
      if (indexShouldExists) {
        version=si.getVersion();
        if (si.getUserData().containsKey(Translog.TRANSLOG_ID_KEY)) {
          translogId=Long.parseLong(si.getUserData().get(Translog.TRANSLOG_ID_KEY));
        }
 else {
          translogId=version;
        }
        logger.trace("using existing shard data, translog id [{}]",translogId);
      }
 else {
        logger.trace("cleaning existing shard, shouldn't exists");
        IndexWriter writer=new IndexWriter(indexShard.store().directory(),new IndexWriterConfig(Lucene.VERSION,Lucene.STANDARD_ANALYZER).setOpenMode(IndexWriterConfig.OpenMode.CREATE));
        writer.close();
      }
    }
 else     if (indexShouldExists && indexShard.store().indexStore().persistent()) {
      throw new IndexShardGatewayRecoveryException(shardId(),"shard allocated for local recovery (post api), should exists, but doesn't");
    }
  }
 catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to fetch index version after copying it over",e);
  }
  recoveryStatus.index().updateVersion(version);
  recoveryStatus.index().time(System.currentTimeMillis() - recoveryStatus.index().startTime());
  try {
    int numberOfFiles=0;
    long totalSizeInBytes=0;
    for (    String name : indexShard.store().directory().listAll()) {
      numberOfFiles++;
      totalSizeInBytes+=indexShard.store().directory().fileLength(name);
    }
    recoveryStatus.index().files(numberOfFiles,totalSizeInBytes,numberOfFiles,totalSizeInBytes);
  }
 catch (  Exception e) {
  }
  recoveryStatus.start().startTime(System.currentTimeMillis());
  recoveryStatus.updateStage(RecoveryStatus.Stage.START);
  if (translogId == -1) {
    indexShard.start("post recovery from gateway, no translog");
    recoveryStatus.start().time(System.currentTimeMillis() - recoveryStatus.start().startTime());
    recoveryStatus.start().checkIndexTime(indexShard.checkIndexTook());
    return;
  }
  FsTranslog translog=(FsTranslog)indexShard.translog();
  String translogName="translog-" + translogId;
  String recoverTranslogName=translogName + ".recovering";
  File recoveringTranslogFile=null;
  for (  File translogLocation : translog.locations()) {
    File tmpRecoveringFile=new File(translogLocation,recoverTranslogName);
    if (!tmpRecoveringFile.exists()) {
      File tmpTranslogFile=new File(translogLocation,translogName);
      if (tmpTranslogFile.exists()) {
        for (int i=0; i < 3; i++) {
          if (tmpTranslogFile.renameTo(tmpRecoveringFile)) {
            recoveringTranslogFile=tmpRecoveringFile;
            break;
          }
        }
      }
    }
 else {
      recoveringTranslogFile=tmpRecoveringFile;
      break;
    }
  }
  if (recoveringTranslogFile == null || !recoveringTranslogFile.exists()) {
    indexShard.start("post recovery from gateway, no translog");
    recoveryStatus.start().time(System.currentTimeMillis() - recoveryStatus.start().startTime());
    recoveryStatus.start().checkIndexTime(indexShard.checkIndexTook());
    return;
  }
  indexShard.performRecoveryPrepareForTranslog();
  recoveryStatus.start().time(System.currentTimeMillis() - recoveryStatus.start().startTime());
  recoveryStatus.start().checkIndexTime(indexShard.checkIndexTook());
  recoveryStatus.translog().startTime(System.currentTimeMillis());
  recoveryStatus.updateStage(RecoveryStatus.Stage.TRANSLOG);
  FileInputStream fs=null;
  try {
    fs=new FileInputStream(recoveringTranslogFile);
    InputStreamStreamInput si=new InputStreamStreamInput(fs);
    while (true) {
      Translog.Operation operation;
      try {
        int opSize=si.readInt();
        operation=TranslogStreams.readTranslogOperation(si);
      }
 catch (      EOFException e) {
        break;
      }
catch (      IOException e) {
        break;
      }
      try {
        indexShard.performRecoveryOperation(operation);
        recoveryStatus.translog().addTranslogOperations(1);
      }
 catch (      ElasticSearchException e) {
        if (e.status() == RestStatus.BAD_REQUEST) {
          logger.info("ignoring recovery of a corrupt translog entry",e);
        }
 else {
          throw e;
        }
      }
    }
  }
 catch (  Throwable e) {
    indexShard.translog().close(true);
    throw new IndexShardGatewayRecoveryException(shardId,"failed to recover shard",e);
  }
 finally {
    Closeables.closeQuietly(fs);
  }
  indexShard.performRecoveryFinalization(true);
  recoveringTranslogFile.delete();
  recoveryStatus.translog().time(System.currentTimeMillis() - recoveryStatus.translog().startTime());
}
