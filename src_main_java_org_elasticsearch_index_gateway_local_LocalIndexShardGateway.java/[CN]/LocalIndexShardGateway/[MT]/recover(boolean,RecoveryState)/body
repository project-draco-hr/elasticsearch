{
  recoveryState.getIndex().startTime(System.currentTimeMillis());
  recoveryState.setStage(RecoveryState.Stage.INDEX);
  long version=-1;
  long translogId=-1;
  indexShard.store().incRef();
  try {
    try {
      indexShard.store().failIfCorrupted();
      SegmentInfos si=null;
      try {
        si=Lucene.readSegmentInfos(indexShard.store().directory());
      }
 catch (      Throwable e) {
        String files="_unknown_";
        try {
          files=Arrays.toString(indexShard.store().directory().listAll());
        }
 catch (        Throwable e1) {
          files+=" (failure=" + ExceptionsHelper.detailedMessage(e1) + ")";
        }
        if (indexShouldExists) {
          throw new IndexShardGatewayRecoveryException(shardId(),"shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files,e);
        }
      }
      if (si != null) {
        if (indexShouldExists) {
          version=si.getVersion();
          if (si.getUserData().containsKey(Translog.TRANSLOG_ID_KEY)) {
            translogId=Long.parseLong(si.getUserData().get(Translog.TRANSLOG_ID_KEY));
          }
 else {
            translogId=version;
          }
          logger.trace("using existing shard data, translog id [{}]",translogId);
        }
 else {
          logger.trace("cleaning existing shard, shouldn't exists");
          IndexWriter writer=new IndexWriter(indexShard.store().directory(),new IndexWriterConfig(Lucene.STANDARD_ANALYZER).setOpenMode(IndexWriterConfig.OpenMode.CREATE));
          writer.close();
        }
      }
    }
 catch (    Throwable e) {
      throw new IndexShardGatewayRecoveryException(shardId(),"failed to fetch index version after copying it over",e);
    }
    recoveryState.getIndex().updateVersion(version);
    recoveryState.getIndex().time(System.currentTimeMillis() - recoveryState.getIndex().startTime());
    try {
      int numberOfFiles=0;
      long totalSizeInBytes=0;
      for (      String name : indexShard.store().directory().listAll()) {
        numberOfFiles++;
        long length=indexShard.store().directory().fileLength(name);
        totalSizeInBytes+=length;
        recoveryState.getIndex().addFileDetail(name,length,length);
      }
      RecoveryState.Index index=recoveryState.getIndex();
      index.totalFileCount(numberOfFiles);
      index.totalByteCount(totalSizeInBytes);
      index.reusedFileCount(numberOfFiles);
      index.reusedByteCount(totalSizeInBytes);
      index.recoveredFileCount(numberOfFiles);
      index.recoveredByteCount(totalSizeInBytes);
    }
 catch (    Exception e) {
    }
    recoveryState.getStart().startTime(System.currentTimeMillis());
    recoveryState.setStage(RecoveryState.Stage.START);
    if (translogId == -1) {
      indexShard.postRecovery("post recovery from gateway, no translog for id [" + translogId + "]");
      recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
      recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
      return;
    }
    Translog translog=indexShard.translog();
    final Path translogName=translog.getPath(translogId);
    final Path recoverTranslogName=translogName.resolveSibling(translogName.getFileName() + ".recovering");
    logger.trace("try recover from translog file {} locations: {}",translogName,Arrays.toString(translog.locations()));
    Path recoveringTranslogFile=null;
    for (    Path translogLocation : translog.locations()) {
      final Path tmpRecoveringFile=translogLocation.resolve(recoverTranslogName);
      if (Files.exists(tmpRecoveringFile) == false) {
        Path tmpTranslogFile=translogLocation.resolve(translogName);
        if (Files.exists(tmpTranslogFile)) {
          logger.trace("Translog file found in {} - renaming",translogLocation);
          for (int i=0; i < RECOVERY_TRANSLOG_RENAME_RETRIES; i++) {
            try {
              Files.move(tmpTranslogFile,tmpRecoveringFile,StandardCopyOption.ATOMIC_MOVE);
              recoveringTranslogFile=tmpRecoveringFile;
              logger.trace("Renamed translog from {} to {}",tmpTranslogFile.getFileName(),recoveringTranslogFile.getFileName());
              break;
            }
 catch (            Exception ex) {
              logger.debug("Failed to rename tmp recovery file",ex);
            }
          }
        }
 else {
          logger.trace("Translog file NOT found in {} - continue",translogLocation);
        }
      }
 else {
        recoveringTranslogFile=tmpRecoveringFile;
        break;
      }
    }
    if (recoveringTranslogFile == null || Files.exists(recoveringTranslogFile) == false) {
      indexShard.postRecovery("post recovery from gateway, no translog");
      recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
      recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
      return;
    }
    indexShard.performRecoveryPrepareForTranslog();
    recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
    recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
    recoveryState.getTranslog().startTime(System.currentTimeMillis());
    recoveryState.setStage(RecoveryState.Stage.TRANSLOG);
    StreamInput in=null;
    final Set<String> typesToUpdate=Sets.newHashSet();
    try {
      TranslogStream stream=TranslogStreams.translogStreamFor(recoveringTranslogFile);
      try {
        in=stream.openInput(recoveringTranslogFile);
      }
 catch (      TruncatedTranslogException e) {
        logger.trace("ignoring truncation exception, the translog is either empty or half-written ([{}])",e.getMessage());
      }
      while (true) {
        if (in == null) {
          break;
        }
        Translog.Operation operation;
        try {
          if (stream instanceof LegacyTranslogStream) {
            in.readInt();
          }
          operation=stream.read(in);
        }
 catch (        EOFException e) {
          logger.trace("ignoring translog EOF exception, the last operation was not properly written ([{}])",e.getMessage());
          break;
        }
catch (        IOException e) {
          logger.trace("ignoring translog IO exception, the last operation was not properly written ([{}])",e.getMessage());
          break;
        }
        try {
          Engine.IndexingOperation potentialIndexOperation=indexShard.performRecoveryOperation(operation);
          if (potentialIndexOperation != null && potentialIndexOperation.parsedDoc().mappingsModified()) {
            if (!typesToUpdate.contains(potentialIndexOperation.docMapper().type())) {
              typesToUpdate.add(potentialIndexOperation.docMapper().type());
            }
          }
          recoveryState.getTranslog().addTranslogOperations(1);
        }
 catch (        ElasticsearchException e) {
          if (e.status() == RestStatus.BAD_REQUEST) {
            logger.info("ignoring recovery of a corrupt translog entry",e);
          }
 else {
            throw e;
          }
        }
      }
    }
 catch (    Throwable e) {
      IOUtils.closeWhileHandlingException(indexShard.translog());
      throw new IndexShardGatewayRecoveryException(shardId,"failed to recover shard",e);
    }
 finally {
      IOUtils.closeWhileHandlingException(in);
    }
    indexShard.performRecoveryFinalization(true);
    try {
      Files.deleteIfExists(recoveringTranslogFile);
    }
 catch (    Exception ex) {
      logger.debug("Failed to delete recovering translog file {}",ex,recoveringTranslogFile);
    }
    for (    final String type : typesToUpdate) {
      final CountDownLatch latch=new CountDownLatch(1);
      mappingUpdatedAction.updateMappingOnMaster(indexService.index().name(),indexService.mapperService().documentMapper(type),indexService.indexUUID(),new MappingUpdatedAction.MappingUpdateListener(){
        @Override public void onMappingUpdate(){
          latch.countDown();
        }
        @Override public void onFailure(        Throwable t){
          latch.countDown();
          logger.debug("failed to send mapping update post recovery to master for [{}]",t,type);
        }
      }
);
      try {
        boolean waited=latch.await(waitForMappingUpdatePostRecovery.millis(),TimeUnit.MILLISECONDS);
        if (!waited) {
          logger.debug("waited for mapping update on master for [{}], yet timed out");
        }
      }
 catch (      InterruptedException e) {
        logger.debug("interrupted while waiting for mapping update");
      }
    }
  }
  finally {
    indexShard.store().decRef();
  }
  recoveryState.getTranslog().time(System.currentTimeMillis() - recoveryState.getTranslog().startTime());
}
