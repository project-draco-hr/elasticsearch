{
  recoveryState.getIndex().startTime(System.currentTimeMillis());
  recoveryState.setStage(RecoveryState.Stage.INDEX);
  long version=-1;
  long translogId=-1;
  try {
    SegmentInfos si=null;
    try {
      si=Lucene.readSegmentInfos(indexShard.store().directory());
    }
 catch (    Throwable e) {
      String files="_unknown_";
      try {
        files=Arrays.toString(indexShard.store().directory().listAll());
      }
 catch (      Throwable e1) {
        files+=" (failure=" + ExceptionsHelper.detailedMessage(e1) + ")";
      }
      if (indexShouldExists && indexShard.store().indexStore().persistent()) {
        throw new IndexShardGatewayRecoveryException(shardId(),"shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files,e);
      }
    }
    if (si != null) {
      if (indexShouldExists) {
        version=si.getVersion();
        if (si.getUserData().containsKey(Translog.TRANSLOG_ID_KEY)) {
          translogId=Long.parseLong(si.getUserData().get(Translog.TRANSLOG_ID_KEY));
        }
 else {
          translogId=version;
        }
        logger.trace("using existing shard data, translog id [{}]",translogId);
      }
 else {
        logger.trace("cleaning existing shard, shouldn't exists");
        IndexWriter writer=new IndexWriter(indexShard.store().directory(),new IndexWriterConfig(Lucene.VERSION,Lucene.STANDARD_ANALYZER).setOpenMode(IndexWriterConfig.OpenMode.CREATE));
        writer.close();
      }
    }
  }
 catch (  Throwable e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"failed to fetch index version after copying it over",e);
  }
  recoveryState.getIndex().updateVersion(version);
  recoveryState.getIndex().time(System.currentTimeMillis() - recoveryState.getIndex().startTime());
  try {
    int numberOfFiles=0;
    long totalSizeInBytes=0;
    for (    String name : indexShard.store().directory().listAll()) {
      numberOfFiles++;
      long length=indexShard.store().directory().fileLength(name);
      totalSizeInBytes+=length;
      recoveryState.getIndex().addFileDetail(name,length,length);
    }
    recoveryState.getIndex().files(numberOfFiles,totalSizeInBytes,numberOfFiles,totalSizeInBytes);
    recoveryState.getIndex().recoveredFileCount(numberOfFiles);
    recoveryState.getIndex().recoveredByteCount(totalSizeInBytes);
  }
 catch (  Exception e) {
  }
  recoveryState.getStart().startTime(System.currentTimeMillis());
  recoveryState.setStage(RecoveryState.Stage.START);
  if (translogId == -1) {
    indexShard.postRecovery("post recovery from gateway, no translog");
    recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
    recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
    return;
  }
  FsTranslog translog=(FsTranslog)indexShard.translog();
  String translogName="translog-" + translogId;
  String recoverTranslogName=translogName + ".recovering";
  File recoveringTranslogFile=null;
  for (  File translogLocation : translog.locations()) {
    File tmpRecoveringFile=new File(translogLocation,recoverTranslogName);
    if (!tmpRecoveringFile.exists()) {
      File tmpTranslogFile=new File(translogLocation,translogName);
      if (tmpTranslogFile.exists()) {
        for (int i=0; i < 3; i++) {
          if (tmpTranslogFile.renameTo(tmpRecoveringFile)) {
            recoveringTranslogFile=tmpRecoveringFile;
            break;
          }
        }
      }
    }
 else {
      recoveringTranslogFile=tmpRecoveringFile;
      break;
    }
  }
  if (recoveringTranslogFile == null || !recoveringTranslogFile.exists()) {
    indexShard.postRecovery("post recovery from gateway, no translog");
    recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
    recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
    return;
  }
  indexShard.performRecoveryPrepareForTranslog();
  recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
  recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
  recoveryState.getTranslog().startTime(System.currentTimeMillis());
  recoveryState.setStage(RecoveryState.Stage.TRANSLOG);
  FileInputStream fs=null;
  try {
    fs=new FileInputStream(recoveringTranslogFile);
    InputStreamStreamInput si=new InputStreamStreamInput(fs);
    while (true) {
      Translog.Operation operation;
      try {
        int opSize=si.readInt();
        operation=TranslogStreams.readTranslogOperation(si);
      }
 catch (      EOFException e) {
        break;
      }
catch (      IOException e) {
        break;
      }
      try {
        indexShard.performRecoveryOperation(operation);
        recoveryState.getTranslog().addTranslogOperations(1);
      }
 catch (      ElasticsearchException e) {
        if (e.status() == RestStatus.BAD_REQUEST) {
          logger.info("ignoring recovery of a corrupt translog entry",e);
        }
 else {
          throw e;
        }
      }
    }
  }
 catch (  Throwable e) {
    indexShard.translog().closeWithDelete();
    throw new IndexShardGatewayRecoveryException(shardId,"failed to recover shard",e);
  }
 finally {
    try {
      fs.close();
    }
 catch (    IOException e) {
    }
  }
  indexShard.performRecoveryFinalization(true);
  recoveringTranslogFile.delete();
  recoveryState.getTranslog().time(System.currentTimeMillis() - recoveryState.getTranslog().startTime());
}
