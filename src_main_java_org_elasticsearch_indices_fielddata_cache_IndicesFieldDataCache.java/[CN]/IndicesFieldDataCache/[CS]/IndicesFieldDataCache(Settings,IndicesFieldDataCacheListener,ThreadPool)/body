{
  super(settings);
  this.threadPool=threadPool;
  this.indicesFieldDataCacheListener=indicesFieldDataCacheListener;
  final String size=settings.get(INDICES_FIELDDATA_CACHE_SIZE_KEY,"-1");
  final long sizeInBytes=settings.getAsMemory(INDICES_FIELDDATA_CACHE_SIZE_KEY,"-1").bytes();
  final TimeValue expire=settings.getAsTime(INDICES_FIELDDATA_CACHE_EXPIRE_KEY,null);
  CacheBuilder<Key,Accountable> cacheBuilder=CacheBuilder.newBuilder().removalListener(this);
  if (sizeInBytes > 0) {
    cacheBuilder.maximumWeight(sizeInBytes).weigher(new FieldDataWeigher());
  }
  final int concurrencyLevel=settings.getAsInt(FIELDDATA_CACHE_CONCURRENCY_LEVEL,16);
  if (concurrencyLevel <= 0) {
    throw new IllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);
  }
  cacheBuilder.concurrencyLevel(concurrencyLevel);
  if (expire != null && expire.millis() > 0) {
    cacheBuilder.expireAfterAccess(expire.millis(),TimeUnit.MILLISECONDS);
  }
  logger.debug("using size [{}] [{}], expire [{}]",size,new ByteSizeValue(sizeInBytes),expire);
  cache=cacheBuilder.build();
  this.cleanInterval=settings.getAsTime(FIELDDATA_CLEAN_INTERVAL_SETTING,TimeValue.timeValueMinutes(1));
  threadPool.schedule(this.cleanInterval,ThreadPool.Names.SAME,new FieldDataCacheCleaner(this.cache,this.logger,this.threadPool,this.cleanInterval));
}
