{
  IndexService indexService=createIndex("test",Settings.EMPTY,"type","my_field1","type=string,store=yes","my_field2","type=integer,precision_step=10");
  DocumentMapper newMapper=indexService.mapperService().documentMapperWithAutoCreate("type2").v1();
  Mapper update=parse(newMapper,indexService.mapperService().documentMapperParser(),XContentFactory.jsonBuilder().startObject().field("my_field1",42).endObject());
  Mapper myField1Mapper=null;
  for (  Mapper m : update) {
    if (m.name().equals("my_field1")) {
      myField1Mapper=m;
    }
  }
  assertNotNull(myField1Mapper);
  assertTrue(myField1Mapper instanceof StringFieldMapper);
  assertTrue(((StringFieldMapper)myField1Mapper).fieldType().stored());
  update=parse(newMapper,indexService.mapperService().documentMapperParser(),XContentFactory.jsonBuilder().startObject().field("my_field2",42).endObject());
  Mapper myField2Mapper=null;
  for (  Mapper m : update) {
    if (m.name().equals("my_field2")) {
      myField2Mapper=m;
    }
  }
  assertNotNull(myField2Mapper);
  assertTrue(myField2Mapper instanceof IntegerFieldMapper);
  assertEquals(10,((IntegerFieldMapper)myField2Mapper).fieldType().numericPrecisionStep());
  try {
    parse(newMapper,indexService.mapperService().documentMapperParser(),XContentFactory.jsonBuilder().startObject().field("my_field2","foobar").endObject());
    fail("Cannot succeed, incompatible types");
  }
 catch (  MapperParsingException e) {
  }
}
