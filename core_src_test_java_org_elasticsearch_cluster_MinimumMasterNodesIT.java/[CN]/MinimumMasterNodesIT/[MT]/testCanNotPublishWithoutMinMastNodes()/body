{
  Settings settings=settingsBuilder().put("discovery.type","zen").put(FaultDetection.SETTING_PING_TIMEOUT,"1h").put(ZenDiscovery.SETTING_PING_TIMEOUT,"200ms").put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES,2).put(DiscoverySettings.COMMIT_TIMEOUT,"100ms").build();
  internalCluster().startNodesAsync(3,settings).get();
  ensureGreen();
  final String master=internalCluster().getMasterName();
  Set<String> otherNodes=new HashSet<>(Arrays.asList(internalCluster().getNodeNames()));
  otherNodes.remove(master);
  NetworkDelaysPartition partition=new NetworkDelaysPartition(Collections.singleton(master),otherNodes,60000,random());
  internalCluster().setDisruptionScheme(partition);
  partition.startDisrupting();
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicReference<Throwable> failure=new AtomicReference<>();
  logger.debug("--> submitting for cluster state to be rejected");
  final ClusterService masterClusterService=internalCluster().clusterService(master);
  masterClusterService.submitStateUpdateTask("test",new ClusterStateUpdateTask(){
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      latch.countDown();
    }
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      MetaData.Builder metaData=MetaData.builder(currentState.metaData()).persistentSettings(Settings.builder().put(currentState.metaData().persistentSettings()).put("_SHOULD_NOT_BE_THERE_",true).build());
      return ClusterState.builder(currentState).metaData(metaData).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      failure.set(t);
      latch.countDown();
    }
  }
);
  logger.debug("--> waiting for cluster state to be processed/rejected");
  latch.await();
  assertThat(failure.get(),instanceOf(Discovery.FailedToCommitClusterStateException.class));
  assertBusy(new Runnable(){
    @Override public void run(){
      assertThat(masterClusterService.state().nodes().masterNode(),nullValue());
    }
  }
);
  partition.stopDisrupting();
  logger.debug("--> waiting for cluster to heal");
  assertNoTimeout(client().admin().cluster().prepareHealth().setWaitForNodes("3").setWaitForEvents(Priority.LANGUID));
  for (  String node : internalCluster().getNodeNames()) {
    Settings nodeSetting=internalCluster().clusterService(node).state().metaData().settings();
    assertThat(node + " processed the cluster state despite of a min master node violation",nodeSetting.get("_SHOULD_NOT_BE_THERE_"),nullValue());
  }
}
