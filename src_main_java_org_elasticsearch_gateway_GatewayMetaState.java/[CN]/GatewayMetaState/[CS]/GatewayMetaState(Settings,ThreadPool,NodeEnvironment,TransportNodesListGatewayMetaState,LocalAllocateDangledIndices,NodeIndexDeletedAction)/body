{
  super(settings);
  this.nodeEnv=nodeEnv;
  this.threadPool=threadPool;
  this.format=XContentType.fromRestContentType(settings.get("format","smile"));
  this.allocateDangledIndices=allocateDangledIndices;
  this.nodeIndexDeletedAction=nodeIndexDeletedAction;
  nodesListGatewayMetaState.init(this);
  if (this.format == XContentType.SMILE) {
    Map<String,String> params=Maps.newHashMap();
    params.put("binary","true");
    formatParams=new ToXContent.MapParams(params);
    Map<String,String> gatewayModeParams=Maps.newHashMap();
    gatewayModeParams.put("binary","true");
    gatewayModeParams.put(MetaData.CONTEXT_MODE_PARAM,MetaData.CONTEXT_MODE_GATEWAY);
    gatewayModeFormatParams=new ToXContent.MapParams(gatewayModeParams);
  }
 else {
    formatParams=ToXContent.EMPTY_PARAMS;
    Map<String,String> gatewayModeParams=Maps.newHashMap();
    gatewayModeParams.put(MetaData.CONTEXT_MODE_PARAM,MetaData.CONTEXT_MODE_GATEWAY);
    gatewayModeFormatParams=new ToXContent.MapParams(gatewayModeParams);
  }
  this.autoImportDangled=AutoImportDangledState.fromString(settings.get(GATEWAY_AUTO_IMPORT_DANGLED,settings.get(GATEWAY_LOCAL_AUTO_IMPORT_DANGLED,AutoImportDangledState.YES.toString())));
  this.danglingTimeout=settings.getAsTime(GATEWAY_DANGLING_TIMEOUT,settings.getAsTime(GATEWAY_LOCAL_DANGLING_TIMEOUT,TimeValue.timeValueHours(2)));
  logger.debug("using gateway.local.auto_import_dangled [{}], with gateway.dangling_timeout [{}]",this.autoImportDangled,this.danglingTimeout);
  if (DiscoveryNode.masterNode(settings) || DiscoveryNode.dataNode(settings)) {
    nodeEnv.ensureAtomicMoveSupported();
  }
  if (DiscoveryNode.masterNode(settings)) {
    try {
      ensureNoPre019State();
      pre20Upgrade();
      long start=System.currentTimeMillis();
      loadState();
      logger.debug("took {} to load state",TimeValue.timeValueMillis(System.currentTimeMillis() - start));
    }
 catch (    Exception e) {
      logger.error("failed to read local state, exiting...",e);
      throw e;
    }
  }
}
