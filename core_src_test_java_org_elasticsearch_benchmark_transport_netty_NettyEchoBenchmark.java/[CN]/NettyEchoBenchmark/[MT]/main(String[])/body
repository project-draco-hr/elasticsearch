{
  final int payloadSize=100;
  int CYCLE_SIZE=50000;
  final long NUMBER_OF_ITERATIONS=500000;
  ChannelBuffer message=ChannelBuffers.buffer(100);
  for (int i=0; i < message.capacity(); i++) {
    message.writeByte((byte)i);
  }
  ServerBootstrap serverBootstrap=new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool()));
  serverBootstrap.setPipelineFactory(new ChannelPipelineFactory(){
    @Override public ChannelPipeline getPipeline() throws Exception {
      return Channels.pipeline(new EchoServerHandler());
    }
  }
);
  serverBootstrap.bind(new InetSocketAddress(9000));
  ClientBootstrap clientBootstrap=new ClientBootstrap(new NioClientSocketChannelFactory(Executors.newCachedThreadPool(),Executors.newCachedThreadPool()));
  final EchoClientHandler clientHandler=new EchoClientHandler();
  clientBootstrap.setPipelineFactory(new ChannelPipelineFactory(){
    @Override public ChannelPipeline getPipeline() throws Exception {
      return Channels.pipeline(clientHandler);
    }
  }
);
  ChannelFuture future=clientBootstrap.connect(new InetSocketAddress("localhost",9000));
  future.awaitUninterruptibly();
  Channel clientChannel=future.getChannel();
  System.out.println("Warming up...");
  for (long i=0; i < 10000; i++) {
    clientHandler.latch=new CountDownLatch(1);
    clientChannel.write(message);
    try {
      clientHandler.latch.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
  System.out.println("Warmed up");
  long start=System.currentTimeMillis();
  long cycleStart=System.currentTimeMillis();
  for (long i=1; i < NUMBER_OF_ITERATIONS; i++) {
    clientHandler.latch=new CountDownLatch(1);
    clientChannel.write(message);
    try {
      clientHandler.latch.await();
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    if ((i % CYCLE_SIZE) == 0) {
      long cycleEnd=System.currentTimeMillis();
      System.out.println("Ran 50000, TPS " + (CYCLE_SIZE / ((double)(cycleEnd - cycleStart) / 1000)));
      cycleStart=cycleEnd;
    }
  }
  long end=System.currentTimeMillis();
  long seconds=(end - start) / 1000;
  System.out.println("Ran [" + NUMBER_OF_ITERATIONS + "] iterations, payload ["+ payloadSize+ "]: took ["+ seconds+ "], TPS: "+ ((double)NUMBER_OF_ITERATIONS) / seconds);
  clientChannel.close().awaitUninterruptibly();
  clientBootstrap.releaseExternalResources();
  serverBootstrap.releaseExternalResources();
}
