{
  Settings settings=Settings.settingsBuilder().put("name",BasePipelineAggregationTestCase.class.toString()).put("path.home",createTempDir()).build();
  namedWriteableRegistry=new NamedWriteableRegistry();
  index=new Index(randomAsciiOfLengthBetween(1,10),"_na_");
  SettingsModule settingsModule=new SettingsModule(settings,new SettingsFilter(settings));
  injector=new ModulesBuilder().add(new EnvironmentModule(new Environment(settings)),settingsModule,new ThreadPoolModule(new ThreadPool(settings)),new ScriptModule(settingsModule),new IndicesModule(){
    @Override protected void configure(){
      bindMapperExtension();
    }
  }
,new SearchModule(settings,namedWriteableRegistry){
    @Override protected void configureSearch(){
    }
    @Override protected void configureSuggesters(){
    }
  }
,new IndexSettingsModule(index,settings),new AbstractModule(){
    @Override protected void configure(){
      bind(ClusterService.class).toProvider(Providers.of((ClusterService)null));
      bind(CircuitBreakerService.class).to(NoneCircuitBreakerService.class);
      bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry);
    }
  }
).createInjector();
  aggParsers=injector.getInstance(AggregatorParsers.class);
  currentTypes=new String[randomIntBetween(0,5)];
  for (int i=0; i < currentTypes.length; i++) {
    String type=randomAsciiOfLengthBetween(1,10);
    currentTypes[i]=type;
  }
  queriesRegistry=injector.getInstance(IndicesQueriesRegistry.class);
  parseFieldMatcher=ParseFieldMatcher.STRICT;
}
