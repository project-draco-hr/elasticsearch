{
  JvmStats stats=new JvmStats(System.currentTimeMillis(),runtimeMXBean.getUptime());
  stats.mem=new Mem();
  MemoryUsage memUsage=memoryMXBean.getHeapMemoryUsage();
  stats.mem.heapUsed=memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();
  stats.mem.heapCommitted=memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();
  memUsage=memoryMXBean.getNonHeapMemoryUsage();
  stats.mem.nonHeapUsed=memUsage.getUsed() < 0 ? 0 : memUsage.getUsed();
  stats.mem.nonHeapCommitted=memUsage.getCommitted() < 0 ? 0 : memUsage.getCommitted();
  List<MemoryPoolMXBean> memoryPoolMXBeans=ManagementFactory.getMemoryPoolMXBeans();
  stats.mem.pools=new MemoryPool[memoryPoolMXBeans.size()];
  for (int i=0; i < memoryPoolMXBeans.size(); i++) {
    MemoryPoolMXBean memoryPoolMXBean=memoryPoolMXBeans.get(i);
    MemoryUsage usage=memoryPoolMXBean.getUsage();
    MemoryUsage peakUsage=memoryPoolMXBean.getPeakUsage();
    stats.mem.pools[i]=new MemoryPool(memoryPoolMXBean.getName(),usage.getUsed() < 0 ? 0 : usage.getUsed(),usage.getMax() < 0 ? 0 : usage.getMax(),peakUsage.getUsed() < 0 ? 0 : peakUsage.getUsed(),peakUsage.getMax() < 0 ? 0 : peakUsage.getMax());
  }
  stats.threads=new Threads();
  stats.threads.count=threadMXBean.getThreadCount();
  stats.threads.peakCount=threadMXBean.getPeakThreadCount();
  List<GarbageCollectorMXBean> gcMxBeans=ManagementFactory.getGarbageCollectorMXBeans();
  stats.gc=new GarbageCollectors();
  stats.gc.collectors=new GarbageCollector[gcMxBeans.size()];
  for (int i=0; i < stats.gc.collectors.length; i++) {
    GarbageCollectorMXBean gcMxBean=gcMxBeans.get(i);
    stats.gc.collectors[i]=new GarbageCollector();
    stats.gc.collectors[i].name=gcMxBean.getName();
    stats.gc.collectors[i].collectionCount=gcMxBean.getCollectionCount();
    stats.gc.collectors[i].collectionTime=gcMxBean.getCollectionTime();
    if (enableLastGc) {
      try {
        Object lastGcInfo=getLastGcInfoMethod.invoke(gcMxBean);
        if (lastGcInfo != null) {
          Map<String,MemoryUsage> usageBeforeGc=(Map<String,MemoryUsage>)getMemoryUsageBeforeGcMethod.invoke(lastGcInfo);
          Map<String,MemoryUsage> usageAfterGc=(Map<String,MemoryUsage>)getMemoryUsageAfterGcMethod.invoke(lastGcInfo);
          long startTime=(Long)getStartTimeMethod.invoke(lastGcInfo);
          long endTime=(Long)getEndTimeMethod.invoke(lastGcInfo);
          long duration=(Long)getDurationMethod.invoke(lastGcInfo);
          long previousMemoryUsed=0;
          long memoryUsed=0;
          long memoryMax=0;
          for (          Map.Entry<String,MemoryUsage> entry : usageBeforeGc.entrySet()) {
            previousMemoryUsed+=entry.getValue().getUsed();
          }
          for (          Map.Entry<String,MemoryUsage> entry : usageAfterGc.entrySet()) {
            MemoryUsage mu=entry.getValue();
            memoryUsed+=mu.getUsed();
            memoryMax+=mu.getMax();
          }
          stats.gc.collectors[i].lastGc=new GarbageCollector.LastGc(startTime,endTime,memoryMax,previousMemoryUsed,memoryUsed,duration);
        }
      }
 catch (      Exception e) {
      }
    }
  }
  if (bufferPoolsEnabled) {
    try {
      List bufferPools=(List)managementFactoryPlatformMXBeansMethod.invoke(null,bufferPoolMXBeanClass);
      stats.bufferPools=new ArrayList<BufferPool>(bufferPools.size());
      for (      Object bufferPool : bufferPools) {
        String name=(String)bufferPoolMXBeanNameMethod.invoke(bufferPool);
        Long count=(Long)bufferPoolMXBeanCountMethod.invoke(bufferPool);
        Long totalCapacity=(Long)bufferPoolMXBeanTotalCapacityMethod.invoke(bufferPool);
        Long memoryUsed=(Long)bufferPoolMXBeanMemoryUsedMethod.invoke(bufferPool);
        stats.bufferPools.add(new BufferPool(name,count,totalCapacity,memoryUsed));
      }
    }
 catch (    Throwable t) {
    }
  }
  return stats;
}
