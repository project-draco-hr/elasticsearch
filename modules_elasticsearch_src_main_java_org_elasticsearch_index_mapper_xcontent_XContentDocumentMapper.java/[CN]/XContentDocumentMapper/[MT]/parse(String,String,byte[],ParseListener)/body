{
  ParseContext context=cache.get().get();
  if (type != null && !type.equals(this.type)) {
    throw new MapperParsingException("Type mismatch, provide type [" + type + "] but mapper is of type ["+ this.type+ "]");
  }
  type=this.type;
  XContentParser parser=null;
  try {
    parser=XContentFactory.xContent(source).createParser(source);
    context.reset(parser,new Document(),type,source,listener);
    XContentParser.Token token=parser.nextToken();
    if (token != XContentParser.Token.START_OBJECT) {
      throw new MapperException("Malformed content, must start with an object");
    }
    token=parser.nextToken();
    if (token != XContentParser.Token.FIELD_NAME) {
      throw new MapperException("Malformed content, after first object, either the type field or the actual properties should exist");
    }
    if (parser.currentName().equals(type)) {
      token=parser.nextToken();
    }
    if (sourceFieldMapper.enabled()) {
      sourceFieldMapper.parse(context);
    }
    if (id != null) {
      context.id(id);
      uidFieldMapper.parse(context);
    }
    typeFieldMapper.parse(context);
    indexFieldMapper.parse(context);
    rootObjectMapper.parse(context);
    if (id == null) {
      uidFieldMapper.parse(context);
    }
    if (context.parsedIdState() != ParseContext.ParsedIdState.PARSED) {
      context.parsedId(ParseContext.ParsedIdState.EXTERNAL);
      idFieldMapper.parse(context);
    }
    analyzerMapper.parse(context);
    allFieldMapper.parse(context);
  }
 catch (  IOException e) {
    throw new MapperParsingException("Failed to parse",e);
  }
 finally {
    if (parser != null) {
      parser.close();
    }
  }
  return new ParsedDocument(context.uid(),context.id(),context.type(),context.doc(),context.analyzer(),source,context.mappersAdded());
}
