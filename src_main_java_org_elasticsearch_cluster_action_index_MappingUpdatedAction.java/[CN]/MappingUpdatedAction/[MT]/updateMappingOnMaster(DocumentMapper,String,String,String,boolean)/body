{
  final CountDownLatch latch=new CountDownLatch(1);
  final MappingUpdatedAction.MappingUpdatedRequest mappingRequest;
  try {
    long orderId=mappingUpdateOrderGen.incrementAndGet();
    documentMapper.refreshSource();
    DiscoveryNode node=clusterService.localNode();
    mappingRequest=new MappingUpdatedAction.MappingUpdatedRequest(index,indexUUID,type,documentMapper.mappingSource(),orderId,node != null ? node.id() : null);
  }
 catch (  Throwable t) {
    logger.warn("Failed to update master on updated mapping for index [" + index + "], type ["+ type+ "]",t);
    latch.countDown();
    throw t;
  }
  logger.trace("Sending mapping updated to master: {}",mappingRequest);
  execute(mappingRequest,new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>(){
    @Override public void onResponse(    MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse){
      latch.countDown();
      logger.debug("Successfully updated master with mapping update: {}",mappingRequest);
    }
    @Override public void onFailure(    Throwable e){
      latch.countDown();
      logger.warn("Failed to update master on updated mapping for {}",e,mappingRequest);
    }
  }
);
  if (waitForMappingChange && !neverWaitForMappingChange) {
    try {
      latch.await(5,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}
