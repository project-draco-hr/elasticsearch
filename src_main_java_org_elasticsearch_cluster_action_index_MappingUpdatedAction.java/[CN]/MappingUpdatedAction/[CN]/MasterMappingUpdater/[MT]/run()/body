{
  Map<UpdateKey,UpdateValue> pendingUpdates=Maps.newHashMap();
  while (running) {
    try {
      MappingChange polledChange=queue.poll(10,TimeUnit.MINUTES);
      if (polledChange == null) {
        continue;
      }
      List<MappingChange> changes=Lists.newArrayList(polledChange);
      if (additionalMappingChangeTime.millis() > 0) {
        Thread.sleep(additionalMappingChangeTime.millis());
      }
      queue.drainTo(changes);
      Collections.reverse(changes);
      for (      MappingChange change : changes) {
        UpdateKey key=new UpdateKey(change.indexUUID,change.documentMapper.type());
        UpdateValue updateValue=pendingUpdates.get(key);
        if (updateValue == null) {
          updateValue=new UpdateValue(change);
          pendingUpdates.put(key,updateValue);
        }
        if (change.listener != null) {
          updateValue.listeners.add(change.listener);
        }
      }
      for (Iterator<UpdateValue> iterator=pendingUpdates.values().iterator(); iterator.hasNext(); ) {
        final UpdateValue updateValue=iterator.next();
        iterator.remove();
        MappingChange change=updateValue.mainChange;
        final MappingUpdatedAction.MappingUpdatedRequest mappingRequest;
        try {
          long orderId=mappingUpdateOrderGen.incrementAndGet();
          change.documentMapper.refreshSource();
          DiscoveryNode node=clusterService.localNode();
          mappingRequest=new MappingUpdatedAction.MappingUpdatedRequest(change.index,change.indexUUID,change.documentMapper.type(),change.documentMapper.mappingSource(),orderId,node != null ? node.id() : null);
        }
 catch (        Throwable t) {
          logger.warn("Failed to update master on updated mapping for index [" + change.index + "], type ["+ change.documentMapper.type()+ "]",t);
          updateValue.notifyListeners(t);
          continue;
        }
        logger.trace("sending mapping updated to master: {}",mappingRequest);
        execute(mappingRequest,new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>(){
          @Override public void onResponse(          MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse){
            logger.debug("successfully updated master with mapping update: {}",mappingRequest);
            updateValue.notifyListeners(null);
          }
          @Override public void onFailure(          Throwable e){
            logger.warn("failed to update master on updated mapping for {}",e,mappingRequest);
            updateValue.notifyListeners(e);
          }
        }
);
      }
    }
 catch (    Throwable t) {
      if (t instanceof InterruptedException && !running) {
      }
 else {
        logger.warn("failed to process mapping updates",t);
      }
      for (Iterator<Map.Entry<UpdateKey,UpdateValue>> iterator=pendingUpdates.entrySet().iterator(); iterator.hasNext(); ) {
        Map.Entry<UpdateKey,UpdateValue> entry=iterator.next();
        iterator.remove();
        entry.getValue().notifyListeners(t);
      }
    }
  }
}
