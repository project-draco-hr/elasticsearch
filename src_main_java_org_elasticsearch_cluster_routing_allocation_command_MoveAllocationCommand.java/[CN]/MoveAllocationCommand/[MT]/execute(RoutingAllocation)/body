{
  DiscoveryNode from=allocation.nodes().resolveNode(fromNode);
  DiscoveryNode to=allocation.nodes().resolveNode(toNode);
  boolean found=false;
  for (  MutableShardRouting shardRouting : allocation.routingNodes().node(from.id())) {
    if (!shardRouting.shardId().equals(shardId)) {
      continue;
    }
    found=true;
    if (!shardRouting.started()) {
      throw new ElasticSearchIllegalArgumentException("[move_allocation] can't move " + shardId + ", shard is not started (state = "+ shardRouting.state()+ "]");
    }
    RoutingNode toRoutingNode=allocation.routingNodes().node(to.id());
    AllocationDecider.Decision decision=allocation.deciders().canAllocate(shardRouting,toRoutingNode,allocation);
    if (!decision.allowed()) {
      throw new ElasticSearchIllegalArgumentException("[move_allocation] can't move " + shardId + ", from "+ from+ ", to "+ to+ ", since its not allowed");
    }
    if (!decision.allocate()) {
    }
    toRoutingNode.add(new MutableShardRouting(shardRouting.index(),shardRouting.id(),toRoutingNode.nodeId(),shardRouting.currentNodeId(),shardRouting.primary(),ShardRoutingState.INITIALIZING,shardRouting.version() + 1));
    shardRouting.relocate(toRoutingNode.nodeId());
  }
  if (!found) {
    throw new ElasticSearchIllegalArgumentException("[move_allocation] can't move " + shardId + ", failed to find it on node "+ from);
  }
}
