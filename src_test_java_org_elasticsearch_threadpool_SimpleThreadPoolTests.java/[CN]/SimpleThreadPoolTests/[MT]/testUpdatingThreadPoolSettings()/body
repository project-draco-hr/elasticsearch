{
  internalCluster().startNodesAsync(2).get();
  ThreadPool threadPool=internalCluster().getDataNodeInstance(ThreadPool.class);
  assertThat(((ThreadPoolExecutor)threadPool.executor(Names.SEARCH)).getKeepAliveTime(TimeUnit.MINUTES),equalTo(5L));
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.keep_alive","10m").build()).execute().actionGet();
  assertThat(((ThreadPoolExecutor)threadPool.executor(Names.SEARCH)).getKeepAliveTime(TimeUnit.MINUTES),equalTo(10L));
  final CyclicBarrier barrier=new CyclicBarrier(2);
  Executor oldExecutor=threadPool.executor(Names.SEARCH);
  threadPool.executor(Names.SEARCH).execute(new Runnable(){
    @Override public void run(){
      try {
        barrier.await();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
catch (      BrokenBarrierException ex) {
      }
    }
  }
);
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.type","fixed").build()).execute().actionGet();
  assertThat(threadPool.executor(Names.SEARCH),not(sameInstance(oldExecutor)));
  assertThat(((ThreadPoolExecutor)oldExecutor).isShutdown(),equalTo(true));
  assertThat(((ThreadPoolExecutor)oldExecutor).isTerminating(),equalTo(true));
  assertThat(((ThreadPoolExecutor)oldExecutor).isTerminated(),equalTo(false));
  barrier.await();
  threadPool.executor(Names.SEARCH).execute(new Runnable(){
    @Override public void run(){
      try {
        barrier.await();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
catch (      BrokenBarrierException ex) {
      }
    }
  }
);
  client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.type","fixed").build()).execute().actionGet();
  barrier.await();
  Thread.sleep(200);
  NodesInfoResponse nodesInfoResponse=client().admin().cluster().prepareNodesInfo().all().execute().actionGet();
  for (int i=0; i < 2; i++) {
    NodeInfo nodeInfo=nodesInfoResponse.getNodes()[i];
    boolean found=false;
    for (    ThreadPool.Info info : nodeInfo.getThreadPool()) {
      if (info.getName().equals(Names.SEARCH)) {
        assertThat(info.getType(),equalTo("fixed"));
        found=true;
        break;
      }
    }
    assertThat(found,equalTo(true));
    Map<String,Object> poolMap=getPoolSettingsThroughJson(nodeInfo.getThreadPool(),Names.SEARCH);
  }
}
