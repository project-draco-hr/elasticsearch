{
  List<String> indicesToClose=new ArrayList<>();
  ArrayList<Throwable> failures=new ArrayList<>(tasks.size());
  try {
    for (    PutMappingClusterStateUpdateRequest request : tasks) {
      for (      String index : request.indices()) {
        if (currentState.metaData().hasIndex(index)) {
          if (indicesService.hasIndex(index) == false) {
            final IndexMetaData indexMetaData=currentState.metaData().index(index);
            IndexService indexService=indicesService.createIndex(nodeServicesProvider,indexMetaData,Collections.EMPTY_LIST);
            indicesToClose.add(indexMetaData.getIndex());
            if (indexMetaData.getMappings().containsKey(MapperService.DEFAULT_MAPPING)) {
              indexService.mapperService().merge(MapperService.DEFAULT_MAPPING,indexMetaData.getMappings().get(MapperService.DEFAULT_MAPPING).source(),false,request.updateAllTypes());
            }
            if (indexMetaData.getMappings().containsKey(request.type())) {
              indexService.mapperService().merge(request.type(),indexMetaData.getMappings().get(request.type()).source(),false,request.updateAllTypes());
            }
          }
        }
      }
    }
    for (    PutMappingClusterStateUpdateRequest request : tasks) {
      try {
        currentState=applyRequest(currentState,request);
        failures.add(null);
      }
 catch (      Throwable t) {
        failures.add(t);
      }
    }
    return new Result(currentState,failures);
  }
  finally {
    for (    String index : indicesToClose) {
      indicesService.removeIndex(index,"created for mapping processing");
    }
  }
}
