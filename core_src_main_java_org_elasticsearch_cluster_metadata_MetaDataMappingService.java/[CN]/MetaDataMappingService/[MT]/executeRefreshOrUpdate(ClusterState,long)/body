{
  final List<MappingTask> allTasks=new ArrayList<>();
synchronized (refreshOrUpdateMutex) {
    if (refreshOrUpdateQueue.isEmpty()) {
      return Tuple.tuple(currentState,allTasks);
    }
    if (insertionOrder < refreshOrUpdateProcessedInsertOrder) {
      return Tuple.tuple(currentState,allTasks);
    }
    allTasks.addAll(refreshOrUpdateQueue);
    refreshOrUpdateQueue.clear();
    refreshOrUpdateProcessedInsertOrder=refreshOrUpdateInsertOrder;
  }
  if (allTasks.isEmpty()) {
    return Tuple.tuple(currentState,allTasks);
  }
  Map<String,List<MappingTask>> tasksPerIndex=new HashMap<>();
  for (  MappingTask task : allTasks) {
    if (task.index == null) {
      logger.debug("ignoring a mapping task of type [{}] with a null index.",task);
    }
    List<MappingTask> indexTasks=tasksPerIndex.get(task.index);
    if (indexTasks == null) {
      indexTasks=new ArrayList<>();
      tasksPerIndex.put(task.index,indexTasks);
    }
    indexTasks.add(task);
  }
  boolean dirty=false;
  MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
  for (  Map.Entry<String,List<MappingTask>> entry : tasksPerIndex.entrySet()) {
    String index=entry.getKey();
    IndexMetaData indexMetaData=mdBuilder.get(index);
    if (indexMetaData == null) {
      logger.debug("[{}] ignoring tasks - index meta data doesn't exist",index);
      continue;
    }
    List<MappingTask> allIndexTasks=entry.getValue();
    List<MappingTask> tasks=new ArrayList<>();
    for (    MappingTask task : allIndexTasks) {
      if (!indexMetaData.isSameUUID(task.indexUUID)) {
        logger.debug("[{}] ignoring task [{}] - index meta data doesn't match task uuid",index,task);
        continue;
      }
      tasks.add(task);
    }
    boolean removeIndex=false;
    IndexService indexService=indicesService.indexService(index);
    if (indexService == null) {
      indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
      removeIndex=true;
      Set<String> typesToIntroduce=new HashSet<>();
      for (      MappingTask task : tasks) {
        if (task instanceof UpdateTask) {
          typesToIntroduce.add(((UpdateTask)task).type);
        }
 else         if (task instanceof RefreshTask) {
          Collections.addAll(typesToIntroduce,((RefreshTask)task).types);
        }
      }
      for (      String type : typesToIntroduce) {
        if (indexMetaData.mappings().containsKey(type)) {
          indexService.mapperService().merge(type,indexMetaData.mappings().get(type).source(),false,true);
        }
      }
    }
    IndexMetaData.Builder builder=IndexMetaData.builder(indexMetaData);
    try {
      boolean indexDirty=processIndexMappingTasks(tasks,indexService,builder);
      if (indexDirty) {
        mdBuilder.put(builder);
        dirty=true;
      }
    }
  finally {
      if (removeIndex) {
        indicesService.removeIndex(index,"created for mapping processing");
      }
    }
  }
  if (!dirty) {
    return Tuple.tuple(currentState,allTasks);
  }
  return Tuple.tuple(ClusterState.builder(currentState).metaData(mdBuilder).build(),allTasks);
}
