{
  final long insertOrder;
synchronized (refreshOrUpdateMutex) {
    insertOrder=++refreshOrUpdateInsertOrder;
    refreshOrUpdateQueue.add(new RefreshTask(index,indexUUID,types));
  }
  clusterService.submitStateUpdateTask("refresh-mapping [" + index + "]["+ Arrays.toString(types)+ "]",Priority.HIGH,new ClusterStateUpdateTask(){
    private volatile List<MappingTask> allTasks;
    @Override public void onFailure(    String source,    Throwable t){
      logger.warn("failure during [{}]",t,source);
    }
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      Tuple<ClusterState,List<MappingTask>> tuple=executeRefreshOrUpdate(currentState,insertOrder);
      this.allTasks=tuple.v2();
      return tuple.v1();
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      if (allTasks == null) {
        return;
      }
      for (      Object task : allTasks) {
        if (task instanceof UpdateTask) {
          UpdateTask uTask=(UpdateTask)task;
          ClusterStateUpdateResponse response=new ClusterStateUpdateResponse(true);
          uTask.listener.onResponse(response);
        }
      }
    }
  }
);
}
