{
  if (query instanceof MatchNoDocsQuery) {
    return Collections.emptySet();
  }
 else   if (query instanceof TermQuery) {
    return Collections.singleton(((TermQuery)query).getTerm());
  }
 else   if (query instanceof TermsQuery) {
    Set<Term> terms=new HashSet<>();
    TermsQuery termsQuery=(TermsQuery)query;
    PrefixCodedTerms.TermIterator iterator=termsQuery.getTermData().iterator();
    for (BytesRef term=iterator.next(); term != null; term=iterator.next()) {
      terms.add(new Term(iterator.field(),term));
    }
    return terms;
  }
 else   if (query instanceof PhraseQuery) {
    Term[] terms=((PhraseQuery)query).getTerms();
    if (terms.length == 0) {
      return Collections.emptySet();
    }
    Term longestTerm=terms[0];
    for (    Term term : terms) {
      if (longestTerm.bytes().length < term.bytes().length) {
        longestTerm=term;
      }
    }
    return Collections.singleton(longestTerm);
  }
 else   if (query instanceof BooleanQuery) {
    List<BooleanClause> clauses=((BooleanQuery)query).clauses();
    boolean hasRequiredClauses=false;
    for (    BooleanClause clause : clauses) {
      if (clause.isRequired()) {
        hasRequiredClauses=true;
        break;
      }
    }
    if (hasRequiredClauses) {
      UnsupportedQueryException uqe=null;
      Set<Term> bestClause=null;
      for (      BooleanClause clause : clauses) {
        if (clause.isRequired() == false) {
          continue;
        }
        Set<Term> temp;
        try {
          temp=extractQueryTerms(clause.getQuery());
        }
 catch (        UnsupportedQueryException e) {
          uqe=e;
          continue;
        }
        bestClause=selectTermListWithTheLongestShortestTerm(temp,bestClause);
      }
      if (bestClause != null) {
        return bestClause;
      }
 else {
        if (uqe != null) {
          throw uqe;
        }
        return Collections.emptySet();
      }
    }
 else {
      Set<Term> terms=new HashSet<>();
      for (      BooleanClause clause : clauses) {
        if (clause.isProhibited()) {
          continue;
        }
        terms.addAll(extractQueryTerms(clause.getQuery()));
      }
      return terms;
    }
  }
 else   if (query instanceof ConstantScoreQuery) {
    Query wrappedQuery=((ConstantScoreQuery)query).getQuery();
    return extractQueryTerms(wrappedQuery);
  }
 else   if (query instanceof BoostQuery) {
    Query wrappedQuery=((BoostQuery)query).getQuery();
    return extractQueryTerms(wrappedQuery);
  }
 else   if (query instanceof CommonTermsQuery) {
    List<Term> terms=((CommonTermsQuery)query).getTerms();
    return new HashSet<>(terms);
  }
 else   if (query instanceof BlendedTermQuery) {
    List<Term> terms=((BlendedTermQuery)query).getTerms();
    return new HashSet<>(terms);
  }
 else   if (query instanceof DisjunctionMaxQuery) {
    List<Query> disjuncts=((DisjunctionMaxQuery)query).getDisjuncts();
    Set<Term> terms=new HashSet<>();
    for (    Query disjunct : disjuncts) {
      terms.addAll(extractQueryTerms(disjunct));
    }
    return terms;
  }
 else   if (query instanceof SpanTermQuery) {
    return Collections.singleton(((SpanTermQuery)query).getTerm());
  }
 else   if (query instanceof SpanNearQuery) {
    Set<Term> bestClause=null;
    SpanNearQuery spanNearQuery=(SpanNearQuery)query;
    for (    SpanQuery clause : spanNearQuery.getClauses()) {
      Set<Term> temp=extractQueryTerms(clause);
      bestClause=selectTermListWithTheLongestShortestTerm(temp,bestClause);
    }
    return bestClause;
  }
 else   if (query instanceof SpanOrQuery) {
    Set<Term> terms=new HashSet<>();
    SpanOrQuery spanOrQuery=(SpanOrQuery)query;
    for (    SpanQuery clause : spanOrQuery.getClauses()) {
      terms.addAll(extractQueryTerms(clause));
    }
    return terms;
  }
 else   if (query instanceof SpanFirstQuery) {
    return extractQueryTerms(((SpanFirstQuery)query).getMatch());
  }
 else   if (query instanceof SpanNotQuery) {
    return extractQueryTerms(((SpanNotQuery)query).getInclude());
  }
 else {
    throw new UnsupportedQueryException(query);
  }
}
