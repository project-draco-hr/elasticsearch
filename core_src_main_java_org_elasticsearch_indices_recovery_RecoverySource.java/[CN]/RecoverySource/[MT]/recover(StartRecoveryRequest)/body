{
  final IndexService indexService=indicesService.indexServiceSafe(request.shardId().getIndex().getName());
  final IndexShard shard=indexService.getShard(request.shardId().id());
  RoutingNode node=clusterService.state().getRoutingNodes().node(request.targetNode().id());
  if (node == null) {
    logger.debug("delaying recovery of {} as source node {} is unknown",request.shardId(),request.targetNode());
    throw new DelayRecoveryException("source node does not have the node [" + request.targetNode() + "] in its state yet..");
  }
  ShardRouting targetShardRouting=null;
  for (  ShardRouting shardRouting : node) {
    if (shardRouting.shardId().equals(request.shardId())) {
      targetShardRouting=shardRouting;
      break;
    }
  }
  if (targetShardRouting == null) {
    logger.debug("delaying recovery of {} as it is not listed as assigned to target node {}",request.shardId(),request.targetNode());
    throw new DelayRecoveryException("source node does not have the shard listed in its state as allocated on the node");
  }
  if (!targetShardRouting.initializing()) {
    logger.debug("delaying recovery of {} as it is not listed as initializing on the target node {}. known shards state is [{}]",request.shardId(),request.targetNode(),targetShardRouting.state());
    throw new DelayRecoveryException("source node has the state of the target shard to be [" + targetShardRouting.state() + "], expecting to be [initializing]");
  }
  logger.trace("[{}][{}] starting recovery to {}",request.shardId().getIndex().getName(),request.shardId().id(),request.targetNode());
  final RecoverySourceHandler handler;
  if (shard.indexSettings().isOnSharedFilesystem()) {
    handler=new SharedFSRecoverySourceHandler(shard,request,recoverySettings,transportService,logger);
  }
 else {
    handler=new RecoverySourceHandler(shard,request,recoverySettings,transportService,logger);
  }
  ongoingRecoveries.add(shard,handler);
  try {
    return handler.recoverToTarget();
  }
  finally {
    ongoingRecoveries.remove(shard,handler);
  }
}
