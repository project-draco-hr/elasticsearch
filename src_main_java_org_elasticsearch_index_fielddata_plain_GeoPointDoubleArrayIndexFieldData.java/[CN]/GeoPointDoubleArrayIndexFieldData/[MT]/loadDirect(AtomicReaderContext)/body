{
  AtomicReader reader=context.reader();
  Terms terms=reader.terms(getFieldNames().indexName());
  AtomicGeoPointFieldData data=null;
  NonEstimatingEstimator estimator=new NonEstimatingEstimator(breakerService.getBreaker());
  if (terms == null) {
    data=new Empty(reader.maxDoc());
    estimator.afterLoad(null,data.getMemorySizeInBytes());
    return data;
  }
  final BigDoubleArrayList lat=new BigDoubleArrayList();
  final BigDoubleArrayList lon=new BigDoubleArrayList();
  lat.add(0);
  lon.add(0);
  final float acceptableTransientOverheadRatio=fieldDataType.getSettings().getAsFloat("acceptable_transient_overhead_ratio",OrdinalsBuilder.DEFAULT_ACCEPTABLE_OVERHEAD_RATIO);
  OrdinalsBuilder builder=new OrdinalsBuilder(terms.size(),reader.maxDoc(),acceptableTransientOverheadRatio);
  boolean success=false;
  try {
    final GeoPointEnum iter=new GeoPointEnum(builder.buildFromTerms(terms.iterator(null)));
    GeoPoint point;
    while ((point=iter.next()) != null) {
      lat.add(point.getLat());
      lon.add(point.getLon());
    }
    Ordinals build=builder.build(fieldDataType.getSettings());
    if (!build.isMultiValued() && CommonSettings.removeOrdsOnSingleValue(fieldDataType)) {
      Docs ordinals=build.ordinals();
      int maxDoc=reader.maxDoc();
      BigDoubleArrayList sLat=new BigDoubleArrayList(reader.maxDoc());
      BigDoubleArrayList sLon=new BigDoubleArrayList(reader.maxDoc());
      for (int i=0; i < maxDoc; i++) {
        long nativeOrdinal=ordinals.getOrd(i);
        sLat.add(lat.get(nativeOrdinal));
        sLon.add(lon.get(nativeOrdinal));
      }
      FixedBitSet set=builder.buildDocsWithValuesSet();
      if (set == null) {
        data=new GeoPointDoubleArrayAtomicFieldData.Single(sLon,sLat,reader.maxDoc(),ordinals.getNumOrds());
      }
 else {
        data=new GeoPointDoubleArrayAtomicFieldData.SingleFixedSet(sLon,sLat,reader.maxDoc(),set,ordinals.getNumOrds());
      }
    }
 else {
      data=new GeoPointDoubleArrayAtomicFieldData.WithOrdinals(lon,lat,reader.maxDoc(),build);
    }
    success=true;
    return data;
  }
  finally {
    if (success) {
      estimator.afterLoad(null,data.getMemorySizeInBytes());
    }
    builder.close();
  }
}
