{
  AtomicReader reader=context.reader();
  Terms terms=reader.terms(getFieldNames().indexName());
  if (terms == null) {
    return GeoPointDoubleArrayAtomicFieldData.EMPTY;
  }
  final TDoubleArrayList lat=new TDoubleArrayList();
  final TDoubleArrayList lon=new TDoubleArrayList();
  lat.add(0);
  lon.add(0);
  OrdinalsBuilder builder=new OrdinalsBuilder(terms,reader.maxDoc());
  final CharsRef spare=new CharsRef();
  try {
    BytesRefIterator iter=builder.buildFromTerms(terms.iterator(null),reader.getLiveDocs());
    BytesRef term;
    while ((term=iter.next()) != null) {
      UnicodeUtil.UTF8toUTF16(term,spare);
      boolean parsed=false;
      for (int i=spare.offset; i < spare.length; i++) {
        if (spare.chars[i] == ',') {
          lat.add(Double.parseDouble(new String(spare.chars,spare.offset,(i - spare.offset))));
          lon.add(Double.parseDouble(new String(spare.chars,(spare.offset + (i + 1)),spare.length - ((i + 1) - spare.offset))));
          parsed=true;
          break;
        }
      }
      assert parsed;
    }
    Ordinals build=builder.build(fieldDataType.getSettings());
    if (!build.isMultiValued() && CommonSettings.removeOrdsOnSingleValue(fieldDataType)) {
      Docs ordinals=build.ordinals();
      double[] sLat=new double[reader.maxDoc()];
      double[] sLon=new double[reader.maxDoc()];
      for (int i=0; i < sLat.length; i++) {
        int nativeOrdinal=ordinals.getOrd(i);
        sLat[i]=lat.get(nativeOrdinal);
        sLon[i]=lon.get(nativeOrdinal);
      }
      FixedBitSet set=builder.buildDocsWithValuesSet();
      if (set == null) {
        return new GeoPointDoubleArrayAtomicFieldData.Single(sLon,sLat,reader.maxDoc());
      }
 else {
        return new GeoPointDoubleArrayAtomicFieldData.SingleFixedSet(sLon,sLat,reader.maxDoc(),set);
      }
    }
 else {
      return new GeoPointDoubleArrayAtomicFieldData.WithOrdinals(lon.toArray(new double[lon.size()]),lat.toArray(new double[lat.size()]),reader.maxDoc(),build);
    }
  }
  finally {
    builder.close();
  }
}
