{
  List<? extends AtomicArray.Entry<? extends QuerySearchResultProvider>> queryResults=queryResultsArr.asList();
  List<? extends AtomicArray.Entry<? extends FetchSearchResultProvider>> fetchResults=fetchResultsArr.asList();
  if (queryResults.isEmpty()) {
    return InternalSearchResponse.empty();
  }
  QuerySearchResult firstResult=queryResults.get(0).value.queryResult();
  boolean sorted=false;
  int sortScoreIndex=-1;
  if (firstResult.topDocs() instanceof TopFieldDocs) {
    sorted=true;
    TopFieldDocs fieldDocs=(TopFieldDocs)firstResult.queryResult().topDocs();
    for (int i=0; i < fieldDocs.fields.length; i++) {
      if (fieldDocs.fields[i].getType() == SortField.Type.SCORE) {
        sortScoreIndex=i;
      }
    }
  }
  long totalHits=0;
  float maxScore=Float.NEGATIVE_INFINITY;
  boolean timedOut=false;
  Boolean terminatedEarly=null;
  for (  AtomicArray.Entry<? extends QuerySearchResultProvider> entry : queryResults) {
    QuerySearchResult result=entry.value.queryResult();
    if (result.searchTimedOut()) {
      timedOut=true;
    }
    if (result.terminatedEarly() != null) {
      if (terminatedEarly == null) {
        terminatedEarly=result.terminatedEarly();
      }
 else       if (result.terminatedEarly()) {
        terminatedEarly=true;
      }
    }
    totalHits+=result.topDocs().totalHits;
    if (!Float.isNaN(result.topDocs().getMaxScore())) {
      maxScore=Math.max(maxScore,result.topDocs().getMaxScore());
    }
  }
  if (Float.isInfinite(maxScore)) {
    maxScore=Float.NaN;
  }
  for (  AtomicArray.Entry<? extends FetchSearchResultProvider> entry : fetchResults) {
    entry.value.fetchResult().initCounter();
  }
  List<InternalSearchHit> hits=new ArrayList<>();
  if (!fetchResults.isEmpty()) {
    for (    ScoreDoc shardDoc : sortedDocs) {
      FetchSearchResultProvider fetchResultProvider=fetchResultsArr.get(shardDoc.shardIndex);
      if (fetchResultProvider == null) {
        continue;
      }
      FetchSearchResult fetchResult=fetchResultProvider.fetchResult();
      int index=fetchResult.counterGetAndIncrement();
      if (index < fetchResult.hits().internalHits().length) {
        InternalSearchHit searchHit=fetchResult.hits().internalHits()[index];
        searchHit.score(shardDoc.score);
        searchHit.shard(fetchResult.shardTarget());
        if (sorted) {
          FieldDoc fieldDoc=(FieldDoc)shardDoc;
          searchHit.sortValues(fieldDoc.fields);
          if (sortScoreIndex != -1) {
            searchHit.score(((Number)fieldDoc.fields[sortScoreIndex]).floatValue());
          }
        }
        hits.add(searchHit);
      }
    }
  }
  Suggest suggest=null;
  if (!queryResults.isEmpty()) {
    final Map<String,List<Suggest.Suggestion>> groupedSuggestions=new HashMap<>();
    boolean hasSuggestions=false;
    for (    AtomicArray.Entry<? extends QuerySearchResultProvider> entry : queryResults) {
      Suggest shardResult=entry.value.queryResult().queryResult().suggest();
      if (shardResult == null) {
        continue;
      }
      hasSuggestions=true;
      Suggest.group(groupedSuggestions,shardResult);
    }
    suggest=hasSuggestions ? new Suggest(Suggest.Fields.SUGGEST,Suggest.reduce(groupedSuggestions)) : null;
  }
  InternalAggregations aggregations=null;
  if (!queryResults.isEmpty()) {
    if (firstResult.aggregations() != null && firstResult.aggregations().asList() != null) {
      List<InternalAggregations> aggregationsList=new ArrayList<>(queryResults.size());
      for (      AtomicArray.Entry<? extends QuerySearchResultProvider> entry : queryResults) {
        aggregationsList.add((InternalAggregations)entry.value.queryResult().aggregations());
      }
      aggregations=InternalAggregations.reduce(aggregationsList,new ReduceContext(null,bigArrays,scriptService));
    }
  }
  if (aggregations != null) {
    List<SiblingReducer> reducers=firstResult.reducers();
    if (reducers != null) {
      List<InternalAggregation> newAggs=new ArrayList<>(Lists.transform(aggregations.asList(),Reducer.AGGREGATION_TRANFORM_FUNCTION));
      for (      SiblingReducer reducer : reducers) {
        InternalAggregation newAgg=reducer.doReduce(new InternalAggregations(newAggs),new ReduceContext(null,bigArrays,scriptService));
        newAggs.add(newAgg);
      }
      aggregations=new InternalAggregations(newAggs);
    }
  }
  InternalSearchHits searchHits=new InternalSearchHits(hits.toArray(new InternalSearchHit[hits.size()]),totalHits,maxScore);
  return new InternalSearchResponse(searchHits,aggregations,suggest,timedOut,terminatedEarly);
}
