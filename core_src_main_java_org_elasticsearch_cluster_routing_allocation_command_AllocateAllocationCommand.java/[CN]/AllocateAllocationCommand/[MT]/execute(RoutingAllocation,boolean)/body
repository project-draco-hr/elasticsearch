{
  final DiscoveryNode discoNode=allocation.nodes().resolveNode(node);
  final RoutingNodes routingNodes=allocation.routingNodes();
  ShardRouting shardRouting=null;
  for (  ShardRouting routing : routingNodes.unassigned()) {
    if (routing.shardId().equals(shardId)) {
      if (shardRouting == null || routing.primary()) {
        shardRouting=routing;
      }
    }
  }
  if (shardRouting == null) {
    if (explain) {
      return new RerouteExplanation(this,allocation.decision(Decision.NO,"allocate_allocation_command","failed to find " + shardId + " on the list of unassigned shards"));
    }
    throw new IllegalArgumentException("[allocate] failed to find " + shardId + " on the list of unassigned shards");
  }
  if (shardRouting.primary() && !allowPrimary) {
    if (explain) {
      return new RerouteExplanation(this,allocation.decision(Decision.NO,"allocate_allocation_command","trying to allocate a primary shard " + shardId + ", which is disabled"));
    }
    throw new IllegalArgumentException("[allocate] trying to allocate a primary shard " + shardId + ", which is disabled");
  }
  RoutingNode routingNode=routingNodes.node(discoNode.id());
  if (routingNode == null) {
    if (!discoNode.dataNode()) {
      if (explain) {
        return new RerouteExplanation(this,allocation.decision(Decision.NO,"allocate_allocation_command","Allocation can only be done on data nodes, not [" + node + "]"));
      }
      throw new IllegalArgumentException("Allocation can only be done on data nodes, not [" + node + "]");
    }
 else {
      if (explain) {
        return new RerouteExplanation(this,allocation.decision(Decision.NO,"allocate_allocation_command","Could not find [" + node + "] among the routing nodes"));
      }
      throw new IllegalStateException("Could not find [" + node + "] among the routing nodes");
    }
  }
  Decision decision=allocation.deciders().canAllocate(shardRouting,routingNode,allocation);
  if (decision.type() == Decision.Type.NO) {
    if (explain) {
      return new RerouteExplanation(this,decision);
    }
    throw new IllegalArgumentException("[allocate] allocation of " + shardId + " on node "+ discoNode+ " is not allowed, reason: "+ decision);
  }
  for (RoutingNodes.UnassignedShards.UnassignedIterator it=routingNodes.unassigned().iterator(); it.hasNext(); ) {
    if (it.next() != shardRouting) {
      continue;
    }
    it.initialize(routingNode.nodeId());
    if (shardRouting.primary()) {
      routingNodes.addClearPostAllocationFlag(shardRouting.shardId());
    }
    break;
  }
  return new RerouteExplanation(this,decision);
}
