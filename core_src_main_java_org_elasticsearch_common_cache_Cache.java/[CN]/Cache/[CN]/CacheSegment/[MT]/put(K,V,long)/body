{
  Entry<K,V> entry=new Entry<>(key,value,now);
  Entry<K,V> existing;
  try (ReleasableLock ignored=writeLock.acquire()){
    try {
      Future<Entry<K,V>> future=map.put(key,CompletableFuture.completedFuture(entry));
      existing=future != null ? future.get() : null;
    }
 catch (    ExecutionException|InterruptedException e) {
      throw new IllegalStateException("future should be a completedFuture for which get should not throw",e);
    }
  }
   return Tuple.tuple(entry,existing);
}
