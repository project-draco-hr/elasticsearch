{
  int parentHitsResolved=0;
  ObjectObjectOpenHashMap<Object,IntObjectOpenHashMap<ParentDoc>> parentDocsPerReader=new ObjectObjectOpenHashMap<>(context.searcher().getIndexReader().leaves().size());
  child_hits:   for (  ScoreDoc scoreDoc : topDocs.scoreDocs) {
    int readerIndex=ReaderUtil.subIndex(scoreDoc.doc,context.searcher().getIndexReader().leaves());
    LeafReaderContext subContext=context.searcher().getIndexReader().leaves().get(readerIndex);
    SortedDocValues parentValues=parentChildIndexFieldData.load(subContext).getOrdinalsValues(parentType);
    int subDoc=scoreDoc.doc - subContext.docBase;
    BytesRef parentId=parentValues.get(subDoc);
    if (parentId == null) {
      continue;
    }
    for (    LeafReaderContext atomicReaderContext : context.searcher().getIndexReader().leaves()) {
      LeafReader indexReader=atomicReaderContext.reader();
      BitSet nonNestedDocs=null;
      if (nonNestedDocsFilter != null) {
        BitDocIdSet nonNestedDocIdSet=nonNestedDocsFilter.getDocIdSet(atomicReaderContext);
        if (nonNestedDocIdSet != null) {
          nonNestedDocs=nonNestedDocIdSet.bits();
        }
      }
      Terms terms=indexReader.terms(UidFieldMapper.NAME);
      if (terms == null) {
        continue;
      }
      TermsEnum termsEnum=terms.iterator(null);
      if (!termsEnum.seekExact(Uid.createUidAsBytes(parentType,parentId))) {
        continue;
      }
      PostingsEnum docsEnum=termsEnum.postings(indexReader.getLiveDocs(),null,PostingsEnum.NONE);
      int parentDocId=docsEnum.nextDoc();
      if (nonNestedDocs != null && !nonNestedDocs.get(parentDocId)) {
        parentDocId=nonNestedDocs.nextSetBit(parentDocId);
      }
      if (parentDocId != DocIdSetIterator.NO_MORE_DOCS) {
        IntObjectOpenHashMap<ParentDoc> readerParentDocs=parentDocsPerReader.get(indexReader.getCoreCacheKey());
        if (readerParentDocs == null) {
          int mapSize=Math.min(indexReader.maxDoc(),context.from() + context.size());
          readerParentDocs=new IntObjectOpenHashMap<>(mapSize);
          parentDocsPerReader.put(indexReader.getCoreCacheKey(),readerParentDocs);
        }
        ParentDoc parentDoc=readerParentDocs.get(parentDocId);
        if (parentDoc == null) {
          parentHitsResolved++;
          parentDoc=new ParentDoc();
          parentDoc.docId=parentDocId;
          parentDoc.count=1;
          parentDoc.maxScore=scoreDoc.score;
          parentDoc.minScore=scoreDoc.score;
          parentDoc.sumScores=scoreDoc.score;
          readerParentDocs.put(parentDocId,parentDoc);
        }
 else {
          parentDoc.count++;
          parentDoc.sumScores+=scoreDoc.score;
          if (scoreDoc.score < parentDoc.minScore) {
            parentDoc.minScore=scoreDoc.score;
          }
          if (scoreDoc.score > parentDoc.maxScore) {
            parentDoc.maxScore=scoreDoc.score;
          }
        }
        continue child_hits;
      }
    }
  }
  boolean[] states=parentDocsPerReader.allocated;
  Object[] keys=parentDocsPerReader.keys;
  Object[] values=parentDocsPerReader.values;
  for (int i=0; i < states.length; i++) {
    if (states[i]) {
      IntObjectOpenHashMap<ParentDoc> value=(IntObjectOpenHashMap<ParentDoc>)values[i];
      ParentDoc[] _parentDocs=value.values().toArray(ParentDoc.class);
      Arrays.sort(_parentDocs,PARENT_DOC_COMP);
      parentDocs.put(keys[i],_parentDocs);
    }
  }
  return parentHitsResolved;
}
