{
  int parentHitsResolved=0;
  Recycler.V<ObjectObjectOpenHashMap<Object,Recycler.V<IntObjectOpenHashMap<ParentDoc>>>> parentDocsPerReader=cacheRecycler.hashMap(context.searcher().getIndexReader().leaves().size());
  for (  ScoreDoc scoreDoc : topDocs.scoreDocs) {
    int readerIndex=ReaderUtil.subIndex(scoreDoc.doc,context.searcher().getIndexReader().leaves());
    AtomicReaderContext subContext=context.searcher().getIndexReader().leaves().get(readerIndex);
    int subDoc=scoreDoc.doc - subContext.docBase;
    HashedBytesArray parentId=context.idCache().reader(subContext.reader()).parentIdByDoc(parentType,subDoc);
    if (parentId == null) {
      continue;
    }
    for (    AtomicReaderContext atomicReaderContext : context.searcher().getIndexReader().leaves()) {
      AtomicReader indexReader=atomicReaderContext.reader();
      int parentDocId=context.idCache().reader(indexReader).docById(parentType,parentId);
      Bits liveDocs=indexReader.getLiveDocs();
      if (parentDocId != -1 && (liveDocs == null || liveDocs.get(parentDocId))) {
        Recycler.V<IntObjectOpenHashMap<ParentDoc>> readerParentDocs=parentDocsPerReader.v().get(indexReader.getCoreCacheKey());
        if (readerParentDocs == null) {
          readerParentDocs=cacheRecycler.intObjectMap(indexReader.maxDoc());
          parentDocsPerReader.v().put(indexReader.getCoreCacheKey(),readerParentDocs);
        }
        ParentDoc parentDoc=readerParentDocs.v().get(parentDocId);
        if (parentDoc == null) {
          parentHitsResolved++;
          parentDoc=new ParentDoc();
          parentDoc.docId=parentDocId;
          parentDoc.count=1;
          parentDoc.maxScore=scoreDoc.score;
          parentDoc.sumScores=scoreDoc.score;
          readerParentDocs.v().put(parentDocId,parentDoc);
        }
 else {
          parentDoc.count++;
          parentDoc.sumScores+=scoreDoc.score;
          if (scoreDoc.score > parentDoc.maxScore) {
            parentDoc.maxScore=scoreDoc.score;
          }
        }
      }
    }
  }
  boolean[] states=parentDocsPerReader.v().allocated;
  Object[] keys=parentDocsPerReader.v().keys;
  Object[] values=parentDocsPerReader.v().values;
  for (int i=0; i < states.length; i++) {
    if (states[i]) {
      Recycler.V<IntObjectOpenHashMap<ParentDoc>> value=(Recycler.V<IntObjectOpenHashMap<ParentDoc>>)values[i];
      ParentDoc[] _parentDocs=value.v().values().toArray(ParentDoc.class);
      Arrays.sort(_parentDocs,PARENT_DOC_COMP);
      parentDocs.v().put(keys[i],_parentDocs);
      Releasables.release(value);
    }
  }
  Releasables.release(parentDocsPerReader);
  return parentHitsResolved;
}
