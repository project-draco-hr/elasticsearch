{
  int parentHitsResolved=0;
  Recycler.V<ObjectObjectOpenHashMap<Object,Recycler.V<IntObjectOpenHashMap<ParentDoc>>>> parentDocsPerReader=cacheRecycler.hashMap(context.searcher().getIndexReader().leaves().size());
  child_hits:   for (  ScoreDoc scoreDoc : topDocs.scoreDocs) {
    int readerIndex=ReaderUtil.subIndex(scoreDoc.doc,context.searcher().getIndexReader().leaves());
    AtomicReaderContext subContext=context.searcher().getIndexReader().leaves().get(readerIndex);
    BytesValues.WithOrdinals parentValues=parentChildIndexFieldData.load(subContext).getBytesValues(parentType);
    int subDoc=scoreDoc.doc - subContext.docBase;
    parentValues.setDocument(subDoc);
    BytesRef parentId=parentValues.nextValue();
    if (parentId == null) {
      continue;
    }
    for (    AtomicReaderContext atomicReaderContext : context.searcher().getIndexReader().leaves()) {
      AtomicReader indexReader=atomicReaderContext.reader();
      FixedBitSet nonNestedDocs=null;
      if (nonNestedDocsFilter != null) {
        nonNestedDocs=(FixedBitSet)nonNestedDocsFilter.getDocIdSet(atomicReaderContext,indexReader.getLiveDocs());
      }
      Terms terms=indexReader.terms(UidFieldMapper.NAME);
      if (terms == null) {
        continue;
      }
      TermsEnum termsEnum=terms.iterator(null);
      if (!termsEnum.seekExact(Uid.createUidAsBytes(parentType,parentId))) {
        continue;
      }
      DocsEnum docsEnum=termsEnum.docs(indexReader.getLiveDocs(),null,DocsEnum.FLAG_NONE);
      int parentDocId=docsEnum.nextDoc();
      if (nonNestedDocs != null && !nonNestedDocs.get(parentDocId)) {
        parentDocId=nonNestedDocs.nextSetBit(parentDocId);
      }
      if (parentDocId != DocsEnum.NO_MORE_DOCS) {
        Recycler.V<IntObjectOpenHashMap<ParentDoc>> readerParentDocs=parentDocsPerReader.v().get(indexReader.getCoreCacheKey());
        if (readerParentDocs == null) {
          readerParentDocs=cacheRecycler.intObjectMap(indexReader.maxDoc());
          parentDocsPerReader.v().put(indexReader.getCoreCacheKey(),readerParentDocs);
        }
        ParentDoc parentDoc=readerParentDocs.v().get(parentDocId);
        if (parentDoc == null) {
          parentHitsResolved++;
          parentDoc=new ParentDoc();
          parentDoc.docId=parentDocId;
          parentDoc.count=1;
          parentDoc.maxScore=scoreDoc.score;
          parentDoc.sumScores=scoreDoc.score;
          readerParentDocs.v().put(parentDocId,parentDoc);
        }
 else {
          parentDoc.count++;
          parentDoc.sumScores+=scoreDoc.score;
          if (scoreDoc.score > parentDoc.maxScore) {
            parentDoc.maxScore=scoreDoc.score;
          }
        }
        continue child_hits;
      }
    }
  }
  boolean[] states=parentDocsPerReader.v().allocated;
  Object[] keys=parentDocsPerReader.v().keys;
  Object[] values=parentDocsPerReader.v().values;
  for (int i=0; i < states.length; i++) {
    if (states[i]) {
      Recycler.V<IntObjectOpenHashMap<ParentDoc>> value=(Recycler.V<IntObjectOpenHashMap<ParentDoc>>)values[i];
      ParentDoc[] _parentDocs=value.v().values().toArray(ParentDoc.class);
      Arrays.sort(_parentDocs,PARENT_DOC_COMP);
      parentDocs.v().put(keys[i],_parentDocs);
      Releasables.close(value);
    }
  }
  Releasables.close(parentDocsPerReader);
  return parentHitsResolved;
}
