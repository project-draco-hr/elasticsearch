{
  int parentHitsResolved=0;
  Recycler.V<ExtTHashMap<Object,Recycler.V<TIntObjectHashMap<ParentDoc>>>> parentDocsPerReader=cacheRecycler.hashMap(context.searcher().getIndexReader().leaves().size());
  for (  ScoreDoc scoreDoc : topDocs.scoreDocs) {
    int readerIndex=ReaderUtil.subIndex(scoreDoc.doc,context.searcher().getIndexReader().leaves());
    AtomicReaderContext subContext=context.searcher().getIndexReader().leaves().get(readerIndex);
    int subDoc=scoreDoc.doc - subContext.docBase;
    HashedBytesArray parentId=context.idCache().reader(subContext.reader()).parentIdByDoc(parentType,subDoc);
    if (parentId == null) {
      continue;
    }
    for (    AtomicReaderContext atomicReaderContext : context.searcher().getIndexReader().leaves()) {
      AtomicReader indexReader=atomicReaderContext.reader();
      int parentDocId=context.idCache().reader(indexReader).docById(parentType,parentId);
      Bits liveDocs=indexReader.getLiveDocs();
      if (parentDocId != -1 && (liveDocs == null || liveDocs.get(parentDocId))) {
        Recycler.V<TIntObjectHashMap<ParentDoc>> readerParentDocs=parentDocsPerReader.v().get(indexReader.getCoreCacheKey());
        if (readerParentDocs == null) {
          readerParentDocs=cacheRecycler.intObjectMap(indexReader.maxDoc());
          parentDocsPerReader.v().put(indexReader.getCoreCacheKey(),readerParentDocs);
        }
        ParentDoc parentDoc=readerParentDocs.v().get(parentDocId);
        if (parentDoc == null) {
          parentHitsResolved++;
          parentDoc=new ParentDoc();
          parentDoc.docId=parentDocId;
          parentDoc.count=1;
          parentDoc.maxScore=scoreDoc.score;
          parentDoc.sumScores=scoreDoc.score;
          readerParentDocs.v().put(parentDocId,parentDoc);
        }
 else {
          parentDoc.count++;
          parentDoc.sumScores+=scoreDoc.score;
          if (scoreDoc.score > parentDoc.maxScore) {
            parentDoc.maxScore=scoreDoc.score;
          }
        }
      }
    }
  }
  for (  Map.Entry<Object,Recycler.V<TIntObjectHashMap<ParentDoc>>> entry : parentDocsPerReader.v().entrySet()) {
    ParentDoc[] values=entry.getValue().v().values(new ParentDoc[entry.getValue().v().size()]);
    Arrays.sort(values,PARENT_DOC_COMP);
    parentDocs.v().put(entry.getKey(),values);
    entry.getValue().release();
  }
  parentDocsPerReader.release();
  return parentHitsResolved;
}
