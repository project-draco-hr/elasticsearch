{
  try {
    Expression expr=(Expression)compiledScript.compiled();
    MapperService mapper=lookup.doc().mapperService();
    SimpleBindings bindings=new SimpleBindings();
    ReplaceableConstValueSource specialValue=null;
    for (    String variable : expr.variables) {
      if (variable.equals("_score")) {
        bindings.add(new SortField("_score",SortField.Type.SCORE));
      }
 else       if (variable.equals("_value")) {
        specialValue=new ReplaceableConstValueSource();
        bindings.add("_value",specialValue);
      }
 else       if (vars != null && vars.containsKey(variable)) {
        Object value=vars.get(variable);
        if (value instanceof Number) {
          bindings.add(variable,new DoubleConstValueSource(((Number)value).doubleValue()));
        }
 else {
          throw new ScriptException("Parameter [" + variable + "] must be a numeric type");
        }
      }
 else {
        String fieldname=null;
        String methodname=null;
        String variablename="value";
        VariableContext[] parts=VariableContext.parse(variable);
        if (parts[0].text.equals("doc") == false) {
          throw new ScriptException("Unknown variable [" + parts[0].text + "] in expression");
        }
        if (parts.length < 2 || parts[1].type != VariableContext.Type.STR_INDEX) {
          throw new ScriptException("Variable 'doc' in expression must be used with a specific field like: doc['myfield']");
        }
 else {
          fieldname=parts[1].text;
        }
        if (parts.length == 3) {
          if (parts[2].type == VariableContext.Type.METHOD) {
            methodname=parts[2].text;
          }
 else           if (parts[2].type == VariableContext.Type.MEMBER) {
            variablename=parts[2].text;
          }
 else {
            throw new ScriptException("Only member variables or member methods may be accessed on a field when not accessing the field directly");
          }
        }
        if (parts.length > 3) {
          throw new ScriptException("Variable [" + variable + "] does not follow an allowed format of either doc['field'] or doc['field'].method()");
        }
        MappedFieldType fieldType=mapper.fullName(fieldname);
        if (fieldType == null) {
          throw new ScriptException("Field [" + fieldname + "] used in expression does not exist in mappings");
        }
        IndexFieldData<?> fieldData=lookup.doc().fieldDataService().getForField(fieldType);
        final ValueSource valueSource;
        if (fieldType instanceof BaseGeoPointFieldMapper.GeoPointFieldType) {
          if (methodname == null) {
            valueSource=GeoField.getVariable(fieldData,fieldname,variablename);
          }
 else {
            valueSource=GeoField.getMethod(fieldData,fieldname,methodname);
          }
        }
 else         if (fieldType instanceof LegacyDateFieldMapper.DateFieldType || fieldType instanceof DateFieldMapper.DateFieldType) {
          if (methodname == null) {
            valueSource=DateField.getVariable(fieldData,fieldname,variablename);
          }
 else {
            valueSource=DateField.getMethod(fieldData,fieldname,methodname);
          }
        }
 else         if (fieldData instanceof IndexNumericFieldData) {
          if (methodname == null) {
            valueSource=NumericField.getVariable(fieldData,fieldname,variablename);
          }
 else {
            valueSource=NumericField.getMethod(fieldData,fieldname,methodname);
          }
        }
 else {
          throw new ScriptException("Field [" + fieldname + "] used in expression must be numeric, date, or geopoint");
        }
        bindings.add(variable,valueSource);
      }
    }
    final boolean needsScores=expr.getSortField(bindings,false).needsScores();
    return new ExpressionSearchScript(compiledScript,bindings,specialValue,needsScores);
  }
 catch (  Exception exception) {
    throw new ScriptException("Error during search with " + compiledScript,exception);
  }
}
