{
  RenderSearchTemplateRequest renderSearchTemplateRequest;
  BytesReference source=RestActions.getRestContent(request);
  XContentParser parser=XContentFactory.xContent(source).createParser(source);
  String templateId=request.param("id");
  final Template template;
  if (templateId == null) {
    template=Template.parse(parser);
  }
 else {
    Map<String,Object> params=null;
    String currentFieldName=null;
    XContentParser.Token token=parser.nextToken();
    if (token != XContentParser.Token.START_OBJECT) {
      throw new ElasticsearchParseException("request body must start with [" + XContentParser.Token.START_OBJECT + "] but found ["+ token+ "]");
    }
    while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
      if (token == XContentParser.Token.FIELD_NAME) {
        currentFieldName=parser.currentName();
      }
 else       if (ScriptField.PARAMS.match(currentFieldName)) {
        if (token == XContentParser.Token.START_OBJECT) {
          params=parser.map();
        }
 else {
          throw new ElasticsearchParseException("Expected [" + XContentParser.Token.START_OBJECT + "] for [params] but found ["+ token+ "]");
        }
      }
 else {
        throw new ElasticsearchParseException("Unknown field [" + currentFieldName + "] of type ["+ token+ "]");
      }
    }
    template=new Template(templateId,ScriptType.INDEXED,MustacheScriptEngineService.NAME,null,params);
  }
  renderSearchTemplateRequest=new RenderSearchTemplateRequest();
  renderSearchTemplateRequest.template(template);
  client.admin().indices().renderSearchTemplate(renderSearchTemplateRequest,new RestBuilderListener<RenderSearchTemplateResponse>(channel){
    @Override public RestResponse buildResponse(    RenderSearchTemplateResponse response,    XContentBuilder builder) throws Exception {
      builder.prettyPrint();
      response.toXContent(builder,ToXContent.EMPTY_PARAMS);
      return new BytesRestResponse(OK,builder);
    }
  }
);
}
