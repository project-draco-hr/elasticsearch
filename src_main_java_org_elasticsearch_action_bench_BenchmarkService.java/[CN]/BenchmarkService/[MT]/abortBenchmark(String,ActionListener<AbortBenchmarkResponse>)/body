{
  final List<DiscoveryNode> nodes=availableBenchmarkNodes();
  if (nodes.size() == 0) {
    listener.onFailure(new BenchmarkNodeMissingException("No available nodes for executing benchmarks"));
  }
 else {
    BenchmarkStateListener benchmarkStateListener=new BenchmarkStateListener(){
      @Override public void onResponse(      final ClusterState newState,      final BenchmarkMetaData.Entry entry){
        if (entry != null) {
          threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable(){
            @Override public void run(){
              final ImmutableOpenMap<String,DiscoveryNode> nodes=newState.nodes().nodes();
              BenchmarkAbortAsyncHandler async=new BenchmarkAbortAsyncHandler(entry.nodes().length,benchmarkName,listener);
              for (              String nodeId : entry.nodes()) {
                final DiscoveryNode node=nodes.get(nodeId);
                if (node != null) {
                  transportService.sendRequest(node,AbortExecutionHandler.ACTION,new NodeAbortRequest(benchmarkName),async);
                }
 else {
                  logger.debug("Node for ID [" + nodeId + "] not found in cluster state - skipping");
                }
              }
            }
          }
);
        }
 else {
          listener.onFailure(new BenchmarkMissingException("Benchmark with name [" + benchmarkName + "] not found"));
        }
      }
      @Override public void onFailure(      Throwable t){
        listener.onFailure(t);
      }
    }
;
    clusterService.submitStateUpdateTask("abort_benchmark",new AbortBenchmarkTask(benchmarkName,benchmarkStateListener));
  }
}
