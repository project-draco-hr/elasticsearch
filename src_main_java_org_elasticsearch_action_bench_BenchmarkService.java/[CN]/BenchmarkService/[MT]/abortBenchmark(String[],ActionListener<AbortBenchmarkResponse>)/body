{
  final List<DiscoveryNode> nodes=availableBenchmarkNodes();
  if (nodes.size() == 0) {
    listener.onFailure(new BenchmarkNodeMissingException("No available nodes for executing benchmarks"));
  }
 else {
    BenchmarkStateListener benchmarkStateListener=new BenchmarkStateListener(){
      @Override public void onResponse(      final ClusterState newState,      final List<BenchmarkMetaData.Entry> changed){
        if (!changed.isEmpty()) {
          threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable(){
            @Override public void run(){
              Set<String> names=new HashSet<>();
              Set<String> nodeNames=new HashSet<>();
              final ImmutableOpenMap<String,DiscoveryNode> nodes=newState.nodes().nodes();
              for (              BenchmarkMetaData.Entry e : changed) {
                names.add(e.benchmarkId());
                nodeNames.addAll(Arrays.asList(e.nodes()));
              }
              BenchmarkAbortAsyncHandler asyncHandler=new BenchmarkAbortAsyncHandler(nodeNames.size(),listener);
              String[] benchmarkNames=names.toArray(new String[names.size()]);
              for (              String nodeId : nodeNames) {
                final DiscoveryNode node=nodes.get(nodeId);
                if (node != null) {
                  transportService.sendRequest(node,ABORT_ACTION_NAME,new NodeAbortRequest(benchmarkNames),asyncHandler);
                }
 else {
                  asyncHandler.countDown.countDown();
                  logger.debug("Node for ID [" + nodeId + "] not found in cluster state - skipping");
                }
              }
            }
          }
);
        }
 else {
          listener.onFailure(new BenchmarkMissingException("No benchmarks found for " + Arrays.toString(benchmarkNames)));
        }
      }
      @Override public void onFailure(      Throwable t){
        listener.onFailure(t);
      }
    }
;
    clusterService.submitStateUpdateTask("abort_benchmark",new AbortBenchmarkTask(benchmarkNames,benchmarkStateListener));
  }
}
