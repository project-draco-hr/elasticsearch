{
  IndexService service=createIndex("foo");
  IndexShard indexShard=service.getShardOrNull(0);
  DiscoveryNode node=new DiscoveryNode("foo",new LocalTransportAddress("bar"),emptyMap(),emptySet(),Version.CURRENT);
  RecoveryTarget status=new RecoveryTarget(indexShard,node,new RecoveryTargetService.RecoveryListener(){
    @Override public void onRecoveryDone(    RecoveryState state){
    }
    @Override public void onRecoveryFailure(    RecoveryState state,    RecoveryFailedException e,    boolean sendShardFailure){
    }
  }
);
  try (IndexOutput indexOutput=status.openAndPutIndexOutput("foo.bar",new StoreFileMetaData("foo.bar",8 + CodecUtil.footerLength(),"9z51nw"),status.store())){
    indexOutput.writeInt(1);
    IndexOutput openIndexOutput=status.getOpenIndexOutput("foo.bar");
    assertSame(openIndexOutput,indexOutput);
    openIndexOutput.writeInt(1);
    CodecUtil.writeFooter(indexOutput);
  }
   try {
    status.openAndPutIndexOutput("foo.bar",new StoreFileMetaData("foo.bar",8 + CodecUtil.footerLength(),"9z51nw"),status.store());
    fail("file foo.bar is already opened and registered");
  }
 catch (  IllegalStateException ex) {
    assertEquals("output for file [foo.bar] has already been created",ex.getMessage());
  }
  status.removeOpenIndexOutputs("foo.bar");
  Set<String> strings=Sets.newHashSet(status.store().directory().listAll());
  String expectedFile=null;
  for (  String file : strings) {
    if (Pattern.compile("recovery[.]\\d+[.]foo[.]bar").matcher(file).matches()) {
      expectedFile=file;
      break;
    }
  }
  assertNotNull(expectedFile);
  indexShard.close("foo",false);
  status.renameAllTempFiles();
  strings=Sets.newHashSet(status.store().directory().listAll());
  assertTrue(strings.toString(),strings.contains("foo.bar"));
  assertFalse(strings.toString(),strings.contains(expectedFile));
  status.fail(new RecoveryFailedException(status.state(),"end of test. OK.",null),false);
}
