{
  List<InternalAggregation> aggregations=reduceContext.aggregations();
  if (aggregations.size() == 1) {
    InternalHistogram<B> histo=(InternalHistogram<B>)aggregations.get(0);
    if (minDocCount == 1) {
      for (      B bucket : histo.buckets) {
        bucket.aggregations.reduce(reduceContext.bigArrays());
      }
      return histo;
    }
    CollectionUtil.introSort(histo.buckets,order.asc ? InternalOrder.KEY_ASC.comparator() : InternalOrder.KEY_DESC.comparator());
    List<B> list=order.asc ? histo.buckets : Lists.reverse(histo.buckets);
    B prevBucket=null;
    ListIterator<B> iter=list.listIterator();
    if (minDocCount == 0) {
      while (iter.hasNext()) {
        B nextBucket=list.get(iter.nextIndex());
        nextBucket.aggregations.reduce(reduceContext.bigArrays());
        if (prevBucket != null) {
          long key=emptyBucketInfo.rounding.nextRoundingValue(prevBucket.key);
          while (key != nextBucket.key) {
            iter.add(createBucket(key,0,emptyBucketInfo.subAggregations,formatter));
            key=emptyBucketInfo.rounding.nextRoundingValue(key);
          }
        }
        prevBucket=iter.next();
      }
    }
 else {
      while (iter.hasNext()) {
        InternalHistogram.Bucket bucket=iter.next();
        if (bucket.getDocCount() < minDocCount) {
          iter.remove();
        }
 else {
          bucket.aggregations.reduce(reduceContext.bigArrays());
        }
      }
    }
    if (order != InternalOrder.KEY_ASC && order != InternalOrder.KEY_DESC) {
      CollectionUtil.introSort(histo.buckets,order.comparator());
    }
    return histo;
  }
  InternalHistogram reduced=(InternalHistogram)aggregations.get(0);
  LongObjectPagedHashMap<List<B>> bucketsByKey=new LongObjectPagedHashMap<List<B>>(reduceContext.bigArrays());
  for (  InternalAggregation aggregation : aggregations) {
    InternalHistogram<B> histogram=(InternalHistogram)aggregation;
    for (    B bucket : histogram.buckets) {
      List<B> bucketList=bucketsByKey.get(bucket.key);
      if (bucketList == null) {
        bucketList=new ArrayList<B>(aggregations.size());
        bucketsByKey.put(bucket.key,bucketList);
      }
      bucketList.add(bucket);
    }
  }
  List<B> reducedBuckets=new ArrayList<B>((int)bucketsByKey.size());
  for (  LongObjectPagedHashMap.Cursor<List<B>> cursor : bucketsByKey) {
    List<B> sameTermBuckets=cursor.value;
    B bucket=sameTermBuckets.get(0).reduce(sameTermBuckets,reduceContext.bigArrays());
    if (bucket.getDocCount() >= minDocCount) {
      reducedBuckets.add(bucket);
    }
  }
  bucketsByKey.release();
  if (minDocCount == 0) {
    CollectionUtil.introSort(reducedBuckets,order.asc ? InternalOrder.KEY_ASC.comparator() : InternalOrder.KEY_DESC.comparator());
    List<B> list=order.asc ? reducedBuckets : Lists.reverse(reducedBuckets);
    B prevBucket=null;
    ListIterator<B> iter=list.listIterator();
    while (iter.hasNext()) {
      B nextBucket=list.get(iter.nextIndex());
      if (prevBucket != null) {
        long key=emptyBucketInfo.rounding.nextRoundingValue(prevBucket.key);
        while (key != nextBucket.key) {
          iter.add(createBucket(key,0,emptyBucketInfo.subAggregations,formatter));
          key=emptyBucketInfo.rounding.nextRoundingValue(key);
        }
      }
      prevBucket=iter.next();
    }
    if (order != InternalOrder.KEY_ASC && order != InternalOrder.KEY_DESC) {
      CollectionUtil.introSort(reducedBuckets,order.comparator());
    }
  }
 else {
    CollectionUtil.introSort(reducedBuckets,order.comparator());
  }
  reduced.buckets=reducedBuckets;
  return reduced;
}
