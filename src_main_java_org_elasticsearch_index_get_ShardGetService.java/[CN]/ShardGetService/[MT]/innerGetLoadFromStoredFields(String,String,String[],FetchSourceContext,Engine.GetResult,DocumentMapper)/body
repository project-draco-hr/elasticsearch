{
  Map<String,GetField> fields=null;
  BytesReference source=null;
  Versions.DocIdAndVersion docIdAndVersion=get.docIdAndVersion();
  FieldsVisitor fieldVisitor=buildFieldsVisitors(gFields,fetchSourceContext);
  if (fieldVisitor != null) {
    try {
      docIdAndVersion.context.reader().document(docIdAndVersion.docId,fieldVisitor);
    }
 catch (    IOException e) {
      throw new ElasticSearchException("Failed to get type [" + type + "] and id ["+ id+ "]",e);
    }
    source=fieldVisitor.source();
    if (!fieldVisitor.fields().isEmpty()) {
      fieldVisitor.postProcess(docMapper);
      fields=new HashMap<String,GetField>(fieldVisitor.fields().size());
      for (      Map.Entry<String,List<Object>> entry : fieldVisitor.fields().entrySet()) {
        fields.put(entry.getKey(),new GetField(entry.getKey(),entry.getValue()));
      }
    }
  }
  if (gFields != null && gFields.length > 0) {
    SearchLookup searchLookup=null;
    for (    String field : gFields) {
      Object value=null;
      if (field.contains("_source.") || field.contains("doc[")) {
        if (searchLookup == null) {
          searchLookup=new SearchLookup(mapperService,fieldDataService,new String[]{type});
          searchLookup.source().setNextSource(source);
          searchLookup.setNextReader(docIdAndVersion.context);
          searchLookup.setNextDocId(docIdAndVersion.docId);
        }
        SearchScript searchScript=scriptService.search(searchLookup,"mvel",field,null);
        searchScript.setNextReader(docIdAndVersion.context);
        searchScript.setNextDocId(docIdAndVersion.docId);
        try {
          value=searchScript.run();
        }
 catch (        RuntimeException e) {
          if (logger.isTraceEnabled()) {
            logger.trace("failed to execute get request script field [{}]",e,field);
          }
        }
      }
 else {
        FieldMappers x=docMapper.mappers().smartName(field);
        if (x == null || !x.mapper().fieldType().stored()) {
          if (searchLookup == null) {
            searchLookup=new SearchLookup(mapperService,fieldDataService,new String[]{type});
            searchLookup.setNextReader(docIdAndVersion.context);
            searchLookup.source().setNextSource(source);
            searchLookup.setNextDocId(docIdAndVersion.docId);
          }
          value=searchLookup.source().extractValue(field);
          if (value != null && x != null) {
            if (value instanceof List) {
              List list=(List)value;
              for (int i=0; i < list.size(); i++) {
                list.set(i,x.mapper().valueForSearch(list.get(i)));
              }
            }
 else {
              value=x.mapper().valueForSearch(value);
            }
          }
        }
      }
      if (value != null) {
        if (fields == null) {
          fields=newHashMapWithExpectedSize(2);
        }
        if (value instanceof List) {
          fields.put(field,new GetField(field,(List)value));
        }
 else {
          fields.put(field,new GetField(field,ImmutableList.of(value)));
        }
      }
    }
  }
  if (!fetchSourceContext.fetchSource()) {
    source=null;
  }
 else   if (fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0) {
    Map<String,Object> filteredSource;
    XContentType sourceContentType=null;
    Tuple<XContentType,Map<String,Object>> typeMapTuple=XContentHelper.convertToMap(source,true);
    sourceContentType=typeMapTuple.v1();
    filteredSource=XContentMapValues.filter(typeMapTuple.v2(),fetchSourceContext.includes(),fetchSourceContext.excludes());
    try {
      source=XContentFactory.contentBuilder(sourceContentType).map(filteredSource).bytes();
    }
 catch (    IOException e) {
      throw new ElasticSearchException("Failed to get type [" + type + "] and id ["+ id+ "] with includes/excludes set",e);
    }
  }
  return new GetResult(shardId.index().name(),type,id,get.version(),get.exists(),source,fields);
}
