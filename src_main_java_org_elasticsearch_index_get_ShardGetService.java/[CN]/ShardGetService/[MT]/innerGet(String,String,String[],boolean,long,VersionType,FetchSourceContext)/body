{
  fetchSourceContext=normalizeFetchSourceContent(fetchSourceContext,gFields);
  boolean loadSource=(gFields != null && gFields.length > 0) || fetchSourceContext.fetchSource();
  Engine.GetResult get=null;
  if (type == null || type.equals("_all")) {
    for (    String typeX : mapperService.types()) {
      get=indexShard.get(new Engine.Get(realtime,new Term(UidFieldMapper.NAME,Uid.createUidAsBytes(typeX,id))).loadSource(loadSource).version(version).versionType(versionType));
      if (get.exists()) {
        type=typeX;
        break;
      }
 else {
        get.release();
      }
    }
    if (get == null) {
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
    if (!get.exists()) {
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
  }
 else {
    get=indexShard.get(new Engine.Get(realtime,new Term(UidFieldMapper.NAME,Uid.createUidAsBytes(type,id))).loadSource(loadSource).version(version).versionType(versionType));
    if (!get.exists()) {
      get.release();
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
  }
  DocumentMapper docMapper=mapperService.documentMapper(type);
  if (docMapper == null) {
    get.release();
    return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
  }
  try {
    if (get.docIdAndVersion() != null) {
      return innerGetLoadFromStoredFields(type,id,gFields,fetchSourceContext,get,docMapper);
    }
 else {
      Translog.Source source=get.source();
      Map<String,GetField> fields=null;
      SearchLookup searchLookup=null;
      if (gFields != null && gFields.length > 0) {
        Map<String,Object> sourceAsMap=null;
        for (        String field : gFields) {
          if (SourceFieldMapper.NAME.equals(field)) {
            continue;
          }
          Object value=null;
          if (field.equals(RoutingFieldMapper.NAME) && docMapper.routingFieldMapper().fieldType().stored()) {
            value=source.routing;
          }
 else           if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active() && docMapper.parentFieldMapper().fieldType().stored()) {
            value=source.parent;
          }
 else           if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().fieldType().stored()) {
            value=source.timestamp;
          }
 else           if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().fieldType().stored()) {
            if (source.ttl > 0) {
              value=docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl);
            }
          }
 else           if (field.equals(SizeFieldMapper.NAME) && docMapper.rootMapper(SizeFieldMapper.class).fieldType().stored()) {
            value=source.source.length();
          }
 else {
            if (searchLookup == null) {
              searchLookup=new SearchLookup(mapperService,fieldDataService,new String[]{type});
              searchLookup.source().setNextSource(source.source);
            }
            FieldMapper<?> x=docMapper.mappers().smartNameFieldMapper(field);
            if (x == null) {
              if (docMapper.objectMappers().get(field) != null) {
                throw new ElasticsearchIllegalArgumentException("field [" + field + "] isn't a leaf field");
              }
            }
 else             if (docMapper.sourceMapper().enabled() || x.fieldType().stored()) {
              List<Object> values=searchLookup.source().extractRawValues(field);
              if (!values.isEmpty()) {
                for (int i=0; i < values.size(); i++) {
                  values.set(i,x.valueForSearch(values.get(i)));
                }
                value=values;
              }
            }
          }
          if (value != null) {
            if (fields == null) {
              fields=newHashMapWithExpectedSize(2);
            }
            if (value instanceof List) {
              fields.put(field,new GetField(field,(List)value));
            }
 else {
              fields.put(field,new GetField(field,ImmutableList.of(value)));
            }
          }
        }
      }
      BytesReference sourceToBeReturned=null;
      SourceFieldMapper sourceFieldMapper=docMapper.sourceMapper();
      if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) {
        sourceToBeReturned=source.source;
        Map<String,Object> filteredSource=null;
        XContentType sourceContentType=null;
        if (sourceFieldMapper.includes().length > 0 || sourceFieldMapper.excludes().length > 0) {
          Tuple<XContentType,Map<String,Object>> typeMapTuple=XContentHelper.convertToMap(source.source,true);
          sourceContentType=typeMapTuple.v1();
          filteredSource=XContentMapValues.filter(typeMapTuple.v2(),sourceFieldMapper.includes(),sourceFieldMapper.excludes());
        }
        if (fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0) {
          if (filteredSource == null) {
            Tuple<XContentType,Map<String,Object>> typeMapTuple=XContentHelper.convertToMap(source.source,true);
            sourceContentType=typeMapTuple.v1();
            filteredSource=typeMapTuple.v2();
          }
          filteredSource=XContentMapValues.filter(filteredSource,fetchSourceContext.includes(),fetchSourceContext.excludes());
        }
        if (filteredSource != null) {
          try {
            sourceToBeReturned=XContentFactory.contentBuilder(sourceContentType).map(filteredSource).bytes();
          }
 catch (          IOException e) {
            throw new ElasticsearchException("Failed to get type [" + type + "] and id ["+ id+ "] with includes/excludes set",e);
          }
        }
      }
      return new GetResult(shardId.index().name(),type,id,get.version(),get.exists(),sourceToBeReturned,fields);
    }
  }
  finally {
    get.release();
  }
}
