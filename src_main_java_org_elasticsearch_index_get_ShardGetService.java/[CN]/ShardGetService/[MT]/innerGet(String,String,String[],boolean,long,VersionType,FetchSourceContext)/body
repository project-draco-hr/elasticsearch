{
  fetchSourceContext=normalizeFetchSourceContent(fetchSourceContext,gFields);
  boolean loadSource=(gFields != null && gFields.length > 0) || fetchSourceContext.fetchSource();
  Engine.GetResult get=null;
  if (type == null || type.equals("_all")) {
    for (    String typeX : mapperService.types()) {
      get=indexShard.get(new Engine.Get(realtime,new Term(UidFieldMapper.NAME,Uid.createUidAsBytes(typeX,id))).loadSource(loadSource).version(version).versionType(versionType));
      if (get.exists()) {
        type=typeX;
        break;
      }
 else {
        get.release();
      }
    }
    if (get == null) {
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
    if (!get.exists()) {
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
  }
 else {
    get=indexShard.get(new Engine.Get(realtime,new Term(UidFieldMapper.NAME,Uid.createUidAsBytes(type,id))).loadSource(loadSource).version(version).versionType(versionType));
    if (!get.exists()) {
      get.release();
      return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
    }
  }
  DocumentMapper docMapper=mapperService.documentMapper(type);
  if (docMapper == null) {
    get.release();
    return new GetResult(shardId.index().name(),type,id,-1,false,null,null);
  }
  try {
    if (get.docIdAndVersion() != null) {
      return innerGetLoadFromStoredFields(type,id,gFields,fetchSourceContext,get,docMapper);
    }
 else {
      Translog.Source source=get.source();
      Map<String,GetField> fields=null;
      SearchLookup searchLookup=null;
      if (gFields != null && gFields.length > 0) {
        Map<String,Object> sourceAsMap=null;
        for (        String field : gFields) {
          if (SourceFieldMapper.NAME.equals(field)) {
            continue;
          }
          Object value=null;
          if (field.equals(RoutingFieldMapper.NAME) && docMapper.routingFieldMapper().fieldType().stored()) {
            value=source.routing;
          }
 else           if (field.equals(ParentFieldMapper.NAME) && docMapper.parentFieldMapper().active() && docMapper.parentFieldMapper().fieldType().stored()) {
            value=source.parent;
          }
 else           if (field.equals(TimestampFieldMapper.NAME) && docMapper.timestampFieldMapper().fieldType().stored()) {
            value=source.timestamp;
          }
 else           if (field.equals(TTLFieldMapper.NAME) && docMapper.TTLFieldMapper().fieldType().stored()) {
            if (source.ttl > 0) {
              value=docMapper.TTLFieldMapper().valueForSearch(source.timestamp + source.ttl);
            }
          }
 else           if (field.equals(SizeFieldMapper.NAME) && docMapper.rootMapper(SizeFieldMapper.class).fieldType().stored()) {
            value=source.source.length();
          }
 else {
            if (field.contains("_source.")) {
              if (searchLookup == null) {
                searchLookup=new SearchLookup(mapperService,fieldDataService,new String[]{type});
              }
              if (sourceAsMap == null) {
                sourceAsMap=SourceLookup.sourceAsMap(source.source);
              }
              SearchScript searchScript=scriptService.search(searchLookup,"mvel",field,null);
              searchScript.setNextSource(sourceAsMap);
              try {
                value=searchScript.run();
              }
 catch (              RuntimeException e) {
                if (logger.isTraceEnabled()) {
                  logger.trace("failed to execute get request script field [{}]",e,field);
                }
              }
            }
 else {
              if (searchLookup == null) {
                searchLookup=new SearchLookup(mapperService,fieldDataService,new String[]{type});
                searchLookup.source().setNextSource(source.source);
              }
              FieldMapper<?> x=docMapper.mappers().smartNameFieldMapper(field);
              if (docMapper.sourceMapper().enabled() || x == null || x.fieldType().stored()) {
                value=searchLookup.source().extractValue(field);
                if (value != null && x != null) {
                  if (value instanceof List) {
                    List list=(List)value;
                    for (int i=0; i < list.size(); i++) {
                      list.set(i,x.valueForSearch(list.get(i)));
                    }
                  }
 else {
                    value=x.valueForSearch(value);
                  }
                }
              }
            }
          }
          if (value != null) {
            if (fields == null) {
              fields=newHashMapWithExpectedSize(2);
            }
            if (value instanceof List) {
              fields.put(field,new GetField(field,(List)value));
            }
 else {
              fields.put(field,new GetField(field,ImmutableList.of(value)));
            }
          }
        }
      }
      BytesReference sourceToBeReturned=null;
      SourceFieldMapper sourceFieldMapper=docMapper.sourceMapper();
      if (fetchSourceContext.fetchSource() && sourceFieldMapper.enabled()) {
        sourceToBeReturned=source.source;
        Map<String,Object> filteredSource=null;
        XContentType sourceContentType=null;
        if (sourceFieldMapper.includes().length > 0 || sourceFieldMapper.excludes().length > 0) {
          Tuple<XContentType,Map<String,Object>> typeMapTuple=XContentHelper.convertToMap(source.source,true);
          sourceContentType=typeMapTuple.v1();
          filteredSource=XContentMapValues.filter(typeMapTuple.v2(),sourceFieldMapper.includes(),sourceFieldMapper.excludes());
        }
        if (fetchSourceContext.includes().length > 0 || fetchSourceContext.excludes().length > 0) {
          if (filteredSource == null) {
            Tuple<XContentType,Map<String,Object>> typeMapTuple=XContentHelper.convertToMap(source.source,true);
            sourceContentType=typeMapTuple.v1();
            filteredSource=typeMapTuple.v2();
          }
          filteredSource=XContentMapValues.filter(filteredSource,fetchSourceContext.includes(),fetchSourceContext.excludes());
        }
        if (filteredSource != null) {
          try {
            sourceToBeReturned=XContentFactory.contentBuilder(sourceContentType).map(filteredSource).bytes();
          }
 catch (          IOException e) {
            throw new ElasticSearchException("Failed to get type [" + type + "] and id ["+ id+ "] with includes/excludes set",e);
          }
        }
      }
      return new GetResult(shardId.index().name(),type,id,get.version(),get.exists(),sourceToBeReturned,fields);
    }
  }
  finally {
    get.release();
  }
}
