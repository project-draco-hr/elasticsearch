{
  internalCluster().ensureAtLeastNumDataNodes(randomIntBetween(2,3));
  client().admin().indices().prepareCreate("test").setSettings(Settings.settingsBuilder().put("index.number_of_shards",1).put("index.number_of_replicas",0)).addMapping("type","field","type=string").get();
  ensureGreen("test");
  final AtomicBoolean finished=new AtomicBoolean(false);
  Thread indexingThread=new Thread(){
    @Override public void run(){
      while (finished.get() == false) {
        IndexResponse indexResponse=client().prepareIndex("test","type","id").setSource("field","value").get();
        assertThat("deleted document was found",indexResponse.isCreated(),equalTo(true));
        DeleteResponse deleteResponse=client().prepareDelete("test","type","id").get();
        assertThat("indexed document was not found",deleteResponse.isFound(),equalTo(true));
      }
    }
  }
;
  indexingThread.start();
  ClusterState initialState=client().admin().cluster().prepareState().get().getState();
  DiscoveryNode[] dataNodes=initialState.getNodes().dataNodes().values().toArray(DiscoveryNode.class);
  DiscoveryNode relocationSource=initialState.getNodes().dataNodes().get(initialState.getRoutingTable().shardRoutingTable("test",0).primaryShard().currentNodeId());
  for (int i=0; i < RELOCATION_COUNT; i++) {
    DiscoveryNode relocationTarget=randomFrom(dataNodes);
    while (relocationTarget.equals(relocationSource)) {
      relocationTarget=randomFrom(dataNodes);
    }
    logger.info("--> [iteration {}] relocating from {} to {} ",i,relocationSource.getName(),relocationTarget.getName());
    client().admin().cluster().prepareReroute().add(new MoveAllocationCommand("test",0,relocationSource.getId(),relocationTarget.getId())).execute().actionGet();
    ClusterHealthResponse clusterHealthResponse=client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForRelocatingShards(0).execute().actionGet();
    assertThat(clusterHealthResponse.isTimedOut(),equalTo(false));
    logger.info("--> [iteration {}] relocation complete",i);
    relocationSource=relocationTarget;
    if (indexingThread.isAlive() == false) {
      break;
    }
  }
  finished.set(true);
  indexingThread.join();
}
