{
  if (before == null) {
    throw new IllegalStateException(error("Illegal tree structure."));
  }
 else   if (before.sort == Definition.Sort.ARRAY) {
    throw new IllegalArgumentException(error("Illegal call [" + name + "] on array type."));
  }
 else   if (store) {
    throw new IllegalArgumentException(error("Cannot assign a value to a call [" + name + "]."));
  }
  final Struct struct=before.struct;
  method=statik ? struct.functions.get(name) : struct.methods.get(name);
  if (method != null) {
    final Definition.Type[] types=new Definition.Type[method.arguments.size()];
    method.arguments.toArray(types);
    if (method.arguments.size() != arguments.size()) {
      throw new IllegalArgumentException(error("When calling [" + name + "] on type ["+ struct.name+ "]"+ " expected ["+ method.arguments.size()+ "] arguments, but found ["+ arguments.size()+ "]."));
    }
    for (int argument=0; argument < arguments.size(); ++argument) {
      final AExpression expression=arguments.get(argument);
      expression.expected=types[argument];
      expression.analyze(settings,definition,variables);
      arguments.set(argument,expression.cast(settings,definition,variables));
    }
    statement=true;
    after=method.rtn;
    return this;
  }
 else   if (before.sort == Definition.Sort.DEF) {
    final ALink link=new LDefCall(location,name,arguments);
    link.copy(this);
    return link.analyze(settings,definition,variables);
  }
  throw new IllegalArgumentException(error("Unknown call [" + name + "] on type ["+ struct.name+ "]."));
}
