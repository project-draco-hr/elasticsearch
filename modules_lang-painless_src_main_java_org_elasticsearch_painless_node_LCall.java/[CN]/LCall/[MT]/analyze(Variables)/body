{
  if (before == null) {
    throw new IllegalStateException(error("Illegal tree structure."));
  }
 else   if (before.sort == Definition.Sort.ARRAY) {
    throw new IllegalArgumentException(error("Illegal call [" + name + "] on array type."));
  }
 else   if (store) {
    throw new IllegalArgumentException(error("Cannot assign a value to a call [" + name + "]."));
  }
  Definition.MethodKey methodKey=new Definition.MethodKey(name,arguments.size());
  final Struct struct=before.struct;
  method=statik ? struct.staticMethods.get(methodKey) : struct.methods.get(methodKey);
  if (method != null) {
    for (int argument=0; argument < arguments.size(); ++argument) {
      final AExpression expression=arguments.get(argument);
      expression.expected=method.arguments.get(argument);
      expression.analyze(variables);
      arguments.set(argument,expression.cast(variables));
    }
    statement=true;
    after=method.rtn;
    return this;
  }
 else   if (before.sort == Definition.Sort.DEF) {
    final ALink link=new LDefCall(line,location,name,arguments);
    link.copy(this);
    return link.analyze(variables);
  }
  throw new IllegalArgumentException(error("Unknown call [" + name + "] with ["+ arguments.size()+ "] arguments on type ["+ struct.name+ "]."));
}
