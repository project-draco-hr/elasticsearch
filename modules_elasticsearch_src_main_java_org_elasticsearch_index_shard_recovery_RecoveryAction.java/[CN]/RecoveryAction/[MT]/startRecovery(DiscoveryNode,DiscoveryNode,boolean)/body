{
  sendStartRecoveryThread=Thread.currentThread();
  try {
    IndexShardState preRecoveringState;
    try {
      preRecoveringState=indexShard.recovering();
    }
 catch (    IndexShardRecoveringException e) {
      throw new IgnoreRecoveryException("Already in recovering process",e);
    }
catch (    IndexShardStartedException e) {
      throw new IgnoreRecoveryException("Already in recovering process",e);
    }
catch (    IndexShardRelocatedException e) {
      throw new IgnoreRecoveryException("Already in recovering process",e);
    }
catch (    IndexShardClosedException e) {
      throw new IgnoreRecoveryException("Can't recover a closed shard.",e);
    }
    StopWatch throttlingWaitTime=new StopWatch().start();
    while (!recoveryThrottler.tryRecovery(shardId,"peer recovery target")) {
      try {
        Thread.sleep(recoveryThrottler.throttleInterval().millis());
      }
 catch (      InterruptedException e) {
        if (indexShard.ignoreRecoveryAttempt()) {
          throw new IgnoreRecoveryException("Interrupted while waiting for recovery, but we should ignore ...");
        }
        throw new RecoveryFailedException(shardId,node,targetNode,e);
      }
    }
    throttlingWaitTime.stop();
    try {
      if (closed) {
        throw new IgnoreRecoveryException("Recovery closed");
      }
      logger.debug("starting recovery from {}",targetNode);
      StartRecoveryRequest startRecoveryRequest=new StartRecoveryRequest(node,markAsRelocated,store.listWithMd5());
      StopWatch stopWatch=null;
      RecoveryStatus recoveryStatus=null;
      boolean retry=true;
      while (retry) {
        stopWatch=new StopWatch().start();
        recoveryStatus=transportService.submitRequest(targetNode,startTransportAction,startRecoveryRequest,new FutureTransportResponseHandler<RecoveryStatus>(){
          @Override public RecoveryStatus newInstance(){
            return new RecoveryStatus();
          }
        }
).txGet();
        retry=recoveryStatus.retry;
        if (retry) {
          try {
            Thread.sleep(recoveryThrottler.throttleInterval().millis());
          }
 catch (          InterruptedException e) {
            if (indexShard.ignoreRecoveryAttempt()) {
              throw new IgnoreRecoveryException("Interrupted while waiting for remote recovery, but we should ignore ...");
            }
            throw new RecoveryFailedException(shardId,node,targetNode,e);
          }
        }
      }
      stopWatch.stop();
      if (logger.isDebugEnabled()) {
        StringBuilder sb=new StringBuilder();
        sb.append("recovery completed from ").append(targetNode).append(", took[").append(stopWatch.totalTime()).append("], throttling_wait [").append(throttlingWaitTime.totalTime()).append("]\n");
        sb.append("   phase1: recovered_files [").append(recoveryStatus.phase1FileNames.size()).append("]").append(" with total_size of [").append(new ByteSizeValue(recoveryStatus.phase1TotalSize)).append("]").append(", took [").append(timeValueMillis(recoveryStatus.phase1Time)).append("], throttling_wait [").append(timeValueMillis(recoveryStatus.phase1ThrottlingWaitTime)).append(']').append("\n");
        sb.append("         : reusing_files   [").append(recoveryStatus.phase1ExistingFileNames.size()).append("] with total_size of [").append(new ByteSizeValue(recoveryStatus.phase1ExistingTotalSize)).append("]\n");
        sb.append("   phase2: recovered [").append(recoveryStatus.phase2Operations).append("]").append(" transaction log operations").append(", took [").append(timeValueMillis(recoveryStatus.phase2Time)).append("]").append("\n");
        sb.append("   phase3: recovered [").append(recoveryStatus.phase3Operations).append("]").append(" transaction log operations").append(", took [").append(timeValueMillis(recoveryStatus.phase3Time)).append("]");
        logger.debug(sb.toString());
      }
    }
 catch (    RemoteTransportException e) {
      if (closed) {
        throw new IgnoreRecoveryException("Recovery closed",e);
      }
      logger.trace("recovery from [{}] failed",e,targetNode);
      Throwable cause=ExceptionsHelper.unwrapCause(e);
      if (cause instanceof ActionNotFoundTransportException || cause instanceof IndexShardNotStartedException) {
        indexShard.restoreRecoveryState(preRecoveringState);
        throw new IgnoreRecoveryException("Ignoring recovery attempt, remote shard not started",e);
      }
 else       if (cause instanceof RecoveryEngineException) {
        if (cause.getCause() instanceof IgnoreRecoveryException) {
          throw (IgnoreRecoveryException)cause.getCause();
        }
      }
 else       if (cause instanceof IgnoreRecoveryException) {
        throw (IgnoreRecoveryException)cause;
      }
      throw new RecoveryFailedException(shardId,node,targetNode,e);
    }
catch (    Exception e) {
      if (closed) {
        throw new IgnoreRecoveryException("Recovery closed",e);
      }
      throw new RecoveryFailedException(shardId,node,targetNode,e);
    }
 finally {
      recoveryThrottler.recoveryDone(shardId,"peer recovery target");
    }
  }
  finally {
    sendStartRecoveryThread=null;
  }
}
