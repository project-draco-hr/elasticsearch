{
  ObjectLongOpenHashMap<DiscoveryNode> shardStates=cachedShardsState.get(shard.shardId());
  ObjectOpenHashSet<String> nodeIds;
  if (shardStates == null) {
    shardStates=new ObjectLongOpenHashMap<>();
    cachedShardsState.put(shard.shardId(),shardStates);
    nodeIds=ObjectOpenHashSet.from(nodes.dataNodes().keys());
  }
 else {
    shardStates.keys().removeAll(new ObjectPredicate<DiscoveryNode>(){
      @Override public boolean apply(      DiscoveryNode node){
        return !nodes.nodeExists(node.id());
      }
    }
);
    nodeIds=ObjectOpenHashSet.newInstance();
    for (    ObjectCursor<DiscoveryNode> cursor : nodes.dataNodes().values()) {
      DiscoveryNode node=cursor.value;
      if (!shardStates.containsKey(node)) {
        nodeIds.add(node.id());
      }
    }
  }
  if (nodeIds.isEmpty()) {
    return shardStates;
  }
  String[] nodesIdsArray=nodeIds.toArray(String.class);
  TransportNodesListGatewayStartedShards.NodesGatewayStartedShards response=listGatewayStartedShards.list(shard.shardId(),indexMetaData.getUUID(),nodesIdsArray,listTimeout).actionGet();
  logListActionFailures(shard,"state",response.failures());
  for (  TransportNodesListGatewayStartedShards.NodeGatewayStartedShards nodeShardState : response) {
    long version=nodeShardState.version();
    Settings idxSettings=indexMetaData.settings();
    if (IndexMetaData.isOnSharedFilesystem(idxSettings) && idxSettings.getAsBoolean(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE,false)) {
      version=Math.max(0,version);
    }
    logger.trace("[{}] on node [{}] has version [{}] of shard",shard,nodeShardState.getNode(),version);
    shardStates.put(nodeShardState.getNode(),version);
  }
  return shardStates;
}
