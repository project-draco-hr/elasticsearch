{
  allocation.debugDecision(true);
  UnassignedInfo ui=shard.unassignedInfo();
  RoutingNodesIterator iter=routingNodes.nodes();
  Map<DiscoveryNode,Decision> nodeToDecision=new HashMap<>();
  while (iter.hasNext()) {
    RoutingNode node=iter.next();
    DiscoveryNode discoNode=node.node();
    if (discoNode.isDataNode()) {
      Decision d=tryShardOnNode(shard,node,allocation,includeYesDecisions);
      nodeToDecision.put(discoNode,d);
    }
  }
  long remainingDelayNanos=0;
  final MetaData metadata=allocation.metaData();
  final IndexMetaData indexMetaData=metadata.index(shard.index());
  if (ui != null) {
    final Settings indexSettings=indexMetaData.getSettings();
    remainingDelayNanos=ui.getRemainingDelay(System.nanoTime(),metadata.settings(),indexSettings);
  }
  return new ClusterAllocationExplanation(shard.shardId(),shard.primary(),shard.currentNodeId(),ui,nodeToDecision,shardAllocator.weighShard(allocation,shard),remainingDelayNanos,shardStores,indexMetaData.activeAllocationIds(shard.getId()));
}
