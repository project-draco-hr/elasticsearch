{
  allocation.debugDecision(true);
  UnassignedInfo ui=shard.unassignedInfo();
  RoutingNodesIterator iter=routingNodes.nodes();
  Map<DiscoveryNode,Decision> nodeToDecision=new HashMap<>();
  while (iter.hasNext()) {
    RoutingNode node=iter.next();
    DiscoveryNode discoNode=node.node();
    if (discoNode.isDataNode()) {
      Decision d=tryShardOnNode(shard,node,allocation,includeYesDecisions);
      nodeToDecision.put(discoNode,d);
    }
  }
  long remainingDelayMillis=0;
  final MetaData metadata=allocation.metaData();
  final IndexMetaData indexMetaData=metadata.index(shard.index());
  if (ui != null) {
    final Settings indexSettings=indexMetaData.getSettings();
    long remainingDelayNanos=ui.getRemainingDelay(System.nanoTime(),metadata.settings(),indexSettings);
    remainingDelayMillis=TimeValue.timeValueNanos(remainingDelayNanos).millis();
  }
  Map<DiscoveryNode,Float> weights=shardAllocator.weighShard(allocation,shard);
  Map<DiscoveryNode,IndicesShardStoresResponse.StoreStatus> nodeToStatus=new HashMap<>(shardStores.size());
  for (  IndicesShardStoresResponse.StoreStatus status : shardStores) {
    nodeToStatus.put(status.getNode(),status);
  }
  Map<DiscoveryNode,NodeExplanation> explanations=new HashMap<>(shardStores.size());
  for (  Map.Entry<DiscoveryNode,Decision> entry : nodeToDecision.entrySet()) {
    DiscoveryNode node=entry.getKey();
    Decision decision=entry.getValue();
    Float weight=weights.get(node);
    IndicesShardStoresResponse.StoreStatus storeStatus=nodeToStatus.get(node);
    NodeExplanation nodeExplanation=calculateNodeExplanation(shard,indexMetaData,node,decision,weight,storeStatus,shard.currentNodeId(),indexMetaData.activeAllocationIds(shard.getId()),allocation.hasPendingAsyncFetch());
    explanations.put(node,nodeExplanation);
  }
  return new ClusterAllocationExplanation(shard.shardId(),shard.primary(),shard.currentNodeId(),remainingDelayMillis,ui,gatewayAllocator.hasFetchPending(shard.shardId(),shard.primary()),explanations);
}
