{
  allocation.debugDecision(true);
  UnassignedInfo ui=shard.unassignedInfo();
  RoutingNodesIterator iter=routingNodes.nodes();
  Map<DiscoveryNode,Decision> nodeToDecision=new HashMap<>();
  while (iter.hasNext()) {
    RoutingNode node=iter.next();
    DiscoveryNode discoNode=node.node();
    if (discoNode.isDataNode()) {
      Decision d=tryShardOnNode(shard,node,allocation,includeYesDecisions);
      nodeToDecision.put(discoNode,d);
    }
  }
  long remainingDelayNanos=0;
  if (ui != null) {
    final MetaData metadata=allocation.metaData();
    final Settings indexSettings=metadata.index(shard.index()).getSettings();
    remainingDelayNanos=ui.getRemainingDelay(System.nanoTime(),metadata.settings(),indexSettings);
  }
  return new ClusterAllocationExplanation(shard.shardId(),shard.primary(),shard.currentNodeId(),ui,nodeToDecision,shardAllocator.weighShard(allocation,shard),remainingDelayNanos);
}
