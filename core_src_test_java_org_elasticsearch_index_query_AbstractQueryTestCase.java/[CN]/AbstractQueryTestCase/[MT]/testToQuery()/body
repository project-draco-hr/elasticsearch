{
  for (int runs=0; runs < NUMBER_OF_TESTQUERIES; runs++) {
    QueryShardContext context=createShardContext();
    context.setAllowUnmappedFields(true);
    QB firstQuery=createTestQueryBuilder();
    QB controlQuery=copyQuery(firstQuery);
    setSearchContext(randomTypes);
    Query firstLuceneQuery=rewriteQuery(firstQuery,context).toQuery(context);
    assertLuceneQuery(firstQuery,firstLuceneQuery,context);
    SearchContext.removeCurrent();
    assertTrue("query is not equal to its copy after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: "+ controlQuery,firstQuery.equals(controlQuery));
    assertTrue("equals is not symmetric after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: "+ controlQuery,controlQuery.equals(firstQuery));
    assertThat("query copy's hashcode is different from original hashcode after calling toQuery, firstQuery: " + firstQuery + ", secondQuery: "+ controlQuery,controlQuery.hashCode(),equalTo(firstQuery.hashCode()));
    QB secondQuery=copyQuery(firstQuery);
    if (randomBoolean()) {
      secondQuery.queryName(secondQuery.queryName() == null ? randomAsciiOfLengthBetween(1,30) : secondQuery.queryName() + randomAsciiOfLengthBetween(1,10));
    }
    setSearchContext(randomTypes);
    Query secondLuceneQuery=rewriteQuery(secondQuery,context).toQuery(context);
    assertLuceneQuery(secondQuery,secondLuceneQuery,context);
    SearchContext.removeCurrent();
    assertThat("two equivalent query builders lead to different lucene queries",secondLuceneQuery,equalTo(firstLuceneQuery));
    if (firstLuceneQuery != null && supportsBoostAndQueryName()) {
      secondQuery.boost(firstQuery.boost() + 1f + randomFloat());
      setSearchContext(randomTypes);
      Query thirdLuceneQuery=rewriteQuery(secondQuery,context).toQuery(context);
      SearchContext.removeCurrent();
      assertThat("modifying the boost doesn't affect the corresponding lucene query",firstLuceneQuery,not(equalTo(thirdLuceneQuery)));
    }
  }
}
