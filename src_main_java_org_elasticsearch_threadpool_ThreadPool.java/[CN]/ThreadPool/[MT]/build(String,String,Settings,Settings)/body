{
  if (settings == null) {
    settings=ImmutableSettings.Builder.EMPTY_SETTINGS;
  }
  String type=settings.get("type",defaultType);
  ThreadFactory threadFactory=EsExecutors.daemonThreadFactory(this.settings,name);
  if ("same".equals(type)) {
    logger.debug("creating thread_pool [{}], type [{}]",name,type);
    return new ExecutorHolder(MoreExecutors.sameThreadExecutor(),new Info(name,type));
  }
 else   if ("cached".equals(type)) {
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultSettings.getAsTime("keep_alive",timeValueMinutes(5)));
    logger.debug("creating thread_pool [{}], type [{}], keep_alive [{}]",name,type,keepAlive);
    Executor executor=new EsThreadPoolExecutor(0,Integer.MAX_VALUE,keepAlive.millis(),TimeUnit.MILLISECONDS,new SynchronousQueue<Runnable>(),threadFactory);
    return new ExecutorHolder(executor,new Info(name,type,-1,-1,keepAlive,null));
  }
 else   if ("fixed".equals(type)) {
    int size=settings.getAsInt("size",defaultSettings.getAsInt("size",Runtime.getRuntime().availableProcessors() * 5));
    SizeValue capacity=settings.getAsSize("capacity",settings.getAsSize("queue",settings.getAsSize("queue_size",defaultSettings.getAsSize("queue",defaultSettings.getAsSize("queue_size",null)))));
    RejectedExecutionHandler rejectedExecutionHandler;
    String rejectSetting=settings.get("reject_policy",defaultSettings.get("reject_policy","abort"));
    if ("abort".equals(rejectSetting)) {
      rejectedExecutionHandler=EsAbortPolicy.INSTANCE;
    }
 else     if ("caller".equals(rejectSetting)) {
      rejectedExecutionHandler=new ThreadPoolExecutor.CallerRunsPolicy();
    }
 else {
      throw new ElasticSearchIllegalArgumentException("reject_policy [" + rejectSetting + "] not valid for ["+ name+ "] thread pool");
    }
    logger.debug("creating thread_pool [{}], type [{}], size [{}], queue_size [{}], reject_policy [{}]",name,type,size,capacity,rejectSetting);
    BlockingQueue<Runnable> workQueue;
    if (capacity == null) {
      workQueue=new LinkedTransferQueue<Runnable>();
    }
 else     if ((int)capacity.singles() > 0) {
      workQueue=new ArrayBlockingQueue<Runnable>((int)capacity.singles());
    }
 else {
      workQueue=new SynchronousQueue<Runnable>();
    }
    Executor executor=new EsThreadPoolExecutor(size,size,0L,TimeUnit.MILLISECONDS,workQueue,threadFactory,rejectedExecutionHandler);
    return new ExecutorHolder(executor,new Info(name,type,size,size,null,capacity));
  }
 else   if ("scaling".equals(type)) {
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultSettings.getAsTime("keep_alive",timeValueMinutes(5)));
    int min=settings.getAsInt("min",defaultSettings.getAsInt("min",1));
    int size=settings.getAsInt("max",settings.getAsInt("size",defaultSettings.getAsInt("size",Runtime.getRuntime().availableProcessors() * 5)));
    logger.debug("creating thread_pool [{}], type [{}], min [{}], size [{}], keep_alive [{}]",name,type,min,size,keepAlive);
    Executor executor=EsExecutors.newScalingExecutorService(min,size,keepAlive.millis(),TimeUnit.MILLISECONDS,threadFactory);
    return new ExecutorHolder(executor,new Info(name,type,min,size,keepAlive,null));
  }
 else   if ("blocking".equals(type)) {
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultSettings.getAsTime("keep_alive",timeValueMinutes(5)));
    int min=settings.getAsInt("min",defaultSettings.getAsInt("min",1));
    int size=settings.getAsInt("max",settings.getAsInt("size",defaultSettings.getAsInt("size",Runtime.getRuntime().availableProcessors() * 5)));
    SizeValue capacity=settings.getAsSize("capacity",settings.getAsSize("queue_size",defaultSettings.getAsSize("queue_size",new SizeValue(1000))));
    TimeValue waitTime=settings.getAsTime("wait_time",defaultSettings.getAsTime("wait_time",timeValueSeconds(60)));
    logger.debug("creating thread_pool [{}], type [{}], min [{}], size [{}], queue_size [{}], keep_alive [{}], wait_time [{}]",name,type,min,size,capacity.singles(),keepAlive,waitTime);
    Executor executor=EsExecutors.newBlockingExecutorService(min,size,keepAlive.millis(),TimeUnit.MILLISECONDS,threadFactory,(int)capacity.singles(),waitTime.millis(),TimeUnit.MILLISECONDS);
    return new ExecutorHolder(executor,new Info(name,type,min,size,keepAlive,capacity));
  }
  throw new ElasticSearchIllegalArgumentException("No type found [" + type + "], for ["+ name+ "]");
}
