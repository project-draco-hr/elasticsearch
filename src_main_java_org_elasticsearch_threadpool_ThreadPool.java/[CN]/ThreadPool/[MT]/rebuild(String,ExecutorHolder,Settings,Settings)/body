{
  if (Names.SAME.equals(name)) {
    return previousExecutorHolder;
  }
  if (settings == null) {
    settings=ImmutableSettings.Builder.EMPTY_SETTINGS;
  }
  Info previousInfo=previousExecutorHolder != null ? previousExecutorHolder.info : null;
  String type=settings.get("type",previousInfo != null ? previousInfo.type() : defaultSettings.get("type"));
  ThreadFactory threadFactory=EsExecutors.daemonThreadFactory(this.settings,name);
  if ("same".equals(type)) {
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}]",name,type);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}]",name,type);
    }
    return new ExecutorHolder(MoreExecutors.sameThreadExecutor(),new Info(name,type));
  }
 else   if ("cached".equals(type)) {
    TimeValue defaultKeepAlive=defaultSettings.getAsTime("keep_alive",timeValueMinutes(5));
    if (previousExecutorHolder != null) {
      if ("cached".equals(previousInfo.type())) {
        TimeValue updatedKeepAlive=settings.getAsTime("keep_alive",previousInfo.keepAlive());
        if (!previousInfo.keepAlive().equals(updatedKeepAlive)) {
          logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,updatedKeepAlive);
          ((EsThreadPoolExecutor)previousExecutorHolder.executor).setKeepAliveTime(updatedKeepAlive.millis(),TimeUnit.MILLISECONDS);
          return new ExecutorHolder(previousExecutorHolder.executor,new Info(name,type,-1,-1,updatedKeepAlive,null));
        }
        return previousExecutorHolder;
      }
      if (previousInfo.keepAlive() != null) {
        defaultKeepAlive=previousInfo.keepAlive();
      }
    }
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultKeepAlive);
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,keepAlive);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}], keep_alive [{}]",name,type,keepAlive);
    }
    Executor executor=new EsThreadPoolExecutor(0,Integer.MAX_VALUE,keepAlive.millis(),TimeUnit.MILLISECONDS,new SynchronousQueue<Runnable>(),threadFactory);
    return new ExecutorHolder(executor,new Info(name,type,-1,-1,keepAlive,null));
  }
 else   if ("fixed".equals(type)) {
    int defaultSize=defaultSettings.getAsInt("size",Runtime.getRuntime().availableProcessors() * 5);
    SizeValue defaultCapacity=defaultSettings.getAsSize("queue",defaultSettings.getAsSize("queue_size",null));
    String defaultRejectSetting=defaultSettings.get("reject_policy","abort");
    String defaultQueueType=defaultSettings.get("queue_type","linked");
    if (previousExecutorHolder != null) {
      if ("fixed".equals(previousInfo.type())) {
        SizeValue updatedCapacity=settings.getAsSize("capacity",settings.getAsSize("queue",settings.getAsSize("queue_size",previousInfo.capacity())));
        String updatedQueueType=settings.get("queue_type",previousInfo.queueType());
        if (Objects.equal(previousInfo.capacity(),updatedCapacity) && previousInfo.queueType().equals(updatedQueueType)) {
          int updatedSize=settings.getAsInt("size",previousInfo.max());
          String updatedRejectSetting=settings.get("reject_policy",previousInfo.rejectSetting());
          if (previousInfo.max() != updatedSize) {
            logger.debug("updating thread_pool [{}], type [{}], size [{}], queue_size [{}], reject_policy [{}], queue_type [{}]",name,type,updatedSize,updatedCapacity,updatedRejectSetting,updatedQueueType);
            ((EsThreadPoolExecutor)previousExecutorHolder.executor).setCorePoolSize(updatedSize);
            ((EsThreadPoolExecutor)previousExecutorHolder.executor).setMaximumPoolSize(updatedSize);
            return new ExecutorHolder(previousExecutorHolder.executor,new Info(name,type,updatedSize,updatedSize,null,updatedCapacity,null,updatedRejectSetting,updatedQueueType));
          }
          if (!previousInfo.rejectSetting().equals(updatedRejectSetting)) {
            logger.debug("updating thread_pool [{}], type [{}], size [{}], queue_size [{}], reject_policy [{}], queue_type [{}]",name,type,updatedSize,updatedCapacity,updatedRejectSetting,updatedQueueType);
            ((EsThreadPoolExecutor)previousExecutorHolder.executor).setRejectedExecutionHandler(newRejectedExecutionHandler(name,updatedRejectSetting));
            return new ExecutorHolder(previousExecutorHolder.executor,new Info(name,type,updatedSize,updatedSize,null,updatedCapacity,null,updatedRejectSetting,updatedQueueType));
          }
          return previousExecutorHolder;
        }
      }
      if (previousInfo.max() >= 0) {
        defaultSize=previousInfo.max();
      }
      defaultCapacity=previousInfo.capacity();
      if (previousInfo.rejectSetting != null) {
        defaultRejectSetting=previousInfo.rejectSetting;
      }
      if (previousInfo.queueType() != null) {
        defaultQueueType=previousInfo.queueType();
      }
    }
    int size=settings.getAsInt("size",defaultSize);
    SizeValue capacity=settings.getAsSize("capacity",settings.getAsSize("queue",settings.getAsSize("queue_size",defaultCapacity)));
    String rejectSetting=settings.get("reject_policy",defaultRejectSetting);
    RejectedExecutionHandler rejectedExecutionHandler=newRejectedExecutionHandler(name,rejectSetting);
    String queueType=settings.get("queue_type",defaultQueueType);
    BlockingQueue<Runnable> workQueue=newQueue(capacity,queueType);
    logger.debug("creating thread_pool [{}], type [{}], size [{}], queue_size [{}], reject_policy [{}], queue_type [{}]",name,type,size,capacity,rejectSetting,queueType);
    Executor executor=new EsThreadPoolExecutor(size,size,0L,TimeUnit.MILLISECONDS,workQueue,threadFactory,rejectedExecutionHandler);
    return new ExecutorHolder(executor,new Info(name,type,size,size,null,capacity,null,rejectSetting,queueType));
  }
 else   if ("scaling".equals(type)) {
    TimeValue defaultKeepAlive=defaultSettings.getAsTime("keep_alive",timeValueMinutes(5));
    int defaultMin=defaultSettings.getAsInt("min",1);
    int defaultSize=defaultSettings.getAsInt("size",Runtime.getRuntime().availableProcessors() * 5);
    if (previousExecutorHolder != null) {
      if ("scaling".equals(previousInfo.getType())) {
        TimeValue updatedKeepAlive=settings.getAsTime("keep_alive",previousInfo.getKeepAlive());
        int updatedMin=settings.getAsInt("min",previousInfo.getMin());
        int updatedSize=settings.getAsInt("max",settings.getAsInt("size",previousInfo.getMax()));
        if (!previousInfo.keepAlive().equals(updatedKeepAlive) || previousInfo.min() != updatedMin || previousInfo.max() != updatedSize) {
          logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,updatedKeepAlive);
          if (!previousInfo.getKeepAlive().equals(updatedKeepAlive)) {
            ((EsThreadPoolExecutor)previousExecutorHolder.executor).setKeepAliveTime(updatedKeepAlive.millis(),TimeUnit.MILLISECONDS);
          }
          if (previousInfo.getMin() != updatedMin) {
            ((EsThreadPoolExecutor)previousExecutorHolder.executor).setCorePoolSize(updatedMin);
          }
          if (previousInfo.getMax() != updatedSize) {
            ((EsThreadPoolExecutor)previousExecutorHolder.executor).setMaximumPoolSize(updatedSize);
          }
          return new ExecutorHolder(previousExecutorHolder.executor,new Info(name,type,updatedMin,updatedSize,updatedKeepAlive,null));
        }
        return previousExecutorHolder;
      }
      if (previousInfo.getKeepAlive() != null) {
        defaultKeepAlive=previousInfo.getKeepAlive();
      }
      if (previousInfo.getMin() >= 0) {
        defaultMin=previousInfo.getMin();
      }
      if (previousInfo.getMax() >= 0) {
        defaultSize=previousInfo.getMax();
      }
    }
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultKeepAlive);
    int min=settings.getAsInt("min",defaultMin);
    int size=settings.getAsInt("max",settings.getAsInt("size",defaultSize));
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}], min [{}], size [{}], keep_alive [{}]",name,type,min,size,keepAlive);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}], min [{}], size [{}], keep_alive [{}]",name,type,min,size,keepAlive);
    }
    Executor executor=EsExecutors.newScalingExecutorService(min,size,keepAlive.millis(),TimeUnit.MILLISECONDS,threadFactory);
    return new ExecutorHolder(executor,new Info(name,type,min,size,keepAlive,null));
  }
 else   if ("blocking".equals(type)) {
    TimeValue defaultKeepAlive=defaultSettings.getAsTime("keep_alive",timeValueMinutes(5));
    int defaultMin=defaultSettings.getAsInt("min",1);
    int defaultSize=defaultSettings.getAsInt("size",Runtime.getRuntime().availableProcessors() * 5);
    SizeValue defaultCapacity=defaultSettings.getAsSize("queue_size",new SizeValue(1000));
    TimeValue defaultWaitTime=defaultSettings.getAsTime("wait_time",timeValueSeconds(60));
    if (previousExecutorHolder != null) {
      if ("blocking".equals(previousInfo.getType())) {
        SizeValue updatedCapacity=settings.getAsSize("capacity",settings.getAsSize("queue",settings.getAsSize("queue_size",defaultCapacity)));
        TimeValue updatedWaitTime=settings.getAsTime("wait_time",defaultWaitTime);
        if (previousInfo.capacity().equals(updatedCapacity) && previousInfo.waitTime().equals(updatedWaitTime)) {
          TimeValue updatedKeepAlive=settings.getAsTime("keep_alive",previousInfo.getKeepAlive());
          int updatedMin=settings.getAsInt("min",previousInfo.getMin());
          int updatedSize=settings.getAsInt("max",settings.getAsInt("size",previousInfo.getMax()));
          if (!previousInfo.getKeepAlive().equals(updatedKeepAlive) || !previousInfo.waitTime().equals(settings.getAsTime("wait_time",defaultWaitTime)) || previousInfo.getMin() != updatedMin || previousInfo.getMax() != updatedSize) {
            logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,updatedKeepAlive);
            if (!previousInfo.getKeepAlive().equals(updatedKeepAlive)) {
              ((EsThreadPoolExecutor)previousExecutorHolder.executor).setKeepAliveTime(updatedKeepAlive.millis(),TimeUnit.MILLISECONDS);
            }
            if (previousInfo.getMin() != updatedMin) {
              ((EsThreadPoolExecutor)previousExecutorHolder.executor).setCorePoolSize(updatedMin);
            }
            if (previousInfo.getMax() != updatedSize) {
              ((EsThreadPoolExecutor)previousExecutorHolder.executor).setMaximumPoolSize(updatedSize);
            }
            return new ExecutorHolder(previousExecutorHolder.executor,new Info(name,type,updatedMin,updatedSize,updatedKeepAlive,updatedCapacity,updatedWaitTime));
          }
          return previousExecutorHolder;
        }
      }
      if (previousInfo.getKeepAlive() != null) {
        defaultKeepAlive=previousInfo.getKeepAlive();
      }
      if (previousInfo.getMin() >= 0) {
        defaultMin=previousInfo.getMin();
      }
      if (previousInfo.getMax() >= 0) {
        defaultSize=previousInfo.getMax();
      }
      if (previousInfo.getCapacity() != null) {
        defaultCapacity=previousInfo.getCapacity();
      }
      if (previousInfo.waitTime() != null) {
        defaultWaitTime=previousInfo.getKeepAlive();
      }
    }
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultKeepAlive);
    int min=settings.getAsInt("min",defaultMin);
    int size=settings.getAsInt("max",settings.getAsInt("size",defaultSize));
    SizeValue capacity=settings.getAsSize("capacity",settings.getAsSize("queue",settings.getAsSize("queue_size",defaultCapacity)));
    TimeValue waitTime=settings.getAsTime("wait_time",defaultWaitTime);
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}], min [{}], size [{}], queue_size [{}], keep_alive [{}], wait_time [{}]",name,type,min,size,capacity.singles(),keepAlive,waitTime);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}], min [{}], size [{}], queue_size [{}], keep_alive [{}], wait_time [{}]",name,type,min,size,capacity.singles(),keepAlive,waitTime);
    }
    Executor executor=EsExecutors.newBlockingExecutorService(min,size,keepAlive.millis(),TimeUnit.MILLISECONDS,threadFactory,(int)capacity.singles(),waitTime.millis(),TimeUnit.MILLISECONDS);
    return new ExecutorHolder(executor,new Info(name,type,min,size,keepAlive,capacity,waitTime));
  }
  throw new ElasticSearchIllegalArgumentException("No type found [" + type + "], for ["+ name+ "]");
}
