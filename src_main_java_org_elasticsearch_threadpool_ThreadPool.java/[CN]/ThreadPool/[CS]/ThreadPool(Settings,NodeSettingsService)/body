{
  super(settings);
  Map<String,Settings> groupSettings=settings.getGroups(THREADPOOL_GROUP);
  int availableProcessors=EsExecutors.boundedNumberOfProcessors(settings);
  int halfProcMaxAt5=Math.min(((availableProcessors + 1) / 2),5);
  int halfProcMaxAt10=Math.min(((availableProcessors + 1) / 2),10);
  defaultExecutorTypeSettings=ImmutableMap.<String,Settings>builder().put(Names.GENERIC,settingsBuilder().put("type","cached").put("keep_alive","30s").build()).put(Names.INDEX,settingsBuilder().put("type","fixed").put("size",availableProcessors).put("queue_size",200).build()).put(Names.BULK,settingsBuilder().put("type","fixed").put("size",availableProcessors).put("queue_size",50).build()).put(Names.GET,settingsBuilder().put("type","fixed").put("size",availableProcessors).put("queue_size",1000).build()).put(Names.SEARCH,settingsBuilder().put("type","fixed").put("size",availableProcessors * 3).put("queue_size",1000).build()).put(Names.SUGGEST,settingsBuilder().put("type","fixed").put("size",availableProcessors).put("queue_size",1000).build()).put(Names.PERCOLATE,settingsBuilder().put("type","fixed").put("size",availableProcessors).put("queue_size",1000).build()).put(Names.MANAGEMENT,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",5).build()).put(Names.FLUSH,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",halfProcMaxAt5).build()).put(Names.MERGE,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",halfProcMaxAt5).build()).put(Names.REFRESH,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",halfProcMaxAt10).build()).put(Names.WARMER,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",halfProcMaxAt5).build()).put(Names.SNAPSHOT,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",halfProcMaxAt5).build()).put(Names.OPTIMIZE,settingsBuilder().put("type","fixed").put("size",1).build()).build();
  Map<String,ExecutorHolder> executors=Maps.newHashMap();
  for (  Map.Entry<String,Settings> executor : defaultExecutorTypeSettings.entrySet()) {
    executors.put(executor.getKey(),build(executor.getKey(),groupSettings.get(executor.getKey()),executor.getValue()));
  }
  executors.put(Names.SAME,new ExecutorHolder(MoreExecutors.sameThreadExecutor(),new Info(Names.SAME,"same")));
  if (!executors.get(Names.GENERIC).info.getType().equals("cached")) {
    throw new ElasticsearchIllegalArgumentException("generic thread pool must be of type cached");
  }
  this.executors=ImmutableMap.copyOf(executors);
  this.scheduler=new ScheduledThreadPoolExecutor(1,EsExecutors.daemonThreadFactory(settings,"scheduler"),new EsAbortPolicy());
  this.scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
  this.scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
  if (nodeSettingsService != null) {
    nodeSettingsService.addListener(new ApplySettings());
  }
  TimeValue estimatedTimeInterval=componentSettings.getAsTime("estimated_time_interval",TimeValue.timeValueMillis(200));
  this.estimatedTimeThread=new EstimatedTimeThread(EsExecutors.threadName(settings,"[timer]"),estimatedTimeInterval.millis());
  this.estimatedTimeThread.start();
}
