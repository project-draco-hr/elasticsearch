{
  super(settings);
  Map<String,Settings> groupSettings=settings.getGroups(THREADPOOL_GROUP);
  defaultExecutorTypeSettings=ImmutableMap.<String,Settings>builder().put(Names.GENERIC,settingsBuilder().put("type","cached").put("keep_alive","30s").build()).put(Names.INDEX,settingsBuilder().put("type","cached").build()).put(Names.BULK,settingsBuilder().put("type","cached").build()).put(Names.GET,settingsBuilder().put("type","cached").build()).put(Names.SEARCH,settingsBuilder().put("type","cached").build()).put(Names.PERCOLATE,settingsBuilder().put("type","cached").build()).put(Names.MANAGEMENT,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",5).build()).put(Names.FLUSH,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",10).build()).put(Names.MERGE,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",20).build()).put(Names.REFRESH,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",10).build()).put(Names.WARMER,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",Math.min(Runtime.getRuntime().availableProcessors() / 2,5)).build()).put(Names.CACHE,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",4).build()).put(Names.SNAPSHOT,settingsBuilder().put("type","scaling").put("keep_alive","5m").put("size",5).build()).build();
  Map<String,ExecutorHolder> executors=Maps.newHashMap();
  for (  Map.Entry<String,Settings> executor : defaultExecutorTypeSettings.entrySet()) {
    executors.put(executor.getKey(),build(executor.getKey(),groupSettings.get(executor.getKey()),executor.getValue()));
  }
  executors.put(Names.SAME,new ExecutorHolder(MoreExecutors.sameThreadExecutor(),new Info(Names.SAME,"same")));
  this.executors=ImmutableMap.copyOf(executors);
  this.scheduler=(ScheduledThreadPoolExecutor)Executors.newScheduledThreadPool(1,EsExecutors.daemonThreadFactory(settings,"scheduler"));
  this.scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
  this.scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
  if (nodeSettingsService != null) {
    nodeSettingsService.addListener(new ApplySettings());
  }
  TimeValue estimatedTimeInterval=componentSettings.getAsTime("estimated_time_interval",TimeValue.timeValueMillis(200));
  this.estimatedTimeThread=new EstimatedTimeThread(EsExecutors.threadName(settings,"[timer]"),estimatedTimeInterval.millis());
  this.estimatedTimeThread.start();
}
