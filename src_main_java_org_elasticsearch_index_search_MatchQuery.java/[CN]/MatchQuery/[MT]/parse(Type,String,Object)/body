{
  FieldMapper mapper=null;
  final String field;
  MapperService.SmartNameFieldMappers smartNameFieldMappers=parseContext.smartFieldMappers(fieldName);
  if (smartNameFieldMappers != null && smartNameFieldMappers.hasMapper()) {
    mapper=smartNameFieldMappers.mapper();
    field=mapper.names().indexName();
  }
 else {
    field=fieldName;
  }
  if (mapper != null && mapper.useTermQueryWithQueryString() && !forceAnalyzeQueryString()) {
    if (smartNameFieldMappers.explicitTypeInNameWithDocMapper()) {
      String[] previousTypes=QueryParseContext.setTypesWithPrevious(new String[]{smartNameFieldMappers.docMapper().type()});
      try {
        return wrapSmartNameQuery(mapper.termQuery(value,parseContext),smartNameFieldMappers,parseContext);
      }
 catch (      RuntimeException e) {
        if (lenient) {
          return null;
        }
        throw e;
      }
 finally {
        QueryParseContext.setTypes(previousTypes);
      }
    }
 else {
      try {
        return wrapSmartNameQuery(mapper.termQuery(value,parseContext),smartNameFieldMappers,parseContext);
      }
 catch (      RuntimeException e) {
        if (lenient) {
          return null;
        }
        throw e;
      }
    }
  }
  Analyzer analyzer=getAnalyzer(mapper,smartNameFieldMappers);
  MatchQueryBuilder builder=new MatchQueryBuilder(analyzer,mapper);
  builder.setEnablePositionIncrements(this.enablePositionIncrements);
  Query query=null;
switch (type) {
case BOOLEAN:
    if (commonTermsCutoff == null) {
      query=builder.createBooleanQuery(field,value.toString(),occur);
    }
 else {
      query=builder.createCommonTermsQuery(field,value.toString(),occur,occur,commonTermsCutoff);
    }
  break;
case PHRASE:
query=builder.createPhraseQuery(field,value.toString(),phraseSlop);
break;
case PHRASE_PREFIX:
query=builder.createPhrasePrefixQuery(field,value.toString(),phraseSlop,maxExpansions);
break;
default :
throw new ElasticsearchIllegalStateException("No type found for [" + type + "]");
}
if (query == null) {
return zeroTermsQuery();
}
 else {
return wrapSmartNameQuery(query,smartNameFieldMappers,parseContext);
}
}
