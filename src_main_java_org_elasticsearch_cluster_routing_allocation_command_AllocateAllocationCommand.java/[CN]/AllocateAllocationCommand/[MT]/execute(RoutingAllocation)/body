{
  DiscoveryNode discoNode=allocation.nodes().resolveNode(node);
  MutableShardRouting shardRouting=null;
  for (  MutableShardRouting routing : allocation.routingNodes().unassigned()) {
    if (routing.shardId().equals(shardId)) {
      if (shardRouting == null || routing.primary()) {
        shardRouting=routing;
      }
    }
  }
  if (shardRouting == null) {
    throw new ElasticsearchIllegalArgumentException("[allocate] failed to find " + shardId + " on the list of unassigned shards");
  }
  if (shardRouting.primary() && !allowPrimary) {
    throw new ElasticsearchIllegalArgumentException("[allocate] trying to allocate a primary shard " + shardId + "], which is disabled");
  }
  RoutingNode routingNode=allocation.routingNodes().node(discoNode.id());
  if (routingNode == null) {
    if (!discoNode.dataNode()) {
      throw new ElasticsearchIllegalArgumentException("Allocation can only be done on data nodes, not [" + node + "]");
    }
 else {
      throw new ElasticsearchIllegalStateException("Could not find [" + node + "] among the routing nodes");
    }
  }
  Decision decision=allocation.deciders().canAllocate(shardRouting,routingNode,allocation);
  if (decision.type() == Decision.Type.NO) {
    throw new ElasticsearchIllegalArgumentException("[allocate] allocation of " + shardId + " on node "+ discoNode+ " is not allowed, reason: "+ decision);
  }
  for (Iterator<MutableShardRouting> it=allocation.routingNodes().unassigned().iterator(); it.hasNext(); ) {
    if (it.next() != shardRouting) {
      continue;
    }
    it.remove();
    allocation.routingNodes().assign(shardRouting,routingNode.nodeId());
    if (shardRouting.primary()) {
      allocation.routingNodes().addClearPostAllocationFlag(shardRouting.shardId());
    }
    break;
  }
}
