{
  final String bloomFileName=IndexFileNames.segmentFileName(state.segmentInfo.name,state.segmentSuffix,BLOOM_EXTENSION);
  final Directory directory=state.directory;
  IndexInput dataInput=directory.openInput(bloomFileName,state.context);
  try {
    ChecksumIndexInput bloomIn=new BufferedChecksumIndexInput(dataInput.clone());
    version=CodecUtil.checkHeader(bloomIn,BLOOM_CODEC_NAME,BLOOM_CODEC_VERSION,BLOOM_CODEC_VERSION_CURRENT);
    final String delegatePostings=bloomIn.readString();
    int numBlooms=bloomIn.readInt();
    boolean load=false;
    Store.StoreDirectory storeDir=DirectoryUtils.getStoreDirectory(state.directory);
    if (storeDir != null && storeDir.codecService() != null) {
      load=storeDir.codecService().isLoadBloomFilter();
    }
    if (load) {
      for (int i=0; i < numBlooms; i++) {
        int fieldNum=bloomIn.readInt();
        FieldInfo fieldInfo=state.fieldInfos.fieldInfo(fieldNum);
        LazyBloomLoader loader=new LazyBloomLoader(bloomIn.getFilePointer(),dataInput);
        bloomsByFieldName.put(fieldInfo.name,loader);
        BloomFilter.skipBloom(bloomIn);
      }
      if (version >= BLOOM_CODEC_VERSION_CHECKSUM) {
        CodecUtil.checkFooter(bloomIn);
      }
 else {
        CodecUtil.checkEOF(bloomIn);
      }
    }
    this.delegateFieldsProducer=PostingsFormat.forName(delegatePostings).fieldsProducer(state);
    this.data=dataInput;
    dataInput=null;
  }
  finally {
    IOUtils.closeWhileHandlingException(dataInput);
  }
}
