{
  boolean http10=nettyRequest.getProtocolVersion().equals(HttpVersion.HTTP_1_0);
  boolean close=HttpHeaders.Values.CLOSE.equalsIgnoreCase(nettyRequest.headers().get(HttpHeaders.Names.CONNECTION)) || (http10 && !HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(nettyRequest.headers().get(HttpHeaders.Names.CONNECTION)));
  HttpResponseStatus status=getStatus(response.status());
  org.jboss.netty.handler.codec.http.HttpResponse resp;
  if (http10) {
    resp=new DefaultHttpResponse(HttpVersion.HTTP_1_0,status);
    if (!close) {
      resp.headers().add(HttpHeaders.Names.CONNECTION,"Keep-Alive");
    }
  }
 else {
    resp=new DefaultHttpResponse(HttpVersion.HTTP_1_1,status);
  }
  if (RestUtils.isBrowser(nettyRequest.headers().get(USER_AGENT))) {
    if (transport.settings().getAsBoolean(SETTING_CORS_ENABLED,false)) {
      String originHeader=request.header(ORIGIN);
      if (!Strings.isNullOrEmpty(originHeader)) {
        if (corsPattern == null) {
          resp.headers().add(ACCESS_CONTROL_ALLOW_ORIGIN,transport.settings().get(SETTING_CORS_ALLOW_ORIGIN,"*"));
        }
 else {
          resp.headers().add(ACCESS_CONTROL_ALLOW_ORIGIN,corsPattern.matcher(originHeader).matches() ? originHeader : "null");
        }
      }
      if (nettyRequest.getMethod() == HttpMethod.OPTIONS) {
        resp.headers().add(ACCESS_CONTROL_MAX_AGE,transport.settings().getAsInt(SETTING_CORS_MAX_AGE,1728000));
        resp.headers().add(ACCESS_CONTROL_ALLOW_METHODS,transport.settings().get(SETTING_CORS_ALLOW_METHODS,"OPTIONS, HEAD, GET, POST, PUT, DELETE"));
        resp.headers().add(ACCESS_CONTROL_ALLOW_HEADERS,transport.settings().get(SETTING_CORS_ALLOW_HEADERS,"X-Requested-With, Content-Type, Content-Length"));
      }
      if (transport.settings().getAsBoolean(SETTING_CORS_ALLOW_CREDENTIALS,false)) {
        resp.headers().add(ACCESS_CONTROL_ALLOW_CREDENTIALS,"true");
      }
    }
  }
  String opaque=nettyRequest.headers().get("X-Opaque-Id");
  if (opaque != null) {
    resp.headers().add("X-Opaque-Id",opaque);
  }
  Map<String,List<String>> customHeaders=response.getHeaders();
  if (customHeaders != null) {
    for (    Map.Entry<String,List<String>> headerEntry : customHeaders.entrySet()) {
      for (      String headerValue : headerEntry.getValue()) {
        resp.headers().add(headerEntry.getKey(),headerValue);
      }
    }
  }
  BytesReference content=response.content();
  ChannelBuffer buffer;
  boolean addedReleaseListener=false;
  try {
    if (response.contentThreadSafe()) {
      buffer=content.toChannelBuffer();
    }
 else {
      buffer=content.copyBytesArray().toChannelBuffer();
    }
    String callback=request.param("callback");
    if (callback != null) {
      final BytesRef callbackBytes=new BytesRef(callback);
      callbackBytes.bytes[callbackBytes.length]='(';
      callbackBytes.length++;
      buffer=ChannelBuffers.wrappedBuffer(NettyUtils.DEFAULT_GATHERING,ChannelBuffers.wrappedBuffer(callbackBytes.bytes,callbackBytes.offset,callbackBytes.length),buffer,ChannelBuffers.wrappedBuffer(END_JSONP));
      resp.headers().add(HttpHeaders.Names.CONTENT_TYPE,"application/javascript");
    }
    resp.setContent(buffer);
    if (!resp.headers().contains(HttpHeaders.Names.CONTENT_TYPE)) {
      resp.headers().add(HttpHeaders.Names.CONTENT_TYPE,response.contentType());
    }
    if (!resp.headers().contains(HttpHeaders.Names.CONTENT_LENGTH)) {
      resp.headers().add(HttpHeaders.Names.CONTENT_LENGTH,String.valueOf(buffer.readableBytes()));
    }
    if (transport.resetCookies) {
      String cookieString=nettyRequest.headers().get(HttpHeaders.Names.COOKIE);
      if (cookieString != null) {
        CookieDecoder cookieDecoder=new CookieDecoder();
        Set<Cookie> cookies=cookieDecoder.decode(cookieString);
        if (!cookies.isEmpty()) {
          CookieEncoder cookieEncoder=new CookieEncoder(true);
          for (          Cookie cookie : cookies) {
            cookieEncoder.addCookie(cookie);
          }
          resp.headers().add(HttpHeaders.Names.SET_COOKIE,cookieEncoder.encode());
        }
      }
    }
    ChannelFuture future=channel.write(resp);
    if (response.contentThreadSafe() && content instanceof Releasable) {
      future.addListener(new ReleaseChannelFutureListener((Releasable)content));
      addedReleaseListener=true;
    }
    if (close) {
      future.addListener(ChannelFutureListener.CLOSE);
    }
  }
  finally {
    if (!addedReleaseListener && content instanceof Releasable) {
      ((Releasable)content).close();
    }
  }
}
