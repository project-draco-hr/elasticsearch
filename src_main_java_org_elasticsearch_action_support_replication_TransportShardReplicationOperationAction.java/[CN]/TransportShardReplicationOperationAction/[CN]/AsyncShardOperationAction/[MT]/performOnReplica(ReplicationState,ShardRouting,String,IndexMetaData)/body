{
  if (!observer.observedState().nodes().nodeExists(nodeId)) {
    state.onReplicaFailure(nodeId,null);
    return;
  }
  final ReplicaOperationRequest shardRequest=new ReplicaOperationRequest(shardIt.shardId(),state.replicaRequest(),shard.currentNodeId());
  if (IndexMetaData.isIndexUsingShadowReplicas(indexMetaData.settings())) {
    state.onReplicaSuccess(newReplicaResponseInstance());
    return;
  }
  if (!nodeId.equals(observer.observedState().nodes().localNodeId())) {
    final DiscoveryNode node=observer.observedState().nodes().get(nodeId);
    transportService.sendRequest(node,transportReplicaAction,shardRequest,transportOptions,new TransportResponseHandler<ReplicaResponse>(){
      @Override public ReplicaResponse newInstance(){
        return newReplicaResponseInstance();
      }
      @Override public void handleResponse(      ReplicaResponse vResponse){
        state.onReplicaSuccess(vResponse);
      }
      @Override public void handleException(      TransportException exp){
        state.onReplicaFailure(nodeId,exp);
        logger.trace("[{}] Transport failure during replica request [{}] ",exp,node,internalRequest.request());
        if (!ignoreReplicaException(exp)) {
          logger.warn("Failed to perform " + actionName + " on remote replica "+ node+ shardIt.shardId(),exp);
          shardStateAction.shardFailed(shard,indexMetaData.getUUID(),"Failed to perform [" + actionName + "] on replica, message ["+ ExceptionsHelper.detailedMessage(exp)+ "]");
        }
      }
      @Override public String executor(){
        return ThreadPool.Names.SAME;
      }
    }
);
  }
 else {
    if (internalRequest.request().operationThreaded()) {
      try {
        threadPool.executor(executor).execute(new AbstractRunnable(){
          @Override protected void doRun(){
            try {
              ReplicaResponse response=shardOperationOnReplica(shardRequest);
              state.onReplicaSuccess(response);
            }
 catch (            Throwable e) {
              state.onReplicaFailure(nodeId,e);
              failReplicaIfNeeded(shard.index(),shard.id(),e);
            }
          }
          @Override public boolean isForceExecution(){
            return true;
          }
          @Override public void onFailure(          Throwable t){
            state.onReplicaFailure(nodeId,t);
          }
        }
);
      }
 catch (      Throwable e) {
        failReplicaIfNeeded(shard.index(),shard.id(),e);
        state.onReplicaFailure(nodeId,e);
      }
    }
 else {
      try {
        ReplicaResponse response=shardOperationOnReplica(shardRequest);
        state.onReplicaSuccess(response);
      }
 catch (      Throwable e) {
        failReplicaIfNeeded(shard.index(),shard.id(),e);
        state.onReplicaFailure(nodeId,e);
      }
    }
  }
}
