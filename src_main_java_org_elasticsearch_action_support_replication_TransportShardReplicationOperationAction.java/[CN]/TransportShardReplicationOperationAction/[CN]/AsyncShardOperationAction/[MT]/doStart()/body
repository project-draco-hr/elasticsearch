{
  try {
    ClusterBlockException blockException=checkGlobalBlock(observer.observedState());
    if (blockException != null) {
      if (blockException.retryable()) {
        logger.trace("cluster is blocked ({}), scheduling a retry",blockException.getMessage());
        retry(blockException);
        return;
      }
 else {
        throw blockException;
      }
    }
    if (resolveIndex()) {
      internalRequest.concreteIndex(observer.observedState().metaData().concreteSingleIndex(internalRequest.request().index(),internalRequest.request().indicesOptions()));
    }
 else {
      internalRequest.concreteIndex(internalRequest.request().index());
    }
    if (!resolveRequest(observer.observedState(),internalRequest,listener)) {
      return;
    }
    blockException=checkRequestBlock(observer.observedState(),internalRequest);
    if (blockException != null) {
      if (blockException.retryable()) {
        logger.trace("cluster is blocked ({}), scheduling a retry",blockException.getMessage());
        retry(blockException);
        return;
      }
 else {
        throw blockException;
      }
    }
    shardIt=shards(observer.observedState(),internalRequest);
  }
 catch (  Throwable e) {
    listener.onFailure(e);
    return;
  }
  if (shardIt.size() == 0) {
    logger.trace("no shard instances known for shard [{}], scheduling a retry",shardIt.shardId());
    retryBecauseUnavailable(shardIt.shardId(),"No active shards.");
    return;
  }
  boolean foundPrimary=false;
  ShardRouting shardX;
  while ((shardX=shardIt.nextOrNull()) != null) {
    final ShardRouting shard=shardX;
    if (!shard.primary()) {
      continue;
    }
    if (!shard.active() || !observer.observedState().nodes().nodeExists(shard.currentNodeId())) {
      logger.trace("primary shard [{}] is not yet active or we do not know the node it is assigned to [{}], scheduling a retry.",shard.shardId(),shard.currentNodeId());
      retryBecauseUnavailable(shardIt.shardId(),"Primary shard is not active or isn't assigned is a known node.");
      return;
    }
    if (!primaryOperationStarted.compareAndSet(false,true)) {
      return;
    }
    foundPrimary=true;
    if (shard.currentNodeId().equals(observer.observedState().nodes().localNodeId())) {
      try {
        if (internalRequest.request().operationThreaded()) {
          internalRequest.request().beforeLocalFork();
          threadPool.executor(executor).execute(new Runnable(){
            @Override public void run(){
              try {
                performOnPrimary(shard.id(),shard);
              }
 catch (              Throwable t) {
                listener.onFailure(t);
              }
            }
          }
);
        }
 else {
          performOnPrimary(shard.id(),shard);
        }
      }
 catch (      Throwable t) {
        listener.onFailure(t);
      }
    }
 else {
      DiscoveryNode node=observer.observedState().nodes().get(shard.currentNodeId());
      transportService.sendRequest(node,actionName,internalRequest.request(),transportOptions,new BaseTransportResponseHandler<Response>(){
        @Override public Response newInstance(){
          return newResponseInstance();
        }
        @Override public String executor(){
          return ThreadPool.Names.SAME;
        }
        @Override public void handleResponse(        Response response){
          listener.onResponse(response);
        }
        @Override public void handleException(        TransportException exp){
          if (exp.unwrapCause() instanceof ConnectTransportException || exp.unwrapCause() instanceof NodeClosedException || retryPrimaryException(exp)) {
            primaryOperationStarted.set(false);
            internalRequest.request().setCanHaveDuplicates();
            logger.trace("received an error from node the primary was assigned to ({}), scheduling a retry",exp.getMessage());
            retry(exp);
          }
 else {
            listener.onFailure(exp);
          }
        }
      }
);
    }
    break;
  }
  if (!foundPrimary) {
    logger.trace("couldn't find a eligible primary shard, scheduling for retry.");
    retryBecauseUnavailable(shardIt.shardId(),"No active shards.");
  }
}
