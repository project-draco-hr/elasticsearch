{
  if (!fromClusterEvent) {
    request.beforeLocalFork();
    request.operationThreaded(true);
    clusterService.add(request.timeout(),new TimeoutClusterStateListener(){
      @Override public void postAdded(){
        long sampledVersion=clusterState.version();
        long currentVersion=clusterService.state().version();
        if (sampledVersion != currentVersion) {
          logger.trace("state change while we were trying to add listener, trying to start again, sampled_version [{}], current_version [{}]",sampledVersion,currentVersion);
          if (start(true)) {
            clusterService.remove(this);
          }
        }
      }
      @Override public void onClose(){
        clusterService.remove(this);
        listener.onFailure(new NodeClosedException(clusterService.localNode()));
      }
      @Override public void clusterChanged(      ClusterChangedEvent event){
        logger.trace("cluster changed (version {}), trying to start again",event.state().version());
        if (start(true)) {
          clusterService.remove(this);
        }
      }
      @Override public void onTimeout(      TimeValue timeValue){
        if (start(true)) {
          clusterService.remove(this);
          return;
        }
        clusterService.remove(this);
        Throwable listenerFailure=failure;
        if (listenerFailure == null) {
          if (shardIt == null) {
            listenerFailure=new UnavailableShardsException(null,"no available shards: Timeout waiting for [" + timeValue + "], request: "+ request.toString());
          }
 else {
            listenerFailure=new UnavailableShardsException(shardIt.shardId(),"[" + shardIt.size() + "] shardIt, ["+ shardIt.sizeActive()+ "] active : Timeout waiting for ["+ timeValue+ "], request: "+ request.toString());
          }
        }
        listener.onFailure(listenerFailure);
      }
    }
);
  }
 else {
    logger.trace("retry scheduling ignored as it as we already have a listener in place");
  }
}
