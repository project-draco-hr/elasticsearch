{
  if (fromClusterEvent) {
    logger.trace("retry scheduling ignored as it as we already have a listener in place");
    return;
  }
  request.beforeLocalFork();
  request.operationThreaded(true);
  TimeValue timeout=new TimeValue(request.timeout().millis() - (System.currentTimeMillis() - startTime));
  if (timeout.millis() <= 0) {
    raiseTimeoutFailure(timeout,failure);
    return;
  }
  clusterService.add(timeout,new TimeoutClusterStateListener(){
    @Override public void postAdded(){
      long sampledVersion=clusterState.version();
      long currentVersion=clusterService.state().version();
      if (sampledVersion != currentVersion) {
        logger.trace("state change while we were trying to add listener, trying to start again, sampled_version [{}], current_version [{}]",sampledVersion,currentVersion);
        if (start(true)) {
          clusterService.remove(this);
        }
      }
    }
    @Override public void onClose(){
      clusterService.remove(this);
      listener.onFailure(new NodeClosedException(clusterService.localNode()));
    }
    @Override public void clusterChanged(    ClusterChangedEvent event){
      logger.trace("cluster changed (version {}), trying to start again",event.state().version());
      if (start(true)) {
        clusterService.remove(this);
      }
    }
    @Override public void onTimeout(    TimeValue timeValue){
      if (start(true)) {
        clusterService.remove(this);
        return;
      }
      clusterService.remove(this);
      raiseTimeoutFailure(timeValue,failure);
    }
  }
);
}
