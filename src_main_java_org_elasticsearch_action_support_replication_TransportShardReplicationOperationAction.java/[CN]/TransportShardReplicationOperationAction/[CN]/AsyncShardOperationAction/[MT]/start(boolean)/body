{
  this.clusterState=clusterService.state();
  try {
    ClusterBlockException blockException=checkGlobalBlock(clusterState,request);
    if (blockException != null) {
      if (blockException.retryable()) {
        retry(fromClusterEvent,blockException);
        return false;
      }
 else {
        throw blockException;
      }
    }
    if (!resolveRequest(clusterState,request,listener)) {
      return true;
    }
    blockException=checkRequestBlock(clusterState,request);
    if (blockException != null) {
      if (blockException.retryable()) {
        retry(fromClusterEvent,blockException);
        return false;
      }
 else {
        throw blockException;
      }
    }
    shardIt=shards(clusterState,request);
  }
 catch (  Throwable e) {
    listener.onFailure(e);
    return true;
  }
  if (shardIt.size() == 0) {
    retry(fromClusterEvent,null);
    return false;
  }
  boolean foundPrimary=false;
  ShardRouting shardX;
  while ((shardX=shardIt.nextOrNull()) != null) {
    final ShardRouting shard=shardX;
    if (!shard.primary()) {
      continue;
    }
    if (!shard.active() || !clusterState.nodes().nodeExists(shard.currentNodeId())) {
      retry(fromClusterEvent,null);
      return false;
    }
    if (checkWriteConsistency) {
      WriteConsistencyLevel consistencyLevel=defaultWriteConsistencyLevel;
      if (request.consistencyLevel() != WriteConsistencyLevel.DEFAULT) {
        consistencyLevel=request.consistencyLevel();
      }
      int requiredNumber=1;
      if (consistencyLevel == WriteConsistencyLevel.QUORUM && shardIt.size() > 2) {
        requiredNumber=(shardIt.size() / 2) + 1;
      }
 else       if (consistencyLevel == WriteConsistencyLevel.ALL) {
        requiredNumber=shardIt.size();
      }
      if (shardIt.sizeActive() < requiredNumber) {
        retry(fromClusterEvent,null);
        return false;
      }
    }
    if (!primaryOperationStarted.compareAndSet(false,true)) {
      return true;
    }
    foundPrimary=true;
    if (shard.currentNodeId().equals(clusterState.nodes().localNodeId())) {
      if (request.operationThreaded()) {
        request.beforeLocalFork();
        threadPool.executor(executor).execute(new Runnable(){
          @Override public void run(){
            performOnPrimary(shard.id(),fromClusterEvent,shard,clusterState);
          }
        }
);
      }
 else {
        performOnPrimary(shard.id(),fromClusterEvent,shard,clusterState);
      }
    }
 else {
      DiscoveryNode node=clusterState.nodes().get(shard.currentNodeId());
      transportService.sendRequest(node,transportAction,request,transportOptions,new BaseTransportResponseHandler<Response>(){
        @Override public Response newInstance(){
          return newResponseInstance();
        }
        @Override public String executor(){
          return ThreadPool.Names.SAME;
        }
        @Override public void handleResponse(        Response response){
          listener.onResponse(response);
        }
        @Override public void handleException(        TransportException exp){
          if (exp.unwrapCause() instanceof ConnectTransportException || exp.unwrapCause() instanceof NodeClosedException || retryPrimaryException(exp)) {
            primaryOperationStarted.set(false);
            retry(false,null);
          }
 else {
            listener.onFailure(exp);
          }
        }
      }
);
    }
    break;
  }
  if (!foundPrimary) {
    retry(fromClusterEvent,null);
    return false;
  }
  return true;
}
