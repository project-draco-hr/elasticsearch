{
  final Settings.Builder transientUpdates=Settings.settingsBuilder();
  final Settings.Builder persistentUpdates=Settings.settingsBuilder();
  clusterService.submitStateUpdateTask("cluster_update_settings",new AckedClusterStateUpdateTask<ClusterUpdateSettingsResponse>(Priority.IMMEDIATE,request,listener){
    private volatile boolean changed=false;
    @Override protected ClusterUpdateSettingsResponse newResponse(    boolean acknowledged){
      return new ClusterUpdateSettingsResponse(acknowledged,transientUpdates.build(),persistentUpdates.build());
    }
    @Override public void onAllNodesAcked(    @Nullable Throwable t){
      if (changed) {
        reroute(true);
      }
 else {
        super.onAllNodesAcked(t);
      }
    }
    @Override public void onAckTimeout(){
      if (changed) {
        reroute(false);
      }
 else {
        super.onAckTimeout();
      }
    }
    private void reroute(    final boolean updateSettingsAcked){
      if (!clusterService.state().nodes().localNodeMaster()) {
        logger.debug("Skipping reroute after cluster update settings, because node is no longer master");
        listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked,transientUpdates.build(),persistentUpdates.build()));
        return;
      }
      clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings",new AckedClusterStateUpdateTask<ClusterUpdateSettingsResponse>(Priority.URGENT,request,listener){
        @Override public boolean mustAck(        DiscoveryNode discoveryNode){
          return updateSettingsAcked;
        }
        @Override protected ClusterUpdateSettingsResponse newResponse(        boolean acknowledged){
          return new ClusterUpdateSettingsResponse(updateSettingsAcked && acknowledged,transientUpdates.build(),persistentUpdates.build());
        }
        @Override public void onNoLongerMaster(        String source){
          logger.debug("failed to preform reroute after cluster settings were updated - current node is no longer a master");
          listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked,transientUpdates.build(),persistentUpdates.build()));
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.debug("failed to perform [{}]",t,source);
          listener.onFailure(new ElasticsearchException("reroute after update settings failed",t));
        }
        @Override public ClusterState execute(        final ClusterState currentState){
          RoutingAllocation.Result routingResult=allocationService.reroute(currentState,"reroute after cluster update settings");
          if (!routingResult.changed()) {
            return currentState;
          }
          return ClusterState.builder(currentState).routingResult(routingResult).build();
        }
      }
);
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.debug("failed to perform [{}]",t,source);
      super.onFailure(source,t);
    }
    @Override public ClusterState execute(    final ClusterState currentState){
      Settings.Builder transientSettings=Settings.settingsBuilder();
      transientSettings.put(currentState.metaData().transientSettings());
      for (      Map.Entry<String,String> entry : request.transientSettings().getAsMap().entrySet()) {
        if (dynamicSettings.isLoggerSetting(entry.getKey()) || dynamicSettings.hasDynamicSetting(entry.getKey())) {
          transientSettings.put(entry.getKey(),entry.getValue());
          transientUpdates.put(entry.getKey(),entry.getValue());
          changed=true;
        }
 else {
          throw new IllegalArgumentException("transient setting [" + entry.getKey() + "], not dynamically updateable");
        }
      }
      Settings.Builder persistentSettings=Settings.settingsBuilder();
      persistentSettings.put(currentState.metaData().persistentSettings());
      for (      Map.Entry<String,String> entry : request.persistentSettings().getAsMap().entrySet()) {
        if (dynamicSettings.isLoggerSetting(entry.getKey()) || dynamicSettings.hasDynamicSetting(entry.getKey())) {
          persistentSettings.put(entry.getKey(),entry.getValue());
          persistentUpdates.put(entry.getKey(),entry.getValue());
          changed=true;
        }
 else {
          throw new IllegalArgumentException("persistent setting [" + entry.getKey() + "], not dynamically updateable");
        }
      }
      for (      String entry : request.getPersistentReset()) {
        Set<String> strings=persistentSettings.internalMap().keySet();
        Set<String> keysToRemove=new HashSet<String>();
        for (        String key : strings) {
          if (Regex.simpleMatch(entry,key)) {
            keysToRemove.add(key);
          }
        }
        for (        String keyToRemove : keysToRemove) {
          persistentSettings.remove(keyToRemove);
          persistentUpdates.remove(keyToRemove);
        }
        changed|=keysToRemove.isEmpty() == false;
      }
      for (      String entry : request.getTransientReset()) {
        Set<String> strings=transientSettings.internalMap().keySet();
        Set<String> keysToRemove=new HashSet<>();
        for (        String key : strings) {
          if (Regex.simpleMatch(entry,key)) {
            keysToRemove.add(key);
          }
        }
        for (        String keyToRemove : keysToRemove) {
          transientSettings.remove(keyToRemove);
          transientUpdates.remove(keyToRemove);
        }
        changed|=keysToRemove.isEmpty() == false;
      }
      if (!changed) {
        return currentState;
      }
      MetaData.Builder metaData=MetaData.builder(currentState.metaData()).persistentSettings(persistentSettings.build()).transientSettings(transientSettings.build());
      ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
      boolean updatedReadOnly=MetaData.SETTING_READ_ONLY_SETTING.get(metaData.persistentSettings()) || MetaData.SETTING_READ_ONLY_SETTING.get(metaData.transientSettings());
      if (updatedReadOnly) {
        blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);
      }
 else {
        blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);
      }
      ClusterState build=builder(currentState).metaData(metaData).blocks(blocks).build();
      Settings settings=build.metaData().settings();
      clusterSettingsService.dryRun(settings);
      return build;
    }
  }
);
}
