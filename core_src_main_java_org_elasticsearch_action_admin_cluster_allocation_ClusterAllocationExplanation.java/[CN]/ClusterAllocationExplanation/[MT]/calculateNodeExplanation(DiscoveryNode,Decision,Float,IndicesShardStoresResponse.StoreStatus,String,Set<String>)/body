{
  FinalDecision finalDecision;
  StoreCopy storeCopy;
  String finalExplanation;
  if (node.getId().equals(assignedNodeId)) {
    finalDecision=FinalDecision.ALREADY_ASSIGNED;
    finalExplanation="the shard is already assigned to this node";
  }
 else   if (nodeDecision.type() == Decision.Type.NO) {
    finalDecision=FinalDecision.NO;
    finalExplanation="the shard cannot be assigned because one or more allocation decider returns a 'NO' decision";
  }
 else {
    finalDecision=FinalDecision.YES;
    finalExplanation="the shard can be assigned";
  }
  if (storeStatus != null) {
    final Throwable storeErr=storeStatus.getStoreException();
    if (storeErr != null) {
      finalDecision=FinalDecision.NO;
      if (ExceptionsHelper.unwrapCause(storeErr) instanceof IOException) {
        storeCopy=StoreCopy.IO_ERROR;
        finalExplanation="there was an IO error reading from data in the shard store";
      }
 else {
        storeCopy=StoreCopy.CORRUPT;
        finalExplanation="the copy of data in the shard store is corrupt";
      }
    }
 else     if (activeAllocationIds.isEmpty() || activeAllocationIds.contains(storeStatus.getAllocationId())) {
      storeCopy=StoreCopy.AVAILABLE;
      finalExplanation="the shard can be assigned and the node contains a valid copy of the shard data";
    }
 else {
      storeCopy=StoreCopy.STALE;
      finalExplanation="the copy of the shard is stale, allocation ids do not match";
      finalDecision=FinalDecision.NO;
    }
  }
 else {
    storeCopy=StoreCopy.NONE;
  }
  return new NodeExplanation(node,nodeDecision,nodeWeight,storeStatus,finalDecision,finalExplanation,storeCopy);
}
