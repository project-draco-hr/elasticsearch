{
  clusterService.submitStateUpdateTask("index-aliases",Priority.URGENT,new TimeoutClusterStateUpdateTask(){
    @Override public TimeValue timeout(){
      return request.masterTimeout;
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    final ClusterState currentState){
      List<String> indicesToClose=Lists.newArrayList();
      Map<String,IndexService> indices=Maps.newHashMap();
      try {
        for (        AliasAction aliasAction : request.actions) {
          if (!Strings.hasText(aliasAction.alias()) || !Strings.hasText(aliasAction.index())) {
            throw new ElasticSearchIllegalArgumentException("Index name and alias name are required");
          }
          if (!currentState.metaData().hasIndex(aliasAction.index())) {
            throw new IndexMissingException(new Index(aliasAction.index()));
          }
          if (currentState.metaData().hasIndex(aliasAction.alias())) {
            throw new InvalidAliasNameException(new Index(aliasAction.index()),aliasAction.alias(),"an index exists with the same name as the alias");
          }
          if (aliasAction.indexRouting() != null && aliasAction.indexRouting().indexOf(',') != -1) {
            throw new ElasticSearchIllegalArgumentException("alias [" + aliasAction.alias() + "] has several routing values associated with it");
          }
        }
        boolean changed=false;
        MetaData.Builder builder=MetaData.builder(currentState.metaData());
        for (        AliasAction aliasAction : request.actions) {
          IndexMetaData indexMetaData=builder.get(aliasAction.index());
          if (indexMetaData == null) {
            throw new IndexMissingException(new Index(aliasAction.index()));
          }
          IndexMetaData.Builder indexMetaDataBuilder=IndexMetaData.builder(indexMetaData);
          if (aliasAction.actionType() == AliasAction.Type.ADD) {
            String filter=aliasAction.filter();
            if (Strings.hasLength(filter)) {
              IndexService indexService=indices.get(indexMetaData.index());
              if (indexService == null) {
                indexService=indicesService.indexService(indexMetaData.index());
                if (indexService == null) {
                  try {
                    indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),clusterService.localNode().id());
                    if (indexMetaData.mappings().containsKey(MapperService.DEFAULT_MAPPING)) {
                      indexService.mapperService().merge(MapperService.DEFAULT_MAPPING,indexMetaData.mappings().get(MapperService.DEFAULT_MAPPING).source().string(),false);
                    }
                    for (                    MappingMetaData mappingMetaData : indexMetaData.mappings().values()) {
                      indexService.mapperService().merge(mappingMetaData.type(),mappingMetaData.source().string(),false);
                    }
                  }
 catch (                  Exception e) {
                    logger.warn("[{}] failed to temporary create in order to apply alias action",e,indexMetaData.index());
                    continue;
                  }
                  indicesToClose.add(indexMetaData.index());
                }
                indices.put(indexMetaData.index(),indexService);
              }
              IndexQueryParserService indexQueryParser=indexService.queryParserService();
              try {
                XContentParser parser=XContentFactory.xContent(filter).createParser(filter);
                try {
                  indexQueryParser.parseInnerFilter(parser);
                }
  finally {
                  parser.close();
                }
              }
 catch (              Throwable e) {
                throw new ElasticSearchIllegalArgumentException("failed to parse filter for [" + aliasAction.alias() + "]",e);
              }
            }
            AliasMetaData newAliasMd=AliasMetaData.newAliasMetaDataBuilder(aliasAction.alias()).filter(filter).indexRouting(aliasAction.indexRouting()).searchRouting(aliasAction.searchRouting()).build();
            AliasMetaData aliasMd=indexMetaData.aliases().get(aliasAction.alias());
            if (aliasMd != null && aliasMd.equals(newAliasMd)) {
              continue;
            }
            indexMetaDataBuilder.putAlias(newAliasMd);
          }
 else           if (aliasAction.actionType() == AliasAction.Type.REMOVE) {
            if (!indexMetaData.aliases().containsKey(aliasAction.alias())) {
              continue;
            }
            indexMetaDataBuilder.removerAlias(aliasAction.alias());
          }
          changed=true;
          builder.put(indexMetaDataBuilder);
        }
        if (changed) {
          ClusterState updatedState=ClusterState.builder(currentState).metaData(builder).build();
          if (updatedState.metaData().aliases().equals(currentState.metaData().aliases())) {
            return currentState;
          }
          int responseCount=updatedState.nodes().size();
          long version=updatedState.version() + 1;
          logger.trace("waiting for [{}] notifications with version [{}]",responseCount,version);
          aliasOperationPerformedAction.add(new CountDownListener(responseCount,listener,version),request.timeout);
          return updatedState;
        }
 else {
          return currentState;
        }
      }
  finally {
        for (        String index : indicesToClose) {
          indicesService.removeIndex(index,"created for alias processing");
        }
      }
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      if (oldState == newState) {
        listener.onResponse(new Response(true));
      }
    }
  }
);
}
