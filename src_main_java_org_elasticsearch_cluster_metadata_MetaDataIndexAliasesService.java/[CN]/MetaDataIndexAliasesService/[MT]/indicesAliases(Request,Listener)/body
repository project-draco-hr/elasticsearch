{
  clusterService.submitStateUpdateTask("index-aliases",Priority.URGENT,new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      for (      AliasAction aliasAction : request.actions) {
        if (!currentState.metaData().hasIndex(aliasAction.index())) {
          listener.onFailure(new IndexMissingException(new Index(aliasAction.index())));
          return currentState;
        }
        if (currentState.metaData().hasIndex(aliasAction.alias())) {
          listener.onFailure(new InvalidAliasNameException(new Index(aliasAction.index()),aliasAction.alias(),"an index exists with the same name as the alias"));
          return currentState;
        }
        if (aliasAction.indexRouting() != null && aliasAction.indexRouting().indexOf(',') != -1) {
          listener.onFailure(new ElasticSearchIllegalArgumentException("alias [" + aliasAction.alias() + "] has several routing values associated with it"));
          return currentState;
        }
      }
      List<String> indicesToClose=Lists.newArrayList();
      Map<String,IndexService> indices=Maps.newHashMap();
      try {
        boolean changed=false;
        MetaData.Builder builder=newMetaDataBuilder().metaData(currentState.metaData());
        for (        AliasAction aliasAction : request.actions) {
          IndexMetaData indexMetaData=builder.get(aliasAction.index());
          if (indexMetaData == null) {
            throw new IndexMissingException(new Index(aliasAction.index()));
          }
          IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(indexMetaData);
          if (aliasAction.actionType() == AliasAction.Type.ADD) {
            String filter=aliasAction.filter();
            if (Strings.hasLength(filter)) {
              IndexService indexService=indices.get(indexMetaData.index());
              if (indexService == null) {
                indexService=indicesService.indexService(indexMetaData.index());
                if (indexService == null) {
                  try {
                    indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),currentState.nodes().localNode().id());
                  }
 catch (                  Exception e) {
                    logger.warn("[{}] failed to temporary create in order to apply alias action",e,indexMetaData.index());
                    continue;
                  }
                  indicesToClose.add(indexMetaData.index());
                }
                indices.put(indexMetaData.index(),indexService);
              }
              IndexQueryParserService indexQueryParser=indexService.queryParserService();
              try {
                XContentParser parser=XContentFactory.xContent(filter).createParser(filter);
                try {
                  indexQueryParser.parseInnerFilter(parser);
                }
  finally {
                  parser.close();
                }
              }
 catch (              Exception e) {
                listener.onFailure(new ElasticSearchIllegalArgumentException("failed to parse filter for [" + aliasAction.alias() + "]",e));
                return currentState;
              }
            }
            AliasMetaData newAliasMd=AliasMetaData.newAliasMetaDataBuilder(aliasAction.alias()).filter(filter).indexRouting(aliasAction.indexRouting()).searchRouting(aliasAction.searchRouting()).build();
            AliasMetaData aliasMd=indexMetaData.aliases().get(aliasAction.alias());
            if (aliasMd != null && aliasMd.equals(newAliasMd)) {
              continue;
            }
            indexMetaDataBuilder.putAlias(newAliasMd);
          }
 else           if (aliasAction.actionType() == AliasAction.Type.REMOVE) {
            if (!indexMetaData.aliases().containsKey(aliasAction.alias())) {
              continue;
            }
            indexMetaDataBuilder.removerAlias(aliasAction.alias());
          }
          changed=true;
          builder.put(indexMetaDataBuilder);
        }
        if (changed) {
          ClusterState updatedState=newClusterStateBuilder().state(currentState).metaData(builder).build();
          if (updatedState.metaData().aliases().equals(currentState.metaData().aliases())) {
            listener.onResponse(new Response(true));
            return currentState;
          }
          int responseCount=updatedState.nodes().size();
          long version=updatedState.version() + 1;
          logger.trace("waiting for [{}] notifications with version [{}]",responseCount,version);
          aliasOperationPerformedAction.add(new CountDownListener(responseCount,listener,version),request.timeout);
          return updatedState;
        }
 else {
          listener.onResponse(new Response(true));
          return currentState;
        }
      }
  finally {
        for (        String index : indicesToClose) {
          indicesService.cleanIndex(index,"created for alias processing");
        }
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
    }
  }
);
}
