{
  clusterService.submitStateUpdateTask("index-aliases",Priority.URGENT,new AckedClusterStateUpdateTask(){
    @Override public boolean mustAck(    DiscoveryNode discoveryNode){
      return true;
    }
    @Override public void onAllNodesAcked(    @Nullable Throwable t){
      listener.onResponse(new ClusterStateUpdateResponse(true));
    }
    @Override public void onAckTimeout(){
      listener.onResponse(new ClusterStateUpdateResponse(false));
    }
    @Override public TimeValue ackTimeout(){
      return request.ackTimeout();
    }
    @Override public TimeValue timeout(){
      return request.masterNodeTimeout();
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    final ClusterState currentState){
      List<String> indicesToClose=Lists.newArrayList();
      Map<String,IndexService> indices=Maps.newHashMap();
      try {
        for (        AliasAction aliasAction : request.actions()) {
          aliasValidator.validateAliasAction(aliasAction,currentState.metaData());
          if (!currentState.metaData().hasIndex(aliasAction.index())) {
            throw new IndexMissingException(new Index(aliasAction.index()));
          }
        }
        boolean changed=false;
        MetaData.Builder builder=MetaData.builder(currentState.metaData());
        for (        AliasAction aliasAction : request.actions()) {
          IndexMetaData indexMetaData=builder.get(aliasAction.index());
          if (indexMetaData == null) {
            throw new IndexMissingException(new Index(aliasAction.index()));
          }
          IndexMetaData.Builder indexMetaDataBuilder=IndexMetaData.builder(indexMetaData);
          if (aliasAction.actionType() == AliasAction.Type.ADD) {
            String filter=aliasAction.filter();
            if (Strings.hasLength(filter)) {
              IndexService indexService=indices.get(indexMetaData.index());
              if (indexService == null) {
                indexService=indicesService.indexService(indexMetaData.index());
                if (indexService == null) {
                  try {
                    indexService=indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),clusterService.localNode().id());
                    if (indexMetaData.mappings().containsKey(MapperService.DEFAULT_MAPPING)) {
                      indexService.mapperService().merge(MapperService.DEFAULT_MAPPING,indexMetaData.mappings().get(MapperService.DEFAULT_MAPPING).source(),false);
                    }
                    for (                    ObjectCursor<MappingMetaData> cursor : indexMetaData.mappings().values()) {
                      MappingMetaData mappingMetaData=cursor.value;
                      indexService.mapperService().merge(mappingMetaData.type(),mappingMetaData.source(),false);
                    }
                  }
 catch (                  Exception e) {
                    logger.warn("[{}] failed to temporary create in order to apply alias action",e,indexMetaData.index());
                    continue;
                  }
                  indicesToClose.add(indexMetaData.index());
                }
                indices.put(indexMetaData.index(),indexService);
              }
              aliasValidator.validateAliasFilter(aliasAction.alias(),filter,indexService.queryParserService());
            }
            AliasMetaData newAliasMd=AliasMetaData.newAliasMetaDataBuilder(aliasAction.alias()).filter(filter).indexRouting(aliasAction.indexRouting()).searchRouting(aliasAction.searchRouting()).build();
            AliasMetaData aliasMd=indexMetaData.aliases().get(aliasAction.alias());
            if (aliasMd != null && aliasMd.equals(newAliasMd)) {
              continue;
            }
            indexMetaDataBuilder.putAlias(newAliasMd);
          }
 else           if (aliasAction.actionType() == AliasAction.Type.REMOVE) {
            if (!indexMetaData.aliases().containsKey(aliasAction.alias())) {
              continue;
            }
            indexMetaDataBuilder.removeAlias(aliasAction.alias());
          }
          changed=true;
          builder.put(indexMetaDataBuilder);
        }
        if (changed) {
          ClusterState updatedState=ClusterState.builder(currentState).metaData(builder).build();
          if (!updatedState.metaData().aliases().equals(currentState.metaData().aliases())) {
            return updatedState;
          }
        }
        return currentState;
      }
  finally {
        for (        String index : indicesToClose) {
          indicesService.removeIndex(index,"created for alias processing");
        }
      }
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
    }
  }
);
}
