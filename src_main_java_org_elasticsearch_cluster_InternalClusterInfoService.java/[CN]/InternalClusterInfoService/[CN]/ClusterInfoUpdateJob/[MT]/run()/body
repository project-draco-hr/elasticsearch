{
  if (logger.isTraceEnabled()) {
    logger.trace("Performing ClusterInfoUpdateJob");
  }
  if (isMaster && this.reschedule) {
    if (logger.isTraceEnabled()) {
      logger.trace("Scheduling next run for updating cluster info in: {}",updateFrequency.toString());
    }
    try {
      threadPool.schedule(updateFrequency,executorName(),new SubmitReschedulingClusterInfoUpdatedJob());
    }
 catch (    EsRejectedExecutionException ex) {
      logger.debug("Reschedule cluster info service was rejected",ex);
    }
  }
  if (!enabled) {
    if (logger.isTraceEnabled()) {
      logger.trace("Skipping ClusterInfoUpdatedJob since it is disabled");
    }
    return;
  }
  NodesStatsRequest nodesStatsRequest=new NodesStatsRequest("data:true");
  nodesStatsRequest.clear();
  nodesStatsRequest.fs(true);
  nodesStatsRequest.timeout(TimeValue.timeValueSeconds(15));
  transportNodesStatsAction.execute(nodesStatsRequest,new ActionListener<NodesStatsResponse>(){
    @Override public void onResponse(    NodesStatsResponse nodeStatses){
      Map<String,DiskUsage> newUsages=new HashMap<>();
      for (      NodeStats nodeStats : nodeStatses.getNodes()) {
        if (nodeStats.getFs() == null) {
          logger.warn("Unable to retrieve node FS stats for {}",nodeStats.getNode().name());
        }
 else {
          long available=0;
          long total=0;
          for (          FsStats.Info info : nodeStats.getFs()) {
            available+=info.getAvailable().bytes();
            total+=info.getTotal().bytes();
          }
          String nodeId=nodeStats.getNode().id();
          if (logger.isTraceEnabled()) {
            logger.trace("node: [{}], total disk: {}, available disk: {}",nodeId,total,available);
          }
          newUsages.put(nodeId,new DiskUsage(nodeId,total,available));
        }
      }
      usages=ImmutableMap.copyOf(newUsages);
    }
    @Override public void onFailure(    Throwable e){
      logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob: " + e.getMessage());
      if (logger.isTraceEnabled()) {
        logger.trace("NodeStatsAction failure",e);
      }
    }
  }
);
  IndicesStatsRequest indicesStatsRequest=new IndicesStatsRequest();
  indicesStatsRequest.clear();
  indicesStatsRequest.store(true);
  transportIndicesStatsAction.execute(indicesStatsRequest,new ActionListener<IndicesStatsResponse>(){
    @Override public void onResponse(    IndicesStatsResponse indicesStatsResponse){
      ShardStats[] stats=indicesStatsResponse.getShards();
      HashMap<String,Long> newShardSizes=new HashMap<>();
      for (      ShardStats s : stats) {
        long size=s.getStats().getStore().sizeInBytes();
        String sid=shardIdentifierFromRouting(s.getShardRouting());
        if (logger.isTraceEnabled()) {
          logger.trace("shard: {} size: {}",sid,size);
        }
        newShardSizes.put(sid,size);
      }
      shardSizes=ImmutableMap.copyOf(newShardSizes);
    }
    @Override public void onFailure(    Throwable e){
      logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob: " + e.getMessage());
      if (logger.isTraceEnabled()) {
        logger.trace("IndicesStatsAction failure",e);
      }
    }
  }
);
  if (logger.isTraceEnabled()) {
    logger.trace("Finished ClusterInfoUpdateJob");
  }
}
