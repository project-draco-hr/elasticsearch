{
  createIndex("idx");
  createIndex("idx_unmapped");
  List<IndexRequestBuilder> builders=new ArrayList<>();
  interval=5;
  numBuckets=randomIntBetween(6,80);
  windowSize=randomIntBetween(3,10);
  alpha=randomDouble();
  beta=randomDouble();
  gapPolicy=randomBoolean() ? BucketHelpers.GapPolicy.SKIP : BucketHelpers.GapPolicy.INSERT_ZEROS;
  metric=randomMetric("the_metric",VALUE_FIELD);
  mockHisto=PipelineAggregationHelperTests.generateHistogram(interval,numBuckets,randomDouble(),randomDouble());
  testValues=new HashMap<>(8);
  for (  MovAvgType type : MovAvgType.values()) {
    for (    MetricTarget target : MetricTarget.values()) {
      setupExpected(type,target);
    }
  }
  for (  PipelineAggregationHelperTests.MockBucket mockBucket : mockHisto) {
    for (    double value : mockBucket.docValues) {
      builders.add(client().prepareIndex("idx","type").setSource(jsonBuilder().startObject().field(INTERVAL_FIELD,mockBucket.key).field(VALUE_FIELD,value).endObject()));
    }
  }
  builders.add(client().prepareIndex("idx","gap_type").setSource(jsonBuilder().startObject().field(INTERVAL_FIELD,0).field(GAP_FIELD,1).endObject()));
  builders.add(client().prepareIndex("idx","gap_type").setSource(jsonBuilder().startObject().field(INTERVAL_FIELD,49).field(GAP_FIELD,1).endObject()));
  indexRandom(true,builders);
  ensureSearchable();
}
