{
  if (!this.getClass().equals(mergeWith.getClass())) {
    String mergedType=mergeWith.getClass().getSimpleName();
    if (mergeWith instanceof AbstractFieldMapper) {
      mergedType=((AbstractFieldMapper)mergeWith).contentType();
    }
    mergeResult.addConflict("mapper [" + fieldType().names().fullName() + "] of different type, current_type ["+ contentType()+ "], merged_type ["+ mergedType+ "]");
    return;
  }
  AbstractFieldMapper fieldMergeWith=(AbstractFieldMapper)mergeWith;
  List<String> subConflicts=new ArrayList<>();
  boolean strict=this.fieldTypeRef.getNumAssociatedMappers() > 1 && mergeResult.updateAllTypes() == false;
  fieldType().checkCompatibility(fieldMergeWith.fieldType(),subConflicts,strict);
  for (  String conflict : subConflicts) {
    mergeResult.addConflict(conflict);
  }
  multiFields.merge(mergeWith,mergeResult);
  if (mergeResult.simulate() == false && mergeResult.hasConflicts() == false) {
    MappedFieldType fieldType=fieldMergeWith.fieldType().clone();
    fieldType.freeze();
    fieldTypeRef.set(fieldType);
    this.customFieldDataSettings=fieldMergeWith.customFieldDataSettings;
    this.copyTo=fieldMergeWith.copyTo;
  }
}
