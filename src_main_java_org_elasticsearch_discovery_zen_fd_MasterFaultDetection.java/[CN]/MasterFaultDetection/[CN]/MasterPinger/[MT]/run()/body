{
  if (!running) {
    return;
  }
  final DiscoveryNode masterToPing=masterNode;
  if (masterToPing == null) {
    threadPool.schedule(pingInterval,ThreadPool.Names.SAME,MasterPinger.this);
    return;
  }
  transportService.sendRequest(masterToPing,MASTER_PING_ACTION_NAME,new MasterPingRequest(nodesProvider.nodes().localNode().id(),masterToPing.id()),options().withType(TransportRequestOptions.Type.PING).withTimeout(pingRetryTimeout),new BaseTransportResponseHandler<MasterPingResponseResponse>(){
    @Override public MasterPingResponseResponse newInstance(){
      return new MasterPingResponseResponse();
    }
    @Override public void handleResponse(    MasterPingResponseResponse response){
      if (!running) {
        return;
      }
      MasterFaultDetection.this.retryCount=0;
      if (masterToPing.equals(MasterFaultDetection.this.masterNode())) {
        if (!response.connectedToMaster) {
          logger.trace("[master] [{}] does not have us registered with it...",masterToPing);
          notifyDisconnectedFromMaster();
        }
        threadPool.schedule(pingInterval,ThreadPool.Names.SAME,MasterPinger.this);
      }
    }
    @Override public void handleException(    TransportException exp){
      if (!running) {
        return;
      }
synchronized (masterNodeMutex) {
        if (masterToPing.equals(MasterFaultDetection.this.masterNode())) {
          if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {
            handleTransportDisconnect(masterToPing);
            return;
          }
 else           if (exp.getCause() instanceof NoLongerMasterException) {
            logger.debug("[master] pinging a master {} that is no longer a master",masterNode);
            notifyMasterFailure(masterToPing,"no longer master");
            return;
          }
 else           if (exp.getCause() instanceof NotMasterException) {
            logger.debug("[master] pinging a master {} that is not the master",masterNode);
            notifyMasterFailure(masterToPing,"not master");
            return;
          }
 else           if (exp.getCause() instanceof NodeDoesNotExistOnMasterException) {
            logger.debug("[master] pinging a master {} but we do not exists on it, act as if its master failure",masterNode);
            notifyMasterFailure(masterToPing,"do not exists on master, act as master failure");
            return;
          }
          int retryCount=++MasterFaultDetection.this.retryCount;
          logger.trace("[master] failed to ping [{}], retry [{}] out of [{}]",exp,masterNode,retryCount,pingRetryCount);
          if (retryCount >= pingRetryCount) {
            logger.debug("[master] failed to ping [{}], tried [{}] times, each with maximum [{}] timeout",masterNode,pingRetryCount,pingRetryTimeout);
            notifyMasterFailure(masterToPing,"failed to ping, tried [" + pingRetryCount + "] times, each with  maximum ["+ pingRetryTimeout+ "] timeout");
          }
 else {
            transportService.sendRequest(masterToPing,MASTER_PING_ACTION_NAME,new MasterPingRequest(nodesProvider.nodes().localNode().id(),masterToPing.id()),options().withType(TransportRequestOptions.Type.PING).withTimeout(pingRetryTimeout),this);
          }
        }
      }
    }
    @Override public String executor(){
      return ThreadPool.Names.SAME;
    }
  }
);
}
