{
  if (closed) {
    logger.trace("{} ignoring fetched [{}] results, already closed",shardId,type);
    return;
  }
  logger.trace("{} processing fetched [{}] results",shardId,type);
  if (responses != null) {
    for (    T response : responses) {
      NodeEntry<T> nodeEntry=cache.get(response.getNode().getId());
      if (nodeEntry == null) {
        continue;
      }
      if (nodeEntry.isFailed()) {
        logger.trace("{} node {} has failed for [{}] (failure [{}])",shardId,nodeEntry.getNodeId(),type,nodeEntry.getFailure());
      }
 else {
        logger.trace("{} marking {} as done for [{}]",shardId,nodeEntry.getNodeId(),type);
        nodeEntry.doneFetching(response);
      }
    }
  }
  if (failures != null) {
    for (    FailedNodeException failure : failures) {
      logger.trace("{} processing failure {} for [{}]",shardId,failure,type);
      NodeEntry<T> nodeEntry=cache.get(failure.nodeId());
      if (nodeEntry != null && nodeEntry.isFailed() == false) {
        Throwable unwrappedCause=ExceptionsHelper.unwrapCause(failure.getCause());
        if (unwrappedCause instanceof EsRejectedExecutionException || unwrappedCause instanceof ReceiveTimeoutTransportException || unwrappedCause instanceof ElasticsearchTimeoutException) {
          nodeEntry.restartFetching();
        }
 else {
          logger.warn("{}: failed to list shard for {} on node [{}]",failure,shardId,type,failure.nodeId());
          nodeEntry.doneFetching(failure.getCause());
        }
      }
    }
  }
  reroute(shardId,"post_response");
}
