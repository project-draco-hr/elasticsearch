{
  boolean changed=false;
  Set<String> liveNodeIds=newHashSet();
  for (  DiscoveryNode liveNode : liveNodes) {
    liveNodeIds.add(liveNode.id());
  }
  Set<String> nodeIdsToRemove=newHashSet();
  for (  RoutingNode routingNode : routingNodes) {
    for (Iterator<MutableShardRouting> shardsIterator=routingNode.shards().iterator(); shardsIterator.hasNext(); ) {
      MutableShardRouting shardRoutingEntry=shardsIterator.next();
      if (!shardRoutingEntry.assignedToNode()) {
        throw new ElasticSearchIllegalStateException(shardRoutingEntry.shardId() + " is not assigned to a node, but listed on as existing on node [" + routingNode.nodeId()+ "]");
      }
      boolean relocating=shardRoutingEntry.relocating();
      String relocatingNodeId=shardRoutingEntry.relocatingNodeId();
      boolean isRelocationDestinationShard=relocatingNodeId != null && shardRoutingEntry.initializing();
      boolean remove=false;
      boolean currentNodeIsDead=false;
      if (!liveNodeIds.contains(shardRoutingEntry.currentNodeId())) {
        changed=true;
        nodeIdsToRemove.add(shardRoutingEntry.currentNodeId());
        if (!isRelocationDestinationShard) {
          routingNodes.unassigned().add(shardRoutingEntry);
        }
        shardRoutingEntry.deassignNode();
        currentNodeIsDead=true;
        remove=true;
      }
      if (relocating && !liveNodeIds.contains(relocatingNodeId)) {
        nodeIdsToRemove.add(relocatingNodeId);
        if (!currentNodeIsDead) {
          changed=true;
          shardRoutingEntry.cancelRelocation();
        }
      }
      if (isRelocationDestinationShard && !liveNodeIds.contains(relocatingNodeId)) {
        changed=true;
        remove=true;
      }
      if (remove) {
        shardsIterator.remove();
      }
    }
  }
  for (  String nodeIdToRemove : nodeIdsToRemove) {
    routingNodes.nodesToShards().remove(nodeIdToRemove);
  }
  for (  RoutingNode routingNode : routingNodes) {
    for (Iterator<MutableShardRouting> shardsIterator=routingNode.shards().iterator(); shardsIterator.hasNext(); ) {
      MutableShardRouting shardRoutingEntry=shardsIterator.next();
      if (!shardRoutingEntry.assignedToNode()) {
        throw new ElasticSearchIllegalStateException(shardRoutingEntry.shardId() + " is not assigned to a node, but listed on as existing on node [" + routingNode.nodeId()+ "]");
      }
      if (shardRoutingEntry.primary()) {
        continue;
      }
      if (!shardRoutingEntry.initializing()) {
        continue;
      }
      if (shardRoutingEntry.relocatingNodeId() != null) {
        continue;
      }
      for (      MutableShardRouting unassignedShardRouting : routingNodes.unassigned()) {
        if (unassignedShardRouting.shardId().equals(shardRoutingEntry.shardId()) && unassignedShardRouting.primary()) {
          routingNodes.unassigned().add(shardRoutingEntry);
          shardRoutingEntry.deassignNode();
          shardsIterator.remove();
          break;
        }
      }
    }
  }
  return changed;
}
