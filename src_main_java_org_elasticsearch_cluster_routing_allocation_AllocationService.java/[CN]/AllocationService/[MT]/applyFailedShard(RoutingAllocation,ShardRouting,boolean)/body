{
  failedShard=new ImmutableShardRouting(failedShard);
  IndexRoutingTable indexRoutingTable=allocation.routingTable().index(failedShard.index());
  if (indexRoutingTable == null) {
    return false;
  }
  RoutingNodes routingNodes=allocation.routingNodes();
  if (failedShard.relocatingNodeId() != null) {
    if (failedShard.state() == INITIALIZING) {
      boolean dirty=false;
      RoutingNode initializingNode=routingNodes.node(failedShard.currentNodeId());
      if (initializingNode != null) {
        for (Iterator<MutableShardRouting> it=initializingNode.iterator(); it.hasNext(); ) {
          MutableShardRouting shardRouting=it.next();
          if (shardRouting.equals(failedShard)) {
            dirty=true;
            it.remove();
            routingNodes.deassignShard(shardRouting);
            if (addToIgnoreList) {
              allocation.addIgnoreShardForNode(failedShard.shardId(),failedShard.currentNodeId());
            }
            break;
          }
        }
      }
      if (dirty) {
        RoutingNode relocatingFromNode=routingNodes.node(failedShard.relocatingNodeId());
        if (relocatingFromNode != null) {
          for (Iterator<MutableShardRouting> it=relocatingFromNode.iterator(); it.hasNext(); ) {
            MutableShardRouting shardRouting=it.next();
            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == RELOCATING) {
              dirty=true;
              routingNodes.cancelRelocationForShard(shardRouting);
              break;
            }
          }
        }
      }
      return dirty;
    }
 else     if (failedShard.state() == RELOCATING) {
      boolean dirty=false;
      RoutingNode relocatingFromNode=routingNodes.node(failedShard.currentNodeId());
      if (relocatingFromNode != null) {
        for (Iterator<MutableShardRouting> it=relocatingFromNode.iterator(); it.hasNext(); ) {
          MutableShardRouting shardRouting=it.next();
          if (shardRouting.equals(failedShard)) {
            dirty=true;
            routingNodes.cancelRelocationForShard(shardRouting);
            it.remove();
            if (addToIgnoreList) {
              allocation.addIgnoreShardForNode(failedShard.shardId(),failedShard.currentNodeId());
            }
            routingNodes.unassigned().add(new MutableShardRouting(failedShard.index(),failedShard.id(),null,failedShard.primary(),ShardRoutingState.UNASSIGNED,failedShard.version() + 1));
            break;
          }
        }
      }
      if (dirty) {
        RoutingNode initializingNode=routingNodes.node(failedShard.relocatingNodeId());
        if (initializingNode != null) {
          for (Iterator<MutableShardRouting> it=initializingNode.iterator(); it.hasNext(); ) {
            MutableShardRouting shardRouting=it.next();
            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == INITIALIZING) {
              dirty=true;
              routingNodes.deassignShard(shardRouting);
              it.remove();
            }
          }
        }
      }
      return dirty;
    }
 else {
      throw new ElasticSearchIllegalStateException("illegal state for a failed shard, relocating node id is set, but state does not match: " + failedShard);
    }
  }
 else {
    boolean dirty=false;
    RoutingNode node=routingNodes.node(failedShard.currentNodeId());
    if (node != null) {
      for (Iterator<MutableShardRouting> it=node.iterator(); it.hasNext(); ) {
        MutableShardRouting shardRouting=it.next();
        if (shardRouting.equals(failedShard)) {
          dirty=true;
          if (addToIgnoreList) {
            allocation.addIgnoreShardForNode(failedShard.shardId(),failedShard.currentNodeId());
          }
          it.remove();
          List<MutableShardRouting> shardsToMove=Lists.newArrayList();
          for (Iterator<MutableShardRouting> unassignedIt=routingNodes.unassigned().iterator(); unassignedIt.hasNext(); ) {
            MutableShardRouting unassignedShardRouting=unassignedIt.next();
            if (unassignedShardRouting.shardId().equals(failedShard.shardId())) {
              unassignedIt.remove();
              shardsToMove.add(unassignedShardRouting);
            }
          }
          if (!shardsToMove.isEmpty()) {
            routingNodes.unassigned().addAll(shardsToMove);
          }
          routingNodes.unassigned().add(new MutableShardRouting(failedShard.index(),failedShard.id(),null,null,failedShard.restoreSource(),failedShard.primary(),ShardRoutingState.UNASSIGNED,failedShard.version() + 1));
          break;
        }
      }
    }
    return dirty;
  }
}
