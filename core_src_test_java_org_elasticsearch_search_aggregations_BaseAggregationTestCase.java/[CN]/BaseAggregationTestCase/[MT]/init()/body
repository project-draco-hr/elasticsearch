{
  Version version=randomBoolean() ? Version.CURRENT : VersionUtils.randomVersionBetween(random(),Version.V_2_0_0_beta1,Version.CURRENT);
  Settings settings=Settings.settingsBuilder().put("node.name",AbstractQueryTestCase.class.toString()).put(Environment.PATH_HOME_SETTING.getKey(),createTempDir()).put(ScriptService.SCRIPT_AUTO_RELOAD_ENABLED_SETTING.getKey(),false).build();
  namedWriteableRegistry=new NamedWriteableRegistry();
  index=new Index(randomAsciiOfLengthBetween(1,10),"_na_");
  Settings indexSettings=Settings.settingsBuilder().put(IndexMetaData.SETTING_VERSION_CREATED,version).build();
  final TestClusterService clusterService=new TestClusterService();
  clusterService.setState(new ClusterState.Builder(clusterService.state()).metaData(new MetaData.Builder().put(new IndexMetaData.Builder(index.getName()).settings(indexSettings).numberOfShards(1).numberOfReplicas(0))));
  SettingsModule settingsModule=new SettingsModule(settings,new SettingsFilter(settings));
  settingsModule.registerSetting(InternalSettingsPlugin.VERSION_CREATED);
  ScriptModule scriptModule=new ScriptModule(){
    @Override protected void configure(){
      Settings settings=Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(),createTempDir()).put(ScriptService.SCRIPT_AUTO_RELOAD_ENABLED_SETTING.getKey(),false).build();
      MockScriptEngine mockScriptEngine=new MockScriptEngine();
      Multibinder<ScriptEngineService> multibinder=Multibinder.newSetBinder(binder(),ScriptEngineService.class);
      multibinder.addBinding().toInstance(mockScriptEngine);
      Set<ScriptEngineService> engines=new HashSet<>();
      engines.add(mockScriptEngine);
      List<ScriptContext.Plugin> customContexts=new ArrayList<>();
      ScriptEngineRegistry scriptEngineRegistry=new ScriptEngineRegistry(Collections.singletonList(new ScriptEngineRegistry.ScriptEngineRegistration(MockScriptEngine.class,MockScriptEngine.TYPES)));
      bind(ScriptEngineRegistry.class).toInstance(scriptEngineRegistry);
      ScriptContextRegistry scriptContextRegistry=new ScriptContextRegistry(customContexts);
      bind(ScriptContextRegistry.class).toInstance(scriptContextRegistry);
      ScriptSettings scriptSettings=new ScriptSettings(scriptEngineRegistry,scriptContextRegistry);
      bind(ScriptSettings.class).toInstance(scriptSettings);
      try {
        ScriptService scriptService=new ScriptService(settings,new Environment(settings),engines,null,scriptEngineRegistry,scriptContextRegistry,scriptSettings);
        bind(ScriptService.class).toInstance(scriptService);
      }
 catch (      IOException e) {
        throw new IllegalStateException("error while binding ScriptService",e);
      }
    }
  }
;
  scriptModule.prepareSettings(settingsModule);
  injector=new ModulesBuilder().add(new EnvironmentModule(new Environment(settings)),settingsModule,new ThreadPoolModule(new ThreadPool(settings)),scriptModule,new IndicesModule(){
    @Override protected void configure(){
      bindMapperExtension();
    }
  }
,new SearchModule(settings,namedWriteableRegistry){
    @Override protected void configureSearch(){
    }
    @Override protected void configureSuggesters(){
    }
  }
,new IndexSettingsModule(index,settings),new AbstractModule(){
    @Override protected void configure(){
      bind(ClusterService.class).toProvider(Providers.of(clusterService));
      bind(CircuitBreakerService.class).to(NoneCircuitBreakerService.class);
      bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry);
    }
  }
).createInjector();
  aggParsers=injector.getInstance(AggregatorParsers.class);
  currentTypes=new String[randomIntBetween(0,5)];
  for (int i=0; i < currentTypes.length; i++) {
    String type=randomAsciiOfLengthBetween(1,10);
    currentTypes[i]=type;
  }
  queriesRegistry=injector.getInstance(IndicesQueriesRegistry.class);
  parseFieldMatcher=ParseFieldMatcher.STRICT;
}
