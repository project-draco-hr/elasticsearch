{
  ObjectOpenHashSet<String> nodesIds=ObjectOpenHashSet.from(clusterService.state().nodes().masterNodes().keys());
  logger.trace("performing state recovery from {}",nodesIds);
  TransportNodesListGatewayMetaState.NodesGatewayMetaState nodesState=listGatewayMetaState.list(nodesIds.toArray(String.class),null).actionGet();
  int requiredAllocation=1;
  try {
    if ("quorum".equals(initialMeta)) {
      if (nodesIds.size() > 2) {
        requiredAllocation=(nodesIds.size() / 2) + 1;
      }
    }
 else     if ("quorum-1".equals(initialMeta) || "half".equals(initialMeta)) {
      if (nodesIds.size() > 2) {
        requiredAllocation=((1 + nodesIds.size()) / 2);
      }
    }
 else     if ("one".equals(initialMeta)) {
      requiredAllocation=1;
    }
 else     if ("full".equals(initialMeta) || "all".equals(initialMeta)) {
      requiredAllocation=nodesIds.size();
    }
 else     if ("full-1".equals(initialMeta) || "all-1".equals(initialMeta)) {
      if (nodesIds.size() > 1) {
        requiredAllocation=nodesIds.size() - 1;
      }
    }
 else {
      requiredAllocation=Integer.parseInt(initialMeta);
    }
  }
 catch (  Exception e) {
    logger.warn("failed to derived initial_meta from value {}",initialMeta);
  }
  if (nodesState.failures().length > 0) {
    for (    FailedNodeException failedNodeException : nodesState.failures()) {
      logger.warn("failed to fetch state from node",failedNodeException);
    }
  }
  ObjectFloatOpenHashMap<String> indices=new ObjectFloatOpenHashMap<>();
  MetaData electedGlobalState=null;
  int found=0;
  for (  TransportNodesListGatewayMetaState.NodeGatewayMetaState nodeState : nodesState) {
    if (nodeState.metaData() == null) {
      continue;
    }
    found++;
    if (electedGlobalState == null) {
      electedGlobalState=nodeState.metaData();
    }
 else     if (nodeState.metaData().version() > electedGlobalState.version()) {
      electedGlobalState=nodeState.metaData();
    }
    for (    ObjectCursor<IndexMetaData> cursor : nodeState.metaData().indices().values()) {
      indices.addTo(cursor.value.index(),1);
    }
  }
  if (found < requiredAllocation) {
    listener.onFailure("found [" + found + "] metadata states, required ["+ requiredAllocation+ "]");
    return;
  }
  MetaData.Builder metaDataBuilder=MetaData.builder(electedGlobalState).removeAllIndices();
  final boolean[] states=indices.allocated;
  final Object[] keys=indices.keys;
  for (int i=0; i < states.length; i++) {
    if (states[i]) {
      String index=(String)keys[i];
      IndexMetaData electedIndexMetaData=null;
      int indexMetaDataCount=0;
      for (      TransportNodesListGatewayMetaState.NodeGatewayMetaState nodeState : nodesState) {
        if (nodeState.metaData() == null) {
          continue;
        }
        IndexMetaData indexMetaData=nodeState.metaData().index(index);
        if (indexMetaData == null) {
          continue;
        }
        if (electedIndexMetaData == null) {
          electedIndexMetaData=indexMetaData;
        }
 else         if (indexMetaData.version() > electedIndexMetaData.version()) {
          electedIndexMetaData=indexMetaData;
        }
        indexMetaDataCount++;
      }
      if (electedIndexMetaData != null) {
        if (indexMetaDataCount < requiredAllocation) {
          logger.debug("[{}] found [{}], required [{}], not adding",index,indexMetaDataCount,requiredAllocation);
        }
        metaDataBuilder.put(electedIndexMetaData,false);
      }
    }
  }
  ClusterState.Builder builder=ClusterState.builder(clusterName);
  builder.metaData(metaDataBuilder);
  listener.onSuccess(builder.build());
}
