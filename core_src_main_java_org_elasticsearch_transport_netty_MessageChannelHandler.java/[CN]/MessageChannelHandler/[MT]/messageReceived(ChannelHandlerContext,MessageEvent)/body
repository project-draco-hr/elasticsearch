{
  Transports.assertTransportThread();
  Object m=e.getMessage();
  if (!(m instanceof ChannelBuffer)) {
    ctx.sendUpstream(e);
    return;
  }
  ChannelBuffer buffer=(ChannelBuffer)m;
  int size=buffer.getInt(buffer.readerIndex() - 4);
  transportServiceAdapter.received(size + 6);
  boolean hasMessageBytesToRead=(size - (NettyHeader.HEADER_SIZE - 6)) != 0;
  int markedReaderIndex=buffer.readerIndex();
  int expectedIndexReader=markedReaderIndex + size;
  StreamInput streamIn=ChannelBufferStreamInputFactory.create(buffer,size);
  long requestId=buffer.readLong();
  byte status=buffer.readByte();
  Version version=Version.fromId(buffer.readInt());
  StreamInput wrappedStream=null;
  try {
    if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable()) {
      Compressor compressor;
      try {
        compressor=CompressorFactory.compressor(buffer);
      }
 catch (      NotCompressedException ex) {
        int maxToRead=Math.min(buffer.readableBytes(),10);
        int offset=buffer.readerIndex();
        StringBuilder sb=new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(buffer.readableBytes()).append("] readable bytes with message size [").append(size).append("] ").append("] are [");
        for (int i=0; i < maxToRead; i++) {
          sb.append(buffer.getByte(offset + i)).append(",");
        }
        sb.append("]");
        throw new IllegalStateException(sb.toString());
      }
      wrappedStream=compressor.streamInput(streamIn);
    }
 else {
      wrappedStream=streamIn;
    }
    wrappedStream=new FilterStreamInput(wrappedStream,namedWriteableRegistry);
    wrappedStream.setVersion(version);
    if (TransportStatus.isRequest(status)) {
      String action=handleRequest(ctx.getChannel(),wrappedStream,requestId,version);
      boolean success=false;
      try {
        final int nextByte=wrappedStream.read();
        if (nextByte != -1) {
          throw new IllegalStateException("Message not fully read (request) for requestId [" + requestId + "], action ["+ action+ "], readerIndex ["+ buffer.readerIndex()+ "] vs expected ["+ expectedIndexReader+ "]; resetting");
        }
        if (buffer.readerIndex() < expectedIndexReader) {
          throw new IllegalStateException("Message is fully read (request), yet there are " + (expectedIndexReader - buffer.readerIndex()) + " remaining bytes; resetting");
        }
        if (buffer.readerIndex() > expectedIndexReader) {
          throw new IllegalStateException("Message read past expected size (request) for requestId [" + requestId + "], action ["+ action+ "], readerIndex ["+ buffer.readerIndex()+ "] vs expected ["+ expectedIndexReader+ "]; resetting");
        }
        success=true;
      }
  finally {
        if (!success) {
          buffer.readerIndex(expectedIndexReader);
        }
      }
    }
 else {
      TransportResponseHandler handler=transportServiceAdapter.onResponseReceived(requestId);
      if (handler != null) {
        if (TransportStatus.isError(status)) {
          handlerResponseError(wrappedStream,handler);
        }
 else {
          handleResponse(ctx.getChannel(),wrappedStream,handler);
        }
      }
 else {
        buffer.readerIndex(markedReaderIndex + size);
      }
      boolean success=false;
      try {
        final int nextByte=wrappedStream.read();
        if (nextByte != -1) {
          throw new IllegalStateException("Message not fully read (response) for requestId [" + requestId + "], handler ["+ handler+ "], error ["+ TransportStatus.isError(status)+ "]; resetting");
        }
        if (buffer.readerIndex() < expectedIndexReader) {
          throw new IllegalStateException("Message is fully read (response), yet there are " + (expectedIndexReader - buffer.readerIndex()) + " remaining bytes; resetting");
        }
        if (buffer.readerIndex() > expectedIndexReader) {
          throw new IllegalStateException("Message read past expected size (response) for requestId [" + requestId + "], handler ["+ handler+ "], error ["+ TransportStatus.isError(status)+ "]; resetting");
        }
        success=true;
      }
  finally {
        if (!success) {
          buffer.readerIndex(expectedIndexReader);
        }
      }
    }
  }
  finally {
    IOUtils.close(wrappedStream);
  }
}
