{
  Transports.assertTransportThread();
  Object m=e.getMessage();
  if (!(m instanceof ChannelBuffer)) {
    ctx.sendUpstream(e);
    return;
  }
  ChannelBuffer buffer=(ChannelBuffer)m;
  Marker marker=new Marker(buffer);
  int size=marker.messageSizeWithRemainingHeaders();
  transportServiceAdapter.received(marker.messageSizeWithAllHeaders());
  boolean hasMessageBytesToRead=marker.messageSize() != 0;
  StreamInput streamIn=ChannelBufferStreamInputFactory.create(buffer,size);
  boolean success=false;
  try (ThreadContext.StoredContext tCtx=threadContext.stashContext()){
    long requestId=streamIn.readLong();
    byte status=streamIn.readByte();
    Version version=Version.fromId(streamIn.readInt());
    if (TransportStatus.isCompress(status) && hasMessageBytesToRead && buffer.readable()) {
      Compressor compressor;
      try {
        compressor=CompressorFactory.compressor(new ChannelBufferBytesReference(buffer));
      }
 catch (      NotCompressedException ex) {
        int maxToRead=Math.min(buffer.readableBytes(),10);
        int offset=buffer.readerIndex();
        StringBuilder sb=new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(buffer.readableBytes()).append("] readable bytes with message size [").append(size).append("] ").append("] are [");
        for (int i=0; i < maxToRead; i++) {
          sb.append(buffer.getByte(offset + i)).append(",");
        }
        sb.append("]");
        throw new IllegalStateException(sb.toString());
      }
      streamIn=compressor.streamInput(streamIn);
    }
    if (version.onOrAfter(Version.CURRENT.minimumCompatibilityVersion()) == false || version.major != Version.CURRENT.major) {
      throw new IllegalStateException("Received message from unsupported version: [" + version + "] minimal compatible version is: ["+ Version.CURRENT.minimumCompatibilityVersion()+ "]");
    }
    streamIn.setVersion(version);
    if (TransportStatus.isRequest(status)) {
      threadContext.readHeaders(streamIn);
      handleRequest(ctx.getChannel(),marker,streamIn,requestId,size,version);
    }
 else {
      TransportResponseHandler<?> handler=transportServiceAdapter.onResponseReceived(requestId);
      if (handler != null) {
        if (TransportStatus.isError(status)) {
          handlerResponseError(streamIn,handler);
        }
 else {
          handleResponse(ctx.getChannel(),streamIn,handler);
        }
        marker.validateResponse(streamIn,requestId,handler,TransportStatus.isError(status));
      }
    }
    success=true;
  }
  finally {
    try {
      if (success) {
        IOUtils.close(streamIn);
      }
 else {
        IOUtils.closeWhileHandlingException(streamIn);
      }
    }
  finally {
      buffer.readerIndex(marker.expectedReaderIndex());
    }
  }
}
