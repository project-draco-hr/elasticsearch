{
  final ShardId shardId=new ShardId(new Index("index"),1);
  DirectoryService directoryService=new LuceneManagedDirectoryService(random());
  Store store=new Store(shardId,Settings.EMPTY,directoryService,new DummyShardLock(shardId));
  final boolean usesOldCodec=randomBoolean();
  IndexWriter writer=new IndexWriter(store.directory(),newIndexWriterConfig(random(),new MockAnalyzer(random())).setCodec(usesOldCodec ? new OldSIMockingCodec() : TestUtil.getDefaultCodec()));
  int docs=1 + random().nextInt(100);
  for (int i=0; i < docs; i++) {
    Document doc=new Document();
    doc.add(new TextField("id","" + i,random().nextBoolean() ? Field.Store.YES : Field.Store.NO));
    doc.add(new TextField("body",TestUtil.randomRealisticUnicodeString(random()),random().nextBoolean() ? Field.Store.YES : Field.Store.NO));
    doc.add(new SortedDocValuesField("dv",new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));
    writer.addDocument(doc);
  }
  if (random().nextBoolean()) {
    for (int i=0; i < docs; i++) {
      if (random().nextBoolean()) {
        Document doc=new Document();
        doc.add(new TextField("id","" + i,random().nextBoolean() ? Field.Store.YES : Field.Store.NO));
        doc.add(new TextField("body",TestUtil.randomRealisticUnicodeString(random()),random().nextBoolean() ? Field.Store.YES : Field.Store.NO));
        writer.updateDocument(new Term("id","" + i),doc);
      }
    }
  }
  if (random().nextBoolean()) {
    DirectoryReader.open(writer,random().nextBoolean()).close();
  }
  Store.MetadataSnapshot metadata;
  try {
    store.getMetadata();
    fail("no index present - expected exception");
  }
 catch (  IndexNotFoundException ex) {
  }
  assertThat(store.getMetadataOrEmpty(),is(Store.MetadataSnapshot.EMPTY));
  writer.close();
  Store.LegacyChecksums checksums=new Store.LegacyChecksums();
  Map<String,StoreFileMetaData> legacyMeta=new HashMap<>();
  for (  String file : store.directory().listAll()) {
    if (file.equals("write.lock") || file.equals(IndexFileNames.OLD_SEGMENTS_GEN) || file.startsWith("extra")) {
      continue;
    }
    BytesRef hash=new BytesRef();
    if (file.startsWith("segments")) {
      hash=Store.MetadataSnapshot.hashFile(store.directory(),file);
    }
    StoreFileMetaData storeFileMetaData=new StoreFileMetaData(file,store.directory().fileLength(file),file + "checksum",null,hash);
    legacyMeta.put(file,storeFileMetaData);
    checksums.add(storeFileMetaData);
  }
  checksums.write(store);
  metadata=store.getMetadata();
  Map<String,StoreFileMetaData> stringStoreFileMetaDataMap=metadata.asMap();
  assertThat(legacyMeta.size(),equalTo(stringStoreFileMetaDataMap.size()));
  if (usesOldCodec) {
    for (    StoreFileMetaData meta : legacyMeta.values()) {
      assertTrue(meta.toString(),stringStoreFileMetaDataMap.containsKey(meta.name()));
      assertEquals(meta.name() + "checksum",meta.checksum());
      assertTrue(meta + " vs. " + stringStoreFileMetaDataMap.get(meta.name()),stringStoreFileMetaDataMap.get(meta.name()).isSame(meta));
    }
  }
 else {
    for (    StoreFileMetaData meta : legacyMeta.values()) {
      assertTrue(meta.toString(),stringStoreFileMetaDataMap.containsKey(meta.name()));
      assertFalse(meta + " vs. " + stringStoreFileMetaDataMap.get(meta.name()),stringStoreFileMetaDataMap.get(meta.name()).isSame(meta));
      StoreFileMetaData storeFileMetaData=metadata.get(meta.name());
      try (IndexInput input=store.openVerifyingInput(meta.name(),IOContext.DEFAULT,storeFileMetaData)){
        assertTrue(storeFileMetaData.toString(),input instanceof Store.VerifyingIndexInput);
        input.seek(meta.length());
        Store.verify(input);
      }
     }
  }
  assertDeleteContent(store,directoryService);
  IOUtils.close(store);
}
