{
  String shardsAllocatorType=shardsAllocators.bindType(binder(),settings,ClusterModule.SHARDS_ALLOCATOR_TYPE_SETTING.getKey(),ClusterModule.BALANCED_ALLOCATOR);
  if (shardsAllocatorType.equals(ClusterModule.EVEN_SHARD_COUNT_ALLOCATOR)) {
    final ESLogger logger=Loggers.getLogger(getClass(),settings);
    logger.warn("{} allocator has been removed in 2.0 using {} instead",ClusterModule.EVEN_SHARD_COUNT_ALLOCATOR,ClusterModule.BALANCED_ALLOCATOR);
  }
  allocationDeciders.bind(binder());
  indexTemplateFilters.bind(binder());
  bind(ClusterInfoService.class).to(clusterInfoServiceImpl).asEagerSingleton();
  bind(GatewayAllocator.class).asEagerSingleton();
  bind(AllocationService.class).asEagerSingleton();
  bind(ClusterService.class).toInstance(clusterService);
  bind(NodeConnectionsService.class).asEagerSingleton();
  bind(MetaDataCreateIndexService.class).asEagerSingleton();
  bind(MetaDataDeleteIndexService.class).asEagerSingleton();
  bind(MetaDataIndexStateService.class).asEagerSingleton();
  bind(MetaDataMappingService.class).asEagerSingleton();
  bind(MetaDataIndexAliasesService.class).asEagerSingleton();
  bind(MetaDataUpdateSettingsService.class).asEagerSingleton();
  bind(MetaDataIndexTemplateService.class).asEagerSingleton();
  bind(IndexNameExpressionResolver.class).toInstance(indexNameExpressionResolver);
  bind(RoutingService.class).asEagerSingleton();
  bind(DelayedAllocationService.class).asEagerSingleton();
  bind(ShardStateAction.class).asEagerSingleton();
  bind(NodeMappingRefreshAction.class).asEagerSingleton();
  bind(MappingUpdatedAction.class).asEagerSingleton();
  bind(TaskPersistenceService.class).asEagerSingleton();
}
