{
  if (committedTranslogId != null) {
    try {
      translog.markCommitted(committedTranslogId);
    }
 catch (    FileNotFoundException ex) {
      if (engineConfig.getIgnoreUnknownTranslog()) {
        logger.warn("ignoring committed translog id [{}] ([{}] set to true)",committedTranslogId,EngineConfig.INDEX_IGNORE_UNKNOWN_TRANSLOG);
      }
 else {
        throw ex;
      }
    }
  }
  int opsRecovered=0;
  final TranslogRecoveryPerformer handler=engineConfig.getTranslogRecoveryPerformer();
  try (Translog.Snapshot snapshot=translog.newSnapshot()){
    Translog.Operation operation;
    while ((operation=snapshot.next()) != null) {
      try {
        handler.performRecoveryOperation(this,operation);
        opsRecovered++;
      }
 catch (      ElasticsearchException e) {
        if (e.status() == RestStatus.BAD_REQUEST) {
          logger.info("ignoring recovery of a corrupt translog entry",e);
        }
 else {
          throw e;
        }
      }
    }
  }
 catch (  Throwable e) {
    throw new EngineException(shardId,"failed to recover from translog",e);
  }
  if (opsRecovered > 0) {
    logger.trace("flushing post recovery from translog. ops recovered [{}]. committed translog id [{}]. current id [{}]",opsRecovered,committedTranslogId,translog.currentId());
    flush(true,true);
  }
 else   if (committedTranslogId != null && translog.currentId() != committedTranslogId) {
    commitIndexWriter(indexWriter,translog.currentId(),lastCommittedSegmentInfos.getUserData().get(Engine.SYNC_COMMIT_ID));
  }
}
