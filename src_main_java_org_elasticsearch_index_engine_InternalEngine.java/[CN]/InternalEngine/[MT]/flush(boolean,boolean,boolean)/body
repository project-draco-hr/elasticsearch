{
  ensureOpen();
  if (commitTranslog) {
    if (onGoingRecoveries.get() > 0) {
      throw new FlushNotAllowedEngineException(shardId,"recovery is in progress, flush with committing translog is not allowed");
    }
  }
  int currentFlushing=flushing.incrementAndGet();
  if (currentFlushing > 1 && waitIfOngoing == false) {
    flushing.decrementAndGet();
    throw new FlushNotAllowedEngineException(shardId,"already flushing...");
  }
  flushLock.lock();
  try {
    if (commitTranslog) {
      try (ReleasableLock _=readLock.acquire()){
        ensureOpen();
        if (onGoingRecoveries.get() > 0) {
          throw new FlushNotAllowedEngineException(shardId,"Recovery is in progress, flush is not allowed");
        }
        if (flushNeeded || force) {
          flushNeeded=false;
          try {
            long translogId=translogIdGenerator.incrementAndGet();
            translog.newTransientTranslog(translogId);
            indexWriter.setCommitData(Collections.singletonMap(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)));
            commitIndexWriter(indexWriter);
            refresh("version_table_flush");
            translog.makeTransientCurrent();
          }
 catch (          Throwable e) {
            try {
              translog.revertTransient();
            }
 catch (            IOException ex) {
              e.addSuppressed(ex);
            }
            throw new FlushFailedEngineException(shardId,e);
          }
        }
      }
       if (engineConfig.isEnableGcDeletes()) {
        pruneDeletedTombstones();
      }
    }
 else {
      try (ReleasableLock _=readLock.acquire()){
        ensureOpen();
        try {
          long translogId=translog.currentId();
          indexWriter.setCommitData(Collections.singletonMap(Translog.TRANSLOG_ID_KEY,Long.toString(translogId)));
          commitIndexWriter(indexWriter);
        }
 catch (        Throwable e) {
          throw new FlushFailedEngineException(shardId,e);
        }
      }
       if (engineConfig.isEnableGcDeletes()) {
        pruneDeletedTombstones();
      }
    }
    store.incRef();
    try (ReleasableLock _=readLock.acquire()){
      ensureOpen();
      lastCommittedSegmentInfos=store.readLastCommittedSegmentsInfo();
    }
 catch (    Throwable e) {
      if (isClosed.get() == false) {
        logger.warn("failed to read latest segment infos on flush",e);
        if (Lucene.isCorruptionException(e)) {
          throw new FlushFailedEngineException(shardId,e);
        }
      }
    }
 finally {
      store.decRef();
    }
  }
 catch (  FlushFailedEngineException ex) {
    maybeFailEngine("flush",ex);
    throw ex;
  }
 finally {
    flushLock.unlock();
    flushing.decrementAndGet();
  }
}
