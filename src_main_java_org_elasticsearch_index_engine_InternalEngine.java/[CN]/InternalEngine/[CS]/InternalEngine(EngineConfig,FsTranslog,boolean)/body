{
  super(engineConfig);
  Preconditions.checkNotNull(translog,"Translog must be provided to the engine");
  this.versionMap=new LiveVersionMap();
  store.incRef();
  IndexWriter writer=null;
  SearcherManager manager=null;
  boolean success=false;
  try {
    this.lastDeleteVersionPruneTimeMSec=engineConfig.getThreadPool().estimatedTimeInMillis();
    this.indexingService=engineConfig.getIndexingService();
    this.warmer=engineConfig.getWarmer();
    this.translog=translog;
    this.mergePolicyProvider=engineConfig.getMergePolicyProvider();
    this.mergeScheduler=engineConfig.getMergeScheduler();
    this.dirtyLocks=new Object[engineConfig.getIndexConcurrency() * 50];
    for (int i=0; i < dirtyLocks.length; i++) {
      dirtyLocks[i]=new Object();
    }
    throttle=new IndexThrottle();
    this.searcherFactory=new SearchFactory(engineConfig);
    final Long committedTranslogId;
    try {
      writer=createWriter();
      indexWriter=writer;
      committedTranslogId=loadCommittedTranslogId(writer,translog);
    }
 catch (    IOException e) {
      throw new EngineCreationFailureException(shardId,"failed to create engine",e);
    }
    manager=createSearcherManager();
    this.searcherManager=manager;
    this.versionMap.setManager(searcherManager);
    this.mergeSchedulerFailureListener=new FailEngineOnMergeFailure();
    this.mergeSchedulerListener=new MergeSchedulerListener();
    this.mergeScheduler.addListener(mergeSchedulerListener);
    this.mergeScheduler.addFailureListener(mergeSchedulerFailureListener);
    try {
      if (skipInitialTranslogRecovery) {
        commitIndexWriter(writer,translog.currentId());
        translog.markCommitted(translog.currentId());
      }
 else {
        recoverFromTranslog(engineConfig,committedTranslogId);
      }
    }
 catch (    IOException|EngineException ex) {
      throw new EngineCreationFailureException(shardId,"failed to recover from translog",ex);
    }
    success=true;
  }
  finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(writer,manager);
      versionMap.clear();
      if (isClosed.get() == false) {
        store.decRef();
      }
    }
  }
  logger.trace("created new InternalEngine");
}
