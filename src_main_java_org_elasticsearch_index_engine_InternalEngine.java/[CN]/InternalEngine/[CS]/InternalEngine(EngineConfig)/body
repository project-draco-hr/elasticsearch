{
  super(engineConfig);
  this.versionMap=new LiveVersionMap();
  store.incRef();
  IndexWriter writer=null;
  SearcherManager manager=null;
  boolean success=false;
  try {
    this.onGoingRecoveries=new FlushingRecoveryCounter(this,store,logger);
    this.lastDeleteVersionPruneTimeMSec=engineConfig.getThreadPool().estimatedTimeInMillis();
    this.indexingService=engineConfig.getIndexingService();
    this.warmer=engineConfig.getWarmer();
    this.translog=engineConfig.getTranslog();
    this.mergePolicyProvider=engineConfig.getMergePolicyProvider();
    this.mergeScheduler=engineConfig.getMergeScheduler();
    this.dirtyLocks=new Object[engineConfig.getIndexConcurrency() * 50];
    for (int i=0; i < dirtyLocks.length; i++) {
      dirtyLocks[i]=new Object();
    }
    throttle=new IndexThrottle();
    this.searcherFactory=new SearchFactory(engineConfig);
    try {
      writer=createWriter();
    }
 catch (    IOException e) {
      throw new EngineCreationFailureException(shardId,"failed to create engine",e);
    }
    indexWriter=writer;
    manager=createSearcherManager();
    this.searcherManager=manager;
    this.mergeSchedulerFailureListener=new FailEngineOnMergeFailure();
    this.mergeSchedulerListener=new MergeSchedulerListener();
    this.mergeScheduler.addListener(mergeSchedulerListener);
    this.mergeScheduler.addFailureListener(mergeSchedulerFailureListener);
    success=true;
  }
  finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(writer,manager);
      versionMap.clear();
      if (isClosed.get() == false) {
        store.decRef();
      }
    }
  }
}
