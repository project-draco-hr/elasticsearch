{
  List<PathAndStateId> files=new ArrayList<>();
  long maxStateId=-1;
  boolean maxStateIdIsLegacy=true;
  if (dataLocations != null) {
    for (    Path dataLocation : dataLocations) {
      final Path stateDir=dataLocation.resolve(STATE_DIR_NAME);
      if (!Files.isDirectory(stateDir)) {
        continue;
      }
      try (DirectoryStream<Path> paths=Files.newDirectoryStream(stateDir)){
        for (        Path stateFile : paths) {
          final Matcher matcher=stateFilePattern.matcher(stateFile.getFileName().toString());
          if (matcher.matches()) {
            final long stateId=Long.parseLong(matcher.group(1));
            maxStateId=Math.max(maxStateId,stateId);
            final boolean legacy=MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false;
            maxStateIdIsLegacy&=legacy;
            PathAndStateId pav=new PathAndStateId(stateFile,stateId,legacy);
            logger.trace("found state file: {}",pav);
            files.add(pav);
          }
        }
      }
     }
  }
  final List<Throwable> exceptions=new ArrayList<>();
  T state=null;
  for (  PathAndStateId pathAndStateId : Collections2.filter(files,new StateIdAndLegacyPredicate(maxStateId,maxStateIdIsLegacy))) {
    try {
      final Path stateFile=pathAndStateId.file;
      final long id=pathAndStateId.id;
      final XContentParser parser;
      if (pathAndStateId.legacy) {
        final byte[] data=Files.readAllBytes(stateFile);
        if (data.length == 0) {
          logger.debug("{}: no data for [{}], ignoring...",prefix,stateFile.toAbsolutePath());
          continue;
        }
        parser=XContentHelper.createParser(new BytesArray(data));
        state=fromXContent(parser);
        if (state == null) {
          logger.debug("{}: no data for [{}], ignoring...",prefix,stateFile.toAbsolutePath());
        }
      }
 else {
        state=read(stateFile);
        logger.trace("state id [{}] read from [{}]",id,stateFile.getFileName());
      }
      return state;
    }
 catch (    Throwable e) {
      exceptions.add(e);
      logger.debug("{}: failed to read [{}], ignoring...",e,pathAndStateId.file.toAbsolutePath(),prefix);
    }
  }
  ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions);
  if (files.size() > 0) {
    throw new IllegalStateException("Could not find a state file to recover from among " + files);
  }
  return state;
}
