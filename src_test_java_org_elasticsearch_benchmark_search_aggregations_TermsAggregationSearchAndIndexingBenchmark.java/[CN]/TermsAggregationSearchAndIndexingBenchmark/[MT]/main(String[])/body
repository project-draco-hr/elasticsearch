{
  Natives.tryMlockall();
  Settings settings=settingsBuilder().put("refresh_interval","-1").put(SETTING_NUMBER_OF_SHARDS,1).put(SETTING_NUMBER_OF_REPLICAS,0).build();
  String clusterName=TermsAggregationSearchAndIndexingBenchmark.class.getSimpleName();
  nodes=new Node[1];
  for (int i=0; i < nodes.length; i++) {
    nodes[i]=nodeBuilder().settings(settingsBuilder().put(settings).put("name","node1")).clusterName(clusterName).node();
  }
  Client client=nodes[0].client();
  client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout("10s").execute().actionGet();
  try {
    client.admin().indices().prepareCreate(indexName).addMapping(typeName,generateMapping("eager","lazy")).get();
    Thread.sleep(5000);
    long startTime=System.currentTimeMillis();
    ObjectOpenHashSet<String> uniqueTerms=ObjectOpenHashSet.newInstance();
    for (int i=0; i < NUMBER_OF_TERMS; i++) {
      boolean added;
      do {
        added=uniqueTerms.add(RandomStrings.randomAsciiOfLength(random,STRING_TERM_SIZE));
      }
 while (!added);
    }
    String[] sValues=uniqueTerms.toArray(String.class);
    long ITERS=COUNT / BATCH;
    long i=1;
    int counter=0;
    for (; i <= ITERS; i++) {
      BulkRequestBuilder request=client.prepareBulk();
      for (int j=0; j < BATCH; j++) {
        counter++;
        XContentBuilder builder=jsonBuilder().startObject();
        builder.field("id",Integer.toString(counter));
        final String sValue=sValues[counter % sValues.length];
        builder.field("s_value",sValue);
        builder.field("s_value_dv",sValue);
        for (        String field : new String[]{"sm_value","sm_value_dv"}) {
          builder.startArray(field);
          for (int k=0; k < NUMBER_OF_MULTI_VALUE_TERMS; k++) {
            builder.value(sValues[ThreadLocalRandom.current().nextInt(sValues.length)]);
          }
          builder.endArray();
        }
        request.add(Requests.indexRequest(indexName).type("type1").id(Integer.toString(counter)).source(builder));
      }
      BulkResponse response=request.execute().actionGet();
      if (response.hasFailures()) {
        System.err.println("--> failures...");
      }
      if (((i * BATCH) % 10000) == 0) {
        System.out.println("--> Indexed " + (i * BATCH));
      }
    }
    System.out.println("--> Indexing took " + ((System.currentTimeMillis() - startTime) / 1000) + " seconds.");
  }
 catch (  IndexAlreadyExistsException e) {
    System.out.println("--> Index already exists, ignoring indexing phase, waiting for green");
    ClusterHealthResponse clusterHealthResponse=client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout("10m").execute().actionGet();
    if (clusterHealthResponse.isTimedOut()) {
      System.err.println("--> Timed out waiting for cluster health");
    }
  }
  client.admin().indices().preparePutMapping(indexName).setType(typeName).setSource(generateMapping("lazy","lazy")).get();
  client.admin().indices().prepareRefresh().execute().actionGet();
  System.out.println("--> Number of docs in index: " + client.prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount());
  String[] nodeIds=new String[nodes.length];
  for (int i=0; i < nodeIds.length; i++) {
    nodeIds[i]=nodes[i].injector().getInstance(Discovery.class).localNode().getId();
  }
  List<TestRun> testRuns=new ArrayList<>();
  testRuns.add(new TestRun("Regular field ordinals","eager","lazy","s_value","ordinals"));
  testRuns.add(new TestRun("Docvalues field ordinals","lazy","eager","s_value_dv","ordinals"));
  testRuns.add(new TestRun("Regular field global ordinals","eager_global_ordinals","lazy","s_value",null));
  testRuns.add(new TestRun("Docvalues field global","lazy","eager_global_ordinals","s_value_dv",null));
  List<TestResult> testResults=new ArrayList<>();
  for (  TestRun testRun : testRuns) {
    client.admin().indices().preparePutMapping(indexName).setType(typeName).setSource(generateMapping(testRun.indexedFieldEagerLoading,testRun.docValuesEagerLoading)).get();
    client.admin().indices().prepareClearCache(indexName).setFieldDataCache(true).get();
    SearchThread searchThread=new SearchThread(client,testRun.termsAggsField,testRun.termsAggsExecutionHint);
    RefreshThread refreshThread=new RefreshThread(client);
    System.out.println("--> Running '" + testRun.name + "' round...");
    new Thread(refreshThread).start();
    new Thread(searchThread).start();
    Thread.sleep(2 * 60 * 1000);
    refreshThread.stop();
    searchThread.stop();
    System.out.println("--> Avg refresh time: " + refreshThread.avgRefreshTime + " ms");
    System.out.println("--> Avg query time: " + searchThread.avgQueryTime + " ms");
    ClusterStatsResponse clusterStateResponse=client.admin().cluster().prepareClusterStats().setNodesIds(nodeIds).get();
    System.out.println("--> Heap used: " + clusterStateResponse.getNodesStats().getJvm().getHeapUsed());
    ByteSizeValue fieldDataMemoryUsed=clusterStateResponse.getIndicesStats().getFieldData().getMemorySize();
    System.out.println("--> Fielddata memory size: " + fieldDataMemoryUsed);
    testResults.add(new TestResult(testRun.name,refreshThread.avgRefreshTime,searchThread.avgQueryTime,fieldDataMemoryUsed));
  }
  System.out.println("----------------------------------------- SUMMARY ----------------------------------------------");
  System.out.format(Locale.ENGLISH,"%30s%18s%15s%15s\n","name","avg refresh time","avg query time","fieldata size");
  for (  TestResult testResult : testResults) {
    System.out.format(Locale.ENGLISH,"%30s%18s%15s%15s\n",testResult.name,testResult.avgRefreshTime,testResult.avgQueryTime,testResult.fieldDataSizeInMemory);
  }
  System.out.println("----------------------------------------- SUMMARY ----------------------------------------------");
  client.close();
  for (  Node node : nodes) {
    node.close();
  }
}
