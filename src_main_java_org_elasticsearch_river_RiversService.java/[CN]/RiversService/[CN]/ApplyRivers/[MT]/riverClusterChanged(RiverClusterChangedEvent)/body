{
  DiscoveryNode localNode=clusterService.localNode();
  RiverClusterState state=event.state();
  for (  final RiverName riverName : rivers.keySet()) {
    RiverRouting routing=state.routing().routing(riverName);
    if (routing == null || !localNode.equals(routing.node())) {
      closeRiver(riverName);
      try {
        client.prepareGet(riverIndexName,riverName.name(),"_meta").setListenerThreaded(true).execute(new ActionListener<GetResponse>(){
          @Override public void onResponse(          GetResponse getResponse){
            if (!getResponse.isExists()) {
              client.admin().indices().prepareDeleteMapping(riverIndexName).setType(riverName.name()).execute(new ActionListener<DeleteMappingResponse>(){
                @Override public void onResponse(                DeleteMappingResponse deleteMappingResponse){
                }
                @Override public void onFailure(                Throwable e){
                  logger.debug("failed to (double) delete river [{}] content",e,riverName.name());
                }
              }
);
            }
          }
          @Override public void onFailure(          Throwable e){
            logger.debug("failed to (double) delete river [{}] content",e,riverName.name());
          }
        }
);
      }
 catch (      IndexMissingException e) {
      }
catch (      Exception e) {
        logger.warn("unexpected failure when trying to verify river [{}] deleted",e,riverName.name());
      }
    }
  }
  for (  final RiverRouting routing : state.routing()) {
    if (routing.node() == null) {
      logger.trace("river {} has no routing node",routing.riverName().getName());
      continue;
    }
    if (!routing.node().equals(localNode)) {
      logger.trace("river {} belongs to node {}",routing.riverName().getName(),routing.node());
      continue;
    }
    if (rivers.containsKey(routing.riverName())) {
      logger.trace("river {} is already allocated",routing.riverName().getName());
      continue;
    }
    prepareGetMetaDocument(routing.riverName().name()).execute(new ActionListener<GetResponse>(){
      @Override public void onResponse(      GetResponse getResponse){
        if (!rivers.containsKey(routing.riverName())) {
          if (getResponse.isExists()) {
            createRiver(routing.riverName(),getResponse.getSourceAsMap());
          }
 else {
            logger.warn("{}/{}/_meta document not found",riverIndexName,routing.riverName().getName());
          }
        }
      }
      @Override public void onFailure(      Throwable e){
        Throwable failure=ExceptionsHelper.unwrapCause(e);
        if (isShardNotAvailableException(failure)) {
          logger.debug("failed to get _meta from [{}]/[{}], retrying...",e,routing.riverName().type(),routing.riverName().name());
          final ActionListener<GetResponse> listener=this;
          try {
            threadPool.schedule(TimeValue.timeValueSeconds(5),ThreadPool.Names.SAME,new Runnable(){
              @Override public void run(){
                prepareGetMetaDocument(routing.riverName().name()).execute(listener);
              }
            }
);
          }
 catch (          EsRejectedExecutionException ex) {
            logger.debug("Couldn't schedule river start retry, node might be shutting down",ex);
          }
        }
 else {
          logger.warn("failed to get _meta from [{}]/[{}]",e,routing.riverName().type(),routing.riverName().name());
        }
      }
    }
);
  }
}
