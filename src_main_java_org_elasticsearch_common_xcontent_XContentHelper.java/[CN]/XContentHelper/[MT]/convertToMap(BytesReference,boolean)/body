{
  if (bytes.hasArray()) {
    return convertToMap(bytes.array(),bytes.arrayOffset(),bytes.length(),ordered);
  }
  try {
    XContentParser parser;
    XContentType contentType;
    Compressor compressor=CompressorFactory.compressor(bytes);
    if (compressor != null) {
      CompressedStreamInput compressedStreamInput=compressor.streamInput(bytes.streamInput());
      contentType=XContentFactory.xContentType(compressedStreamInput);
      compressedStreamInput.resetToBufferStart();
      parser=XContentFactory.xContent(contentType).createParser(compressedStreamInput);
    }
 else {
      contentType=XContentFactory.xContentType(bytes);
      parser=XContentFactory.xContent(contentType).createParser(bytes.streamInput());
    }
    if (ordered) {
      return Tuple.tuple(contentType,parser.mapOrderedAndClose());
    }
 else {
      return Tuple.tuple(contentType,parser.mapAndClose());
    }
  }
 catch (  IOException e) {
    throw new ElasticSearchParseException("Failed to parse content to map",e);
  }
}
