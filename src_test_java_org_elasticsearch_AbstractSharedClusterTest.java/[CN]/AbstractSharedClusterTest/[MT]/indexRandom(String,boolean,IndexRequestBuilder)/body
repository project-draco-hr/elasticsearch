{
  Random random=getRandom();
  List<IndexRequestBuilder> list=Arrays.asList(builders);
  Collections.shuffle(list,random);
  final CopyOnWriteArrayList<Throwable> errors=new CopyOnWriteArrayList<Throwable>();
  List<CountDownLatch> latches=new ArrayList<CountDownLatch>();
  if (frequently()) {
    logger.info("Index [{}] docs async: [{}]",list.size(),true);
    final CountDownLatch latch=new CountDownLatch(list.size());
    latches.add(latch);
    for (    IndexRequestBuilder indexRequestBuilder : list) {
      indexRequestBuilder.execute(new LatchedActionListener<IndexResponse>(latch,errors));
      if (rarely()) {
        if (rarely()) {
          client().admin().indices().prepareRefresh(index).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches),errors));
        }
 else         if (rarely()) {
          client().admin().indices().prepareFlush(index).execute(new LatchedActionListener<FlushResponse>(newLatch(latches),errors));
        }
 else         if (rarely()) {
          client().admin().indices().prepareOptimize(index).setMaxNumSegments(between(1,10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches),errors));
        }
      }
    }
  }
 else {
    logger.info("Index [{}] docs async: [{}]",list.size(),false);
    for (    IndexRequestBuilder indexRequestBuilder : list) {
      indexRequestBuilder.execute().actionGet();
      if (rarely()) {
        if (rarely()) {
          client().admin().indices().prepareRefresh(index).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches),errors));
        }
 else         if (rarely()) {
          client().admin().indices().prepareFlush(index).execute(new LatchedActionListener<FlushResponse>(newLatch(latches),errors));
        }
 else         if (rarely()) {
          client().admin().indices().prepareOptimize(index).setMaxNumSegments(between(1,10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches),errors));
        }
      }
    }
  }
  for (  CountDownLatch countDownLatch : latches) {
    countDownLatch.await();
  }
  assertThat(errors,Matchers.emptyIterable());
  if (forceRefresh) {
    assertNoFailures(client().admin().indices().prepareRefresh(index).execute().get());
  }
}
