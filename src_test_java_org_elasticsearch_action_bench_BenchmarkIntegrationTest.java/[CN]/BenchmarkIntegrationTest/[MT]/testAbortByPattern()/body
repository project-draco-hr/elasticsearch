{
  final int iters=between(1,3);
  for (int i=0; i < iters; i++) {
    List<BenchmarkRequest> requests=new ArrayList<>();
    List<ActionFuture<BenchmarkResponse>> responses=new ArrayList<>();
    SearchRequest searchRequest=prepareBlockingScriptQuery();
    final int benches=between(1,3);
    String[] names=new String[benches];
    for (int k=0; k < benches; k++) {
      final BenchmarkRequest request=BenchmarkTestUtil.randomRequest(client(),indices,numExecutorNodes,competitionSettingsMap,searchRequest);
      request.settings().iterations(Integer.MAX_VALUE,true);
      names[k]=BENCHMARK_NAME + Integer.toString(k);
      request.benchmarkName(names[k]);
      requests.add(request);
      logger.info("--> Submitting benchmark - competitors [{}] iterations [{}]",request.competitors().size(),request.settings().iterations());
    }
    boolean aborted=false;
    for (    BenchmarkRequest r : requests) {
      final ActionFuture<BenchmarkResponse> benchmarkResponse=client().bench(r);
      responses.add(benchmarkResponse);
    }
    try {
      waitForQuery.await();
      if (benches > 1) {
        awaitBusy(new Predicate<Object>(){
          @Override public boolean apply(          java.lang.Object input){
            return client().prepareBenchStatus().get().benchmarkResponses().size() == benches;
          }
        }
);
      }
      final String badPatternA="*z";
      final String badPatternB="xxx";
      final String[] patterns;
switch (getRandom().nextInt(3)) {
case 0:
        patterns=new String[]{"*"};
      break;
case 1:
    patterns=new String[]{BENCHMARK_NAME_WILDCARD,badPatternA,badPatternB};
  break;
case 2:
patterns=names;
break;
default :
patterns=new String[]{BENCHMARK_NAME_WILDCARD};
}
final AbortBenchmarkResponse abortResponse=client().prepareAbortBench(patterns).get();
aborted=true;
assertAcked(abortResponse);
final BenchmarkStatusResponse statusResponse=client().prepareBenchStatus().execute().actionGet();
waitForTestLatch.countDown();
assertThat(statusResponse.totalActiveBenchmarks(),equalTo(0));
for (ActionFuture<BenchmarkResponse> r : responses) {
assertThat(r.get().state(),is(BenchmarkResponse.State.ABORTED));
}
}
  finally {
if (waitForTestLatch.getCount() == 1) {
waitForTestLatch.countDown();
}
if (!aborted) {
client().prepareAbortBench(BENCHMARK_NAME).get();
}
assertThat(waitForTestLatch.getCount(),is(0l));
}
}
}
