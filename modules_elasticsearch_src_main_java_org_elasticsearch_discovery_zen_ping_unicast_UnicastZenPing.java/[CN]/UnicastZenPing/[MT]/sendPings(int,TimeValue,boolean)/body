{
  UnicastPingRequest pingRequest=new UnicastPingRequest();
  pingRequest.id=id;
  pingRequest.timeout=timeout;
  DiscoveryNodes discoNodes=nodesProvider.nodes();
  pingRequest.pingResponse=new PingResponse(discoNodes.localNode(),discoNodes.masterNode(),clusterName);
  List<DiscoveryNode> nodesToPing=newArrayList(nodes);
  for (  UnicastHostsProvider provider : hostsProviders) {
    nodesToPing.addAll(provider.buildDynamicNodes());
  }
  final CountDownLatch latch=new CountDownLatch(nodesToPing.size());
  for (  final DiscoveryNode node : nodesToPing) {
    boolean disconnectX;
    DiscoveryNode nodeToSendX=discoNodes.findByAddress(node.address());
    if (nodeToSendX != null) {
      disconnectX=false;
    }
 else {
      nodeToSendX=node;
      disconnectX=true;
    }
    final DiscoveryNode nodeToSend=nodeToSendX;
    try {
      transportService.connectToNode(nodeToSend);
    }
 catch (    ConnectTransportException e) {
      logger.trace("[{}] failed to connect to {}",e,id,nodeToSend);
      latch.countDown();
      continue;
    }
    logger.trace("[{}] connecting to {}, disconnect[{}]",id,nodeToSend,disconnectX);
    final boolean disconnect=disconnectX;
    transportService.sendRequest(nodeToSend,UnicastPingRequestHandler.ACTION,pingRequest,TransportRequestOptions.options().withTimeout((long)(timeout.millis() * 1.25)),new BaseTransportResponseHandler<UnicastPingResponse>(){
      @Override public UnicastPingResponse newInstance(){
        return new UnicastPingResponse();
      }
      @Override public void handleResponse(      UnicastPingResponse response){
        logger.trace("[{}] received response from {}: {}",id,nodeToSend,Arrays.toString(response.pingResponses));
        try {
          DiscoveryNodes discoveryNodes=nodesProvider.nodes();
          for (          PingResponse pingResponse : response.pingResponses) {
            if (disconnect) {
              transportService.disconnectFromNode(nodeToSend);
            }
            if (pingResponse.target().id().equals(discoveryNodes.localNodeId())) {
              continue;
            }
            if (!pingResponse.clusterName().equals(clusterName)) {
              logger.debug("[{}] filtering out response from {}, not same cluster_name [{}]",pingResponse.target(),pingResponse.clusterName().value());
              return;
            }
            ConcurrentMap<DiscoveryNode,PingResponse> responses=receivedResponses.get(response.id);
            if (responses == null) {
              logger.warn("received ping response with no matching id [{}]",response.id);
            }
 else {
              responses.put(pingResponse.target(),pingResponse);
            }
          }
        }
  finally {
          latch.countDown();
        }
      }
      @Override public void handleException(      TransportException exp){
        latch.countDown();
        if (exp instanceof ConnectTransportException) {
          logger.trace("failed to connect to {}",exp,nodeToSend);
        }
 else {
          if (disconnect) {
            transportService.disconnectFromNode(nodeToSend);
          }
          logger.warn("failed to send ping to [{}]",exp,node);
        }
      }
      @Override public boolean spawn(){
        return false;
      }
    }
);
  }
  if (wait) {
    try {
      latch.await(timeout.millis() * 5,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
    }
  }
}
