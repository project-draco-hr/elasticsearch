{
  if (!lifecycle.started()) {
    return;
  }
  if (event.state().blocks().disableStatePersistence()) {
    this.currentMetaData=null;
    return;
  }
  if (!event.metaDataChanged()) {
    return;
  }
  writeStateExecutor.execute(new Runnable(){
    @Override public void run(){
      Set<String> indicesDeleted=Sets.newHashSet();
      if (event.localNodeMaster()) {
        logger.debug("writing to gateway {} ...",this);
        StopWatch stopWatch=new StopWatch().start();
        try {
          write(event.state().metaData());
          logger.debug("wrote to gateway {}, took {}",this,stopWatch.stop().totalTime());
        }
 catch (        Exception e) {
          logger.error("failed to write to gateway",e);
        }
        if (currentMetaData != null) {
          for (          IndexMetaData current : currentMetaData) {
            if (!event.state().metaData().hasIndex(current.index())) {
              delete(current);
              indicesDeleted.add(current.index());
            }
          }
        }
      }
      if (nodeEnv != null && nodeEnv.hasNodeFile()) {
        if (currentMetaData != null) {
          for (          IndexMetaData current : currentMetaData) {
            if (!event.state().metaData().hasIndex(current.index())) {
              FileSystemUtils.deleteRecursively(nodeEnv.indexLocations(new Index(current.index())));
              indicesDeleted.add(current.index());
            }
          }
        }
      }
      currentMetaData=event.state().metaData();
      for (      String indexDeleted : indicesDeleted) {
        try {
          nodeIndexDeletedAction.nodeIndexStoreDeleted(indexDeleted,event.state().nodes().masterNodeId());
        }
 catch (        Exception e) {
          logger.debug("[{}] failed to notify master on local index store deletion",e,indexDeleted);
        }
      }
    }
  }
);
}
