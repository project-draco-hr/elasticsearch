{
  GeometryCollectionBuilder mutation=copyShape(original);
  if (mutation.shapes.size() > 0) {
    int shapePosition=randomIntBetween(0,mutation.shapes.size() - 1);
    ShapeBuilder shapeToChange=mutation.shapes.get(shapePosition);
switch (shapeToChange.type()) {
case POINT:
      shapeToChange=PointBuilderTests.PROTOTYPE.mutate((PointBuilder)shapeToChange);
    break;
case CIRCLE:
  shapeToChange=CircleBuilderTests.PROTOTYPE.mutate((CircleBuilder)shapeToChange);
break;
case ENVELOPE:
shapeToChange=EnvelopeBuilderTests.PROTOTYPE.mutate((EnvelopeBuilder)shapeToChange);
break;
case LINESTRING:
shapeToChange=LineStringBuilderTests.PROTOTYPE.mutate((LineStringBuilder)shapeToChange);
break;
case MULTILINESTRING:
shapeToChange=MultiLineStringBuilderTests.PROTOTYPE.mutate((MultiLineStringBuilder)shapeToChange);
break;
case MULTIPOLYGON:
shapeToChange=MultiPolygonBuilderTests.PROTOTYPE.mutate((MultiPolygonBuilder)shapeToChange);
break;
case MULTIPOINT:
shapeToChange=MultiPointBuilderTests.PROTOTYPE.mutate((MultiPointBuilder)shapeToChange);
break;
case POLYGON:
shapeToChange=PolygonBuilderTests.PROTOTYPE.mutate((PolygonBuilder)shapeToChange);
break;
case GEOMETRYCOLLECTION:
throw new UnsupportedOperationException("GeometryCollection should not be nested inside each other");
}
mutation.shapes.set(shapePosition,shapeToChange);
}
 else {
mutation.shape(RandomShapeGenerator.createShape(getRandom()));
}
return mutation;
}
