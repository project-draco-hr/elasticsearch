{
  if (optimizeMutex.compareAndSet(false,true)) {
    ElasticsearchMergePolicy elasticsearchMergePolicy=null;
    try (InternalLock _=readLock.acquire()){
      final IndexWriter writer=currentIndexWriter();
      if (writer.getConfig().getMergePolicy() instanceof ElasticsearchMergePolicy) {
        elasticsearchMergePolicy=(ElasticsearchMergePolicy)writer.getConfig().getMergePolicy();
      }
      if (optimize.force() && elasticsearchMergePolicy == null) {
        throw new ElasticsearchIllegalStateException("The `force` flag can only be used if the merge policy is an instance of " + ElasticsearchMergePolicy.class.getSimpleName() + ", got ["+ writer.getConfig().getMergePolicy().getClass().getName()+ "]");
      }
      if (optimize.force()) {
        elasticsearchMergePolicy.setForce(true);
      }
      if (optimize.onlyExpungeDeletes()) {
        writer.forceMergeDeletes(false);
      }
 else       if (optimize.maxNumSegments() <= 0) {
        writer.maybeMerge();
        possibleMergeNeeded=false;
      }
 else {
        writer.forceMerge(optimize.maxNumSegments(),false);
      }
    }
 catch (    Throwable t) {
      maybeFailEngine(t,"optimize");
      throw new OptimizeFailedEngineException(shardId,t);
    }
 finally {
      if (elasticsearchMergePolicy != null) {
        elasticsearchMergePolicy.setForce(false);
      }
      optimizeMutex.set(false);
    }
  }
  if (optimize.waitForMerge()) {
    waitForMerges(optimize.flush());
  }
 else   if (optimize.flush()) {
    threadPool.executor(ThreadPool.Names.OPTIMIZE).execute(new AbstractRunnable(){
      @Override public void onFailure(      Throwable t){
        logger.error("Exception while waiting for merges asynchronously after optimize",t);
      }
      @Override protected void doRun() throws Exception {
        waitForMerges(true);
      }
    }
);
  }
}
