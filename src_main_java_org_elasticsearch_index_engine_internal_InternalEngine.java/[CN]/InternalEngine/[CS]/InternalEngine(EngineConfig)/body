{
  Preconditions.checkNotNull(engineConfig.getStore(),"Store must be provided to the engine");
  Preconditions.checkNotNull(engineConfig.getDeletionPolicy(),"Snapshot deletion policy must be provided to the engine");
  Preconditions.checkNotNull(engineConfig.getTranslog(),"Translog must be provided to the engine");
  this.store=engineConfig.getStore();
  this.versionMap=new LiveVersionMap();
  store.incRef();
  IndexWriter writer=null;
  SearcherManager manager=null;
  boolean success=false;
  try {
    this.shardId=engineConfig.getShardId();
    this.logger=Loggers.getLogger(getClass(),engineConfig.getIndexSettings(),shardId);
    this.lastDeleteVersionPruneTimeMSec=engineConfig.getThreadPool().estimatedTimeInMillis();
    this.indexingService=engineConfig.getIndexingService();
    this.warmer=engineConfig.getWarmer();
    this.deletionPolicy=engineConfig.getDeletionPolicy();
    this.translog=engineConfig.getTranslog();
    this.mergePolicyProvider=engineConfig.getMergePolicyProvider();
    this.mergeScheduler=engineConfig.getMergeScheduler();
    this.dirtyLocks=new Object[engineConfig.getIndexConcurrency() * 50];
    for (int i=0; i < dirtyLocks.length; i++) {
      dirtyLocks[i]=new Object();
    }
    this.failedEngineListener=engineConfig.getFailedEngineListener();
    throttle=new IndexThrottle();
    this.engineConfig=engineConfig;
    listener=new EngineConfig.EngineSettingsListener(logger,engineConfig){
      @Override protected void onChange(){
        updateSettings();
      }
    }
;
    engineConfig.getIndexSettingsService().addListener(listener);
    try {
      writer=createWriter();
    }
 catch (    IOException e) {
      throw new EngineCreationFailureException(shardId,"failed to create engine",e);
    }
    indexWriter=writer;
    manager=createSearcherManager();
    this.searcherManager=manager;
    this.mergeSchedulerFailureListener=new FailEngineOnMergeFailure();
    this.mergeSchedulerListener=new MergeSchedulerListener();
    this.mergeScheduler.addListener(mergeSchedulerListener);
    this.mergeScheduler.addFailureListener(mergeSchedulerFailureListener);
    success=true;
  }
  finally {
    if (success == false) {
      IOUtils.closeWhileHandlingException(writer,manager);
      versionMap.clear();
      store.decRef();
    }
  }
}
