{
  IndexSearcher searcher=new IndexSearcher(reader);
  searcher.setSimilarity(similarityService.similarity());
  if (warmer != null) {
    Searcher currentSearcher=null;
    IndexSearcher newSearcher=null;
    boolean closeNewSearcher=false;
    try {
      if (searcherManager == null) {
        newSearcher=searcher;
      }
 else {
        currentSearcher=acquireSearcher("search_factory");
        List<IndexReader> readers=Lists.newArrayList();
        for (        AtomicReaderContext newReaderContext : searcher.getIndexReader().leaves()) {
          if (isMergedSegment(newReaderContext.reader())) {
            continue;
          }
          boolean found=false;
          for (          AtomicReaderContext currentReaderContext : currentSearcher.reader().leaves()) {
            if (currentReaderContext.reader().getCoreCacheKey().equals(newReaderContext.reader().getCoreCacheKey())) {
              found=true;
              break;
            }
          }
          if (!found) {
            readers.add(newReaderContext.reader());
          }
        }
        if (!readers.isEmpty()) {
          newSearcher=new IndexSearcher(new MultiReader(readers.toArray(new IndexReader[readers.size()]),false));
          closeNewSearcher=true;
        }
      }
      if (newSearcher != null) {
        IndicesWarmer.WarmerContext context=new IndicesWarmer.WarmerContext(shardId,new SimpleSearcher("warmer",newSearcher));
        warmer.warm(context);
      }
    }
 catch (    Throwable e) {
      if (!closed) {
        logger.warn("failed to prepare/warm",e);
      }
    }
 finally {
      Releasables.release(currentSearcher);
      if (newSearcher != null && closeNewSearcher) {
        IOUtils.closeWhileHandlingException(newSearcher.getIndexReader());
      }
    }
  }
  return searcher;
}
