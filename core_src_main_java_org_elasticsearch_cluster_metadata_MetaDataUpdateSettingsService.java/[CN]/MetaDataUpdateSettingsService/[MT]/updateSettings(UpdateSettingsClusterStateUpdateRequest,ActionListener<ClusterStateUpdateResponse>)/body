{
  Settings.Builder updatedSettingsBuilder=Settings.settingsBuilder();
  updatedSettingsBuilder.put(request.settings()).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX);
  Settings.Builder settingsForClosedIndices=Settings.builder();
  Settings.Builder settingsForOpenIndices=Settings.builder();
  Settings.Builder skipppedSettings=Settings.builder();
  for (  Map.Entry<String,String> entry : updatedSettingsBuilder.internalMap().entrySet()) {
    if (entry.getKey().equals(IndexMetaData.SETTING_NUMBER_OF_SHARDS)) {
      listener.onFailure(new IllegalArgumentException("can't change the number of shards for an index"));
      return;
    }
    Setting setting=indexScopeSettings.get(entry.getKey());
    if (setting == null) {
      throw new IllegalArgumentException("setting [" + entry.getKey() + "] is unknown");
    }
    indexScopeSettings.validate(entry.getKey(),entry.getValue());
    settingsForClosedIndices.put(entry.getKey(),entry.getValue());
    if (setting.isDynamic()) {
      settingsForOpenIndices.put(entry.getKey(),entry.getValue());
    }
 else {
      skipppedSettings.put(entry.getKey(),entry.getValue());
    }
  }
  final Settings skippedSettigns=skipppedSettings.build();
  final Settings closedSettings=settingsForClosedIndices.build();
  final Settings openSettings=settingsForOpenIndices.build();
  clusterService.submitStateUpdateTask("update-settings",new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT,request,listener){
    @Override protected ClusterStateUpdateResponse newResponse(    boolean acknowledged){
      return new ClusterStateUpdateResponse(acknowledged);
    }
    @Override public ClusterState execute(    ClusterState currentState){
      String[] actualIndices=indexNameExpressionResolver.concreteIndices(currentState,IndicesOptions.strictExpand(),request.indices());
      RoutingTable.Builder routingTableBuilder=RoutingTable.builder(currentState.routingTable());
      MetaData.Builder metaDataBuilder=MetaData.builder(currentState.metaData());
      Set<String> openIndices=new HashSet<>();
      Set<String> closeIndices=new HashSet<>();
      for (      String index : actualIndices) {
        if (currentState.metaData().index(index).getState() == IndexMetaData.State.OPEN) {
          openIndices.add(index);
        }
 else {
          closeIndices.add(index);
        }
      }
      if (closeIndices.size() > 0 && closedSettings.get(IndexMetaData.SETTING_NUMBER_OF_REPLICAS) != null) {
        throw new IllegalArgumentException(String.format(Locale.ROOT,"Can't update [%s] on closed indices [%s] - can leave index in an unopenable state",IndexMetaData.SETTING_NUMBER_OF_REPLICAS,closeIndices));
      }
      if (!skippedSettigns.getAsMap().isEmpty() && !openIndices.isEmpty()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT,"Can't update non dynamic settings[%s] for open indices [%s]",skippedSettigns.getAsMap().keySet(),openIndices));
      }
      int updatedNumberOfReplicas=openSettings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,-1);
      if (updatedNumberOfReplicas != -1) {
        routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas,actualIndices);
        metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas,actualIndices);
        logger.info("updating number_of_replicas to [{}] for indices {}",updatedNumberOfReplicas,actualIndices);
      }
      ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
      final boolean updatedReadOnly=IndexMetaData.INDEX_READ_ONLY_SETTING.get(openSettings);
      for (      String index : actualIndices) {
        if (updatedReadOnly) {
          blocks.addIndexBlock(index,IndexMetaData.INDEX_READ_ONLY_BLOCK);
        }
 else {
          blocks.removeIndexBlock(index,IndexMetaData.INDEX_READ_ONLY_BLOCK);
        }
      }
      final boolean updateMetaDataBlock=IndexMetaData.INDEX_BLOCKS_METADATA_SETTING.get(openSettings);
      for (      String index : actualIndices) {
        if (updateMetaDataBlock) {
          blocks.addIndexBlock(index,IndexMetaData.INDEX_METADATA_BLOCK);
        }
 else {
          blocks.removeIndexBlock(index,IndexMetaData.INDEX_METADATA_BLOCK);
        }
      }
      final boolean updateWriteBlock=IndexMetaData.INDEX_BLOCKS_WRITE_SETTING.get(openSettings);
      for (      String index : actualIndices) {
        if (updateWriteBlock) {
          blocks.addIndexBlock(index,IndexMetaData.INDEX_WRITE_BLOCK);
        }
 else {
          blocks.removeIndexBlock(index,IndexMetaData.INDEX_WRITE_BLOCK);
        }
      }
      final boolean updateReadBlock=IndexMetaData.INDEX_BLOCKS_READ_SETTING.get(openSettings);
      for (      String index : actualIndices) {
        if (updateReadBlock) {
          blocks.addIndexBlock(index,IndexMetaData.INDEX_READ_BLOCK);
        }
 else {
          blocks.removeIndexBlock(index,IndexMetaData.INDEX_READ_BLOCK);
        }
      }
      if (!openIndices.isEmpty()) {
        String[] indices=openIndices.toArray(new String[openIndices.size()]);
        metaDataBuilder.updateSettings(openSettings,indices);
      }
      if (!closeIndices.isEmpty()) {
        String[] indices=closeIndices.toArray(new String[closeIndices.size()]);
        metaDataBuilder.updateSettings(closedSettings,indices);
      }
      ClusterState updatedState=ClusterState.builder(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder.build()).blocks(blocks).build();
      RoutingAllocation.Result routingResult=allocationService.reroute(updatedState,"settings update");
      updatedState=ClusterState.builder(updatedState).routingResult(routingResult).build();
      for (      String index : openIndices) {
        indexScopeSettings.dryRun(updatedState.metaData().index(index).getSettings());
      }
      for (      String index : closeIndices) {
        indexScopeSettings.dryRun(updatedState.metaData().index(index).getSettings());
      }
      return updatedState;
    }
  }
);
}
