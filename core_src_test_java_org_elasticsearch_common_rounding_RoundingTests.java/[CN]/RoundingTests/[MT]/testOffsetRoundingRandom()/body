{
  for (int i=0; i < 1000; ++i) {
    final long interval=randomIntBetween(1,100);
    Rounding.Interval internalRounding=new Rounding.Interval(interval);
    final long offset=randomIntBetween(-100,100);
    Rounding.OffsetRounding rounding=new Rounding.OffsetRounding(internalRounding,offset);
    long safetyMargin=Math.abs(interval) + Math.abs(offset);
    long value=Math.max(randomLong() - safetyMargin,Long.MIN_VALUE + safetyMargin);
    final long key=rounding.roundKey(value);
    final long key_next=rounding.roundKey(value + interval);
    final long r_value=rounding.round(value);
    final long nextRoundingValue=rounding.nextRoundingValue(r_value);
    assertThat("Rounding should be idempotent",r_value,equalTo(rounding.round(r_value)));
    assertThat("Rounded value smaller than unrounded, regardless of offset",r_value - offset,lessThanOrEqualTo(value - offset));
    assertThat("Key and next_key should differ by one",key_next - key,equalTo(1L));
    assertThat("Rounded value <= value < next interval start",r_value + interval,greaterThan(value));
    assertThat("NextRounding value should be interval from rounded value",r_value + interval,equalTo(nextRoundingValue));
  }
}
