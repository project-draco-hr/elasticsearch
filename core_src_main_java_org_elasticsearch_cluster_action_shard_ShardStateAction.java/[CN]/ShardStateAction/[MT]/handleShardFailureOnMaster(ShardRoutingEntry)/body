{
  logger.warn("{} received shard failed for {}",shardRoutingEntry.failure,shardRoutingEntry.shardRouting.shardId(),shardRoutingEntry);
  failedShardQueue.add(shardRoutingEntry);
  clusterService.submitStateUpdateTask("shard-failed (" + shardRoutingEntry.shardRouting + "), message ["+ shardRoutingEntry.message+ "]",Priority.HIGH,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      if (shardRoutingEntry.processed) {
        return currentState;
      }
      List<ShardRoutingEntry> shardRoutingEntries=new ArrayList<>();
      failedShardQueue.drainTo(shardRoutingEntries);
      if (shardRoutingEntries.isEmpty()) {
        return currentState;
      }
      List<FailedRerouteAllocation.FailedShard> shardRoutingsToBeApplied=new ArrayList<>(shardRoutingEntries.size());
      for (      ShardRoutingEntry entry : shardRoutingEntries) {
        entry.processed=true;
        shardRoutingsToBeApplied.add(new FailedRerouteAllocation.FailedShard(entry.shardRouting,entry.message,entry.failure));
      }
      RoutingAllocation.Result routingResult=allocationService.applyFailedShards(currentState,shardRoutingsToBeApplied);
      if (!routingResult.changed()) {
        return currentState;
      }
      return ClusterState.builder(currentState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("unexpected failure during [{}]",t,source);
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      if (oldState != newState && newState.getRoutingNodes().unassigned().size() > 0) {
        logger.trace("unassigned shards after shard failures. scheduling a reroute.");
        routingService.reroute("unassigned shards after shard failures, scheduling a reroute");
      }
    }
  }
);
}
