{
  logger.debug("received shard started for {}",shardRoutingEntry);
  startedShardsQueue.add(shardRoutingEntry);
  clusterService.submitStateUpdateTask("shard-started (" + shardRoutingEntry.shardRouting + "), reason ["+ shardRoutingEntry.message+ "]",Priority.URGENT,new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      if (shardRoutingEntry.processed) {
        return currentState;
      }
      List<ShardRoutingEntry> shardRoutingEntries=new ArrayList<>();
      startedShardsQueue.drainTo(shardRoutingEntries);
      if (shardRoutingEntries.isEmpty()) {
        return currentState;
      }
      RoutingTable routingTable=currentState.routingTable();
      MetaData metaData=currentState.getMetaData();
      List<ShardRouting> shardRoutingToBeApplied=new ArrayList<>(shardRoutingEntries.size());
      for (      ShardRoutingEntry entry : extractShardsToBeApplied(shardRoutingEntries,"started",metaData,logger)) {
        shardRoutingToBeApplied.add(entry.shardRouting);
      }
      for (      ShardRoutingEntry entry : shardRoutingEntries) {
        entry.processed=true;
      }
      if (shardRoutingToBeApplied.isEmpty()) {
        return currentState;
      }
      RoutingAllocation.Result routingResult=allocationService.applyStartedShards(currentState,shardRoutingToBeApplied,true);
      if (!routingResult.changed()) {
        return currentState;
      }
      return ClusterState.builder(currentState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("unexpected failure during [{}]",t,source);
    }
  }
);
}
