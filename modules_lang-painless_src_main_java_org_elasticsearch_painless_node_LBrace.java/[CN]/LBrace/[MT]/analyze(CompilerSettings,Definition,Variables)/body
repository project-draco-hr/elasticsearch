{
  if (before == null) {
    throw new IllegalStateException(error("Illegal tree structure."));
  }
  final Sort sort=before.sort;
  if (sort == Sort.ARRAY) {
    index.expected=definition.intType;
    index.analyze(settings,definition,variables);
    index=index.cast(settings,definition,variables);
    after=definition.getType(before.struct,before.dimensions - 1);
    return this;
  }
 else   if (sort == Sort.DEF) {
    return new LDefArray(line,location,index).copy(this).analyze(settings,definition,variables);
  }
 else {
    if (Map.class.isAssignableFrom(before.clazz)) {
      return new LMapShortcut(line,location,index).copy(this).analyze(settings,definition,variables);
    }
    if (List.class.isAssignableFrom(before.clazz)) {
      return new LListShortcut(line,location,index).copy(this).analyze(settings,definition,variables);
    }
  }
  throw new IllegalArgumentException(error("Illegal array access on type [" + before.name + "]."));
}
