{
  request.request().routing(state.metaData().resolveIndexRouting(request.request().routing(),request.request().index()));
  if (state.metaData().hasIndex(request.concreteIndex())) {
    MappingMetaData mappingMd=state.metaData().index(request.concreteIndex()).mappingOrDefault(request.request().type());
    if (mappingMd != null && mappingMd.routing().required()) {
      if (request.request().routing() == null) {
        if (request.request().versionType() != VersionType.INTERNAL) {
          throw new ElasticsearchIllegalArgumentException("routing value is required for deleting documents of type [" + request.request().type() + "] while using version_type ["+ request.request().versionType()+ "]");
        }
        indexDeleteAction.execute(new IndexDeleteRequest(request.request(),request.concreteIndex()),new ActionListener<IndexDeleteResponse>(){
          @Override public void onResponse(          IndexDeleteResponse indexDeleteResponse){
            long version=Versions.MATCH_ANY;
            boolean found=false;
            for (            ShardDeleteResponse deleteResponse : indexDeleteResponse.getResponses()) {
              if (deleteResponse.isFound()) {
                version=deleteResponse.getVersion();
                found=true;
                break;
              }
            }
            DeleteResponse response=new DeleteResponse(request.concreteIndex(),request.request().type(),request.request().id(),version,found);
            response.setShardInfo(indexDeleteResponse.getShardInfo());
            listener.onResponse(response);
          }
          @Override public void onFailure(          Throwable e){
            listener.onFailure(e);
          }
        }
);
        return false;
      }
    }
  }
  return true;
}
