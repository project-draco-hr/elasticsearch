{
  request.routing(state.metaData().resolveIndexRouting(request.routing(),request.index()));
  request.index(state.metaData().concreteSingleIndex(request.index(),request.indicesOptions()));
  if (state.metaData().hasIndex(request.index())) {
    MappingMetaData mappingMd=state.metaData().index(request.index()).mappingOrDefault(request.type());
    if (mappingMd != null && mappingMd.routing().required()) {
      if (request.routing() == null) {
        if (request.versionType() != VersionType.INTERNAL) {
          throw new ElasticsearchIllegalArgumentException("routing value is required for deleting documents of type [" + request.type() + "] while using version_type ["+ request.versionType()+ "]");
        }
        indexDeleteAction.execute(new IndexDeleteRequest(request),new ActionListener<IndexDeleteResponse>(){
          @Override public void onResponse(          IndexDeleteResponse indexDeleteResponse){
            long version=Versions.MATCH_ANY;
            boolean found=false;
            for (            ShardDeleteResponse deleteResponse : indexDeleteResponse.getResponses()) {
              if (deleteResponse.isFound()) {
                version=deleteResponse.getVersion();
                found=true;
                break;
              }
            }
            listener.onResponse(new DeleteResponse(request.index(),request.type(),request.id(),version,found));
          }
          @Override public void onFailure(          Throwable e){
            listener.onFailure(e);
          }
        }
);
        return false;
      }
    }
  }
  return true;
}
