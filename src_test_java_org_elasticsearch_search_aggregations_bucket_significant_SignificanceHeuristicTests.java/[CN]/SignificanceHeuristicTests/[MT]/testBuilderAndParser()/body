{
  Set<SignificanceHeuristicParser> parsers=new HashSet<>();
  parsers.add(new JLHScore.JLHScoreParser());
  parsers.add(new MutualInformation.MutualInformationParser());
  SignificanceHeuristicParserMapper heuristicParserMapper=new SignificanceHeuristicParserMapper(parsers);
  SearchContext searchContext=new SignificantTermsTestSearchContext();
  XContentParser stParser=JsonXContent.jsonXContent.createParser("{\"field\":\"text\", \"jlh\":{}, \"min_doc_count\":200}");
  stParser.nextToken();
  SignificantTermsAggregatorFactory aggregatorFactory=(SignificantTermsAggregatorFactory)new SignificantTermsParser(heuristicParserMapper).parse("testagg",stParser,searchContext);
  stParser.nextToken();
  assertThat(aggregatorFactory.getBucketCountThresholds().getMinDocCount(),equalTo(200l));
  assertThat(stParser.currentToken(),equalTo(null));
  stParser.close();
  SignificantTermsBuilder stBuilder=new SignificantTermsBuilder("testagg");
  stBuilder.significanceHeuristic(new JLHScore.JLHScoreBuilder()).field("text").minDocCount(200);
  XContentBuilder stXContentBuilder=XContentFactory.jsonBuilder();
  stBuilder.internalXContent(stXContentBuilder,null);
  stParser=JsonXContent.jsonXContent.createParser(stXContentBuilder.string());
  stParser.nextToken();
  aggregatorFactory=(SignificantTermsAggregatorFactory)new SignificantTermsParser(heuristicParserMapper).parse("testagg",stParser,searchContext);
  stParser.nextToken();
  assertThat(aggregatorFactory.getBucketCountThresholds().getMinDocCount(),equalTo(200l));
  assertThat(stParser.currentToken(),equalTo(null));
  stParser.close();
  stParser=JsonXContent.jsonXContent.createParser("{\"field\":\"text\", \"mutual_information\":{\"include_negatives\": false}, \"min_doc_count\":200}");
  stParser.nextToken();
  aggregatorFactory=(SignificantTermsAggregatorFactory)new SignificantTermsParser(heuristicParserMapper).parse("testagg",stParser,searchContext);
  stParser.nextToken();
  assertThat(aggregatorFactory.getBucketCountThresholds().getMinDocCount(),equalTo(200l));
  assertTrue(!((MutualInformation)aggregatorFactory.getSignificanceHeuristic()).getIncludeNegatives());
  assertThat(stParser.currentToken(),equalTo(null));
  stParser.close();
  stBuilder=new SignificantTermsBuilder("testagg");
  stBuilder.significanceHeuristic(new MutualInformation.MutualInformationBuilder(false,true)).field("text").minDocCount(200);
  stXContentBuilder=XContentFactory.jsonBuilder();
  stBuilder.internalXContent(stXContentBuilder,null);
  stParser=JsonXContent.jsonXContent.createParser(stXContentBuilder.string());
  stParser.nextToken();
  aggregatorFactory=(SignificantTermsAggregatorFactory)new SignificantTermsParser(heuristicParserMapper).parse("testagg",stParser,searchContext);
  stParser.nextToken();
  assertThat(aggregatorFactory.getBucketCountThresholds().getMinDocCount(),equalTo(200l));
  assertTrue(!((MutualInformation)aggregatorFactory.getSignificanceHeuristic()).getIncludeNegatives());
  assertThat(stParser.currentToken(),equalTo(null));
  stParser.close();
  try {
    stParser=JsonXContent.jsonXContent.createParser("{\"field\":\"text\", \"mutual_information\":{\"include_negatives\": false, \"some_unknown_field\": false}\"min_doc_count\":200}");
    stParser.nextToken();
    new SignificantTermsParser(heuristicParserMapper).parse("testagg",stParser,searchContext);
    fail();
  }
 catch (  ElasticsearchParseException e) {
    assertTrue(e.getMessage().contains("unknown for mutual_information"));
  }
  try {
    stParser=JsonXContent.jsonXContent.createParser("{\"field\":\"text\", \"jlh\":{\"unknown_field\": true}, \"min_doc_count\":200}");
    stParser.nextToken();
    new SignificantTermsParser(heuristicParserMapper).parse("testagg",stParser,searchContext);
    fail();
  }
 catch (  ElasticsearchParseException e) {
    assertTrue(e.getMessage().contains("expected }, got "));
  }
}
