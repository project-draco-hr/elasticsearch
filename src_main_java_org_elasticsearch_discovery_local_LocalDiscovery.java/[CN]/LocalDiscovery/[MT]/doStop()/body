{
synchronized (clusterGroups) {
    ClusterGroup clusterGroup=clusterGroups.get(clusterName);
    if (clusterGroup == null) {
      logger.warn("Illegal state, should not have an empty cluster group when stopping, I should be there at teh very least...");
      return;
    }
    clusterGroup.members().remove(this);
    if (clusterGroup.members().isEmpty()) {
      clusterGroups.remove(clusterName);
      return;
    }
    LocalDiscovery firstMaster=null;
    for (    LocalDiscovery localDiscovery : clusterGroup.members()) {
      if (localDiscovery.localNode().masterNode()) {
        firstMaster=localDiscovery;
        break;
      }
    }
    if (firstMaster != null) {
      if (master) {
        firstMaster.master=true;
      }
      final Set<String> newMembers=newHashSet();
      for (      LocalDiscovery discovery : clusterGroup.members()) {
        newMembers.add(discovery.localNode.id());
      }
      final LocalDiscovery master=firstMaster;
      master.clusterService.submitStateUpdateTask("local-disco-update",new ClusterStateNonMasterUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState){
          DiscoveryNodes newNodes=currentState.nodes().removeDeadMembers(newMembers,master.localNode.id());
          DiscoveryNodes.Delta delta=newNodes.delta(currentState.nodes());
          if (delta.added()) {
            logger.warn("No new nodes should be created when a new discovery view is accepted");
          }
          ClusterState updatedState=ClusterState.builder(currentState).nodes(newNodes).build();
          RoutingAllocation.Result routingResult=master.allocationService.reroute(ClusterState.builder(updatedState).build());
          return ClusterState.builder(updatedState).routingResult(routingResult).build();
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.error("unexpected failure during [{}]",t,source);
        }
      }
);
    }
  }
}
