{
  if (!master) {
    throw new ElasticSearchIllegalStateException("Shouldn't publish state when not master");
  }
  ClusterGroup clusterGroup=clusterGroups.get(clusterName);
  if (clusterGroup == null) {
    return;
  }
  try {
    final byte[] clusterStateBytes=Builder.toBytes(clusterState);
    LocalDiscovery[] members=clusterGroup.members().toArray(new LocalDiscovery[0]);
    final CountDownLatch latch=new CountDownLatch(members.length);
    for (    LocalDiscovery discovery : members) {
      if (discovery.master) {
        latch.countDown();
        continue;
      }
      final ClusterState nodeSpecificClusterState=ClusterState.Builder.fromBytes(clusterStateBytes,discovery.localNode);
      if (nodeSpecificClusterState.nodes().localNode() != null) {
        discovery.clusterService.submitStateUpdateTask("local-disco-receive(from master)",new ProcessedClusterStateUpdateTask(){
          @Override public ClusterState execute(          ClusterState currentState){
            ClusterState.Builder builder=ClusterState.builder().state(nodeSpecificClusterState);
            if (nodeSpecificClusterState.routingTable().version() == currentState.routingTable().version()) {
              builder.routingTable(currentState.routingTable());
            }
            if (nodeSpecificClusterState.metaData().version() == currentState.metaData().version()) {
              builder.metaData(currentState.metaData());
            }
            return builder.build();
          }
          @Override public void onFailure(          String source,          Throwable t){
            logger.error("unexpected failure during [{}]",t,source);
            latch.countDown();
          }
          @Override public void clusterStateProcessed(          String source,          ClusterState oldState,          ClusterState newState){
            sendInitialStateEventIfNeeded();
            latch.countDown();
          }
        }
);
      }
 else {
        latch.countDown();
      }
    }
    if (publishTimeout.millis() > 0) {
      try {
        boolean awaited=latch.await(publishTimeout.millis(),TimeUnit.MILLISECONDS);
        if (!awaited) {
          logger.debug("awaiting all nodes to process published state {} timed out, timeout {}",clusterState.version(),publishTimeout);
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
 catch (  Exception e) {
    throw new ElasticSearchIllegalStateException("Cluster state failed to serialize",e);
  }
}
