{
  final AtomicLong recycles=new AtomicLong(numRecycles);
  final CountDownLatch latch=new CountDownLatch(1);
  final Thread[] threads=new Thread[numThreads];
  for (int i=0; i < numThreads; ++i) {
    for (int j=RANDOM.nextInt(5); j >= 0; --j) {
      new Thread();
    }
    threads[i]=new Thread(){
      @Override public void run(){
        try {
          latch.await();
        }
 catch (        InterruptedException e) {
          return;
        }
        while (recycles.getAndDecrement() > 0) {
          final Recycler.V<?> v=recycler.obtain();
          v.close();
        }
      }
    }
;
  }
  for (  Thread thread : threads) {
    thread.start();
  }
  final long start=System.nanoTime();
  latch.countDown();
  for (  Thread thread : threads) {
    thread.join();
  }
  return System.nanoTime() - start;
}
