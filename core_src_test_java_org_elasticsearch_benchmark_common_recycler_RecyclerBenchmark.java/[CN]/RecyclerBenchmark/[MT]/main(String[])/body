{
  final int limit=100;
  final Recycler.C<Object> c=new AbstractRecyclerC<Object>(){
    @Override public Object newInstance(    int sizing){
      return new Object();
    }
    @Override public void recycle(    Object value){
    }
  }
;
  Map<String,Recycler<Object>> recyclers=new HashMap<>();
  recyclers.put("none",none(c));
  recyclers.put("concurrent-queue",concurrentDeque(c,limit));
  recyclers.put("locked",locked(deque(c,limit)));
  recyclers.put("concurrent",concurrent(dequeFactory(c,limit),Runtime.getRuntime().availableProcessors()));
  final long start=System.nanoTime();
  while (System.nanoTime() - start < TimeUnit.SECONDS.toNanos(10)) {
    for (    Recycler<?> recycler : recyclers.values()) {
      bench(recycler,NUM_RECYCLES,2);
    }
  }
  for (int numThreads=1; numThreads <= 4 * Runtime.getRuntime().availableProcessors(); numThreads*=2) {
    System.out.println("## " + numThreads + " threads\n");
    System.gc();
    Thread.sleep(1000);
    for (    Recycler<?> recycler : recyclers.values()) {
      bench(recycler,NUM_RECYCLES,numThreads);
    }
    for (int i=0; i < 5; ++i) {
      for (      Map.Entry<String,Recycler<Object>> entry : recyclers.entrySet()) {
        System.out.println(entry.getKey() + "\t" + TimeUnit.NANOSECONDS.toMillis(bench(entry.getValue(),NUM_RECYCLES,numThreads)));
      }
      System.out.println();
    }
  }
}
