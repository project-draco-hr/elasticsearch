{
  List<Facet> facets=context.facets();
  if (facets.size() == 1) {
    InternalStringTermsFacet facet=(InternalStringTermsFacet)facets.get(0);
    facet.trimExcessEntries();
    return facet;
  }
  InternalStringTermsFacet first=null;
  Recycler.V<ObjectIntOpenHashMap<Text>> aggregated=context.cacheRecycler().objectIntMap(-1);
  long missing=0;
  long total=0;
  for (  Facet facet : facets) {
    InternalTermsFacet termsFacet=(InternalTermsFacet)facet;
    missing+=termsFacet.getMissingCount();
    total+=termsFacet.getTotalCount();
    if (!(termsFacet instanceof InternalStringTermsFacet)) {
      return termsFacet.reduce(context);
    }
    if (first == null) {
      first=(InternalStringTermsFacet)termsFacet;
    }
    for (    Entry entry : termsFacet.getEntries()) {
      aggregated.v().addTo(entry.getTerm(),entry.getCount());
    }
  }
  BoundedTreeSet<TermEntry> ordered=new BoundedTreeSet<TermEntry>(first.comparatorType.comparator(),first.requiredSize);
  ObjectIntOpenHashMap<Text> aggregatedEntries=aggregated.v();
  final boolean[] states=aggregatedEntries.allocated;
  Object[] keys=aggregatedEntries.keys;
  int[] values=aggregatedEntries.values;
  for (int i=0; i < aggregatedEntries.allocated.length; i++) {
    if (states[i]) {
      Text key=(Text)keys[i];
      ordered.add(new TermEntry(key,values[i]));
    }
  }
  first.entries=ordered;
  first.missing=missing;
  first.total=total;
  aggregated.release();
  return first;
}
