{
  final BytesValues.WithOrdinals values=super.getBytesValues();
  return new BytesValues.WithOrdinals(values.ordinals()){
    BytesRef spare=new BytesRef(16);
    Iter inIter;
    Iter iter=new Iter(){
      BytesRef current=null;
      @Override public boolean hasNext(){
        return inIter.hasNext();
      }
      @Override public BytesRef next(){
        return current=convert(inIter.next());
      }
      @Override public int hash(){
        return current.hashCode();
      }
    }
;
    private BytesRef convert(    BytesRef spare){
      if (spare.length == 0) {
        return spare;
      }
      if (numericType.isFloatingPoint()) {
        return new BytesRef(Double.toString(numericType.toDouble(spare)));
      }
 else {
        return new BytesRef(Long.toString(numericType.toLong(spare)));
      }
    }
    @Override public BytesRef getValueScratchByOrd(    long ord,    BytesRef ret){
      return convert(values.getValueScratchByOrd(ord,spare));
    }
    @Override public Iter getIter(    int docId){
      inIter=values.getIter(docId);
      return iter;
    }
  }
;
}
