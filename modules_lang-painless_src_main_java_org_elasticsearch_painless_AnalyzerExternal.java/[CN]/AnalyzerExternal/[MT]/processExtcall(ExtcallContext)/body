{
  final ExtNodeMetadata callenmd=metadata.getExtNodeMetadata(ctx);
  final ParserRuleContext parent=callenmd.parent;
  final ExternalMetadata parentemd=metadata.getExternalMetadata(parent);
  final ExtdotContext dotctx=ctx.extdot();
  final ExtbraceContext bracectx=ctx.extbrace();
  callenmd.last=parentemd.scope == 0 && dotctx == null && bracectx == null;
  final String name=ctx.EXTID().getText();
  if (parentemd.current.sort == Sort.ARRAY) {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Unexpected call [" + name+ "] on an array.");
  }
 else   if (callenmd.last && parentemd.storeExpr != null) {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Cannot assign a value to a call [" + name+ "].");
  }
  final Struct struct=parentemd.current.struct;
  final List<ExpressionContext> arguments=ctx.arguments().expression();
  final int size=arguments.size();
  Type[] types;
  final Method method=parentemd.statik ? struct.functions.get(name) : struct.methods.get(name);
  final boolean def=parentemd.current.sort == Sort.DEF;
  if (method == null && !def) {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Unknown call [" + name+ "] on type ["+ struct.name+ "].");
  }
 else   if (method != null) {
    types=new Type[method.arguments.size()];
    method.arguments.toArray(types);
    callenmd.target=method;
    callenmd.type=method.rtn;
    parentemd.statement=!parentemd.read && callenmd.last;
    parentemd.current=method.rtn;
    if (size != types.length) {
      throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "When calling [" + name+ "] on type "+ "["+ struct.name+ "] expected ["+ types.length+ "] arguments,"+ " but found ["+ arguments.size()+ "].");
    }
  }
 else {
    types=new Type[arguments.size()];
    Arrays.fill(types,definition.defType);
    callenmd.target=name;
    callenmd.type=definition.defType;
    parentemd.statement=!parentemd.read && callenmd.last;
    parentemd.current=callenmd.type;
  }
  for (int argument=0; argument < size; ++argument) {
    final ExpressionContext exprctx=AnalyzerUtility.updateExpressionTree(arguments.get(argument));
    final ExpressionMetadata expremd=metadata.createExpressionMetadata(exprctx);
    expremd.to=types[argument];
    analyzer.visit(exprctx);
    caster.markCast(expremd);
  }
  parentemd.statik=false;
  if (dotctx != null) {
    metadata.createExtNodeMetadata(parent,dotctx);
    analyzer.visit(dotctx);
  }
 else   if (bracectx != null) {
    metadata.createExtNodeMetadata(parent,bracectx);
    analyzer.visit(bracectx);
  }
}
