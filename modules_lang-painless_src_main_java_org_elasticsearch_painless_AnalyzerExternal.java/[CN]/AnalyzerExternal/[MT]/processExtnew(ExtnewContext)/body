{
  final ExtNodeMetadata newenmd=metadata.getExtNodeMetadata(ctx);
  final ParserRuleContext parent=newenmd.parent;
  final ExternalMetadata parentemd=metadata.getExternalMetadata(parent);
  final ExtdotContext dotctx=ctx.extdot();
  newenmd.last=parentemd.scope == 0 && dotctx == null;
  final IdentifierContext idctx=ctx.identifier();
  final String type=idctx.getText();
  utility.isValidType(idctx,true);
  if (parentemd.current != null) {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Unexpected new call.");
  }
 else   if (newenmd.last && parentemd.storeExpr != null) {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Cannot assign a value to a new call.");
  }
  final Struct struct=definition.structs.get(type);
  final boolean newclass=ctx.arguments() != null;
  final boolean newarray=!ctx.expression().isEmpty();
  final List<ExpressionContext> arguments=newclass ? ctx.arguments().expression() : ctx.expression();
  final int size=arguments.size();
  Type[] types;
  if (newarray) {
    if (!parentemd.read) {
      throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "A newly created array must be assigned.");
    }
    types=new Type[size];
    Arrays.fill(types,definition.intType);
    newenmd.target="#makearray";
    if (size > 1) {
      newenmd.type=definition.getType(struct,size);
      parentemd.current=newenmd.type;
    }
 else     if (size == 1) {
      newenmd.type=definition.getType(struct,0);
      parentemd.current=definition.getType(struct,1);
    }
 else {
      throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "A newly created array cannot have zero dimensions.");
    }
  }
 else   if (newclass) {
    final Constructor constructor=struct.constructors.get("new");
    if (constructor != null) {
      types=new Type[constructor.arguments.size()];
      constructor.arguments.toArray(types);
      newenmd.target=constructor;
      newenmd.type=definition.getType(struct,0);
      parentemd.statement=!parentemd.read && newenmd.last;
      parentemd.current=newenmd.type;
    }
 else {
      throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Unknown new call on type [" + struct.name+ "].");
    }
  }
 else {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "Unknown state.");
  }
  if (size != types.length) {
    throw new IllegalArgumentException(AnalyzerUtility.error(ctx) + "When calling constructor on type " + "["+ struct.name+ "] expected ["+ types.length+ "] arguments,"+ " but found ["+ arguments.size()+ "].");
  }
  for (int argument=0; argument < size; ++argument) {
    final ExpressionContext exprctx=AnalyzerUtility.updateExpressionTree(arguments.get(argument));
    final ExpressionMetadata expremd=metadata.createExpressionMetadata(exprctx);
    expremd.to=types[argument];
    analyzer.visit(exprctx);
    caster.markCast(expremd);
  }
  if (dotctx != null) {
    metadata.createExtNodeMetadata(parent,dotctx);
    analyzer.visit(dotctx);
  }
}
