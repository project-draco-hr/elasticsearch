{
  final int maxDoc=randomIntBetween(5,100);
  Bits bits=DocIdSets.asSequentialAccessBits(100,null);
  for (int i=0; i < maxDoc; ++i) {
    assertFalse(bits.get(i));
  }
  bits=DocIdSets.asSequentialAccessBits(100,DocIdSet.EMPTY);
  for (int i=0; i < maxDoc; ++i) {
    assertFalse(bits.get(i));
  }
  RoaringDocIdSet.Builder b=new RoaringDocIdSet.Builder(maxDoc);
  for (int i=randomInt(maxDoc - 1); i < maxDoc; i+=randomIntBetween(1,10)) {
    b.add(i);
  }
  final RoaringDocIdSet set=b.build();
  assertNull(set.bits());
  bits=DocIdSets.asSequentialAccessBits(100,set);
  bits.get(4);
  try {
    bits.get(2);
    fail("Should have thrown an exception because of out-of-order consumption");
  }
 catch (  ElasticsearchIllegalArgumentException e) {
  }
  bits=DocIdSets.asSequentialAccessBits(100,set);
  DocIdSetIterator iterator=set.iterator();
  for (int i=randomInt(maxDoc - 1); i < maxDoc; i+=randomIntBetween(1,10)) {
    if (iterator.docID() < i) {
      iterator.advance(i);
    }
    assertEquals(iterator.docID() == i,bits.get(i));
  }
}
