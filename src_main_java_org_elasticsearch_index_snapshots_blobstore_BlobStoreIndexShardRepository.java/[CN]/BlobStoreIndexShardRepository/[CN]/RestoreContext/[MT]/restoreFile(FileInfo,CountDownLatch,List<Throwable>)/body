{
  final IndexOutput indexOutput;
  try {
    indexOutput=store.createVerifyingOutput(fileInfo.physicalName(),IOContext.DEFAULT,fileInfo.metadata());
  }
 catch (  IOException e) {
    try {
      failures.add(e);
    }
  finally {
      latch.countDown();
    }
    return;
  }
  String firstFileToRecover=fileInfo.partName(0);
  final AtomicInteger partIndex=new AtomicInteger();
  boolean success=false;
  try {
    blobContainer.readBlob(firstFileToRecover,new BlobContainer.ReadBlobListener(){
      @Override public synchronized void onPartial(      byte[] data,      int offset,      int size) throws IOException {
        recoveryState.getIndex().addRecoveredByteCount(size);
        RecoveryState.File file=recoveryState.getIndex().file(fileInfo.name());
        if (file != null) {
          file.updateRecovered(size);
        }
        indexOutput.writeBytes(data,offset,size);
        if (restoreRateLimiter != null) {
          rateLimiterListener.onRestorePause(restoreRateLimiter.pause(size));
        }
      }
      @Override public synchronized void onCompleted(){
        int part=partIndex.incrementAndGet();
        if (part < fileInfo.numberOfParts()) {
          String partName=fileInfo.partName(part);
          blobContainer.readBlob(partName,this);
          return;
        }
 else {
          try {
            Store.verify(indexOutput);
            indexOutput.close();
            if (fileInfo.metadata().hasLegacyChecksum()) {
              Store.LegacyChecksums legacyChecksums=new Store.LegacyChecksums();
              legacyChecksums.add(fileInfo.metadata());
              legacyChecksums.write(store);
            }
            store.directory().sync(Collections.singleton(fileInfo.physicalName()));
            recoveryState.getIndex().addRecoveredFileCount(1);
          }
 catch (          IOException e) {
            onFailure(e);
            return;
          }
        }
        latch.countDown();
      }
      @Override public void onFailure(      Throwable t){
        try {
          failures.add(t);
          IOUtils.closeWhileHandlingException(indexOutput);
          if (t instanceof CorruptIndexException) {
            try {
              store.markStoreCorrupted((CorruptIndexException)t);
            }
 catch (            IOException e) {
              logger.warn("store cannot be marked as corrupted",e);
            }
          }
          store.deleteQuiet(fileInfo.physicalName());
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    success=true;
  }
  finally {
    if (!success) {
      try {
        IOUtils.closeWhileHandlingException(indexOutput);
        store.deleteQuiet(fileInfo.physicalName());
      }
  finally {
        latch.countDown();
      }
    }
  }
}
