{
  store.incRef();
  try {
    logger.debug("[{}] [{}] restoring to [{}] ...",snapshotId,repositoryName,shardId);
    BlobStoreIndexShardSnapshot snapshot=loadSnapshot();
    recoveryState.setStage(RecoveryState.Stage.INDEX);
    int numberOfFiles=0;
    long totalSize=0;
    int numberOfReusedFiles=0;
    long reusedTotalSize=0;
    Map<String,StoreFileMetaData> metadata=Collections.emptyMap();
    try {
      metadata=store.getMetadata().asMap();
    }
 catch (    CorruptIndexException e) {
      logger.warn("{} Can't read metadata from store",e,shardId);
      throw new IndexShardRestoreFailedException(shardId,"Can't restore corrupted shard",e);
    }
catch (    Throwable e) {
      logger.warn("{} Can't read metadata from store",e,shardId);
    }
    List<FileInfo> filesToRecover=Lists.newArrayList();
    for (    FileInfo fileInfo : snapshot.indexFiles()) {
      String fileName=fileInfo.physicalName();
      final StoreFileMetaData md=metadata.get(fileName);
      numberOfFiles++;
      if (md != null && fileInfo.isSame(md)) {
        totalSize+=md.length();
        numberOfReusedFiles++;
        reusedTotalSize+=md.length();
        recoveryState.getIndex().addReusedFileDetail(fileInfo.name(),fileInfo.length());
        if (logger.isTraceEnabled()) {
          logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same",shardId,snapshotId,fileInfo.physicalName(),fileInfo.name());
        }
      }
 else {
        totalSize+=fileInfo.length();
        filesToRecover.add(fileInfo);
        recoveryState.getIndex().addFileDetail(fileInfo.name(),fileInfo.length());
        if (logger.isTraceEnabled()) {
          if (md == null) {
            logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store",shardId,snapshotId,fileInfo.physicalName(),fileInfo.name());
          }
 else {
            logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different",shardId,snapshotId,fileInfo.physicalName(),fileInfo.name());
          }
        }
      }
    }
    final RecoveryState.Index index=recoveryState.getIndex();
    index.totalFileCount(numberOfFiles);
    index.totalByteCount(totalSize);
    index.reusedFileCount(numberOfReusedFiles);
    index.reusedByteCount(reusedTotalSize);
    if (filesToRecover.isEmpty()) {
      logger.trace("no files to recover, all exists within the local store");
    }
    if (logger.isTraceEnabled()) {
      logger.trace("[{}] [{}] recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]",shardId,snapshotId,numberOfFiles,new ByteSizeValue(totalSize),numberOfReusedFiles,new ByteSizeValue(reusedTotalSize));
    }
    final CountDownLatch latch=new CountDownLatch(filesToRecover.size());
    final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<>();
    for (    final FileInfo fileToRecover : filesToRecover) {
      logger.trace("[{}] [{}] restoring file [{}]",shardId,snapshotId,fileToRecover.name());
      restoreFile(fileToRecover,latch,failures);
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
    if (!failures.isEmpty()) {
      throw new IndexShardRestoreFailedException(shardId,"Failed to recover index",failures.get(0));
    }
    long version=-1;
    try {
      if (Lucene.indexExists(store.directory())) {
        version=Lucene.readSegmentInfos(store.directory()).getVersion();
      }
    }
 catch (    IOException e) {
      throw new IndexShardRestoreFailedException(shardId,"Failed to fetch index version after copying it over",e);
    }
    recoveryState.getIndex().updateVersion(version);
    try {
      for (      String storeFile : store.directory().listAll()) {
        if (!snapshot.containPhysicalIndexFile(storeFile)) {
          try {
            store.directory().deleteFile(storeFile);
          }
 catch (          IOException e) {
          }
        }
      }
    }
 catch (    IOException e) {
    }
  }
  finally {
    store.decRef();
  }
}
