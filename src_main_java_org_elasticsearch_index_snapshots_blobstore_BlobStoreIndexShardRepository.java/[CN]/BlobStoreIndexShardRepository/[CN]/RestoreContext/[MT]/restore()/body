{
  store.incRef();
  try {
    logger.debug("[{}] [{}] restoring to [{}] ...",snapshotId,repositoryName,shardId);
    BlobStoreIndexShardSnapshot snapshot=loadSnapshot();
    recoveryState.setStage(RecoveryState.Stage.INDEX);
    int numberOfFiles=0;
    long totalSize=0;
    int numberOfReusedFiles=0;
    long reusedTotalSize=0;
    final Store.MetadataSnapshot recoveryTargetMetadata;
    try {
      recoveryTargetMetadata=store.getMetadataOrEmpty();
    }
 catch (    CorruptIndexException|IndexFormatTooOldException|IndexFormatTooNewException e) {
      logger.warn("{} Can't read metadata from store",e,shardId);
      throw new IndexShardRestoreFailedException(shardId,"Can't restore corrupted shard",e);
    }
    final List<FileInfo> filesToRecover=Lists.newArrayList();
    final Map<String,StoreFileMetaData> snapshotMetaData=new HashMap<>();
    final Map<String,FileInfo> fileInfos=new HashMap<>();
    for (    final FileInfo fileInfo : snapshot.indexFiles()) {
      try {
        maybeRecalculateMetadataHash(blobContainer,fileInfo,recoveryTargetMetadata);
      }
 catch (      Throwable e) {
        logger.warn("{} Can't calculate hash from blog for file [{}] [{}]",e,shardId,fileInfo.physicalName(),fileInfo.metadata());
      }
      snapshotMetaData.put(fileInfo.metadata().name(),fileInfo.metadata());
      fileInfos.put(fileInfo.metadata().name(),fileInfo);
    }
    final Store.MetadataSnapshot sourceMetaData=new Store.MetadataSnapshot(snapshotMetaData);
    final Store.RecoveryDiff diff=sourceMetaData.recoveryDiff(recoveryTargetMetadata);
    for (    StoreFileMetaData md : diff.identical) {
      FileInfo fileInfo=fileInfos.get(md.name());
      numberOfFiles++;
      totalSize+=md.length();
      numberOfReusedFiles++;
      reusedTotalSize+=md.length();
      recoveryState.getIndex().addReusedFileDetail(fileInfo.name(),fileInfo.length());
      if (logger.isTraceEnabled()) {
        logger.trace("[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same",shardId,snapshotId,fileInfo.physicalName(),fileInfo.name());
      }
    }
    for (    StoreFileMetaData md : Iterables.concat(diff.different,diff.missing)) {
      FileInfo fileInfo=fileInfos.get(md.name());
      numberOfFiles++;
      totalSize+=fileInfo.length();
      filesToRecover.add(fileInfo);
      recoveryState.getIndex().addFileDetail(fileInfo.name(),fileInfo.length());
      if (logger.isTraceEnabled()) {
        if (md == null) {
          logger.trace("[{}] [{}] recovering [{}] from [{}], does not exists in local store",shardId,snapshotId,fileInfo.physicalName(),fileInfo.name());
        }
 else {
          logger.trace("[{}] [{}] recovering [{}] from [{}], exists in local store but is different",shardId,snapshotId,fileInfo.physicalName(),fileInfo.name());
        }
      }
    }
    final RecoveryState.Index index=recoveryState.getIndex();
    index.totalFileCount(numberOfFiles);
    index.totalByteCount(totalSize);
    index.reusedFileCount(numberOfReusedFiles);
    index.reusedByteCount(reusedTotalSize);
    if (filesToRecover.isEmpty()) {
      logger.trace("no files to recover, all exists within the local store");
    }
    if (logger.isTraceEnabled()) {
      logger.trace("[{}] [{}] recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]",shardId,snapshotId,numberOfFiles,new ByteSizeValue(totalSize),numberOfReusedFiles,new ByteSizeValue(reusedTotalSize));
    }
    try {
      for (      final FileInfo fileToRecover : filesToRecover) {
        logger.trace("[{}] [{}] restoring file [{}]",shardId,snapshotId,fileToRecover.name());
        restoreFile(fileToRecover);
      }
    }
 catch (    IOException ex) {
      throw new IndexShardRestoreFailedException(shardId,"Failed to recover index",ex);
    }
    long version=-1;
    try {
      if (Lucene.indexExists(store.directory())) {
        version=Lucene.readSegmentInfos(store.directory()).getVersion();
      }
    }
 catch (    IOException e) {
      throw new IndexShardRestoreFailedException(shardId,"Failed to fetch index version after copying it over",e);
    }
    recoveryState.getIndex().updateVersion(version);
    try {
      for (      String storeFile : store.directory().listAll()) {
        if (!snapshot.containPhysicalIndexFile(storeFile)) {
          try {
            store.directory().deleteFile(storeFile);
          }
 catch (          IOException e) {
          }
        }
      }
    }
 catch (    IOException e) {
    }
  }
  finally {
    store.decRef();
  }
}
