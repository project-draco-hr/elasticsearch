{
  int startNode=summary.floorNode(x);
  if (startNode == RedBlackTree.NIL) {
    startNode=summary.ceilingNode(x);
  }
  if (startNode == RedBlackTree.NIL) {
    summary.addGroup(x,w);
    count=w;
  }
 else {
    double minDistance=Double.POSITIVE_INFINITY;
    int lastNeighbor=0;
    summary.headSum(startNode,sizeAndSum);
    final int headSize=sizeAndSum.size;
    int i=headSize;
    for (int node=startNode; node != RedBlackTree.NIL; node=summary.nextNode(node)) {
      double z=Math.abs(summary.mean(node) - x);
      if (z <= minDistance) {
        minDistance=z;
        lastNeighbor=i;
      }
 else {
        break;
      }
      i++;
    }
    int closest=RedBlackTree.NIL;
    long sum=sizeAndSum.sum;
    i=headSize;
    double n=1;
    for (int node=startNode; node != RedBlackTree.NIL; node=summary.nextNode(node)) {
      if (i > lastNeighbor) {
        break;
      }
      double z=Math.abs(summary.mean(node) - x);
      double q=(sum + summary.count(node) / 2.0) / count;
      double k=4 * count * q* (1 - q) / compression;
      if (z == minDistance && summary.count(node) + w <= k) {
        if (gen.nextDouble() < 1 / n) {
          closest=node;
        }
        n++;
      }
      sum+=summary.count(node);
      i++;
    }
    if (closest == RedBlackTree.NIL) {
      summary.addGroup(x,w);
    }
 else {
      double centroid=summary.mean(closest);
      long count=summary.count(closest);
      count+=w;
      centroid+=w * (x - centroid) / count;
      summary.updateGroup(closest,centroid,count);
    }
    count+=w;
    if (summary.size() > 100 * compression) {
      compress();
    }
  }
}
