{
  if (current != null) {
    missing+=current.counts[0];
    total+=current.total - current.counts[0];
    if (current.values.ordinals().getNumOrds() > 0) {
      aggregators.add(current);
    }
  }
  AggregatorPriorityQueue queue=new AggregatorPriorityQueue(aggregators.size());
  for (  ReaderAggregator aggregator : aggregators) {
    if (aggregator.nextPosition()) {
      queue.add(aggregator);
    }
  }
  if (size < EntryPriorityQueue.LIMIT) {
    EntryPriorityQueue ordered=new EntryPriorityQueue(size,comparatorType.comparator());
    while (queue.size() > 0) {
      ReaderAggregator agg=queue.top();
      BytesRef value=agg.values.makeSafe(agg.current);
      int count=0;
      do {
        count+=agg.counts[agg.position];
        if (agg.nextPosition()) {
          agg=queue.updateTop();
        }
 else {
          queue.pop();
          agg=queue.top();
        }
      }
 while (agg != null && value.equals(agg.current));
      if (count > minCount) {
        if (excluded != null && excluded.contains(value)) {
          continue;
        }
        if (matcher != null && !matcher.reset(value.utf8ToString()).matches()) {
          continue;
        }
        InternalStringTermsFacet.TermEntry entry=new InternalStringTermsFacet.TermEntry(value,count);
        ordered.insertWithOverflow(entry);
      }
    }
    InternalStringTermsFacet.TermEntry[] list=new InternalStringTermsFacet.TermEntry[ordered.size()];
    for (int i=ordered.size() - 1; i >= 0; i--) {
      list[i]=(InternalStringTermsFacet.TermEntry)ordered.pop();
    }
    for (    ReaderAggregator aggregator : aggregators) {
      CacheRecycler.pushIntArray(aggregator.counts);
    }
    return new InternalStringTermsFacet(facetName,comparatorType,size,Arrays.asList(list),missing,total);
  }
  BoundedTreeSet<InternalStringTermsFacet.TermEntry> ordered=new BoundedTreeSet<InternalStringTermsFacet.TermEntry>(comparatorType.comparator(),size);
  while (queue.size() > 0) {
    ReaderAggregator agg=queue.top();
    BytesRef value=agg.values.makeSafe(agg.current);
    int count=0;
    do {
      count+=agg.counts[agg.position];
      if (agg.nextPosition()) {
        agg=queue.updateTop();
      }
 else {
        queue.pop();
        agg=queue.top();
      }
    }
 while (agg != null && value.equals(agg.current));
    if (count > minCount) {
      if (excluded != null && excluded.contains(value)) {
        continue;
      }
      if (matcher != null && !matcher.reset(value.utf8ToString()).matches()) {
        continue;
      }
      InternalStringTermsFacet.TermEntry entry=new InternalStringTermsFacet.TermEntry(value,count);
      ordered.add(entry);
    }
  }
  for (  ReaderAggregator aggregator : aggregators) {
    CacheRecycler.pushIntArray(aggregator.counts);
  }
  return new InternalStringTermsFacet(facetName,comparatorType,size,ordered,missing,total);
}
