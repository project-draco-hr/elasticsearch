{
  String[] indexNames=new String[request.indices.length];
  for (int i=0; i < request.indices.length; i++) {
    indexNames[i]=request.indices[i].index();
  }
  clusterService.submitStateUpdateTask("allocation dangled indices " + Arrays.toString(indexNames),new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      if (currentState.blocks().disableStatePersistence()) {
        return currentState;
      }
      MetaData.Builder metaData=MetaData.builder().metaData(currentState.metaData());
      ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
      RoutingTable.Builder routingTableBuilder=RoutingTable.builder().routingTable(currentState.routingTable());
      boolean importNeeded=false;
      StringBuilder sb=new StringBuilder();
      for (      IndexMetaData indexMetaData : request.indices) {
        if (currentState.metaData().hasIndex(indexMetaData.index())) {
          continue;
        }
        importNeeded=true;
        metaData.put(indexMetaData,false);
        blocks.addBlocks(indexMetaData);
        routingTableBuilder.addAsRecovery(indexMetaData);
        sb.append("[").append(indexMetaData.index()).append("/").append(indexMetaData.state()).append("]");
      }
      if (!importNeeded) {
        return currentState;
      }
      logger.info("auto importing dangled indices {} from [{}]",sb.toString(),request.fromNode);
      ClusterState updatedState=ClusterState.builder().state(currentState).metaData(metaData).blocks(blocks).routingTable(routingTableBuilder).build();
      RoutingAllocation.Result routingResult=allocationService.reroute(newClusterStateBuilder().state(updatedState).routingTable(routingTableBuilder).build());
      return ClusterState.builder().state(updatedState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("unexpected failure during [{}]",t,source);
      try {
        channel.sendResponse(t);
      }
 catch (      Exception e) {
        logger.error("failed send response for allocating dangled",e);
      }
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      try {
        channel.sendResponse(new AllocateDangledResponse(true));
      }
 catch (      IOException e) {
        logger.error("failed send response for allocating dangled",e);
      }
    }
  }
);
}
