{
  final AtomicReference<Throwable> failureRef=new AtomicReference<Throwable>();
  final CountDownLatch latch=new CountDownLatch(1);
  clusterService.submitStateUpdateTask("cluster_update_settings",Priority.URGENT,new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      try {
        boolean changed=false;
        ImmutableSettings.Builder transientSettings=ImmutableSettings.settingsBuilder();
        transientSettings.put(currentState.metaData().transientSettings());
        for (        Map.Entry<String,String> entry : request.transientSettings().getAsMap().entrySet()) {
          if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith("logger.")) {
            String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());
            if (error == null) {
              transientSettings.put(entry.getKey(),entry.getValue());
              changed=true;
            }
 else {
              logger.warn("ignoring transient setting [{}], [{}]",entry.getKey(),error);
            }
          }
 else {
            logger.warn("ignoring transient setting [{}], not dynamically updateable",entry.getKey());
          }
        }
        ImmutableSettings.Builder persistentSettings=ImmutableSettings.settingsBuilder();
        persistentSettings.put(currentState.metaData().persistentSettings());
        for (        Map.Entry<String,String> entry : request.persistentSettings().getAsMap().entrySet()) {
          if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith("logger.")) {
            String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());
            if (error == null) {
              persistentSettings.put(entry.getKey(),entry.getValue());
              changed=true;
            }
 else {
              logger.warn("ignoring persistent setting [{}], [{}]",entry.getKey(),error);
            }
          }
 else {
            logger.warn("ignoring persistent setting [{}], not dynamically updateable",entry.getKey());
          }
        }
        if (!changed) {
          latch.countDown();
          return currentState;
        }
        MetaData.Builder metaData=MetaData.builder().metaData(currentState.metaData()).persistentSettings(persistentSettings.build()).transientSettings(transientSettings.build());
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        boolean updatedReadOnly=metaData.persistentSettings().getAsBoolean(MetaData.SETTING_READ_ONLY,false) || metaData.transientSettings().getAsBoolean(MetaData.SETTING_READ_ONLY,false);
        if (updatedReadOnly) {
          blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);
        }
 else {
          blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);
        }
        return ClusterState.builder().state(currentState).metaData(metaData).blocks(blocks).build();
      }
 catch (      Exception e) {
        latch.countDown();
        logger.warn("failed to update cluster settings",e);
        return currentState;
      }
 finally {
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
      clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings",Priority.URGENT,new ClusterStateUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState){
          try {
            RoutingAllocation.Result routingResult=allocationService.reroute(currentState);
            return newClusterStateBuilder().state(currentState).routingResult(routingResult).build();
          }
  finally {
            latch.countDown();
          }
        }
      }
);
    }
  }
);
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    failureRef.set(e);
  }
  if (failureRef.get() != null) {
    if (failureRef.get() instanceof ElasticSearchException) {
      throw (ElasticSearchException)failureRef.get();
    }
 else {
      throw new ElasticSearchException(failureRef.get().getMessage(),failureRef.get());
    }
  }
  return new ClusterUpdateSettingsResponse();
}
