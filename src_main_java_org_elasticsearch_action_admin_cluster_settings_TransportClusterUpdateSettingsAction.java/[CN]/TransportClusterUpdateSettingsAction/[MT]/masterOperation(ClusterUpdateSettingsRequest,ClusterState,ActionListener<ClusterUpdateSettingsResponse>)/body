{
  final ImmutableSettings.Builder transientUpdates=ImmutableSettings.settingsBuilder();
  final ImmutableSettings.Builder persistentUpdates=ImmutableSettings.settingsBuilder();
  clusterService.submitStateUpdateTask("cluster_update_settings",Priority.IMMEDIATE,new AckedClusterStateUpdateTask(){
    private volatile boolean changed=false;
    @Override public boolean mustAck(    DiscoveryNode discoveryNode){
      return true;
    }
    @Override public void onAllNodesAcked(    @Nullable Throwable t){
      if (changed) {
        reroute(true);
      }
 else {
        listener.onResponse(new ClusterUpdateSettingsResponse(true,transientUpdates.build(),persistentUpdates.build()));
      }
    }
    @Override public void onAckTimeout(){
      if (changed) {
        reroute(false);
      }
 else {
        listener.onResponse(new ClusterUpdateSettingsResponse(false,transientUpdates.build(),persistentUpdates.build()));
      }
    }
    private void reroute(    final boolean updateSettingsAcked){
      clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings",Priority.URGENT,new AckedClusterStateUpdateTask(){
        @Override public boolean mustAck(        DiscoveryNode discoveryNode){
          return updateSettingsAcked;
        }
        @Override public void onAllNodesAcked(        @Nullable Throwable t){
          listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked,transientUpdates.build(),persistentUpdates.build()));
        }
        @Override public void onAckTimeout(){
          listener.onResponse(new ClusterUpdateSettingsResponse(false,transientUpdates.build(),persistentUpdates.build()));
        }
        @Override public TimeValue ackTimeout(){
          return request.timeout();
        }
        @Override public TimeValue timeout(){
          return request.masterNodeTimeout();
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.debug("failed to perform [{}]",t,source);
        }
        @Override public ClusterState execute(        final ClusterState currentState){
          RoutingAllocation.Result routingResult=allocationService.reroute(currentState);
          if (!routingResult.changed()) {
            return currentState;
          }
          return ClusterState.builder(currentState).routingResult(routingResult).build();
        }
        @Override public void clusterStateProcessed(        String source,        ClusterState oldState,        ClusterState newState){
        }
      }
);
    }
    @Override public TimeValue ackTimeout(){
      return request.timeout();
    }
    @Override public TimeValue timeout(){
      return request.masterNodeTimeout();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.debug("failed to perform [{}]",t,source);
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    final ClusterState currentState){
      ImmutableSettings.Builder transientSettings=ImmutableSettings.settingsBuilder();
      transientSettings.put(currentState.metaData().transientSettings());
      for (      Map.Entry<String,String> entry : request.transientSettings().getAsMap().entrySet()) {
        if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith("logger.")) {
          String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());
          if (error == null) {
            transientSettings.put(entry.getKey(),entry.getValue());
            transientUpdates.put(entry.getKey(),entry.getValue());
            changed=true;
          }
 else {
            logger.warn("ignoring transient setting [{}], [{}]",entry.getKey(),error);
          }
        }
 else {
          logger.warn("ignoring transient setting [{}], not dynamically updateable",entry.getKey());
        }
      }
      ImmutableSettings.Builder persistentSettings=ImmutableSettings.settingsBuilder();
      persistentSettings.put(currentState.metaData().persistentSettings());
      for (      Map.Entry<String,String> entry : request.persistentSettings().getAsMap().entrySet()) {
        if (dynamicSettings.hasDynamicSetting(entry.getKey()) || entry.getKey().startsWith("logger.")) {
          String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());
          if (error == null) {
            persistentSettings.put(entry.getKey(),entry.getValue());
            persistentUpdates.put(entry.getKey(),entry.getValue());
            changed=true;
          }
 else {
            logger.warn("ignoring persistent setting [{}], [{}]",entry.getKey(),error);
          }
        }
 else {
          logger.warn("ignoring persistent setting [{}], not dynamically updateable",entry.getKey());
        }
      }
      if (!changed) {
        return currentState;
      }
      MetaData.Builder metaData=MetaData.builder(currentState.metaData()).persistentSettings(persistentSettings.build()).transientSettings(transientSettings.build());
      ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
      boolean updatedReadOnly=metaData.persistentSettings().getAsBoolean(MetaData.SETTING_READ_ONLY,false) || metaData.transientSettings().getAsBoolean(MetaData.SETTING_READ_ONLY,false);
      if (updatedReadOnly) {
        blocks.addGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);
      }
 else {
        blocks.removeGlobalBlock(MetaData.CLUSTER_READ_ONLY_BLOCK);
      }
      return builder(currentState).metaData(metaData).blocks(blocks).build();
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
    }
  }
);
}
