{
  final ClusterState clusterState=clusterService.state();
  final DiscoveryNodes nodes=clusterState.nodes();
  if (nodes.localNodeMaster() || localExecute(request)) {
    final ClusterBlockException blockException=checkBlock(request,clusterState);
    if (blockException != null) {
      if (!blockException.retryable()) {
        listener.onFailure(blockException);
        return;
      }
      clusterService.add(request.masterNodeTimeout(),new TimeoutClusterStateListener(){
        @Override public void postAdded(){
          ClusterBlockException blockException=checkBlock(request,clusterService.state());
          if (blockException == null || !blockException.retryable()) {
            clusterService.remove(this);
            innerExecute(request,listener,false);
          }
        }
        @Override public void onClose(){
          clusterService.remove(this);
          listener.onFailure(blockException);
        }
        @Override public void onTimeout(        TimeValue timeout){
          clusterService.remove(this);
          listener.onFailure(blockException);
        }
        @Override public void clusterChanged(        ClusterChangedEvent event){
          ClusterBlockException blockException=checkBlock(request,event.state());
          if (blockException == null || !blockException.retryable()) {
            clusterService.remove(this);
            innerExecute(request,listener,false);
          }
        }
      }
);
    }
 else {
      try {
        threadPool.executor(executor).execute(new Runnable(){
          @Override public void run(){
            try {
              masterOperation(request,clusterService.state(),listener);
            }
 catch (            Throwable e) {
              listener.onFailure(e);
            }
          }
        }
);
      }
 catch (      Throwable t) {
        listener.onFailure(t);
      }
    }
  }
 else {
    if (nodes.masterNode() == null) {
      if (retrying) {
        listener.onFailure(new MasterNotDiscoveredException());
      }
 else {
        logger.debug("no known master node, scheduling a retry");
        clusterService.add(request.masterNodeTimeout(),new TimeoutClusterStateListener(){
          @Override public void postAdded(){
            ClusterState clusterStateV2=clusterService.state();
            if (clusterStateV2.nodes().masterNodeId() != null) {
              clusterService.remove(this);
              innerExecute(request,listener,true);
            }
          }
          @Override public void onClose(){
            clusterService.remove(this);
            listener.onFailure(new NodeClosedException(clusterService.localNode()));
          }
          @Override public void onTimeout(          TimeValue timeout){
            clusterService.remove(this);
            listener.onFailure(new MasterNotDiscoveredException("waited for [" + timeout + "]"));
          }
          @Override public void clusterChanged(          ClusterChangedEvent event){
            if (event.nodesDelta().masterNodeChanged()) {
              clusterService.remove(this);
              innerExecute(request,listener,true);
            }
          }
        }
);
      }
      return;
    }
    processBeforeDelegationToMaster(request,clusterState);
    transportService.sendRequest(nodes.masterNode(),transportAction,request,new BaseTransportResponseHandler<Response>(){
      @Override public Response newInstance(){
        return newResponse();
      }
      @Override public void handleResponse(      Response response){
        listener.onResponse(response);
      }
      @Override public String executor(){
        return ThreadPool.Names.SAME;
      }
      @Override public void handleException(      final TransportException exp){
        if (exp.unwrapCause() instanceof ConnectTransportException) {
          logger.debug("connection exception while trying to forward request to master node [{}], scheduling a retry. Error: [{}]",nodes.masterNode(),exp.getDetailedMessage());
          clusterService.add(request.masterNodeTimeout(),new TimeoutClusterStateListener(){
            @Override public void postAdded(){
              ClusterState clusterStateV2=clusterService.state();
              if (clusterState.version() != clusterStateV2.version()) {
                clusterService.remove(this);
                innerExecute(request,listener,false);
              }
            }
            @Override public void onClose(){
              clusterService.remove(this);
              listener.onFailure(new NodeClosedException(clusterService.localNode()));
            }
            @Override public void onTimeout(            TimeValue timeout){
              clusterService.remove(this);
              listener.onFailure(new MasterNotDiscoveredException());
            }
            @Override public void clusterChanged(            ClusterChangedEvent event){
              if (event.nodesDelta().masterNodeChanged()) {
                clusterService.remove(this);
                innerExecute(request,listener,false);
              }
            }
          }
);
        }
 else {
          listener.onFailure(exp);
        }
      }
    }
);
  }
}
