{
class MlockallCheckTestCase {
    private final boolean mlockallSet;
    private final boolean isMemoryLocked;
    private final boolean shouldFail;
    public MlockallCheckTestCase(    boolean mlockallSet,    boolean isMemoryLocked,    boolean shouldFail){
      this.mlockallSet=mlockallSet;
      this.isMemoryLocked=isMemoryLocked;
      this.shouldFail=shouldFail;
    }
  }
  final List<MlockallCheckTestCase> testCases=new ArrayList<>();
  testCases.add(new MlockallCheckTestCase(true,true,false));
  testCases.add(new MlockallCheckTestCase(true,false,true));
  testCases.add(new MlockallCheckTestCase(false,true,false));
  testCases.add(new MlockallCheckTestCase(false,false,false));
  for (  final MlockallCheckTestCase testCase : testCases) {
    final BootstrapCheck.MlockallCheck check=new BootstrapCheck.MlockallCheck(testCase.mlockallSet){
      @Override boolean isMemoryLocked(){
        return testCase.isMemoryLocked;
      }
    }
;
    if (testCase.shouldFail) {
      try {
        BootstrapCheck.check(true,Collections.singletonList(check));
        fail("should have failed due to memory not being locked");
      }
 catch (      RuntimeException e) {
        assertThat(e.getMessage(),containsString("Memory locking requested for elasticsearch process but memory is not locked"));
      }
    }
 else {
      BootstrapCheck.check(true,Collections.singletonList(check));
    }
  }
}
