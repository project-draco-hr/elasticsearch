{
  long chunkBytes=Long.MAX_VALUE;
  if (chunkSize != null) {
    chunkBytes=chunkSize.bytes();
  }
  long totalLength=fileInfo.length();
  long numberOfChunks=totalLength / chunkBytes;
  if (totalLength % chunkBytes > 0) {
    numberOfChunks++;
  }
  if (numberOfChunks == 0) {
    numberOfChunks++;
  }
  final long fNumberOfChunks=numberOfChunks;
  final AtomicLong counter=new AtomicLong(numberOfChunks);
  for (long i=0; i < fNumberOfChunks; i++) {
    final long partNumber=i;
    IndexInput indexInput=null;
    try {
      indexInput=indexShard.store().openInputRaw(fileInfo.physicalName());
      indexInput.seek(partNumber * chunkBytes);
      InputStreamIndexInput is=new ThreadSafeInputStreamIndexInput(indexInput,chunkBytes);
      String blobName=fileInfo.name();
      if (fNumberOfChunks > 1) {
        blobName+=".part" + partNumber;
      }
      final IndexInput fIndexInput=indexInput;
      blobContainer.writeBlob(blobName,is,is.actualSizeToRead(),new ImmutableBlobContainer.WriterListener(){
        @Override public void onCompleted(){
          try {
            fIndexInput.close();
          }
 catch (          IOException e) {
          }
          if (counter.decrementAndGet() == 0) {
            latch.countDown();
          }
        }
        @Override public void onFailure(        Throwable t){
          try {
            fIndexInput.close();
          }
 catch (          IOException e) {
          }
          failures.add(t);
          if (counter.decrementAndGet() == 0) {
            latch.countDown();
          }
        }
      }
);
    }
 catch (    Exception e) {
      if (indexInput != null) {
        try {
          indexInput.close();
        }
 catch (        IOException e1) {
        }
      }
      failures.add(e);
      latch.countDown();
    }
  }
}
