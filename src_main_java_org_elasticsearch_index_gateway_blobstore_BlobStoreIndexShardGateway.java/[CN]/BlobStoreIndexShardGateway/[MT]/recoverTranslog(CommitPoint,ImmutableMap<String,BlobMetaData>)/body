{
  if (commitPoint.translogFiles().isEmpty()) {
    recoveryState.getStart().startTime(System.currentTimeMillis());
    recoveryState.setStage(RecoveryState.Stage.START);
    indexShard.postRecovery("post recovery from gateway, no translog");
    recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
    recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
    return;
  }
  try {
    recoveryState.getStart().startTime(System.currentTimeMillis());
    recoveryState.setStage(RecoveryState.Stage.START);
    indexShard.performRecoveryPrepareForTranslog();
    recoveryState.getStart().time(System.currentTimeMillis() - recoveryState.getStart().startTime());
    recoveryState.getStart().checkIndexTime(indexShard.checkIndexTook());
    recoveryState.setStage(RecoveryState.Stage.TRANSLOG);
    recoveryState.getTranslog().startTime(System.currentTimeMillis());
    final AtomicReference<Throwable> failure=new AtomicReference<Throwable>();
    final CountDownLatch latch=new CountDownLatch(1);
    final Iterator<CommitPoint.FileInfo> transIt=commitPoint.translogFiles().iterator();
    blobContainer.readBlob(transIt.next().name(),new BlobContainer.ReadBlobListener(){
      BytesStreamOutput bos=new BytesStreamOutput();
      boolean ignore=false;
      @Override public synchronized void onPartial(      byte[] data,      int offset,      int size) throws IOException {
        if (ignore) {
          return;
        }
        bos.write(data,offset,size);
        if (bos.size() < 4) {
          return;
        }
        BytesStreamInput si=new BytesStreamInput(bos.bytes());
        int position;
        while (true) {
          try {
            position=si.position();
            if (position + 4 > bos.size()) {
              break;
            }
            int opSize=si.readInt();
            int curPos=si.position();
            if ((si.position() + opSize) > bos.size()) {
              break;
            }
            Translog.Operation operation=TranslogStreams.readTranslogOperation(si);
            if ((si.position() - curPos) != opSize) {
              logger.warn("mismatch in size, expected [{}], got [{}]",opSize,si.position() - curPos);
            }
            recoveryState.getTranslog().addTranslogOperations(1);
            indexShard.performRecoveryOperation(operation);
            if (si.position() >= bos.size()) {
              position=si.position();
              break;
            }
          }
 catch (          Throwable e) {
            logger.warn("failed to retrieve translog after [{}] operations, ignoring the rest, considered corrupted",e,recoveryState.getTranslog().currentTranslogOperations());
            ignore=true;
            latch.countDown();
            return;
          }
        }
        BytesStreamOutput newBos=new BytesStreamOutput();
        int leftOver=bos.size() - position;
        if (leftOver > 0) {
          newBos.write(bos.bytes().array(),position,leftOver);
        }
        bos=newBos;
      }
      @Override public synchronized void onCompleted(){
        if (ignore) {
          return;
        }
        if (!transIt.hasNext()) {
          latch.countDown();
          return;
        }
        blobContainer.readBlob(transIt.next().name(),this);
      }
      @Override public void onFailure(      Throwable t){
        failure.set(t);
        latch.countDown();
      }
    }
);
    latch.await();
    if (failure.get() != null) {
      throw failure.get();
    }
    indexShard.performRecoveryFinalization(true);
    recoveryState.getTranslog().time(System.currentTimeMillis() - recoveryState.getTranslog().startTime());
  }
 catch (  Throwable e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recover translog",e);
  }
}
