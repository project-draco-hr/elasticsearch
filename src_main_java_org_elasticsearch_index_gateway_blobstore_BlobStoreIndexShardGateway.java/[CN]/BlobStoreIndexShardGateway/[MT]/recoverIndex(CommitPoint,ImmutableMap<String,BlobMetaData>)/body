{
  recoveryStatus.updateStage(RecoveryStatus.Stage.INDEX);
  int numberOfFiles=0;
  long totalSize=0;
  int numberOfReusedFiles=0;
  long reusedTotalSize=0;
  List<CommitPoint.FileInfo> filesToRecover=Lists.newArrayList();
  for (  CommitPoint.FileInfo fileInfo : commitPoint.indexFiles()) {
    String fileName=fileInfo.physicalName();
    StoreFileMetaData md=null;
    try {
      md=store.metaData(fileName);
    }
 catch (    Exception e) {
    }
    if (!fileName.startsWith("segments") && md != null && fileInfo.isSame(md)) {
      numberOfFiles++;
      totalSize+=md.length();
      numberOfReusedFiles++;
      reusedTotalSize+=md.length();
      if (logger.isTraceEnabled()) {
        logger.trace("not_recovering [{}], exists in local store and is same",fileInfo.physicalName());
      }
    }
 else {
      if (logger.isTraceEnabled()) {
        if (md == null) {
          logger.trace("recovering [{}], does not exists in local store",fileInfo.physicalName());
        }
 else {
          logger.trace("recovering [{}], exists in local store but is different",fileInfo.physicalName());
        }
      }
      numberOfFiles++;
      totalSize+=fileInfo.length();
      filesToRecover.add(fileInfo);
    }
  }
  recoveryStatus.index().files(numberOfFiles,totalSize,numberOfReusedFiles,reusedTotalSize);
  if (filesToRecover.isEmpty()) {
    logger.trace("no files to recover, all exists within the local store");
  }
  if (logger.isTraceEnabled()) {
    logger.trace("recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]",numberOfFiles,new ByteSizeValue(totalSize),numberOfReusedFiles,new ByteSizeValue(reusedTotalSize));
  }
  final CountDownLatch latch=new CountDownLatch(filesToRecover.size());
  final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
  for (  final CommitPoint.FileInfo fileToRecover : filesToRecover) {
    recoverFile(fileToRecover,blobs,latch,failures);
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    throw new IndexShardGatewayRecoveryException(shardId,"Interrupted while recovering index",e);
  }
  if (!failures.isEmpty()) {
    throw new IndexShardGatewayRecoveryException(shardId,"Failed to recover index",failures.get(0));
  }
  long version=-1;
  try {
    if (Lucene.indexExists(store.directory())) {
      version=Lucene.readSegmentInfos(store.directory()).getVersion();
    }
  }
 catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to fetch index version after copying it over",e);
  }
  recoveryStatus.index().updateVersion(version);
  try {
    for (    String storeFile : store.directory().listAll()) {
      if (!commitPoint.containPhysicalIndexFile(storeFile)) {
        try {
          store.directory().deleteFile(storeFile);
        }
 catch (        Exception e) {
        }
      }
    }
  }
 catch (  Exception e) {
  }
}
