{
  List<Facet> facets=context.facets();
  if (facets.size() == 1) {
    InternalTermsStatsDoubleFacet tsFacet=(InternalTermsStatsDoubleFacet)facets.get(0);
    if (requiredSize == 0) {
      if (!tsFacet.entries.isEmpty()) {
        List<DoubleEntry> entries=tsFacet.mutableList();
        CollectionUtil.timSort(entries,comparatorType.comparator());
      }
    }
    tsFacet.trimExcessEntries();
    return facets.get(0);
  }
  int missing=0;
  Recycler.V<DoubleObjectOpenHashMap<DoubleEntry>> map=context.cacheRecycler().doubleObjectMap(-1);
  for (  Facet facet : facets) {
    InternalTermsStatsDoubleFacet tsFacet=(InternalTermsStatsDoubleFacet)facet;
    missing+=tsFacet.missing;
    for (    Entry entry : tsFacet) {
      DoubleEntry doubleEntry=(DoubleEntry)entry;
      DoubleEntry current=map.v().get(doubleEntry.term);
      if (current != null) {
        current.count+=doubleEntry.count;
        current.totalCount+=doubleEntry.totalCount;
        current.total+=doubleEntry.total;
        if (doubleEntry.min < current.min) {
          current.min=doubleEntry.min;
        }
        if (doubleEntry.max > current.max) {
          current.max=doubleEntry.max;
        }
      }
 else {
        map.v().put(doubleEntry.term,doubleEntry);
      }
    }
  }
  if (requiredSize == 0) {
    DoubleEntry[] entries1=map.v().values().toArray(DoubleEntry.class);
    Arrays.sort(entries1,comparatorType.comparator());
    map.close();
    return new InternalTermsStatsDoubleFacet(getName(),comparatorType,requiredSize,Arrays.asList(entries1),missing);
  }
 else {
    Object[] values=map.v().values;
    Arrays.sort(values,(Comparator)comparatorType.comparator());
    List<DoubleEntry> ordered=new ArrayList<>(map.v().size());
    for (int i=0; i < requiredSize; i++) {
      DoubleEntry value=(DoubleEntry)values[i];
      if (value == null) {
        break;
      }
      ordered.add(value);
    }
    map.close();
    return new InternalTermsStatsDoubleFacet(getName(),comparatorType,requiredSize,ordered,missing);
  }
}
