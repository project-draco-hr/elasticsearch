{
  boolean changed=false;
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    InternalIndexService indexService=(InternalIndexService)indicesService.indexService(shard.index());
    if (indexService == null) {
      continue;
    }
    if (!indexService.store().persistent()) {
      continue;
    }
    TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData=transportNodesListShardStoreMetaData.list(shard.shardId(),false).actionGet();
    long lastSizeMatched=0;
    DiscoveryNode lastDiscoNodeMatched=null;
    RoutingNode lastNodeMatched=null;
    for (    TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData nodeStoreFilesMetaData : nodesStoreFilesMetaData) {
      DiscoveryNode discoNode=nodeStoreFilesMetaData.node();
      IndexStore.StoreFilesMetaData storeFilesMetaData=nodeStoreFilesMetaData.storeFilesMetaData();
      if (storeFilesMetaData == null) {
        continue;
      }
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (!(node.canAllocate(routingNodes.metaData(),routingNodes.routingTable()) && node.canAllocate(shard))) {
        continue;
      }
      if (storeFilesMetaData.allocated()) {
        continue;
      }
      if (shard.primary() && indexService.gateway() instanceof BlobStoreIndexGateway) {
        BlobStoreIndexGateway indexGateway=(BlobStoreIndexGateway)indexService.gateway();
        try {
          ImmutableMap<String,BlobMetaData> indexBlobsMetaData=indexGateway.listIndexBlobs(shard.id());
          long sizeMatched=0;
          for (          StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
            if (indexBlobsMetaData.containsKey(storeFileMetaData.name()) && indexBlobsMetaData.get(storeFileMetaData.name()).md5().equals(storeFileMetaData.md5())) {
              sizeMatched+=storeFileMetaData.sizeInBytes();
            }
          }
          if (sizeMatched > lastSizeMatched) {
            lastSizeMatched=sizeMatched;
            lastDiscoNodeMatched=discoNode;
            lastNodeMatched=node;
          }
          continue;
        }
 catch (        Exception e) {
          logger.debug("Failed to guess allocation of primary based on gateway for " + shard,e);
        }
      }
      if (!shard.primary()) {
        MutableShardRouting primaryShard=routingNodes.findPrimaryForBackup(shard);
        if (primaryShard != null && primaryShard.active()) {
          TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData primaryNodeStoreFileMetaData=nodesStoreFilesMetaData.nodesMap().get(primaryShard.currentNodeId());
          if (primaryNodeStoreFileMetaData != null && primaryNodeStoreFileMetaData.storeFilesMetaData() != null && primaryNodeStoreFileMetaData.storeFilesMetaData().allocated()) {
            long sizeMatched=0;
            IndexStore.StoreFilesMetaData primaryStoreFilesMetaData=primaryNodeStoreFileMetaData.storeFilesMetaData();
            for (            StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
              if (primaryStoreFilesMetaData.fileExists(storeFileMetaData.name()) && primaryStoreFilesMetaData.file(storeFileMetaData.name()).sizeInBytes() == storeFileMetaData.sizeInBytes()) {
                sizeMatched+=storeFileMetaData.sizeInBytes();
              }
            }
            if (sizeMatched > lastSizeMatched) {
              lastSizeMatched=sizeMatched;
              lastDiscoNodeMatched=discoNode;
              lastNodeMatched=node;
            }
            continue;
          }
        }
      }
    }
    if (lastNodeMatched != null) {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}] allocating to [{}] in order to reuse its unallocated persistent store",shard.index(),shard.id(),lastDiscoNodeMatched);
      }
      changed=true;
      lastNodeMatched.add(shard);
      unassignedIterator.remove();
    }
  }
  return changed;
}
