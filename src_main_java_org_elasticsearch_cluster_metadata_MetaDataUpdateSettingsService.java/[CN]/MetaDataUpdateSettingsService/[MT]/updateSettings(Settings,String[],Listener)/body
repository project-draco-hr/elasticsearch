{
  ImmutableSettings.Builder updatedSettingsBuilder=ImmutableSettings.settingsBuilder();
  for (  Map.Entry<String,String> entry : pSettings.getAsMap().entrySet()) {
    if (entry.getKey().equals("index")) {
      continue;
    }
    if (!entry.getKey().startsWith("index.")) {
      updatedSettingsBuilder.put("index." + entry.getKey(),entry.getValue());
    }
 else {
      updatedSettingsBuilder.put(entry.getKey(),entry.getValue());
    }
  }
  for (  String key : updatedSettingsBuilder.internalMap().keySet()) {
    if (key.equals(IndexMetaData.SETTING_NUMBER_OF_SHARDS)) {
      listener.onFailure(new ElasticSearchIllegalArgumentException("can't change the number of shards for an index"));
      return;
    }
  }
  final Settings closeSettings=updatedSettingsBuilder.build();
  final Set<String> removedSettings=Sets.newHashSet();
  final Set<String> errors=Sets.newHashSet();
  for (  Map.Entry<String,String> setting : updatedSettingsBuilder.internalMap().entrySet()) {
    if (!dynamicSettings.hasDynamicSetting(setting.getKey())) {
      removedSettings.add(setting.getKey());
    }
 else {
      String error=dynamicSettings.validateDynamicSetting(setting.getKey(),setting.getValue());
      if (error != null) {
        errors.add("[" + setting.getKey() + "] - "+ error);
      }
    }
  }
  if (!errors.isEmpty()) {
    listener.onFailure(new ElasticSearchIllegalArgumentException("can't process the settings: " + errors.toString()));
    return;
  }
  if (!removedSettings.isEmpty()) {
    for (    String removedSetting : removedSettings) {
      updatedSettingsBuilder.remove(removedSetting);
    }
  }
  final Settings openSettings=updatedSettingsBuilder.build();
  clusterService.submitStateUpdateTask("update-settings",Priority.URGENT,new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      try {
        String[] actualIndices=currentState.metaData().concreteIndices(indices);
        RoutingTable.Builder routingTableBuilder=RoutingTable.builder().routingTable(currentState.routingTable());
        MetaData.Builder metaDataBuilder=MetaData.newMetaDataBuilder().metaData(currentState.metaData());
        Set<String> openIndices=Sets.newHashSet();
        Set<String> closeIndices=Sets.newHashSet();
        for (        String index : actualIndices) {
          if (currentState.metaData().index(index).state() == IndexMetaData.State.OPEN) {
            openIndices.add(index);
          }
 else {
            closeIndices.add(index);
          }
        }
        if (!removedSettings.isEmpty() && !openIndices.isEmpty()) {
          listener.onFailure(new ElasticSearchIllegalArgumentException(String.format(Locale.ROOT,"Can't update non dynamic settings[%s] for open indices[%s]",removedSettings,openIndices)));
          return currentState;
        }
        int updatedNumberOfReplicas=openSettings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,-1);
        if (updatedNumberOfReplicas != -1) {
          routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas,actualIndices);
          metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas,actualIndices);
          logger.info("updating number_of_replicas to [{}] for indices {}",updatedNumberOfReplicas,actualIndices);
        }
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        Boolean updatedReadOnly=openSettings.getAsBoolean(IndexMetaData.SETTING_READ_ONLY,null);
        if (updatedReadOnly != null) {
          for (          String index : actualIndices) {
            if (updatedReadOnly) {
              blocks.addIndexBlock(index,IndexMetaData.INDEX_READ_ONLY_BLOCK);
            }
 else {
              blocks.removeIndexBlock(index,IndexMetaData.INDEX_READ_ONLY_BLOCK);
            }
          }
        }
        Boolean updateMetaDataBlock=openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_METADATA,null);
        if (updateMetaDataBlock != null) {
          for (          String index : actualIndices) {
            if (updateMetaDataBlock) {
              blocks.addIndexBlock(index,IndexMetaData.INDEX_METADATA_BLOCK);
            }
 else {
              blocks.removeIndexBlock(index,IndexMetaData.INDEX_METADATA_BLOCK);
            }
          }
        }
        Boolean updateWriteBlock=openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_WRITE,null);
        if (updateWriteBlock != null) {
          for (          String index : actualIndices) {
            if (updateWriteBlock) {
              blocks.addIndexBlock(index,IndexMetaData.INDEX_WRITE_BLOCK);
            }
 else {
              blocks.removeIndexBlock(index,IndexMetaData.INDEX_WRITE_BLOCK);
            }
          }
        }
        Boolean updateReadBlock=openSettings.getAsBoolean(IndexMetaData.SETTING_BLOCKS_READ,null);
        if (updateReadBlock != null) {
          for (          String index : actualIndices) {
            if (updateReadBlock) {
              blocks.addIndexBlock(index,IndexMetaData.INDEX_READ_BLOCK);
            }
 else {
              blocks.removeIndexBlock(index,IndexMetaData.INDEX_READ_BLOCK);
            }
          }
        }
        if (!openIndices.isEmpty()) {
          String[] indices=openIndices.toArray(new String[openIndices.size()]);
          metaDataBuilder.updateSettings(openSettings,indices);
        }
        if (!closeIndices.isEmpty()) {
          String[] indices=closeIndices.toArray(new String[closeIndices.size()]);
          metaDataBuilder.updateSettings(closeSettings,indices);
        }
        ClusterState updatedState=ClusterState.builder().state(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder).blocks(blocks).build();
        RoutingAllocation.Result routingResult=allocationService.reroute(updatedState);
        updatedState=newClusterStateBuilder().state(updatedState).routingResult(routingResult).build();
        return updatedState;
      }
 catch (      Throwable e) {
        listener.onFailure(e);
        return currentState;
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
      listener.onSuccess();
    }
  }
);
}
