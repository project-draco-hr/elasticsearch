{
  List<SnapshotStatus> builder=new ArrayList<>();
  Set<SnapshotId> currentSnapshotIds=new HashSet<>();
  if (!currentSnapshots.isEmpty()) {
    Map<String,TransportNodesSnapshotsStatus.NodeSnapshotStatus> nodeSnapshotStatusMap;
    if (nodeSnapshotStatuses != null) {
      nodeSnapshotStatusMap=nodeSnapshotStatuses.getNodesMap();
    }
 else {
      nodeSnapshotStatusMap=new HashMap<>();
    }
    for (    SnapshotsInProgress.Entry entry : currentSnapshots) {
      currentSnapshotIds.add(entry.snapshotId());
      List<SnapshotIndexShardStatus> shardStatusBuilder=new ArrayList<>();
      for (      ObjectObjectCursor<ShardId,SnapshotsInProgress.ShardSnapshotStatus> shardEntry : entry.shards()) {
        SnapshotsInProgress.ShardSnapshotStatus status=shardEntry.value;
        if (status.nodeId() != null) {
          TransportNodesSnapshotsStatus.NodeSnapshotStatus nodeStatus=nodeSnapshotStatusMap.get(status.nodeId());
          if (nodeStatus != null) {
            Map<ShardId,SnapshotIndexShardStatus> shardStatues=nodeStatus.status().get(entry.snapshotId());
            if (shardStatues != null) {
              SnapshotIndexShardStatus shardStatus=shardStatues.get(shardEntry.key);
              if (shardStatus != null) {
                shardStatusBuilder.add(shardStatus);
                continue;
              }
            }
          }
        }
        final SnapshotIndexShardStage stage;
switch (shardEntry.value.state()) {
case FAILED:
case ABORTED:
case MISSING:
          stage=SnapshotIndexShardStage.FAILURE;
        break;
case INIT:
case WAITING:
case STARTED:
      stage=SnapshotIndexShardStage.STARTED;
    break;
case SUCCESS:
  stage=SnapshotIndexShardStage.DONE;
break;
default :
throw new IllegalArgumentException("Unknown snapshot state " + shardEntry.value.state());
}
SnapshotIndexShardStatus shardStatus=new SnapshotIndexShardStatus(shardEntry.key,stage);
shardStatusBuilder.add(shardStatus);
}
builder.add(new SnapshotStatus(entry.snapshotId(),entry.state(),Collections.unmodifiableList(shardStatusBuilder)));
}
}
if (Strings.hasText(request.repository())) {
if (request.snapshots() != null && request.snapshots().length > 0) {
for (String snapshotName : request.snapshots()) {
SnapshotId snapshotId=new SnapshotId(request.repository(),snapshotName);
if (currentSnapshotIds.contains(snapshotId)) {
continue;
}
Snapshot snapshot=snapshotsService.snapshot(snapshotId);
List<SnapshotIndexShardStatus> shardStatusBuilder=new ArrayList<>();
if (snapshot.state().completed()) {
Map<ShardId,IndexShardSnapshotStatus> shardStatues=snapshotsService.snapshotShards(snapshotId);
for (ImmutableMap.Entry<ShardId,IndexShardSnapshotStatus> shardStatus : shardStatues.entrySet()) {
shardStatusBuilder.add(new SnapshotIndexShardStatus(shardStatus.getKey(),shardStatus.getValue()));
}
final SnapshotsInProgress.State state;
switch (snapshot.state()) {
case FAILED:
state=SnapshotsInProgress.State.FAILED;
break;
case SUCCESS:
case PARTIAL:
state=SnapshotsInProgress.State.SUCCESS;
break;
default :
throw new IllegalArgumentException("Unknown snapshot state " + snapshot.state());
}
builder.add(new SnapshotStatus(snapshotId,state,Collections.unmodifiableList(shardStatusBuilder)));
}
}
}
}
return new SnapshotsStatusResponse(Collections.unmodifiableList(builder));
}
