{
  final boolean waitForRequest=true;
  final boolean spawn=true;
  final ByteSizeValue payloadSize=new ByteSizeValue(100,ByteSizeUnit.BYTES);
  final int NUMBER_OF_CLIENTS=1;
  final int NUMBER_OF_ITERATIONS=100000;
  final byte[] payload=new byte[(int)payloadSize.bytes()];
  final AtomicLong idGenerator=new AtomicLong();
  Settings settings=ImmutableSettings.settingsBuilder().put("network.server",false).put("network.tcp.blocking",false).build();
  final ThreadPool threadPool=new CachedThreadPool(settings);
  final TimerService timerService=new TimerService(settings,threadPool);
  final TransportService transportService=new TransportService(new NettyTransport(settings,threadPool),threadPool).start();
  final DiscoveryNode node=new DiscoveryNode("server",new InetSocketTransportAddress("localhost",9999));
  transportService.connectToNode(node);
  for (int i=0; i < 10000; i++) {
    BenchmarkMessage message=new BenchmarkMessage(1,payload);
    transportService.submitRequest(node,"benchmark",message,new BaseTransportResponseHandler<BenchmarkMessage>(){
      @Override public BenchmarkMessage newInstance(){
        return new BenchmarkMessage();
      }
      @Override public void handleResponse(      BenchmarkMessage response){
      }
      @Override public void handleException(      TransportException exp){
        exp.printStackTrace();
      }
    }
).txGet();
  }
  Thread[] clients=new Thread[NUMBER_OF_CLIENTS];
  final CountDownLatch latch=new CountDownLatch(NUMBER_OF_CLIENTS * NUMBER_OF_ITERATIONS);
  for (int i=0; i < NUMBER_OF_CLIENTS; i++) {
    clients[i]=new Thread(new Runnable(){
      @Override public void run(){
        for (int j=0; j < NUMBER_OF_ITERATIONS; j++) {
          final long id=idGenerator.incrementAndGet();
          BenchmarkMessage message=new BenchmarkMessage(id,payload);
          BaseTransportResponseHandler<BenchmarkMessage> handler=new BaseTransportResponseHandler<BenchmarkMessage>(){
            @Override public BenchmarkMessage newInstance(){
              return new BenchmarkMessage();
            }
            @Override public void handleResponse(            BenchmarkMessage response){
              if (response.id != id) {
                System.out.println("NO ID MATCH [" + response.id + "] and ["+ id+ "]");
              }
              latch.countDown();
            }
            @Override public void handleException(            TransportException exp){
              exp.printStackTrace();
              latch.countDown();
            }
            @Override public boolean spawn(){
              return spawn;
            }
          }
;
          if (waitForRequest) {
            transportService.submitRequest(node,"benchmark",message,handler).txGet();
          }
 else {
            transportService.sendRequest(node,"benchmark",message,handler);
          }
        }
      }
    }
);
  }
  StopWatch stopWatch=new StopWatch().start();
  for (int i=0; i < NUMBER_OF_CLIENTS; i++) {
    clients[i].start();
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  stopWatch.stop();
  System.out.println("Ran [" + NUMBER_OF_CLIENTS + "], each with ["+ NUMBER_OF_ITERATIONS+ "] iterations, payload ["+ payloadSize+ "]: took ["+ stopWatch.totalTime()+ "], TPS: "+ (NUMBER_OF_CLIENTS * NUMBER_OF_ITERATIONS) / stopWatch.totalTime().secondsFrac());
  transportService.close();
  threadPool.shutdownNow();
}
