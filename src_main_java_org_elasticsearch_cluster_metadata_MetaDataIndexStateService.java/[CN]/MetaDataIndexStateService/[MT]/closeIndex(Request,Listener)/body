{
  if (request.indices == null || request.indices.length == 0) {
    throw new ElasticSearchIllegalArgumentException("Index name is required");
  }
  final String indicesAsString=Arrays.toString(request.indices);
  clusterService.submitStateUpdateTask("close-indices " + indicesAsString,Priority.URGENT,new TimeoutClusterStateUpdateTask(){
    @Override public TimeValue timeout(){
      return request.masterTimeout;
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    ClusterState currentState){
      List<String> indicesToClose=new ArrayList<String>();
      for (      String index : request.indices) {
        IndexMetaData indexMetaData=currentState.metaData().index(index);
        if (indexMetaData == null) {
          throw new IndexMissingException(new Index(index));
        }
        if (indexMetaData.state() != IndexMetaData.State.CLOSE) {
          IndexRoutingTable indexRoutingTable=currentState.routingTable().index(index);
          for (          IndexShardRoutingTable shard : indexRoutingTable) {
            if (!shard.primaryAllocatedPostApi()) {
              throw new IndexPrimaryShardNotAllocatedException(new Index(index));
            }
          }
          indicesToClose.add(index);
        }
      }
      if (indicesToClose.isEmpty()) {
        return currentState;
      }
      logger.info("closing indices [{}]",indicesAsString);
      MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
      ClusterBlocks.Builder blocksBuilder=ClusterBlocks.builder().blocks(currentState.blocks());
      for (      String index : indicesToClose) {
        mdBuilder.put(IndexMetaData.builder(currentState.metaData().index(index)).state(IndexMetaData.State.CLOSE));
        blocksBuilder.addIndexBlock(index,INDEX_CLOSED_BLOCK);
      }
      ClusterState updatedState=ClusterState.builder().state(currentState).metaData(mdBuilder).blocks(blocksBuilder).build();
      RoutingTable.Builder rtBuilder=RoutingTable.builder(currentState.routingTable());
      for (      String index : indicesToClose) {
        rtBuilder.remove(index);
      }
      RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder().state(updatedState).routingTable(rtBuilder).build());
      ClusterState newClusterState=ClusterState.builder().state(updatedState).routingResult(routingResult).build();
      waitForOtherNodes(newClusterState,listener,request.timeout);
      return newClusterState;
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      if (oldState == newState) {
        listener.onResponse(new Response(true));
      }
    }
  }
);
}
