{
  ShardId shardId=new ShardId(index,sShardId);
  if (shardsInjectors.containsKey(shardId.id())) {
    throw new IndexShardAlreadyExistsException(shardId + " already exists");
  }
  indicesLifecycle.beforeIndexShardCreated(shardId);
  logger.debug("Creating shard_id[{}]",shardId.id());
  List<Module> modules=Lists.newArrayList();
  modules.add(new ShardsPluginsModule(indexSettings,pluginsService));
  modules.add(new IndexShardModule(shardId));
  modules.add(new StoreModule(indexSettings));
  modules.add(new DeletionPolicyModule(indexSettings));
  modules.add(new MergePolicyModule(indexSettings));
  modules.add(new MergeSchedulerModule(indexSettings));
  modules.add(new TranslogModule(indexSettings));
  modules.add(new EngineModule(indexSettings));
  modules.add(new IndexShardGatewayModule(injector.getInstance(IndexGateway.class)));
  pluginsService.processModules(modules);
  Injector shardInjector=injector.createChildInjector(modules);
  shardsInjectors=newMapBuilder(shardsInjectors).put(shardId.id(),shardInjector).immutableMap();
  IndexShard indexShard=shardInjector.getInstance(IndexShard.class);
  Store store=shardInjector.getInstance(Store.class);
  try {
    store.deleteContent();
  }
 catch (  IOException e) {
    logger.warn("Failed to clean store on shard creation",e);
  }
  indicesLifecycle.afterIndexShardCreated(indexShard);
  shards=newMapBuilder(shards).put(shardId.id(),indexShard).immutableMap();
  return indexShard;
}
