{
  ValuesSourceConfig<NumericValuesSource> config=new ValuesSourceConfig<>(NumericValuesSource.class);
  String field=null;
  String script=null;
  String scriptLang=null;
  Map<String,Object> scriptParams=null;
  boolean keyed=false;
  long minDocCount=1;
  ExtendedBounds extendedBounds=null;
  InternalOrder order=(InternalOrder)Histogram.Order.KEY_ASC;
  String interval=null;
  boolean preZoneAdjustLargeInterval=false;
  DateTimeZone preZone=DateTimeZone.UTC;
  DateTimeZone postZone=DateTimeZone.UTC;
  String format=null;
  long preOffset=0;
  long postOffset=0;
  boolean assumeSorted=false;
  XContentParser.Token token;
  String currentFieldName=null;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentFieldName=parser.currentName();
    }
 else     if (token == XContentParser.Token.VALUE_STRING) {
      if ("field".equals(currentFieldName)) {
        field=parser.text();
      }
 else       if ("script".equals(currentFieldName)) {
        script=parser.text();
      }
 else       if ("lang".equals(currentFieldName)) {
        scriptLang=parser.text();
      }
 else       if ("time_zone".equals(currentFieldName) || "timeZone".equals(currentFieldName)) {
        preZone=parseZone(parser.text());
      }
 else       if ("pre_zone".equals(currentFieldName) || "preZone".equals(currentFieldName)) {
        preZone=parseZone(parser.text());
      }
 else       if ("post_zone".equals(currentFieldName) || "postZone".equals(currentFieldName)) {
        postZone=parseZone(parser.text());
      }
 else       if ("pre_offset".equals(currentFieldName) || "preOffset".equals(currentFieldName)) {
        preOffset=parseOffset(parser.text());
      }
 else       if ("post_offset".equals(currentFieldName) || "postOffset".equals(currentFieldName)) {
        postOffset=parseOffset(parser.text());
      }
 else       if ("interval".equals(currentFieldName)) {
        interval=parser.text();
      }
 else       if ("format".equals(currentFieldName)) {
        format=parser.text();
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
      }
    }
 else     if (token == XContentParser.Token.VALUE_BOOLEAN) {
      if ("keyed".equals(currentFieldName)) {
        keyed=parser.booleanValue();
      }
 else       if ("script_values_sorted".equals(currentFieldName) || "scriptValuesSorted".equals(currentFieldName)) {
        assumeSorted=parser.booleanValue();
      }
 else       if ("pre_zone_adjust_large_interval".equals(currentFieldName) || "preZoneAdjustLargeInterval".equals(currentFieldName)) {
        preZoneAdjustLargeInterval=parser.booleanValue();
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
      }
    }
 else     if (token == XContentParser.Token.VALUE_NUMBER) {
      if ("min_doc_count".equals(currentFieldName) || "minDocCount".equals(currentFieldName)) {
        minDocCount=parser.longValue();
      }
 else       if ("time_zone".equals(currentFieldName) || "timeZone".equals(currentFieldName)) {
        preZone=DateTimeZone.forOffsetHours(parser.intValue());
      }
 else       if ("pre_zone".equals(currentFieldName) || "preZone".equals(currentFieldName)) {
        preZone=DateTimeZone.forOffsetHours(parser.intValue());
      }
 else       if ("post_zone".equals(currentFieldName) || "postZone".equals(currentFieldName)) {
        postZone=DateTimeZone.forOffsetHours(parser.intValue());
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
      }
    }
 else     if (token == XContentParser.Token.START_OBJECT) {
      if ("params".equals(currentFieldName)) {
        scriptParams=parser.map();
      }
 else       if ("order".equals(currentFieldName)) {
        while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            currentFieldName=parser.currentName();
          }
 else           if (token == XContentParser.Token.VALUE_STRING) {
            String dir=parser.text();
            boolean asc="asc".equals(dir);
            order=resolveOrder(currentFieldName,asc);
          }
        }
      }
 else       if (EXTENDED_BOUNDS.match(currentFieldName)) {
        extendedBounds=new ExtendedBounds();
        while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
          if (token == XContentParser.Token.FIELD_NAME) {
            currentFieldName=parser.currentName();
          }
 else           if (token == XContentParser.Token.VALUE_STRING) {
            if ("min".equals(currentFieldName)) {
              extendedBounds.minAsStr=parser.text();
            }
 else             if ("max".equals(currentFieldName)) {
              extendedBounds.maxAsStr=parser.text();
            }
 else {
              throw new SearchParseException(context,"Unknown extended_bounds key for a " + token + " in aggregation ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
            }
          }
 else           if (token == XContentParser.Token.VALUE_NUMBER) {
            if ("min".equals(currentFieldName)) {
              extendedBounds.min=parser.longValue();
            }
 else             if ("max".equals(currentFieldName)) {
              extendedBounds.max=parser.longValue();
            }
 else {
              throw new SearchParseException(context,"Unknown extended_bounds key for a " + token + " in aggregation ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
            }
          }
 else {
            throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
          }
        }
      }
 else {
        throw new SearchParseException(context,"Unknown key for a " + token + " in ["+ aggregationName+ "]: ["+ currentFieldName+ "].");
      }
    }
 else {
      throw new SearchParseException(context,"Unexpected token " + token + " in ["+ aggregationName+ "].");
    }
  }
  if (interval == null) {
    throw new SearchParseException(context,"Missing required field [interval] for histogram aggregation [" + aggregationName + "]");
  }
  SearchScript searchScript=null;
  if (script != null) {
    searchScript=context.scriptService().search(context.lookup(),scriptLang,script,scriptParams);
    config.script(searchScript);
  }
  if (!assumeSorted) {
    config.ensureSorted(true);
  }
  TimeZoneRounding.Builder tzRoundingBuilder;
  DateTimeUnit dateTimeUnit=dateFieldUnits.get(interval);
  if (dateTimeUnit != null) {
    tzRoundingBuilder=TimeZoneRounding.builder(dateTimeUnit);
  }
 else {
    tzRoundingBuilder=TimeZoneRounding.builder(TimeValue.parseTimeValue(interval,null));
  }
  TimeZoneRounding rounding=tzRoundingBuilder.preZone(preZone).postZone(postZone).preZoneAdjustLargeInterval(preZoneAdjustLargeInterval).preOffset(preOffset).postOffset(postOffset).build();
  if (format != null) {
    config.formatter(new ValueFormatter.DateTime(format));
  }
  if (field == null) {
    if (searchScript != null) {
      ValueParser valueParser=new ValueParser.DateMath(new DateMathParser(DateFieldMapper.Defaults.DATE_TIME_FORMATTER,DateFieldMapper.Defaults.TIME_UNIT));
      config.parser(valueParser);
      return new HistogramAggregator.Factory(aggregationName,config,rounding,order,keyed,minDocCount,extendedBounds,InternalDateHistogram.FACTORY);
    }
    return new HistogramAggregator.Factory(aggregationName,config,rounding,order,keyed,minDocCount,extendedBounds,InternalDateHistogram.FACTORY);
  }
  FieldMapper<?> mapper=context.smartNameFieldMapper(field);
  if (mapper == null) {
    config.unmapped(true);
    if (format == null) {
      config.formatter(new ValueFormatter.DateTime(DateFieldMapper.Defaults.DATE_TIME_FORMATTER));
    }
    config.parser(new ValueParser.DateMath(new DateMathParser(DateFieldMapper.Defaults.DATE_TIME_FORMATTER,DateFieldMapper.Defaults.TIME_UNIT)));
    return new HistogramAggregator.Factory(aggregationName,config,rounding,order,keyed,minDocCount,extendedBounds,InternalDateHistogram.FACTORY);
  }
  if (!(mapper instanceof DateFieldMapper)) {
    throw new SearchParseException(context,"date histogram can only be aggregated on date fields but [" + field + "] is not a date field");
  }
  IndexFieldData<?> indexFieldData=context.fieldData().getForField(mapper);
  config.fieldContext(new FieldContext(field,indexFieldData));
  if (format == null) {
    config.formatter(new ValueFormatter.DateTime(((DateFieldMapper)mapper).dateTimeFormatter()));
  }
  config.parser(new ValueParser.DateMath(new DateMathParser(((DateFieldMapper)mapper).dateTimeFormatter(),DateFieldMapper.Defaults.TIME_UNIT)));
  return new HistogramAggregator.Factory(aggregationName,config,rounding,order,keyed,minDocCount,extendedBounds,InternalDateHistogram.FACTORY);
}
