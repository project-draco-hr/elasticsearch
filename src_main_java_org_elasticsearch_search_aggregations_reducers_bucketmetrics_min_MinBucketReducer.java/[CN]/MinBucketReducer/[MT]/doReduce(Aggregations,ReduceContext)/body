{
  List<String> minBucketKeys=new ArrayList<>();
  double minValue=Double.POSITIVE_INFINITY;
  List<String> bucketsPath=AggregationPath.parse(bucketsPaths()[0]).getPathElementsAsStringList();
  for (  Aggregation aggregation : aggregations) {
    if (aggregation.getName().equals(bucketsPath.get(0))) {
      bucketsPath=bucketsPath.subList(1,bucketsPath.size());
      InternalMultiBucketAggregation multiBucketsAgg=(InternalMultiBucketAggregation)aggregation;
      List<? extends Bucket> buckets=multiBucketsAgg.getBuckets();
      for (int i=0; i < buckets.size(); i++) {
        Bucket bucket=buckets.get(i);
        Double bucketValue=BucketHelpers.resolveBucketValue(multiBucketsAgg,bucket,bucketsPath,gapPolicy);
        if (bucketValue != null) {
          if (bucketValue < minValue) {
            minBucketKeys.clear();
            minBucketKeys.add(bucket.getKeyAsString());
            minValue=bucketValue;
          }
 else           if (bucketValue.equals(minValue)) {
            minBucketKeys.add(bucket.getKeyAsString());
          }
        }
      }
    }
  }
  String[] keys=minBucketKeys.toArray(new String[minBucketKeys.size()]);
  return new InternalBucketMetricValue(name(),keys,minValue,formatter,Collections.EMPTY_LIST,metaData());
}
