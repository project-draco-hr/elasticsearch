{
  ImmutableSettings.Builder updatedSettingsBuilder=ImmutableSettings.settingsBuilder();
  for (  Map.Entry<String,String> entry : pSettings.getAsMap().entrySet()) {
    if (entry.getKey().equals("index")) {
      continue;
    }
    if (!entry.getKey().startsWith("index.")) {
      updatedSettingsBuilder.put("index." + entry.getKey(),entry.getValue());
    }
 else {
      updatedSettingsBuilder.put(entry.getKey(),entry.getValue());
    }
  }
  for (  String key : updatedSettingsBuilder.internalMap().keySet()) {
    if (key.equals(IndexMetaData.SETTING_NUMBER_OF_SHARDS)) {
      listener.onFailure(new ElasticSearchIllegalArgumentException("can't change the number of shards for an index"));
      return;
    }
  }
  Set<String> removedSettings=Sets.newHashSet();
  for (  String key : updatedSettingsBuilder.internalMap().keySet()) {
    if (!IndexMetaData.dynamicSettings().contains(key)) {
      removedSettings.add(key);
    }
  }
  if (!removedSettings.isEmpty()) {
    logger.warn("{} ignoring non dynamic index level settings: {}",indices,removedSettings);
    for (    String removedSetting : removedSettings) {
      updatedSettingsBuilder.remove(removedSetting);
    }
  }
  final Settings settings=updatedSettingsBuilder.build();
  clusterService.submitStateUpdateTask("update-settings",new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      try {
        String[] actualIndices=currentState.metaData().concreteIndices(indices);
        RoutingTable.Builder routingTableBuilder=newRoutingTableBuilder().routingTable(currentState.routingTable());
        MetaData.Builder metaDataBuilder=MetaData.newMetaDataBuilder().metaData(currentState.metaData());
        int updatedNumberOfReplicas=settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,-1);
        if (updatedNumberOfReplicas != -1) {
          routingTableBuilder.updateNumberOfReplicas(updatedNumberOfReplicas,actualIndices);
          metaDataBuilder.updateNumberOfReplicas(updatedNumberOfReplicas,actualIndices);
          logger.info("Updating number_of_replicas to [{}] for indices {}",updatedNumberOfReplicas,actualIndices);
        }
        metaDataBuilder.updateSettings(settings,actualIndices);
        return ClusterState.builder().state(currentState).metaData(metaDataBuilder).routingTable(routingTableBuilder).build();
      }
 catch (      Exception e) {
        listener.onFailure(e);
        return currentState;
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
      listener.onSuccess();
    }
  }
);
}
