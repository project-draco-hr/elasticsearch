{
  final Struct owner=structs.get(struct);
  if (owner == null) {
    throw new IllegalArgumentException("Owner struct [" + struct + "] not defined for"+ " transform with cast type from ["+ from.name+ "] and cast type to ["+ to.name+ "].");
  }
  if (from.equals(to)) {
    throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "] cannot"+ " have cast type from ["+ from.name+ "] be the same as cast type to ["+ to.name+ "].");
  }
  final Cast cast=new Cast(from,to);
  if (transforms.containsKey(cast)) {
    throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] already defined.");
  }
  Method method;
  Type upcast=null;
  Type downcast=null;
  if (statik) {
    method=owner.functions.get(name);
    if (method == null) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using a function ["+ name+ "] that is not defined.");
    }
    if (method.arguments.size() != 1) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using function ["+ name+ "] does not have a single type argument.");
    }
    Type argument=method.arguments.get(0);
    try {
      from.clazz.asSubclass(argument.clazz);
    }
 catch (    ClassCastException cce0) {
      try {
        argument.clazz.asSubclass(from.clazz);
        upcast=argument;
      }
 catch (      ClassCastException cce1) {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using"+ " function ["+ name+ "] cannot cast from type to the function input argument type.");
      }
    }
    final Type rtn=method.rtn;
    try {
      rtn.clazz.asSubclass(to.clazz);
    }
 catch (    ClassCastException cce0) {
      try {
        to.clazz.asSubclass(rtn.clazz);
        downcast=to;
      }
 catch (      ClassCastException cce1) {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using"+ " function ["+ name+ "] cannot cast to type to the function return argument type.");
      }
    }
  }
 else {
    method=owner.methods.get(name);
    if (method == null) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using a method ["+ name+ "] that is not defined.");
    }
    if (!method.arguments.isEmpty()) {
      throw new IllegalArgumentException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using method ["+ name+ "] does not have a single type argument.");
    }
    try {
      from.clazz.asSubclass(owner.clazz);
    }
 catch (    ClassCastException cce0) {
      try {
        owner.clazz.asSubclass(from.clazz);
        upcast=getType(owner.name);
      }
 catch (      ClassCastException cce1) {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "] using"+ " method ["+ name+ "] cannot cast from type to the method input argument type.");
      }
    }
    final Type rtn=method.rtn;
    try {
      rtn.clazz.asSubclass(to.clazz);
    }
 catch (    ClassCastException cce0) {
      try {
        to.clazz.asSubclass(rtn.clazz);
        downcast=to;
      }
 catch (      ClassCastException cce1) {
        throw new ClassCastException("Transform with owner struct [" + owner.name + "]"+ " and cast type from ["+ from.name+ "] to cast type to ["+ to.name+ "]"+ " using method ["+ name+ "] cannot cast to type to the method return argument type.");
      }
    }
  }
  final Transform transform=new Transform(cast,method,upcast,downcast);
  transforms.put(cast,transform);
}
