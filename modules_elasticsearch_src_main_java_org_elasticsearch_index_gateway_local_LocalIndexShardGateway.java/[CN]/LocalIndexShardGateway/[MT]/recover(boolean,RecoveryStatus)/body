{
  recoveryStatus.index().startTime(System.currentTimeMillis());
  long version=-1;
  long translogId=-1;
  try {
    if (IndexReader.indexExists(indexShard.store().directory())) {
      version=IndexReader.getCurrentVersion(indexShard.store().directory());
      Map<String,String> commitUserData=IndexReader.getCommitUserData(indexShard.store().directory());
      if (commitUserData.containsKey(Translog.TRANSLOG_ID_KEY)) {
        translogId=Long.parseLong(commitUserData.get(Translog.TRANSLOG_ID_KEY));
      }
 else {
        translogId=version;
      }
    }
 else     if (indexShouldExists) {
      throw new IndexShardGatewayRecoveryException(shardId(),"shard allocated for local recovery (post api), should exists, but doesn't");
    }
  }
 catch (  IOException e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to fetch index version after copying it over",e);
  }
  recoveryStatus.index().updateVersion(version);
  recoveryStatus.index().time(System.currentTimeMillis() - recoveryStatus.index().startTime());
  try {
    int numberOfFiles=0;
    long totalSizeInBytes=0;
    for (    String name : indexShard.store().directory().listAll()) {
      numberOfFiles++;
      totalSizeInBytes+=indexShard.store().directory().fileLength(name);
    }
    recoveryStatus.index().files(numberOfFiles,totalSizeInBytes,numberOfFiles,totalSizeInBytes);
  }
 catch (  Exception e) {
  }
  recoveryStatus.translog().startTime(System.currentTimeMillis());
  if (translogId == -1) {
    indexShard.start("post recovery from gateway, no translog");
    recoveryStatus.translog().time(System.currentTimeMillis() - recoveryStatus.index().startTime());
    return;
  }
  FsTranslog translog=(FsTranslog)indexShard.translog();
  File recoveringTranslogFile=new File(translog.location(),"translog-" + translogId + ".recovering");
  if (!recoveringTranslogFile.exists()) {
    File translogFile=new File(translog.location(),"translog-" + translogId);
    if (translogFile.exists()) {
      for (int i=0; i < 3; i++) {
        if (translogFile.renameTo(recoveringTranslogFile)) {
          break;
        }
      }
    }
  }
  if (!recoveringTranslogFile.exists()) {
    indexShard.start("post recovery from gateway, no translog");
    recoveryStatus.translog().time(System.currentTimeMillis() - recoveryStatus.index().startTime());
    return;
  }
  indexShard.performRecoveryPrepareForTranslog();
  try {
    InputStreamStreamInput si=new InputStreamStreamInput(new FileInputStream(recoveringTranslogFile));
    while (true) {
      Translog.Operation operation;
      try {
        int opSize=si.readInt();
        operation=TranslogStreams.readTranslogOperation(si);
      }
 catch (      EOFException e) {
        break;
      }
catch (      IOException e) {
        break;
      }
      recoveryStatus.translog().addTranslogOperations(1);
      indexShard.performRecoveryOperation(operation);
    }
  }
 catch (  Throwable e) {
    indexShard.translog().close(true);
    throw new IndexShardGatewayRecoveryException(shardId,"failed to recover shard",e);
  }
  indexShard.performRecoveryFinalization(true);
  recoveringTranslogFile.delete();
  recoveryStatus.translog().time(System.currentTimeMillis() - recoveryStatus.index().startTime());
}
