{
  for (  Map.Entry<String,Object> entry : fieldNode.entrySet()) {
    String propName=Strings.toUnderscoreCase(entry.getKey());
    Object propNode=entry.getValue();
    if (propName.equals("index_name")) {
      builder.indexName(propNode.toString());
    }
 else     if (propName.equals("store")) {
      builder.store(parseStore(name,propNode.toString()));
    }
 else     if (propName.equals("index")) {
      parseIndex(name,propNode.toString(),builder);
    }
 else     if (propName.equals("tokenized")) {
      builder.tokenized(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("term_vector")) {
      parseTermVector(name,propNode.toString(),builder);
    }
 else     if (propName.equals("boost")) {
      builder.boost(nodeFloatValue(propNode));
    }
 else     if (propName.equals("store_term_vectors")) {
      builder.storeTermVectors(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("store_term_vector_offsets")) {
      builder.storeTermVectorOffsets(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("store_term_vector_positions")) {
      builder.storeTermVectorPositions(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("store_term_vector_payloads")) {
      builder.storeTermVectorPayloads(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("omit_norms")) {
      builder.omitNorms(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("omit_term_freq_and_positions")) {
      builder.indexOptions(nodeBooleanValue(propNode) ? IndexOptions.DOCS_ONLY : IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
    }
 else     if (propName.equals("index_options")) {
      builder.indexOptions(nodeIndexOptionValue(propNode));
    }
 else     if (propName.equals("analyzer")) {
      NamedAnalyzer analyzer=parserContext.analysisService().analyzer(propNode.toString());
      if (analyzer == null) {
        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field ["+ name+ "]");
      }
      builder.indexAnalyzer(analyzer);
      builder.searchAnalyzer(analyzer);
    }
 else     if (propName.equals("index_analyzer")) {
      NamedAnalyzer analyzer=parserContext.analysisService().analyzer(propNode.toString());
      if (analyzer == null) {
        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field ["+ name+ "]");
      }
      builder.indexAnalyzer(analyzer);
    }
 else     if (propName.equals("search_analyzer")) {
      NamedAnalyzer analyzer=parserContext.analysisService().analyzer(propNode.toString());
      if (analyzer == null) {
        throw new MapperParsingException("Analyzer [" + propNode.toString() + "] not found for field ["+ name+ "]");
      }
      builder.searchAnalyzer(analyzer);
    }
 else     if (propName.equals("include_in_all")) {
      builder.includeInAll(nodeBooleanValue(propNode));
    }
 else     if (propName.equals("postings_format")) {
      String postingFormatName=propNode.toString();
      builder.postingsFormat(parserContext.postingFormatService().get(postingFormatName));
    }
 else     if (propName.equals(DOC_VALUES_FORMAT)) {
      String docValuesFormatName=propNode.toString();
      builder.docValuesFormat(parserContext.docValuesFormatService().get(docValuesFormatName));
    }
 else     if (propName.equals("similarity")) {
      builder.similarity(parserContext.similarityLookupService().similarity(propNode.toString()));
    }
 else     if (propName.equals("fielddata")) {
      final Settings settings;
      if (propNode instanceof Map) {
        settings=ImmutableSettings.builder().put(SettingsLoader.Helper.loadNestedFromMap((Map<String,Object>)propNode)).build();
      }
 else {
        throw new ElasticSearchParseException("fielddata should be a hash but was of type: " + propNode.getClass());
      }
      builder.fieldDataSettings(settings);
    }
  }
}
