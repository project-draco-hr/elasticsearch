{
  if (propName.equals("path")) {
    builder.multiFieldPathType(parsePathType(name,propNode.toString()));
    return true;
  }
 else   if (propName.equals("fields")) {
    final Map<String,Object> multiFieldsPropNodes;
    if (propNode instanceof List && ((List<?>)propNode).isEmpty()) {
      multiFieldsPropNodes=Collections.emptyMap();
    }
 else     if (propNode instanceof Map) {
      multiFieldsPropNodes=(Map<String,Object>)propNode;
    }
 else {
      throw new MapperParsingException("Expected map for property [fields] on field [" + propNode + "] or "+ "["+ propName+ "] but got a "+ propNode.getClass());
    }
    for (    Map.Entry<String,Object> multiFieldEntry : multiFieldsPropNodes.entrySet()) {
      String multiFieldName=multiFieldEntry.getKey();
      if (!(multiFieldEntry.getValue() instanceof Map)) {
        throw new MapperParsingException("Illegal field [" + multiFieldName + "], only fields can be specified inside fields");
      }
      @SuppressWarnings("unchecked") Map<String,Object> multiFieldNodes=(Map<String,Object>)multiFieldEntry.getValue();
      String type;
      Object typeNode=multiFieldNodes.get("type");
      if (typeNode != null) {
        type=typeNode.toString();
      }
 else {
        throw new MapperParsingException("No type specified for property [" + multiFieldName + "]");
      }
      Mapper.TypeParser typeParser=parserContext.typeParser(type);
      if (typeParser == null) {
        throw new MapperParsingException("No handler for type [" + type + "] declared on field ["+ multiFieldName+ "]");
      }
      builder.addMultiField(typeParser.parse(multiFieldName,multiFieldNodes,parserContext));
      multiFieldNodes.remove("type");
      DocumentMapperParser.checkNoRemainingFields(propName,multiFieldNodes,parserContext.indexVersionCreated());
    }
    return true;
  }
  return false;
}
