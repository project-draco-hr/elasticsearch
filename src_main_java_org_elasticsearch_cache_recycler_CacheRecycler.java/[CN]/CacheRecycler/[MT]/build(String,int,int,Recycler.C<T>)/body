{
  Recycler<T> recycler;
  try {
    final Type t=type == null ? Type.SOFT_THREAD_LOCAL : Type.valueOf(type.toUpperCase(Locale.ROOT));
switch (t) {
case SOFT_THREAD_LOCAL:
      recycler=new SoftThreadLocalRecycler<T>(c,limit);
    break;
case THREAD_LOCAL:
  recycler=new ThreadLocalRecycler<T>(c,limit);
break;
case QUEUE:
recycler=new QueueRecycler<T>(c);
break;
case NONE:
recycler=new NoneRecycler<T>(c);
break;
default :
throw new ElasticSearchIllegalArgumentException("no type support [" + type + "] for recycler");
}
if (smartSize > 0) {
recycler=new Recycler.Sizing<T>(recycler,smartSize);
}
}
 catch (IllegalArgumentException ex) {
throw new ElasticSearchIllegalArgumentException("no type support [" + type + "] for recycler");
}
return recycler;
}
