{
  this.mapperService=mapperService;
  this.type=rootObjectMapper.name();
  this.typeText=new StringAndBytesText(this.type);
  this.mapping=new Mapping(Version.indexCreated(indexSettings),rootObjectMapper,rootMappers.values().toArray(new MetadataFieldMapper[rootMappers.values().size()]),sourceTransforms.toArray(new SourceTransform[sourceTransforms.size()]),meta);
  this.documentParser=new DocumentParser(index,indexSettings,docMapperParser,this,new ReleasableLock(mappingLock.readLock()));
  this.typeFilter=typeMapper().fieldType().termQuery(type,null);
  this.mappingWriteLock=new ReleasableLock(mappingLock.writeLock());
  this.mappingLock=mappingLock;
  if (rootMapper(ParentFieldMapper.class).active()) {
    rootMapper(RoutingFieldMapper.class).markAsRequired();
  }
  List<ObjectMapper> newObjectMappers=new ArrayList<>();
  List<FieldMapper> newFieldMappers=new ArrayList<>();
  for (  MetadataFieldMapper metadataMapper : this.mapping.metadataMappers) {
    if (metadataMapper instanceof FieldMapper) {
      newFieldMappers.add((FieldMapper)metadataMapper);
    }
  }
  MapperUtils.collect(this.mapping.root,newObjectMappers,newFieldMappers);
  this.fieldMappers=new DocumentFieldMappers(docMapperParser.analysisService).copyAndAllAll(newFieldMappers);
  this.objectMappers=Maps.uniqueIndex(newObjectMappers,new Function<ObjectMapper,String>(){
    @Override public String apply(    ObjectMapper mapper){
      return mapper.fullPath();
    }
  }
);
  for (  ObjectMapper objectMapper : newObjectMappers) {
    if (objectMapper.nested().isNested()) {
      hasNestedObjects=true;
    }
  }
  refreshSource();
}
