{
  this.mapperService=mapperService;
  this.type=rootObjectMapper.name();
  this.typeText=new StringAndBytesText(this.type);
  this.mapping=new Mapping(Version.indexCreated(indexSettings),rootObjectMapper,rootMappers.values().toArray(new MetadataFieldMapper[rootMappers.values().size()]),meta);
  this.documentParser=new DocumentParser(indexSettings,docMapperParser,this,new ReleasableLock(mappingLock.readLock()));
  this.mappingWriteLock=new ReleasableLock(mappingLock.writeLock());
  this.mappingLock=mappingLock;
  if (rootMapper(ParentFieldMapper.class).active()) {
    rootMapper(RoutingFieldMapper.class).markAsRequired();
  }
  List<ObjectMapper> newObjectMappers=new ArrayList<>();
  List<FieldMapper> newFieldMappers=new ArrayList<>();
  for (  MetadataFieldMapper metadataMapper : this.mapping.metadataMappers) {
    if (metadataMapper instanceof FieldMapper) {
      newFieldMappers.add(metadataMapper);
    }
  }
  MapperUtils.collect(this.mapping.root,newObjectMappers,newFieldMappers);
  this.fieldMappers=new DocumentFieldMappers(docMapperParser.analysisService).copyAndAllAll(newFieldMappers);
  Map<String,ObjectMapper> builder=new HashMap<>();
  for (  ObjectMapper objectMapper : newObjectMappers) {
    ObjectMapper previous=builder.put(objectMapper.fullPath(),objectMapper);
    if (previous != null) {
      throw new IllegalStateException("duplicate key " + objectMapper.fullPath() + " encountered");
    }
  }
  this.objectMappers=Collections.unmodifiableMap(builder);
  for (  ObjectMapper objectMapper : newObjectMappers) {
    if (objectMapper.nested().isNested()) {
      hasNestedObjects=true;
    }
  }
  refreshSource();
}
