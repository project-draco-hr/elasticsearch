{
  ClusterState state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder()).build();
  assertThat(store.isIngestIndexPresent(state),equalTo(false));
  IndexMetaData.Builder indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,PipelineStore.PIPELINE_MAPPING);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  assertThat(store.isIngestIndexPresent(state),equalTo(true));
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.mapper.dynamic",true).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,PipelineStore.PIPELINE_MAPPING);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest index setting, [index.mapper.dynamic] setting is [true] while [false] is expected"));
  }
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.number_of_shards",2).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,PipelineStore.PIPELINE_MAPPING);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest index setting, [index.number_of_shards] setting is [2] while [1] is expected"));
  }
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.number_of_replicas",2).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,PipelineStore.PIPELINE_MAPPING);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest index setting, [index.number_of_replicas] setting is [2] while [1] is expected"));
  }
  String mapping=XContentFactory.jsonBuilder().startObject().startObject("_all").field("enabled",false).endObject().startObject("properties").startObject("processors").field("type","object").field("enabled",false).field("dynamic",true).endObject().startObject("on_failure").field("type","object").field("enabled",false).field("dynamic",true).endObject().startObject("description").field("type","string").endObject().endObject().endObject().string();
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,mapping);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest mapping, pipeline mapping must be strict"));
  }
  mapping=XContentFactory.jsonBuilder().startObject().field("dynamic","strict").startObject("_all").field("enabled",true).endObject().startObject("properties").startObject("processors").field("type","object").field("enabled",false).field("dynamic","true").endObject().startObject("on_failure").field("type","object").field("enabled",false).field("dynamic","true").endObject().startObject("description").field("type","string").endObject().endObject().endObject().string();
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,mapping);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest mapping, _all field is enabled"));
  }
  mapping=XContentFactory.jsonBuilder().startObject().field("dynamic","strict").startObject("_all").field("enabled",false).endObject().startObject("properties").startObject("processors").field("type","nested").field("enabled",false).field("dynamic","true").endObject().startObject("on_failure").field("type","object").field("enabled",false).field("dynamic","true").endObject().startObject("description").field("type","string").endObject().endObject().endObject().string();
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,mapping);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest mapping, processors field's type is [nested] while [object] is expected"));
  }
  mapping=XContentFactory.jsonBuilder().startObject().field("dynamic","strict").startObject("_all").field("enabled",false).endObject().startObject("properties").startObject("processors").field("type","object").field("enabled",true).field("dynamic","true").endObject().startObject("on_failure").field("type","object").field("enabled",false).field("dynamic","true").endObject().startObject("description").field("type","string").endObject().endObject().endObject().string();
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,mapping);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest mapping, processors field enabled option is [true] while [false] is expected"));
  }
  mapping=XContentFactory.jsonBuilder().startObject().field("dynamic","strict").startObject("_all").field("enabled",false).endObject().startObject("properties").startObject("processors").field("type","object").field("enabled",false).field("dynamic","false").endObject().startObject("on_failure").field("type","object").field("enabled",false).field("dynamic","true").endObject().startObject("description").field("type","string").endObject().endObject().endObject().string();
  indexMetaData=IndexMetaData.builder(PipelineStore.INDEX).settings(Settings.builder().put(PipelineStore.INGEST_INDEX_SETTING).put("index.version.created",Version.CURRENT)).putMapping(PipelineStore.TYPE,mapping);
  state=ClusterState.builder(new ClusterName("_name")).metaData(MetaData.builder().put(indexMetaData)).build();
  try {
    store.isIngestIndexPresent(state);
    fail("exception expected");
  }
 catch (  IllegalStateException e) {
    assertThat(e.getMessage(),equalTo("illegal ingest mapping, processors field dynamic option is [false] while [true] is expected"));
  }
}
