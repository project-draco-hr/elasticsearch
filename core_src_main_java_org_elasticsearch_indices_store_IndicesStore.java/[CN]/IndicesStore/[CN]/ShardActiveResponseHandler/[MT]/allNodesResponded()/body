{
  if (activeCopies.get() != expectedActiveCopies) {
    logger.trace("not deleting shard {}, expected {} active copies, but only {} found active copies",shardId,expectedActiveCopies,activeCopies.get());
    return;
  }
  ClusterState latestClusterState=clusterService.state();
  if (clusterState.getVersion() != latestClusterState.getVersion()) {
    logger.trace("not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,latestClusterState.getVersion(),clusterState.getVersion());
    return;
  }
  clusterService.submitStateUpdateTask("indices_store ([" + shardId + "] active fully on other nodes)",new ClusterStateUpdateTask(){
    @Override public boolean runOnlyOnMaster(){
      return false;
    }
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      if (clusterState.getVersion() != currentState.getVersion()) {
        logger.trace("not deleting shard {}, the update task state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,currentState.getVersion(),clusterState.getVersion());
        return currentState;
      }
      try {
        indicesService.deleteShardStore("no longer used",shardId,currentState);
      }
 catch (      Exception ex) {
        logger.debug(new ParameterizedMessage("{} failed to delete unallocated shard, ignoring",shardId),ex);
      }
      return currentState;
    }
    @Override public void onFailure(    String source,    Exception e){
      logger.error(new ParameterizedMessage("{} unexpected error during deletion of unallocated shard",shardId),e);
    }
  }
);
}
