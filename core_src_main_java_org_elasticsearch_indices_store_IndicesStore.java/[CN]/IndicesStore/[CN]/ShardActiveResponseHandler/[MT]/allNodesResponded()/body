{
  if (activeCopies.get() != expectedActiveCopies) {
    logger.trace("not deleting shard {}, expected {} active copies, but only {} found active copies",shardId,expectedActiveCopies,activeCopies.get());
    return;
  }
  ClusterState latestClusterState=clusterService.state();
  if (clusterState.getVersion() != latestClusterState.getVersion()) {
    logger.trace("not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,latestClusterState.getVersion(),clusterState.getVersion());
    return;
  }
  clusterService.submitStateUpdateTask("indices_store ([" + shardId + "] active fully on other nodes)",new ClusterStateNonMasterUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      if (clusterState.getVersion() != currentState.getVersion()) {
        logger.trace("not deleting shard {}, the update task state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,currentState.getVersion(),clusterState.getVersion());
        return currentState;
      }
      try {
        indicesService.deleteShardStore("no longer used",shardId,currentState);
      }
 catch (      Throwable ex) {
        logger.debug("{} failed to delete unallocated shard, ignoring",ex,shardId);
      }
      return currentState;
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("{} unexpected error during deletion of unallocated shard",t,shardId);
    }
  }
);
}
