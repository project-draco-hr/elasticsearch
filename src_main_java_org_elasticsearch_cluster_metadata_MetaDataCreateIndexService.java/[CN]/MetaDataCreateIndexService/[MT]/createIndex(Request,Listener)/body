{
  ImmutableSettings.Builder updatedSettingsBuilder=ImmutableSettings.settingsBuilder();
  for (  Map.Entry<String,String> entry : request.settings.getAsMap().entrySet()) {
    if (!entry.getKey().startsWith("index.")) {
      updatedSettingsBuilder.put("index." + entry.getKey(),entry.getValue());
    }
 else {
      updatedSettingsBuilder.put(entry.getKey(),entry.getValue());
    }
  }
  request.settings(updatedSettingsBuilder.build());
  MetaDataService.MdLock mdLock=metaDataService.indexMetaDataLock(request.index);
  try {
    mdLock.lock();
  }
 catch (  InterruptedException e) {
    userListener.onFailure(e);
    return;
  }
  final CreateIndexListener listener=new CreateIndexListener(mdLock,request,userListener);
  clusterService.submitStateUpdateTask("create-index [" + request.index + "], cause ["+ request.cause+ "]",new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      boolean indexCreated=false;
      String failureReason=null;
      try {
        try {
          validate(request,currentState);
        }
 catch (        Exception e) {
          listener.onFailure(e);
          return currentState;
        }
        List<IndexTemplateMetaData> templates=findTemplates(request,currentState);
        Map<String,Custom> customs=Maps.newHashMap();
        Map<String,Map<String,Object>> mappings=Maps.newHashMap();
        if (request.index.equals(PercolatorService.INDEX_NAME)) {
          mappings.put(MapperService.DEFAULT_MAPPING,parseMapping("{\n" + "    \"_default_\":{\n" + "        \"properties\" : {\n"+ "            \"query\" : {\n"+ "                \"type\" : \"object\",\n"+ "                \"enabled\" : false\n"+ "            }\n"+ "        }\n"+ "    }\n"+ "}"));
        }
        for (        Map.Entry<String,String> entry : request.mappings.entrySet()) {
          mappings.put(entry.getKey(),parseMapping(entry.getValue()));
        }
        for (        Map.Entry<String,Custom> entry : request.customs.entrySet()) {
          customs.put(entry.getKey(),entry.getValue());
        }
        for (        IndexTemplateMetaData template : templates) {
          for (          Map.Entry<String,CompressedString> entry : template.mappings().entrySet()) {
            if (mappings.containsKey(entry.getKey())) {
              XContentHelper.mergeDefaults(mappings.get(entry.getKey()),parseMapping(entry.getValue().string()));
            }
 else {
              mappings.put(entry.getKey(),parseMapping(entry.getValue().string()));
            }
          }
          for (          Map.Entry<String,Custom> customEntry : template.customs().entrySet()) {
            String type=customEntry.getKey();
            IndexMetaData.Custom custom=customEntry.getValue();
            IndexMetaData.Custom existing=customs.get(type);
            if (existing == null) {
              customs.put(type,custom);
            }
 else {
              IndexMetaData.Custom merged=IndexMetaData.lookupFactorySafe(type).merge(existing,custom);
              customs.put(type,merged);
            }
          }
        }
        File mappingsDir=new File(environment.configFile(),"mappings");
        if (mappingsDir.exists() && mappingsDir.isDirectory()) {
          File indexMappingsDir=new File(mappingsDir,request.index);
          if (indexMappingsDir.exists() && indexMappingsDir.isDirectory()) {
            addMappings(mappings,indexMappingsDir);
          }
          File defaultMappingsDir=new File(mappingsDir,"_default");
          if (defaultMappingsDir.exists() && defaultMappingsDir.isDirectory()) {
            addMappings(mappings,defaultMappingsDir);
          }
        }
        ImmutableSettings.Builder indexSettingsBuilder=settingsBuilder();
        for (int i=templates.size() - 1; i >= 0; i--) {
          indexSettingsBuilder.put(templates.get(i).settings());
        }
        indexSettingsBuilder.put(request.settings);
        if (request.index.equals(PercolatorService.INDEX_NAME)) {
          indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,1);
        }
 else {
          if (indexSettingsBuilder.get(SETTING_NUMBER_OF_SHARDS) == null) {
            if (request.index.equals(riverIndexName)) {
              indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,1));
            }
 else {
              indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,5));
            }
          }
        }
        if (request.index.equals(PercolatorService.INDEX_NAME)) {
          indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,0);
          indexSettingsBuilder.put(SETTING_AUTO_EXPAND_REPLICAS,"0-all");
        }
 else {
          if (indexSettingsBuilder.get(SETTING_NUMBER_OF_REPLICAS) == null) {
            if (request.index.equals(riverIndexName)) {
              indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,1));
            }
 else {
              indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,1));
            }
          }
        }
        if (settings.get(SETTING_AUTO_EXPAND_REPLICAS) != null && indexSettingsBuilder.get(SETTING_AUTO_EXPAND_REPLICAS) == null) {
          indexSettingsBuilder.put(SETTING_AUTO_EXPAND_REPLICAS,settings.get(SETTING_AUTO_EXPAND_REPLICAS));
        }
        indexSettingsBuilder.put(SETTING_VERSION_CREATED,Version.CURRENT);
        Settings actualIndexSettings=indexSettingsBuilder.build();
        indicesService.createIndex(request.index,actualIndexSettings,clusterService.state().nodes().localNode().id());
        indexCreated=true;
        IndexService indexService=indicesService.indexServiceSafe(request.index);
        MapperService mapperService=indexService.mapperService();
        if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {
          try {
            mapperService.merge(MapperService.DEFAULT_MAPPING,XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string(),false);
          }
 catch (          Exception e) {
            failureReason="failed on parsing default mapping on index creation";
            throw new MapperParsingException("mapping [" + MapperService.DEFAULT_MAPPING + "]",e);
          }
        }
        for (        Map.Entry<String,Map<String,Object>> entry : mappings.entrySet()) {
          if (entry.getKey().equals(MapperService.DEFAULT_MAPPING)) {
            continue;
          }
          try {
            mapperService.merge(entry.getKey(),XContentFactory.jsonBuilder().map(entry.getValue()).string(),true);
          }
 catch (          Exception e) {
            failureReason="failed on parsing mappings on index creation";
            throw new MapperParsingException("mapping [" + entry.getKey() + "]",e);
          }
        }
        Map<String,MappingMetaData> mappingsMetaData=Maps.newHashMap();
        for (        DocumentMapper mapper : mapperService) {
          MappingMetaData mappingMd=new MappingMetaData(mapper);
          mappingsMetaData.put(mapper.type(),mappingMd);
        }
        final IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(request.index).settings(actualIndexSettings);
        for (        MappingMetaData mappingMd : mappingsMetaData.values()) {
          indexMetaDataBuilder.putMapping(mappingMd);
        }
        for (        Map.Entry<String,Custom> customEntry : customs.entrySet()) {
          indexMetaDataBuilder.putCustom(customEntry.getKey(),customEntry.getValue());
        }
        indexMetaDataBuilder.state(request.state);
        final IndexMetaData indexMetaData;
        try {
          indexMetaData=indexMetaDataBuilder.build();
        }
 catch (        Exception e) {
          failureReason="failed to build index metadata";
          throw e;
        }
        MetaData newMetaData=newMetaDataBuilder().metaData(currentState.metaData()).put(indexMetaData,false).build();
        logger.info("[{}] creating index, cause [{}], shards [{}]/[{}], mappings {}",request.index,request.cause,indexMetaData.numberOfShards(),indexMetaData.numberOfReplicas(),mappings.keySet());
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        if (!request.blocks.isEmpty()) {
          for (          ClusterBlock block : request.blocks) {
            blocks.addIndexBlock(request.index,block);
          }
        }
        if (request.state == State.CLOSE) {
          blocks.addIndexBlock(request.index,MetaDataStateIndexService.INDEX_CLOSED_BLOCK);
        }
        ClusterState updatedState=newClusterStateBuilder().state(currentState).blocks(blocks).metaData(newMetaData).build();
        if (request.state == State.OPEN) {
          RoutingTable.Builder routingTableBuilder=RoutingTable.builder().routingTable(updatedState.routingTable()).addAsNew(updatedState.metaData().index(request.index));
          RoutingAllocation.Result routingResult=allocationService.reroute(newClusterStateBuilder().state(updatedState).routingTable(routingTableBuilder).build());
          updatedState=newClusterStateBuilder().state(updatedState).routingResult(routingResult).build();
        }
        final AtomicInteger counter=new AtomicInteger(currentState.nodes().size());
        final NodeIndexCreatedAction.Listener nodeIndexCreatedListener=new NodeIndexCreatedAction.Listener(){
          @Override public void onNodeIndexCreated(          String index,          String nodeId){
            if (index.equals(request.index)) {
              if (counter.decrementAndGet() == 0) {
                listener.onResponse(new Response(true,indexMetaData));
                nodeIndexCreatedAction.remove(this);
              }
            }
          }
        }
;
        nodeIndexCreatedAction.add(nodeIndexCreatedListener);
        listener.future=threadPool.schedule(request.timeout,ThreadPool.Names.SAME,new Runnable(){
          @Override public void run(){
            listener.onResponse(new Response(false,indexMetaData));
            nodeIndexCreatedAction.remove(nodeIndexCreatedListener);
          }
        }
);
        return updatedState;
      }
 catch (      Throwable e) {
        logger.warn("[{}] failed to create",e,request.index);
        if (indexCreated) {
          indicesService.deleteIndex(request.index,failureReason != null ? failureReason : "failed to create index");
        }
        listener.onFailure(e);
        return currentState;
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
    }
  }
);
}
