{
  final CreateIndexListener listener=new CreateIndexListener(mdLock,request,userListener);
  clusterService.submitStateUpdateTask("create-index [" + request.index + "], cause ["+ request.cause+ "]",Priority.URGENT,new TimeoutClusterStateUpdateTask(){
    @Override public TimeValue timeout(){
      return request.masterTimeout;
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      boolean indexCreated=false;
      String failureReason=null;
      try {
        validate(request,currentState);
        List<IndexTemplateMetaData> templates=findTemplates(request,currentState);
        Map<String,Custom> customs=Maps.newHashMap();
        Map<String,Map<String,Object>> mappings=Maps.newHashMap();
        for (        Map.Entry<String,String> entry : request.mappings.entrySet()) {
          mappings.put(entry.getKey(),parseMapping(entry.getValue()));
        }
        for (        Map.Entry<String,Custom> entry : request.customs.entrySet()) {
          customs.put(entry.getKey(),entry.getValue());
        }
        for (        IndexTemplateMetaData template : templates) {
          for (          Map.Entry<String,CompressedString> entry : template.mappings().entrySet()) {
            if (mappings.containsKey(entry.getKey())) {
              XContentHelper.mergeDefaults(mappings.get(entry.getKey()),parseMapping(entry.getValue().string()));
            }
 else {
              mappings.put(entry.getKey(),parseMapping(entry.getValue().string()));
            }
          }
          for (          Map.Entry<String,Custom> customEntry : template.customs().entrySet()) {
            String type=customEntry.getKey();
            IndexMetaData.Custom custom=customEntry.getValue();
            IndexMetaData.Custom existing=customs.get(type);
            if (existing == null) {
              customs.put(type,custom);
            }
 else {
              IndexMetaData.Custom merged=IndexMetaData.lookupFactorySafe(type).merge(existing,custom);
              customs.put(type,merged);
            }
          }
        }
        File mappingsDir=new File(environment.configFile(),"mappings");
        if (mappingsDir.exists() && mappingsDir.isDirectory()) {
          File indexMappingsDir=new File(mappingsDir,request.index);
          if (indexMappingsDir.exists() && indexMappingsDir.isDirectory()) {
            addMappings(mappings,indexMappingsDir);
          }
          File defaultMappingsDir=new File(mappingsDir,"_default");
          if (defaultMappingsDir.exists() && defaultMappingsDir.isDirectory()) {
            addMappings(mappings,defaultMappingsDir);
          }
        }
        ImmutableSettings.Builder indexSettingsBuilder=settingsBuilder();
        for (int i=templates.size() - 1; i >= 0; i--) {
          indexSettingsBuilder.put(templates.get(i).settings());
        }
        indexSettingsBuilder.put(request.settings);
        if (indexSettingsBuilder.get(SETTING_NUMBER_OF_SHARDS) == null) {
          if (request.index.equals(riverIndexName)) {
            indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,1));
          }
 else {
            indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,5));
          }
        }
        if (indexSettingsBuilder.get(SETTING_NUMBER_OF_REPLICAS) == null) {
          if (request.index.equals(riverIndexName)) {
            indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,1));
          }
 else {
            indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,1));
          }
        }
        if (settings.get(SETTING_AUTO_EXPAND_REPLICAS) != null && indexSettingsBuilder.get(SETTING_AUTO_EXPAND_REPLICAS) == null) {
          indexSettingsBuilder.put(SETTING_AUTO_EXPAND_REPLICAS,settings.get(SETTING_AUTO_EXPAND_REPLICAS));
        }
        indexSettingsBuilder.put(SETTING_VERSION_CREATED,version);
        indexSettingsBuilder.put(SETTING_UUID,Strings.randomBase64UUID());
        Settings actualIndexSettings=indexSettingsBuilder.build();
        indicesService.createIndex(request.index,actualIndexSettings,clusterService.localNode().id());
        indexCreated=true;
        IndexService indexService=indicesService.indexServiceSafe(request.index);
        MapperService mapperService=indexService.mapperService();
        if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {
          try {
            mapperService.merge(MapperService.DEFAULT_MAPPING,XContentFactory.jsonBuilder().map(mappings.get(MapperService.DEFAULT_MAPPING)).string(),false);
          }
 catch (          Exception e) {
            failureReason="failed on parsing default mapping on index creation";
            throw new MapperParsingException("mapping [" + MapperService.DEFAULT_MAPPING + "]",e);
          }
        }
        for (        Map.Entry<String,Map<String,Object>> entry : mappings.entrySet()) {
          if (entry.getKey().equals(MapperService.DEFAULT_MAPPING)) {
            continue;
          }
          try {
            mapperService.merge(entry.getKey(),XContentFactory.jsonBuilder().map(entry.getValue()).string(),true);
          }
 catch (          Exception e) {
            failureReason="failed on parsing mappings on index creation";
            throw new MapperParsingException("mapping [" + entry.getKey() + "]",e);
          }
        }
        Map<String,MappingMetaData> mappingsMetaData=Maps.newHashMap();
        for (        DocumentMapper mapper : mapperService) {
          MappingMetaData mappingMd=new MappingMetaData(mapper);
          mappingsMetaData.put(mapper.type(),mappingMd);
        }
        final IndexMetaData.Builder indexMetaDataBuilder=newIndexMetaDataBuilder(request.index).settings(actualIndexSettings);
        for (        MappingMetaData mappingMd : mappingsMetaData.values()) {
          indexMetaDataBuilder.putMapping(mappingMd);
        }
        for (        Map.Entry<String,Custom> customEntry : customs.entrySet()) {
          indexMetaDataBuilder.putCustom(customEntry.getKey(),customEntry.getValue());
        }
        indexMetaDataBuilder.state(request.state);
        final IndexMetaData indexMetaData;
        try {
          indexMetaData=indexMetaDataBuilder.build();
        }
 catch (        Exception e) {
          failureReason="failed to build index metadata";
          throw e;
        }
        MetaData newMetaData=newMetaDataBuilder().metaData(currentState.metaData()).put(indexMetaData,false).build();
        logger.info("[{}] creating index, cause [{}], shards [{}]/[{}], mappings {}",request.index,request.cause,indexMetaData.numberOfShards(),indexMetaData.numberOfReplicas(),mappings.keySet());
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        if (!request.blocks.isEmpty()) {
          for (          ClusterBlock block : request.blocks) {
            blocks.addIndexBlock(request.index,block);
          }
        }
        if (request.state == State.CLOSE) {
          blocks.addIndexBlock(request.index,MetaDataIndexStateService.INDEX_CLOSED_BLOCK);
        }
        ClusterState updatedState=newClusterStateBuilder().state(currentState).blocks(blocks).metaData(newMetaData).build();
        if (request.state == State.OPEN) {
          RoutingTable.Builder routingTableBuilder=RoutingTable.builder().routingTable(updatedState.routingTable()).addAsNew(updatedState.metaData().index(request.index));
          RoutingAllocation.Result routingResult=allocationService.reroute(newClusterStateBuilder().state(updatedState).routingTable(routingTableBuilder).build());
          updatedState=newClusterStateBuilder().state(updatedState).routingResult(routingResult).build();
        }
        final AtomicInteger counter=new AtomicInteger(currentState.nodes().size());
        final NodeIndexCreatedAction.Listener nodeIndexCreatedListener=new NodeIndexCreatedAction.Listener(){
          @Override public void onNodeIndexCreated(          String index,          String nodeId){
            if (index.equals(request.index)) {
              if (counter.decrementAndGet() == 0) {
                listener.onResponse(new Response(true,indexMetaData));
                nodeIndexCreatedAction.remove(this);
              }
            }
          }
        }
;
        nodeIndexCreatedAction.add(nodeIndexCreatedListener);
        listener.future=threadPool.schedule(request.timeout,ThreadPool.Names.SAME,new Runnable(){
          @Override public void run(){
            listener.onResponse(new Response(false,indexMetaData));
            nodeIndexCreatedAction.remove(nodeIndexCreatedListener);
          }
        }
);
        return updatedState;
      }
  finally {
        if (indexCreated) {
          indicesService.removeIndex(request.index,failureReason != null ? failureReason : "failed to create index");
        }
      }
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
    }
  }
);
}
