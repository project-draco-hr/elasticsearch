{
  builder.startObject(MoreLikeThisFieldQueryParser.NAME);
  builder.startObject(name);
  if (likeText == null) {
    throw new ElasticsearchIllegalArgumentException("moreLikeThisField requires 'like_text' to be provided");
  }
  builder.field("like_text",likeText);
  if (percentTermsToMatch != -1) {
    builder.field("percent_terms_to_match",percentTermsToMatch);
  }
  if (minTermFreq != -1) {
    builder.field("min_term_freq",minTermFreq);
  }
  if (maxQueryTerms != -1) {
    builder.field("max_query_terms",maxQueryTerms);
  }
  if (stopWords != null && stopWords.length > 0) {
    builder.startArray("stop_words");
    for (    String stopWord : stopWords) {
      builder.value(stopWord);
    }
    builder.endArray();
  }
  if (minDocFreq != -1) {
    builder.field("min_doc_freq",minDocFreq);
  }
  if (maxDocFreq != -1) {
    builder.field("max_doc_freq",maxDocFreq);
  }
  if (minWordLen != -1) {
    builder.field("min_word_len",minWordLen);
  }
  if (maxWordLen != -1) {
    builder.field("max_word_len",maxWordLen);
  }
  if (boostTerms != -1) {
    builder.field("boost_terms",boostTerms);
  }
  if (boost != -1) {
    builder.field("boost",boost);
  }
  if (analyzer != null) {
    builder.field("analyzer",analyzer);
  }
  if (failOnUnsupportedField != null) {
    builder.field("fail_on_unsupported_field",failOnUnsupportedField);
  }
  if (queryName != null) {
    builder.field("_name",queryName);
  }
  builder.endObject();
  builder.endObject();
}
