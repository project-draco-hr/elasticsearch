{
  int stat, ns;
  long parkTime, deadline;
  if ((stat=w.qlock) >= 0 && w.eventCount == ec && ctl == c && !Thread.interrupted()) {
    int e=(int)c;
    int u=(int)(c >>> 32);
    int d=(u >> UAC_SHIFT) + parallelism;
    if (e < 0 || (d <= 0 && tryTerminate(false,false)))     stat=w.qlock=-1;
 else     if ((ns=w.nsteals) != 0) {
      long sc;
      w.nsteals=0;
      do {
      }
 while (!U.compareAndSwapLong(this,STEALCOUNT,sc=stealCount,sc + ns));
    }
 else {
      long pc=((d > 0 || ec != (e | INT_SIGN)) ? 0L : ((long)(w.nextWait & E_MASK)) | ((long)(u + UAC_UNIT)) << 32);
      if (pc != 0L) {
        int dc=-(short)(c >>> TC_SHIFT);
        parkTime=(dc < 0 ? FAST_IDLE_TIMEOUT : (dc + 1) * IDLE_TIMEOUT);
        deadline=System.nanoTime() + parkTime - TIMEOUT_SLOP;
      }
 else       parkTime=deadline=0L;
      if (w.eventCount == ec && ctl == c) {
        Thread wt=Thread.currentThread();
        U.putObject(wt,PARKBLOCKER,this);
        w.parker=wt;
        if (w.eventCount == ec && ctl == c)         U.park(false,parkTime);
        w.parker=null;
        U.putObject(wt,PARKBLOCKER,null);
        if (parkTime != 0L && ctl == c && deadline - System.nanoTime() <= 0L && U.compareAndSwapLong(this,CTL,c,pc))         stat=w.qlock=-1;
      }
    }
  }
  return stat;
}
