{
  WorkQueue[] ws;
  int m;
  long c=ctl;
  if ((ws=workQueues) != null && (m=ws.length - 1) >= 0 && w != null) {
    for (int j=m + m + 1, ec=w.eventCount; ; ) {
      WorkQueue q;
      int b, e;
      ForkJoinTask<?>[] a;
      ForkJoinTask<?> t;
      if ((q=ws[(r - j) & m]) != null && (b=q.base) - q.top < 0 && (a=q.array) != null) {
        long i=(((a.length - 1) & b) << ASHIFT) + ABASE;
        if ((t=((ForkJoinTask<?>)U.getObjectVolatile(a,i))) != null) {
          if (ec < 0)           helpRelease(c,ws,w,q,b);
 else           if (q.base == b && U.compareAndSwapObject(a,i,t,null)) {
            U.putOrderedInt(q,QBASE,b + 1);
            if ((b + 1) - q.top < 0)             signalWork(ws,q);
            w.runTask(t);
          }
        }
        break;
      }
 else       if (--j < 0) {
        if ((ec | (e=(int)c)) < 0)         return awaitWork(w,c,ec);
 else         if (ctl == c) {
          long nc=(long)ec | ((c - AC_UNIT) & (AC_MASK | TC_MASK));
          w.nextWait=e;
          w.eventCount=ec | INT_SIGN;
          if (!U.compareAndSwapLong(this,CTL,c,nc))           w.eventCount=ec;
        }
        break;
      }
    }
  }
  return 0;
}
