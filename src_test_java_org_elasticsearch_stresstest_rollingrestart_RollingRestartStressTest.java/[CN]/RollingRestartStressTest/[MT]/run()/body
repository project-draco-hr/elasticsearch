{
  Random random=new Random(0);
  Node[] nodes=new Node[numberOfNodes];
  for (int i=0; i < nodes.length; i++) {
    nodes[i]=NodeBuilder.nodeBuilder().settings(settings).node();
  }
  client=NodeBuilder.nodeBuilder().settings(settings).client(true).node();
  client.client().admin().indices().prepareCreate("test").setSettings(settingsBuilder().put("index.number_of_shards",numberOfShards).put("index.number_of_replicas",numberOfReplicas)).execute().actionGet();
  logger.info("********** [START] INDEXING INITIAL DOCS");
  for (long i=0; i < initialNumberOfDocs; i++) {
    indexDoc(random);
  }
  logger.info("********** [DONE ] INDEXING INITIAL DOCS");
  Indexer[] indexerThreads=new Indexer[indexers];
  for (int i=0; i < indexerThreads.length; i++) {
    indexerThreads[i]=new Indexer();
  }
  for (int i=0; i < indexerThreads.length; i++) {
    indexerThreads[i].start();
  }
  long testStart=System.currentTimeMillis();
  int nodeIndex=0;
  while (true) {
    File[] nodeData=((InternalNode)nodes[nodeIndex]).injector().getInstance(NodeEnvironment.class).nodeDataLocations();
    nodes[nodeIndex].close();
    if (clearNodeData) {
      try {
        IOUtils.rm(FileSystemUtils.toPaths(nodeData));
      }
 catch (      Exception ex) {
        logger.debug("Failed to delete node data directories",ex);
      }
    }
    try {
      ClusterHealthResponse clusterHealth=client.client().admin().cluster().prepareHealth().setWaitForGreenStatus().setWaitForNodes(Integer.toString(numberOfNodes + 0)).setWaitForRelocatingShards(0).setTimeout("10m").execute().actionGet();
      if (clusterHealth.isTimedOut()) {
        logger.warn("timed out waiting for green status....");
      }
    }
 catch (    Exception e) {
      logger.warn("failed to execute cluster health....");
    }
    nodes[nodeIndex]=NodeBuilder.nodeBuilder().settings(settings).node();
    Thread.sleep(1000);
    try {
      ClusterHealthResponse clusterHealth=client.client().admin().cluster().prepareHealth().setWaitForGreenStatus().setWaitForNodes(Integer.toString(numberOfNodes + 1)).setWaitForRelocatingShards(0).setTimeout("10m").execute().actionGet();
      if (clusterHealth.isTimedOut()) {
        logger.warn("timed out waiting for green status....");
      }
    }
 catch (    Exception e) {
      logger.warn("failed to execute cluster health....");
    }
    if (++nodeIndex == nodes.length) {
      nodeIndex=0;
    }
    if ((System.currentTimeMillis() - testStart) > period.millis()) {
      logger.info("test finished");
      break;
    }
  }
  for (int i=0; i < indexerThreads.length; i++) {
    indexerThreads[i].close=true;
  }
  Thread.sleep(indexerThrottle.millis() + 10000);
  for (int i=0; i < indexerThreads.length; i++) {
    if (!indexerThreads[i].closed) {
      logger.warn("thread not closed!");
    }
  }
  client.client().admin().indices().prepareRefresh().execute().actionGet();
  for (int i=0; i < (nodes.length * 5); i++) {
    CountResponse count=client.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet();
    logger.info("indexed [{}], count [{}], [{}]",count.getCount(),indexCounter.get(),count.getCount() == indexCounter.get() ? "OK" : "FAIL");
    if (count.getCount() != indexCounter.get()) {
      logger.warn("count does not match!");
    }
  }
  SearchResponse searchResponse=client.client().prepareSearch().setSearchType(SearchType.SCAN).setQuery(matchAllQuery()).setSize(50).setScroll(TimeValue.timeValueMinutes(2)).execute().actionGet();
  logger.info("Verifying versions for {} hits...",searchResponse.getHits().totalHits());
  while (true) {
    searchResponse=client.client().prepareSearchScroll(searchResponse.getScrollId()).setScroll(TimeValue.timeValueMinutes(2)).execute().actionGet();
    if (searchResponse.getFailedShards() > 0) {
      logger.warn("Search Failures " + Arrays.toString(searchResponse.getShardFailures()));
    }
    for (    SearchHit hit : searchResponse.getHits()) {
      long version=-1;
      for (int i=0; i < (numberOfReplicas + 1); i++) {
        GetResponse getResponse=client.client().prepareGet(hit.index(),hit.type(),hit.id()).execute().actionGet();
        if (version == -1) {
          version=getResponse.getVersion();
        }
 else {
          if (version != getResponse.getVersion()) {
            logger.warn("Doc {} has different version numbers {} and {}",hit.id(),version,getResponse.getVersion());
          }
        }
      }
    }
    if (searchResponse.getHits().hits().length == 0) {
      break;
    }
  }
  logger.info("Done verifying versions");
  client.close();
  for (  Node node : nodes) {
    node.close();
  }
}
