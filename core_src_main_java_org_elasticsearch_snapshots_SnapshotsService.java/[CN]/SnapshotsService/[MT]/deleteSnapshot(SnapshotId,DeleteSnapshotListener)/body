{
  clusterService.submitStateUpdateTask("delete snapshot",new ProcessedClusterStateUpdateTask(){
    boolean waitForSnapshot=false;
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      MetaData metaData=currentState.metaData();
      MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
      SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
      if (snapshots == null) {
        return currentState;
      }
      SnapshotMetaData.Entry snapshot=snapshots.snapshot(snapshotId);
      if (snapshot == null) {
        if (!snapshots.entries().isEmpty()) {
          throw new ConcurrentSnapshotExecutionException(snapshotId,"another snapshot is currently running cannot delete");
        }
        return currentState;
      }
 else {
        waitForSnapshot=true;
        ImmutableMap<ShardId,ShardSnapshotStatus> shards;
        if (snapshot.state() == State.STARTED && snapshot.shards() != null) {
          ImmutableMap.Builder<ShardId,ShardSnapshotStatus> shardsBuilder=ImmutableMap.builder();
          for (          ImmutableMap.Entry<ShardId,ShardSnapshotStatus> shardEntry : snapshot.shards().entrySet()) {
            ShardSnapshotStatus status=shardEntry.getValue();
            if (!status.state().completed()) {
              shardsBuilder.put(shardEntry.getKey(),new ShardSnapshotStatus(status.nodeId(),State.ABORTED));
            }
 else {
              shardsBuilder.put(shardEntry.getKey(),status);
            }
          }
          shards=shardsBuilder.build();
        }
 else         if (snapshot.state() == State.INIT) {
          shards=snapshot.shards();
          endSnapshot(snapshot);
        }
 else {
          boolean hasUncompletedShards=false;
          for (          ShardSnapshotStatus shardStatus : snapshot.shards().values()) {
            if (shardStatus.state().completed() == false && shardStatus.nodeId() != null && currentState.nodes().get(shardStatus.nodeId()) != null) {
              hasUncompletedShards=true;
              break;
            }
          }
          if (hasUncompletedShards) {
            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes");
            return currentState;
          }
 else {
            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately");
            shards=snapshot.shards();
            endSnapshot(snapshot);
          }
        }
        SnapshotMetaData.Entry newSnapshot=new SnapshotMetaData.Entry(snapshot,State.ABORTED,shards);
        snapshots=new SnapshotMetaData(newSnapshot);
        mdBuilder.putCustom(SnapshotMetaData.TYPE,snapshots);
        return ClusterState.builder(currentState).metaData(mdBuilder).build();
      }
    }
    @Override public void onFailure(    String source,    Throwable t){
      listener.onFailure(t);
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      if (waitForSnapshot) {
        logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish");
        addListener(new SnapshotCompletionListener(){
          @Override public void onSnapshotCompletion(          SnapshotId completedSnapshotId,          SnapshotInfo snapshot){
            if (completedSnapshotId.equals(snapshotId)) {
              logger.trace("deleted snapshot completed - deleting files");
              removeListener(this);
              deleteSnapshotFromRepository(snapshotId,listener);
            }
          }
          @Override public void onSnapshotFailure(          SnapshotId failedSnapshotId,          Throwable t){
            if (failedSnapshotId.equals(snapshotId)) {
              logger.trace("deleted snapshot failed - deleting files",t);
              removeListener(this);
              deleteSnapshotFromRepository(snapshotId,listener);
            }
          }
        }
);
      }
 else {
        logger.trace("deleted snapshot is not running - deleting files");
        deleteSnapshotFromRepository(snapshotId,listener);
      }
    }
  }
);
}
