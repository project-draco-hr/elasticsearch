{
  logger.trace("received updated snapshot restore state [{}]",request);
  updatedSnapshotStateQueue.add(request);
  clusterService.submitStateUpdateTask("update snapshot state",new ClusterStateUpdateTask(){
    private final List<UpdateIndexShardSnapshotStatusRequest> drainedRequests=new ArrayList<>();
    @Override public ClusterState execute(    ClusterState currentState){
      if (request.processed) {
        return currentState;
      }
      updatedSnapshotStateQueue.drainTo(drainedRequests);
      final int batchSize=drainedRequests.size();
      if (batchSize == 0) {
        return currentState;
      }
      final MetaData metaData=currentState.metaData();
      final SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
      if (snapshots != null) {
        int changedCount=0;
        final List<SnapshotMetaData.Entry> entries=newArrayList();
        for (        SnapshotMetaData.Entry entry : snapshots.entries()) {
          HashMap<ShardId,ShardSnapshotStatus> shards=null;
          for (int i=0; i < batchSize; i++) {
            final UpdateIndexShardSnapshotStatusRequest updateSnapshotState=drainedRequests.get(i);
            updateSnapshotState.processed=true;
            if (entry.snapshotId().equals(updateSnapshotState.snapshotId())) {
              logger.trace("[{}] Updating shard [{}] with status [{}]",updateSnapshotState.snapshotId(),updateSnapshotState.shardId(),updateSnapshotState.status().state());
              if (shards == null) {
                shards=newHashMap(entry.shards());
              }
              shards.put(updateSnapshotState.shardId(),updateSnapshotState.status());
              changedCount++;
            }
          }
          if (shards != null) {
            if (!completed(shards.values())) {
              entries.add(new SnapshotMetaData.Entry(entry,ImmutableMap.copyOf(shards)));
            }
 else {
              SnapshotMetaData.Entry updatedEntry=new SnapshotMetaData.Entry(entry,State.SUCCESS,ImmutableMap.copyOf(shards));
              entries.add(updatedEntry);
              endSnapshot(updatedEntry);
              logger.info("snapshot [{}] is done",updatedEntry.snapshotId());
            }
          }
 else {
            entries.add(entry);
          }
        }
        if (changedCount > 0) {
          logger.trace("changed cluster state triggered by {} snapshot state updates",changedCount);
          final SnapshotMetaData updatedSnapshots=new SnapshotMetaData(entries.toArray(new SnapshotMetaData.Entry[entries.size()]));
          final MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData()).putCustom(SnapshotMetaData.TYPE,updatedSnapshots);
          return ClusterState.builder(currentState).metaData(mdBuilder).build();
        }
      }
      return currentState;
    }
    @Override public void onFailure(    String source,    Throwable t){
      for (      UpdateIndexShardSnapshotStatusRequest request : drainedRequests) {
        logger.warn("[{}][{}] failed to update snapshot status to [{}]",t,request.snapshotId(),request.shardId(),request.status());
      }
    }
  }
);
}
