{
  boolean snapshotCreated=false;
  try {
    Repository repository=repositoriesService.repository(snapshot.snapshotId().getRepository());
    MetaData metaData=clusterState.metaData();
    if (!snapshot.includeGlobalState()) {
      MetaData.Builder builder=MetaData.builder();
      for (      String index : snapshot.indices()) {
        builder.put(metaData.index(index),false);
      }
      metaData=builder.build();
    }
    repository.initializeSnapshot(snapshot.snapshotId(),snapshot.indices(),metaData);
    snapshotCreated=true;
    if (snapshot.indices().isEmpty()) {
      userCreateSnapshotListener.onResponse();
      endSnapshot(snapshot);
      return;
    }
    clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshotId().getSnapshot() + "]",new ClusterStateUpdateTask(){
      boolean accepted=false;
      SnapshotsInProgress.Entry updatedSnapshot;
      String failure=null;
      @Override public ClusterState execute(      ClusterState currentState){
        SnapshotsInProgress snapshots=currentState.custom(SnapshotsInProgress.TYPE);
        List<SnapshotsInProgress.Entry> entries=new ArrayList<>();
        for (        SnapshotsInProgress.Entry entry : snapshots.entries()) {
          if (entry.snapshotId().equals(snapshot.snapshotId())) {
            ImmutableOpenMap<ShardId,SnapshotsInProgress.ShardSnapshotStatus> shards=shards(currentState,entry.indices());
            if (!partial) {
              Tuple<Set<String>,Set<String>> indicesWithMissingShards=indicesWithMissingShards(shards,currentState.metaData());
              Set<String> missing=indicesWithMissingShards.v1();
              Set<String> closed=indicesWithMissingShards.v2();
              if (missing.isEmpty() == false || closed.isEmpty() == false) {
                StringBuilder failureMessage=new StringBuilder();
                updatedSnapshot=new SnapshotsInProgress.Entry(entry,State.FAILED,shards);
                entries.add(updatedSnapshot);
                if (missing.isEmpty() == false) {
                  failureMessage.append("Indices don't have primary shards ");
                  failureMessage.append(missing);
                }
                if (closed.isEmpty() == false) {
                  if (failureMessage.length() > 0) {
                    failureMessage.append("; ");
                  }
                  failureMessage.append("Indices are closed ");
                  failureMessage.append(closed);
                }
                failure=failureMessage.toString();
                continue;
              }
            }
            updatedSnapshot=new SnapshotsInProgress.Entry(entry,State.STARTED,shards);
            entries.add(updatedSnapshot);
            if (!completed(shards.values())) {
              accepted=true;
            }
          }
 else {
            entries.add(entry);
          }
        }
        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,new SnapshotsInProgress(Collections.unmodifiableList(entries))).build();
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}] failed to create snapshot",t,snapshot.snapshotId());
        removeSnapshotFromClusterState(snapshot.snapshotId(),null,t,new CleanupAfterErrorListener(snapshot,true,userCreateSnapshotListener,t));
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        userCreateSnapshotListener.onResponse();
        if (!accepted && updatedSnapshot != null) {
          endSnapshot(updatedSnapshot,failure);
        }
      }
    }
);
  }
 catch (  Throwable t) {
    logger.warn("failed to create snapshot [{}]",t,snapshot.snapshotId());
    removeSnapshotFromClusterState(snapshot.snapshotId(),null,t,new CleanupAfterErrorListener(snapshot,snapshotCreated,userCreateSnapshotListener,t));
  }
}
