{
  if (waitingShardsStartedOrUnassigned(event)) {
    clusterService.submitStateUpdateTask("update snapshot state after shards started",new ClusterStateUpdateTask(){
      @Override public ClusterState execute(      ClusterState currentState) throws Exception {
        RoutingTable routingTable=currentState.routingTable();
        SnapshotsInProgress snapshots=currentState.custom(SnapshotsInProgress.TYPE);
        if (snapshots != null) {
          boolean changed=false;
          ArrayList<SnapshotsInProgress.Entry> entries=new ArrayList<>();
          for (          final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {
            SnapshotsInProgress.Entry updatedSnapshot=snapshot;
            if (snapshot.state() == State.STARTED) {
              Map<ShardId,ShardSnapshotStatus> shards=processWaitingShards(snapshot.shards(),routingTable);
              if (shards != null) {
                changed=true;
                if (!snapshot.state().completed() && completed(shards.values())) {
                  updatedSnapshot=new SnapshotsInProgress.Entry(snapshot,State.SUCCESS,shards);
                  endSnapshot(updatedSnapshot);
                }
 else {
                  updatedSnapshot=new SnapshotsInProgress.Entry(snapshot,shards);
                }
              }
              entries.add(updatedSnapshot);
            }
          }
          if (changed) {
            snapshots=new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]));
            return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE,snapshots).build();
          }
        }
        return currentState;
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("failed to update snapshot state after shards started from [{}] ",t,source);
      }
    }
);
  }
}
