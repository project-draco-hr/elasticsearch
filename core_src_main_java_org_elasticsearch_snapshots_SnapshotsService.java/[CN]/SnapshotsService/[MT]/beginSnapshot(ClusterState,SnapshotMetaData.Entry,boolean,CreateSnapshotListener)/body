{
  boolean snapshotCreated=false;
  try {
    Repository repository=repositoriesService.repository(snapshot.snapshotId().getRepository());
    MetaData metaData=clusterState.metaData();
    if (!snapshot.includeGlobalState()) {
      MetaData.Builder builder=MetaData.builder();
      for (      String index : snapshot.indices()) {
        builder.put(metaData.index(index),false);
      }
      metaData=builder.build();
    }
    repository.initializeSnapshot(snapshot.snapshotId(),snapshot.indices(),metaData);
    snapshotCreated=true;
    if (snapshot.indices().isEmpty()) {
      userCreateSnapshotListener.onResponse();
      endSnapshot(snapshot);
      return;
    }
    clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshotId().getSnapshot() + "]",new ProcessedClusterStateUpdateTask(){
      boolean accepted=false;
      SnapshotMetaData.Entry updatedSnapshot;
      String failure=null;
      @Override public ClusterState execute(      ClusterState currentState){
        MetaData metaData=currentState.metaData();
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        SnapshotMetaData snapshots=metaData.custom(SnapshotMetaData.TYPE);
        ImmutableList.Builder<SnapshotMetaData.Entry> entries=ImmutableList.builder();
        for (        SnapshotMetaData.Entry entry : snapshots.entries()) {
          if (entry.snapshotId().equals(snapshot.snapshotId())) {
            ImmutableMap<ShardId,SnapshotMetaData.ShardSnapshotStatus> shards=shards(currentState,entry.indices());
            if (!partial) {
              Tuple<Set<String>,Set<String>> indicesWithMissingShards=indicesWithMissingShards(shards,currentState.metaData());
              Set<String> missing=indicesWithMissingShards.v1();
              Set<String> closed=indicesWithMissingShards.v2();
              if (missing.isEmpty() == false || closed.isEmpty() == false) {
                StringBuilder failureMessage=new StringBuilder();
                updatedSnapshot=new SnapshotMetaData.Entry(entry,State.FAILED,shards);
                entries.add(updatedSnapshot);
                if (missing.isEmpty() == false) {
                  failureMessage.append("Indices don't have primary shards ");
                  failureMessage.append(missing);
                }
                if (closed.isEmpty() == false) {
                  if (failureMessage.length() > 0) {
                    failureMessage.append("; ");
                  }
                  failureMessage.append("Indices are closed ");
                  failureMessage.append(closed);
                }
                failure=failureMessage.toString();
                continue;
              }
            }
            updatedSnapshot=new SnapshotMetaData.Entry(entry,State.STARTED,shards);
            entries.add(updatedSnapshot);
            if (!completed(shards.values())) {
              accepted=true;
            }
          }
 else {
            entries.add(entry);
          }
        }
        mdBuilder.putCustom(SnapshotMetaData.TYPE,new SnapshotMetaData(entries.build()));
        return ClusterState.builder(currentState).metaData(mdBuilder).build();
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}] failed to create snapshot",t,snapshot.snapshotId());
        removeSnapshotFromClusterState(snapshot.snapshotId(),null,t);
        try {
          repositoriesService.repository(snapshot.snapshotId().getRepository()).finalizeSnapshot(snapshot.snapshotId(),snapshot.indices(),snapshot.startTime(),ExceptionsHelper.detailedMessage(t),0,ImmutableList.<SnapshotShardFailure>of());
        }
 catch (        Throwable t2) {
          logger.warn("[{}] failed to close snapshot in repository",snapshot.snapshotId());
        }
        userCreateSnapshotListener.onFailure(t);
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        userCreateSnapshotListener.onResponse();
        if (!accepted && updatedSnapshot != null) {
          endSnapshot(updatedSnapshot,failure);
        }
      }
    }
);
  }
 catch (  Throwable t) {
    logger.warn("failed to create snapshot [{}]",t,snapshot.snapshotId());
    removeSnapshotFromClusterState(snapshot.snapshotId(),null,t);
    if (snapshotCreated) {
      try {
        repositoriesService.repository(snapshot.snapshotId().getRepository()).finalizeSnapshot(snapshot.snapshotId(),snapshot.indices(),snapshot.startTime(),ExceptionsHelper.detailedMessage(t),0,ImmutableList.<SnapshotShardFailure>of());
      }
 catch (      Throwable t2) {
        logger.warn("[{}] failed to close snapshot in repository",snapshot.snapshotId());
      }
    }
    userCreateSnapshotListener.onFailure(t);
  }
}
