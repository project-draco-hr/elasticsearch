{
  if (refreshNeeded(atomicReaderContexts)) {
synchronized (idReaders) {
      if (!refreshNeeded(atomicReaderContexts)) {
        return;
      }
      Map<Object,Map<BytesReference,TypeBuilder>> builders=new HashMap<Object,Map<BytesReference,TypeBuilder>>();
      for (      AtomicReaderContext context : atomicReaderContexts) {
        AtomicReader reader=context.reader();
        if (idReaders.containsKey(reader.getCoreCacheKey())) {
          continue;
        }
        if (reader instanceof SegmentReader) {
          ((SegmentReader)reader).addCoreClosedListener(this);
        }
        Map<BytesReference,TypeBuilder> readerBuilder=new HashMap<BytesReference,TypeBuilder>();
        builders.put(reader.getCoreCacheKey(),readerBuilder);
        Terms terms=reader.terms(UidFieldMapper.NAME);
        if (terms == null) {
          throw new ElasticSearchIllegalArgumentException("Id cache needs _uid field");
        }
        TermsEnum termsEnum=terms.iterator(null);
        DocsEnum docsEnum=null;
        for (BytesRef term=termsEnum.next(); term != null; term=termsEnum.term()) {
          HashedBytesArray[] typeAndId=splitUidIntoTypeAndId(term);
          TypeBuilder typeBuilder=readerBuilder.get(typeAndId[0]);
          if (typeBuilder == null) {
            typeBuilder=new TypeBuilder(reader);
            readerBuilder.put(typeAndId[0],typeBuilder);
          }
          HashedBytesArray idAsBytes=checkIfCanReuse(builders,typeAndId[1]);
          docsEnum=termsEnum.docs(reader.getLiveDocs(),docsEnum,0);
          for (int docId=docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId=docsEnum.nextDoc()) {
            typeBuilder.idToDoc.put(idAsBytes,docId);
            typeBuilder.docToId[docId]=idAsBytes;
          }
        }
      }
      for (      AtomicReaderContext context : atomicReaderContexts) {
        AtomicReader reader=context.reader();
        if (idReaders.containsKey(reader.getCoreCacheKey())) {
          continue;
        }
        Map<BytesReference,TypeBuilder> readerBuilder=builders.get(reader.getCoreCacheKey());
        Terms terms=reader.terms(ParentFieldMapper.NAME);
        if (terms == null) {
          throw new ElasticSearchIllegalArgumentException("Id cache needs _parent field");
        }
        TermsEnum termsEnum=terms.iterator(null);
        DocsEnum docsEnum=null;
        for (BytesRef term=termsEnum.next(); term != null; term=termsEnum.term()) {
          HashedBytesArray[] typeAndId=splitUidIntoTypeAndId(term);
          TypeBuilder typeBuilder=readerBuilder.get(typeAndId[0]);
          if (typeBuilder == null) {
            typeBuilder=new TypeBuilder(reader);
            readerBuilder.put(typeAndId[0],typeBuilder);
          }
          HashedBytesArray idAsBytes=checkIfCanReuse(builders,typeAndId[1]);
          boolean added=false;
          docsEnum=termsEnum.docs(reader.getLiveDocs(),docsEnum,0);
          for (int docId=docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId=docsEnum.nextDoc()) {
            if (!added) {
              typeBuilder.parentIdsValues.add(idAsBytes);
              added=true;
            }
            typeBuilder.parentIdsOrdinals[docId]=typeBuilder.t;
          }
          if (added) {
            typeBuilder.t++;
          }
        }
      }
      for (      Map.Entry<Object,Map<BytesReference,TypeBuilder>> entry : builders.entrySet()) {
        MapBuilder<BytesReference,SimpleIdReaderTypeCache> types=MapBuilder.newMapBuilder();
        for (        Map.Entry<BytesReference,TypeBuilder> typeBuilderEntry : entry.getValue().entrySet()) {
          types.put(typeBuilderEntry.getKey(),new SimpleIdReaderTypeCache(typeBuilderEntry.getKey(),typeBuilderEntry.getValue().idToDoc,typeBuilderEntry.getValue().docToId,typeBuilderEntry.getValue().parentIdsValues.toArray(new HashedBytesArray[typeBuilderEntry.getValue().parentIdsValues.size()]),typeBuilderEntry.getValue().parentIdsOrdinals));
        }
        SimpleIdReaderCache readerCache=new SimpleIdReaderCache(entry.getKey(),types.immutableMap());
        idReaders.put(readerCache.readerCacheKey(),readerCache);
      }
    }
  }
}
