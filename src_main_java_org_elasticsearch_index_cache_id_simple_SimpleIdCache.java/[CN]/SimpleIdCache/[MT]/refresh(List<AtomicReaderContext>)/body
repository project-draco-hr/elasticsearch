{
  if (refreshNeeded(atomicReaderContexts)) {
synchronized (idReaders) {
      if (!refreshNeeded(atomicReaderContexts)) {
        return;
      }
      Map<Object,Map<String,TypeBuilder>> builders=new HashMap<Object,Map<String,TypeBuilder>>();
      Map<Object,IndexReader> cacheToReader=new HashMap<Object,IndexReader>();
      for (      AtomicReaderContext context : atomicReaderContexts) {
        AtomicReader reader=context.reader();
        if (idReaders.containsKey(reader.getCoreCacheKey())) {
          continue;
        }
        if (reader instanceof SegmentReader) {
          ((SegmentReader)reader).addCoreClosedListener(this);
        }
        Map<String,TypeBuilder> readerBuilder=new HashMap<String,TypeBuilder>();
        builders.put(reader.getCoreCacheKey(),readerBuilder);
        cacheToReader.put(reader.getCoreCacheKey(),context.reader());
        Terms terms=reader.terms(UidFieldMapper.NAME);
        if (terms != null) {
          TermsEnum termsEnum=terms.iterator(null);
          DocsEnum docsEnum=null;
          for (BytesRef term=termsEnum.next(); term != null; term=termsEnum.next()) {
            HashedBytesArray[] typeAndId=Uid.splitUidIntoTypeAndId(term);
            TypeBuilder typeBuilder=readerBuilder.get(typeAndId[0].toUtf8());
            if (typeBuilder == null) {
              typeBuilder=new TypeBuilder(reader);
              readerBuilder.put(typeAndId[0].toUtf8(),typeBuilder);
            }
            HashedBytesArray idAsBytes=checkIfCanReuse(builders,typeAndId[1]);
            docsEnum=termsEnum.docs(reader.getLiveDocs(),docsEnum,0);
            for (int docId=docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId=docsEnum.nextDoc()) {
              typeBuilder.idToDoc.put(idAsBytes,docId);
              typeBuilder.docToId[docId]=idAsBytes;
            }
          }
        }
      }
      for (      AtomicReaderContext context : atomicReaderContexts) {
        AtomicReader reader=context.reader();
        if (idReaders.containsKey(reader.getCoreCacheKey())) {
          continue;
        }
        Map<String,TypeBuilder> readerBuilder=builders.get(reader.getCoreCacheKey());
        Terms terms=reader.terms(ParentFieldMapper.NAME);
        if (terms != null) {
          TermsEnum termsEnum=terms.iterator(null);
          DocsEnum docsEnum=null;
          for (BytesRef term=termsEnum.next(); term != null; term=termsEnum.next()) {
            HashedBytesArray[] typeAndId=Uid.splitUidIntoTypeAndId(term);
            TypeBuilder typeBuilder=readerBuilder.get(typeAndId[0].toUtf8());
            if (typeBuilder == null) {
              typeBuilder=new TypeBuilder(reader);
              readerBuilder.put(typeAndId[0].toUtf8(),typeBuilder);
            }
            HashedBytesArray idAsBytes=checkIfCanReuse(builders,typeAndId[1]);
            boolean added=false;
            docsEnum=termsEnum.docs(reader.getLiveDocs(),docsEnum,0);
            for (int docId=docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId=docsEnum.nextDoc()) {
              if (!added) {
                typeBuilder.parentIdsValues.add(idAsBytes);
                added=true;
              }
              typeBuilder.parentIdsOrdinals[docId]=typeBuilder.t;
            }
            if (added) {
              typeBuilder.t++;
            }
          }
        }
      }
      for (      Map.Entry<Object,Map<String,TypeBuilder>> entry : builders.entrySet()) {
        Object readerKey=entry.getKey();
        MapBuilder<String,SimpleIdReaderTypeCache> types=MapBuilder.newMapBuilder();
        for (        Map.Entry<String,TypeBuilder> typeBuilderEntry : entry.getValue().entrySet()) {
          types.put(typeBuilderEntry.getKey(),new SimpleIdReaderTypeCache(typeBuilderEntry.getKey(),typeBuilderEntry.getValue().idToDoc,typeBuilderEntry.getValue().docToId,typeBuilderEntry.getValue().parentIdsValues.toArray(new HashedBytesArray[typeBuilderEntry.getValue().parentIdsValues.size()]),typeBuilderEntry.getValue().parentIdsOrdinals));
        }
        IndexReader indexReader=cacheToReader.get(readerKey);
        SimpleIdReaderCache readerCache=new SimpleIdReaderCache(types.immutableMap(),ShardUtils.extractShardId(indexReader));
        idReaders.put(readerKey,readerCache);
        onCached(readerCache);
      }
    }
  }
}
