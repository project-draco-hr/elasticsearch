{
  if (event.state().blocks().disableStatePersistence()) {
    this.currentMetaData=null;
    return;
  }
  MetaData newMetaData=event.state().metaData();
  boolean success=true;
  if (event.state().nodes().localNode().masterNode()) {
    if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData,newMetaData)) {
      try {
        writeGlobalState("changed",newMetaData);
      }
 catch (      Throwable e) {
        success=false;
      }
    }
    for (    IndexMetaData indexMetaData : newMetaData) {
      String writeReason=null;
      IndexMetaData currentIndexMetaData;
      if (currentMetaData == null) {
        currentIndexMetaData=loadIndexState(indexMetaData.index());
      }
 else {
        currentIndexMetaData=currentMetaData.index(indexMetaData.index());
      }
      if (currentIndexMetaData == null) {
        writeReason="freshly created";
      }
 else       if (currentIndexMetaData.version() != indexMetaData.version()) {
        writeReason="version changed from [" + currentIndexMetaData.version() + "] to ["+ indexMetaData.version()+ "]";
      }
      if (writeReason == null) {
        continue;
      }
      try {
        writeIndex(writeReason,indexMetaData,currentIndexMetaData);
      }
 catch (      Throwable e) {
        success=false;
      }
    }
  }
  if (currentMetaData != null) {
    for (    IndexMetaData current : currentMetaData) {
      if (danglingIndices.containsKey(current.index())) {
        continue;
      }
      if (!newMetaData.hasIndex(current.index())) {
        logger.debug("[{}] deleting index that is no longer part of the metadata (indices: [{}])",current.index(),newMetaData.indices().keys());
        if (nodeEnv.hasNodeFile()) {
          try {
            IOUtils.rm(FileSystemUtils.toPaths(nodeEnv.indexLocations(new Index(current.index()))));
          }
 catch (          Exception ex) {
            logger.debug("[{}] failed to delete index",ex,current.index());
          }
        }
        try {
          nodeIndexDeletedAction.nodeIndexStoreDeleted(event.state(),current.index(),event.state().nodes().localNodeId());
        }
 catch (        Throwable e) {
          logger.debug("[{}] failed to notify master on local index store deletion",e,current.index());
        }
      }
    }
  }
  if (nodeEnv.hasNodeFile()) {
    if (danglingTimeout.millis() >= 0) {
synchronized (danglingMutex) {
        for (        String danglingIndex : danglingIndices.keySet()) {
          if (newMetaData.hasIndex(danglingIndex)) {
            logger.debug("[{}] no longer dangling (created), removing",danglingIndex);
            DanglingIndex removed=danglingIndices.remove(danglingIndex);
            removed.future.cancel(false);
          }
        }
        try {
          for (          String indexName : nodeEnv.findAllIndices()) {
            if (newMetaData.hasIndex(indexName)) {
              continue;
            }
            if (danglingIndices.containsKey(indexName)) {
              continue;
            }
            IndexMetaData indexMetaData=loadIndexState(indexName);
            if (indexMetaData != null) {
              if (danglingTimeout.millis() == 0) {
                logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, timeout set to 0, deleting now",indexName);
                try {
                  IOUtils.rm(FileSystemUtils.toPaths(nodeEnv.indexLocations(new Index(indexName))));
                }
 catch (                Exception ex) {
                  logger.debug("[{}] failed to delete dangling index",ex,indexName);
                }
              }
 else {
                logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, scheduling to delete in [{}], auto import to cluster state [{}]",indexName,danglingTimeout,autoImportDangled);
                danglingIndices.put(indexName,new DanglingIndex(indexName,threadPool.schedule(danglingTimeout,ThreadPool.Names.SAME,new RemoveDanglingIndex(indexName))));
              }
            }
          }
        }
 catch (        Throwable e) {
          logger.warn("failed to find dangling indices",e);
        }
      }
    }
    if (autoImportDangled.shouldImport() && !danglingIndices.isEmpty()) {
      final List<IndexMetaData> dangled=Lists.newArrayList();
      for (      String indexName : danglingIndices.keySet()) {
        IndexMetaData indexMetaData=loadIndexState(indexName);
        if (indexMetaData == null) {
          logger.debug("failed to find state for dangling index [{}]",indexName);
          continue;
        }
        if (!indexMetaData.index().equals(indexName)) {
          logger.info("dangled index directory name is [{}], state name is [{}], renaming to directory name",indexName,indexMetaData.index());
          indexMetaData=IndexMetaData.builder(indexMetaData).index(indexName).build();
        }
        if (autoImportDangled == AutoImportDangledState.CLOSED) {
          indexMetaData=IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE).build();
        }
        if (indexMetaData != null) {
          dangled.add(indexMetaData);
        }
      }
      IndexMetaData[] dangledIndices=dangled.toArray(new IndexMetaData[dangled.size()]);
      try {
        allocateDangledIndices.allocateDangled(dangledIndices,new LocalAllocateDangledIndices.Listener(){
          @Override public void onResponse(          LocalAllocateDangledIndices.AllocateDangledResponse response){
            logger.trace("allocated dangled");
          }
          @Override public void onFailure(          Throwable e){
            logger.info("failed to send allocated dangled",e);
          }
        }
);
      }
 catch (      Throwable e) {
        logger.warn("failed to send allocate dangled",e);
      }
    }
  }
  if (success) {
    currentMetaData=newMetaData;
  }
}
