{
  if (event.state().blocks().disableStatePersistence()) {
    return;
  }
  if (!event.state().nodes().localNode().masterNode()) {
    return;
  }
  if (!event.metaDataChanged()) {
    return;
  }
  boolean success=true;
  if (currentMetaData == null || !MetaData.isGlobalStateEquals(currentMetaData,event.state().metaData())) {
    try {
      writeGlobalState("changed",event.state().metaData(),currentMetaData);
    }
 catch (    Exception e) {
      success=false;
    }
  }
  for (  IndexMetaData indexMetaData : event.state().metaData()) {
    String writeReason=null;
    IndexMetaData currentIndexMetaData=currentMetaData == null ? null : currentMetaData.index(indexMetaData.index());
    if (currentIndexMetaData == null) {
      writeReason="freshly created";
    }
 else     if (currentIndexMetaData.version() != indexMetaData.version()) {
      writeReason="version changed from [" + currentIndexMetaData.version() + "] to ["+ indexMetaData.version()+ "]";
    }
    if (writeReason == null) {
      continue;
    }
    try {
      writeIndex(writeReason,indexMetaData,currentIndexMetaData);
    }
 catch (    Exception e) {
      success=false;
    }
  }
  if (nodeEnv.hasNodeFile()) {
    if (danglingTimeout.millis() >= 0) {
synchronized (danglingMutex) {
        for (        String danglingIndex : danglingIndices.keySet()) {
          if (event.state().metaData().hasIndex(danglingIndex)) {
            logger.debug("[{}] no longer dangling (created), removing",danglingIndex);
            DanglingIndex removed=danglingIndices.remove(danglingIndex);
            removed.future.cancel(false);
          }
        }
        try {
          for (          String indexName : nodeEnv.findAllIndices()) {
            if (event.state().metaData().hasIndex(indexName)) {
              continue;
            }
            if (danglingIndices.containsKey(indexName)) {
              continue;
            }
            if (danglingTimeout.millis() == 0) {
              logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, timeout set to 0, deleting now",indexName);
              FileSystemUtils.deleteRecursively(nodeEnv.indexLocations(new Index(indexName)));
            }
 else {
              logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, scheduling to delete in [{}]",indexName,danglingTimeout);
              danglingIndices.put(indexName,new DanglingIndex(indexName,threadPool.schedule(danglingTimeout,ThreadPool.Names.SAME,new RemoveDanglingIndex(indexName))));
            }
          }
        }
 catch (        Exception e) {
          logger.warn("failed to find dangling indices",e);
        }
      }
    }
  }
  if (currentMetaData != null) {
    for (    IndexMetaData current : currentMetaData) {
      if (event.state().metaData().index(current.index()) == null) {
        if (!danglingIndices.containsKey(current.index())) {
          deleteIndex(current.index());
        }
      }
    }
  }
  if (success) {
    currentMetaData=event.state().metaData();
  }
}
