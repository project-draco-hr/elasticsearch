{
  logger.trace("[_global] writing state, reason [{}]",reason);
  MetaData globalMetaData=MetaData.builder().metaData(metaData).removeAllIndices().build();
  CachedStreamOutput.Entry cachedEntry=CachedStreamOutput.popEntry();
  try {
    XContentBuilder builder=XContentFactory.contentBuilder(format,cachedEntry.bytes());
    builder.startObject();
    MetaData.Builder.toXContent(globalMetaData,builder,formatParams);
    builder.endObject();
    builder.flush();
    String globalFileName="global-" + globalMetaData.version();
    Exception lastFailure=null;
    boolean wroteAtLeastOnce=false;
    for (    File dataLocation : nodeEnv.nodeDataLocations()) {
      File stateLocation=new File(dataLocation,"_state");
      FileSystemUtils.mkdirs(stateLocation);
      File stateFile=new File(stateLocation,globalFileName);
      FileOutputStream fos=null;
      try {
        fos=new FileOutputStream(stateFile);
        BytesReference bytes=cachedEntry.bytes().bytes();
        fos.write(bytes.array(),bytes.arrayOffset(),bytes.length());
        fos.getChannel().force(true);
        Closeables.closeQuietly(fos);
        wroteAtLeastOnce=true;
      }
 catch (      Exception e) {
        lastFailure=e;
      }
 finally {
        Closeables.closeQuietly(fos);
      }
    }
    if (!wroteAtLeastOnce) {
      logger.warn("[_global]: failed to write global state",lastFailure);
      throw new IOException("failed to write global state",lastFailure);
    }
    for (    File dataLocation : nodeEnv.nodeDataLocations()) {
      File[] files=new File(dataLocation,"_state").listFiles();
      if (files == null) {
        continue;
      }
      for (      File file : files) {
        if (!file.getName().startsWith("global-")) {
          continue;
        }
        if (file.getName().equals(globalFileName)) {
          continue;
        }
        file.delete();
      }
    }
  }
  finally {
    CachedStreamOutput.pushEntry(cachedEntry);
  }
}
