{
  logger.trace("[{}] writing state, reason [{}]",indexMetaData.index(),reason);
  XContentBuilder builder=XContentFactory.contentBuilder(format,new BytesStreamOutput());
  builder.startObject();
  IndexMetaData.Builder.toXContent(indexMetaData,builder,formatParams);
  builder.endObject();
  builder.flush();
  String stateFileName="state-" + indexMetaData.version();
  Throwable lastFailure=null;
  boolean wroteAtLeastOnce=false;
  for (  File indexLocation : nodeEnv.indexLocations(new Index(indexMetaData.index()))) {
    File stateLocation=new File(indexLocation,"_state");
    FileSystemUtils.mkdirs(stateLocation);
    File stateFile=new File(stateLocation,stateFileName);
    FileOutputStream fos=null;
    try {
      fos=new FileOutputStream(stateFile);
      BytesReference bytes=builder.bytes();
      fos.write(bytes.array(),bytes.arrayOffset(),bytes.length());
      fos.getChannel().force(true);
      fos.close();
      wroteAtLeastOnce=true;
    }
 catch (    Throwable e) {
      lastFailure=e;
    }
 finally {
      IOUtils.closeWhileHandlingException(fos);
    }
  }
  if (!wroteAtLeastOnce) {
    logger.warn("[{}]: failed to state",lastFailure,indexMetaData.index());
    throw new IOException("failed to write state for [" + indexMetaData.index() + "]",lastFailure);
  }
  if (previousIndexMetaData != null && previousIndexMetaData.version() != indexMetaData.version()) {
    for (    File indexLocation : nodeEnv.indexLocations(new Index(indexMetaData.index()))) {
      File[] files=new File(indexLocation,"_state").listFiles();
      if (files == null) {
        continue;
      }
      for (      File file : files) {
        if (!file.getName().startsWith("state-")) {
          continue;
        }
        if (file.getName().equals(stateFileName)) {
          continue;
        }
        file.delete();
      }
    }
  }
}
