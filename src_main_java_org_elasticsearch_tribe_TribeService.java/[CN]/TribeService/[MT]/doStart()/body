{
  final CountDownLatch latch=new CountDownLatch(1);
  clusterService.submitStateUpdateTask("updating local node id",new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      return ClusterState.builder(currentState).nodes(DiscoveryNodes.builder(currentState.nodes()).put(clusterService.localNode()).localNodeId(clusterService.localNode().id())).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      try {
        logger.error("{}",t,source);
      }
  finally {
        latch.countDown();
      }
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      latch.countDown();
    }
  }
);
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    throw new ElasticsearchIllegalStateException("Interrupted while starting [" + this.getClass().getSimpleName() + "]",e);
  }
  for (  InternalNode node : nodes) {
    try {
      node.start();
    }
 catch (    Throwable e) {
      for (      InternalNode otherNode : nodes) {
        try {
          otherNode.close();
        }
 catch (        Throwable t) {
          logger.warn("failed to close node {} on failed start",otherNode,t);
        }
      }
      if (e instanceof RuntimeException) {
        throw (RuntimeException)e;
      }
      throw new ElasticsearchException(e.getMessage(),e);
    }
  }
}
