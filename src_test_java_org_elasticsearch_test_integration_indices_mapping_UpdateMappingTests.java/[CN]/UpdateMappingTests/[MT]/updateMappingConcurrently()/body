{
  int shardNo=Math.max(5,numberOfNodes());
  prepareCreate("test1").setSettings("index.number_of_shards",shardNo).execute().actionGet();
  prepareCreate("test2").setSettings("index.number_of_shards",shardNo).execute().actionGet();
  final Throwable[] threadException=new Throwable[1];
  final AtomicBoolean stop=new AtomicBoolean(false);
  Thread[] threads=new Thread[3];
  final CyclicBarrier barrier=new CyclicBarrier(threads.length);
  final ArrayList<Client> clientArray=new ArrayList<Client>();
  for (  Client c : clients()) {
    clientArray.add(c);
  }
  for (int j=0; j < threads.length; j++) {
    threads[j]=new Thread(new Runnable(){
      @SuppressWarnings("unchecked") @Override public void run(){
        try {
          barrier.await();
          for (int i=0; i < 100; i++) {
            if (stop.get()) {
              return;
            }
            Client client1=clientArray.get(i % clientArray.size());
            Client client2=clientArray.get((i + 1) % clientArray.size());
            String indexName=i % 2 == 0 ? "test2" : "test1";
            String typeName="type" + (i % 10);
            String fieldName=Thread.currentThread().getName() + "_" + i;
            PutMappingResponse response=client1.admin().indices().preparePutMapping(indexName).setType(typeName).setSource(JsonXContent.contentBuilder().startObject().startObject(typeName).startObject("properties").startObject(fieldName).field("type","string").endObject().endObject().endObject().endObject()).get();
            assertThat(response.isAcknowledged(),equalTo(true));
            GetMappingsResponse getMappingResponse=client2.admin().indices().prepareGetMappings(indexName).get();
            Map<String,MappingMetaData> mappings=getMappingResponse.getMappings().get(indexName);
            assertThat(mappings.keySet(),Matchers.hasItem(typeName));
            assertThat(((Map<String,Object>)mappings.get(typeName).getSourceAsMap().get("properties")).keySet(),Matchers.hasItem(fieldName));
          }
        }
 catch (        Throwable t) {
          threadException[0]=t;
          stop.set(true);
        }
      }
    }
);
    threads[j].setName("t_" + j);
    threads[j].start();
  }
  for (  Thread t : threads)   t.join();
  if (threadException[0] != null) {
    throw threadException[0];
  }
}
