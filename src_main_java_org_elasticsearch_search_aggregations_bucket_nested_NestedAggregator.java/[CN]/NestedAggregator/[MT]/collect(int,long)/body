{
  if (parentDoc == 0 || childDocs == null) {
    return;
  }
  if (parentFilter == null) {
    Filter parentFilterNotCached=findClosestNestedPath(parentAggregator);
    if (parentFilterNotCached == null) {
      parentFilterNotCached=NonNestedDocsFilter.INSTANCE;
    }
    parentFilter=context.searchContext().bitsetFilterCache().getBitDocIdSetFilter(parentFilterNotCached);
    BitDocIdSet parentSet=parentFilter.getDocIdSet(reader);
    if (DocIdSets.isEmpty(parentSet)) {
      childDocs=null;
      return;
    }
 else {
      parentDocs=parentSet.bits();
    }
  }
  int numChildren=0;
  IntArrayList iterator=getChildren(parentDoc);
  final int[] buffer=iterator.buffer;
  final int size=iterator.size();
  for (int i=0; i < size; i++) {
    numChildren++;
    collectBucketNoCounts(buffer[i],bucketOrd);
  }
  incrementBucketDocCount(bucketOrd,numChildren);
}
