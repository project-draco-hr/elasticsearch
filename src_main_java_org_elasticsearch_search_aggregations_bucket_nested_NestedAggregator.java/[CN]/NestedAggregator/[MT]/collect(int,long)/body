{
  if (parentDoc == 0 || childDocs == null) {
    return;
  }
  if (parentFilter == null) {
    Filter parentFilterNotCached=findClosestNestedPath(parentAggregator);
    if (parentFilterNotCached == null) {
      parentFilterNotCached=NonNestedDocsFilter.INSTANCE;
    }
    parentFilter=context.searchContext().bitsetFilterCache().getBitDocIdSetFilter(parentFilterNotCached);
    BitDocIdSet parentSet=parentFilter.getDocIdSet(reader);
    if (DocIdSets.isEmpty(parentSet)) {
      childDocs=null;
      return;
    }
 else {
      parentDocs=parentSet.bits();
    }
  }
  int prevParentDoc=parentDocs.prevSetBit(parentDoc - 1);
  int childDocId;
  if (childDocs.docID() > prevParentDoc) {
    childDocId=childDocs.docID();
  }
 else {
    childDocId=childDocs.advance(prevParentDoc + 1);
  }
  int numChildren=0;
  for (; childDocId < parentDoc; childDocId=childDocs.nextDoc()) {
    numChildren++;
    collectBucketNoCounts(childDocId,bucketOrd);
  }
  incrementBucketDocCount(bucketOrd,numChildren);
}
