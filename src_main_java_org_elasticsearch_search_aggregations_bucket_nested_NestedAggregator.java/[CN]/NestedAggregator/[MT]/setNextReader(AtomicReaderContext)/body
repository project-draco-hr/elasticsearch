{
  if (parentFilter == null) {
    NestedAggregator closestNestedAggregator=findClosestNestedAggregator(parentAggregator);
    final Filter parentFilterNotCached;
    if (closestNestedAggregator == null) {
      parentFilterNotCached=NonNestedDocsFilter.INSTANCE;
    }
 else {
      parentFilterNotCached=closestNestedAggregator.childFilter;
    }
    parentFilter=SearchContext.current().filterCache().cache(parentFilterNotCached);
    parentFilter=new FixedBitSetCachingWrapperFilter(parentFilter);
  }
  try {
    DocIdSet docIdSet=parentFilter.getDocIdSet(reader,null);
    childDocs=DocIdSets.toSafeBits(reader.reader(),childFilter.getDocIdSet(reader,null));
    if (DocIdSets.isEmpty(docIdSet)) {
      parentDocs=null;
    }
 else {
      parentDocs=(FixedBitSet)docIdSet;
    }
  }
 catch (  IOException ioe) {
    throw new AggregationExecutionException("Failed to aggregate [" + name + "]",ioe);
  }
}
