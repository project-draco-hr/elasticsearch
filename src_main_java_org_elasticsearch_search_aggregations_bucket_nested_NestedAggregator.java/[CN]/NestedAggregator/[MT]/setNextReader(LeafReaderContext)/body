{
  if (parentFilter == null) {
    Filter parentFilterNotCached=findClosestNestedPath(parentAggregator);
    if (parentFilterNotCached == null) {
      parentFilterNotCached=NonNestedDocsFilter.INSTANCE;
    }
    parentFilter=SearchContext.current().bitsetFilterCache().getBitDocIdSetFilter(parentFilterNotCached);
  }
  try {
    BitDocIdSet parentSet=parentFilter.getDocIdSet(reader);
    if (DocIdSets.isEmpty(parentSet)) {
      parentDocs=null;
      childDocs=null;
    }
 else {
      parentDocs=parentSet.bits();
      BitDocIdSet childSet=childFilter.getDocIdSet(reader);
      if (DocIdSets.isEmpty(childSet)) {
        childDocs=new Bits.MatchAllBits(reader.reader().maxDoc());
      }
 else {
        childDocs=childSet.bits();
      }
    }
  }
 catch (  IOException ioe) {
    throw new AggregationExecutionException("Failed to aggregate [" + name + "]",ioe);
  }
}
