{
  String[] indices=Strings.splitStringByCommaToArray(request.param("index"));
  String[] features=request.paramAsStringArray("type",null);
  if (features == null && indices.length > 0 && indices[0] != null && indices[0].startsWith("_") && !"_all".equals(indices[0])) {
    features=indices;
    indices=new String[]{"_all"};
  }
  final GetIndexRequest getIndexRequest=new GetIndexRequest();
  getIndexRequest.indices(indices);
  if (features != null) {
    getIndexRequest.features(features);
  }
  getIndexRequest.indicesOptions(IndicesOptions.fromRequest(request,getIndexRequest.indicesOptions()));
  getIndexRequest.local(request.paramAsBoolean("local",getIndexRequest.local()));
  client.admin().indices().getIndex(getIndexRequest,new RestBuilderListener<GetIndexResponse>(channel){
    @Override public RestResponse buildResponse(    GetIndexResponse response,    XContentBuilder builder) throws Exception {
      String[] features=getIndexRequest.features();
      String[] indices=response.indices();
      builder.startObject();
      for (      String index : indices) {
        builder.startObject(index);
        for (        String feature : features) {
switch (feature) {
case "_alias":
case "_aliases":
            writeAliases(response.aliases().get(index),builder,request);
          break;
case "_mapping":
case "_mappings":
        writeMappings(response.mappings().get(index),builder,request);
      break;
case "_settings":
    writeSettings(response.settings().get(index),builder,request);
  break;
case "_warmer":
case "_warmers":
writeWarmers(response.warmers().get(index),builder,request);
break;
default :
throw new ElasticsearchIllegalStateException("feature [" + feature + "] is not valid");
}
}
builder.endObject();
}
builder.endObject();
return new BytesRestResponse(OK,builder);
}
private void writeAliases(ImmutableList<AliasMetaData> aliases,XContentBuilder builder,Params params) throws IOException {
if (aliases != null) {
builder.startObject(Fields.ALIASES);
for (AliasMetaData alias : aliases) {
AliasMetaData.Builder.toXContent(alias,builder,params);
}
builder.endObject();
}
}
private void writeMappings(ImmutableOpenMap<String,MappingMetaData> mappings,XContentBuilder builder,Params params) throws IOException {
if (mappings != null) {
builder.startObject(Fields.MAPPINGS);
for (ObjectObjectCursor<String,MappingMetaData> typeEntry : mappings) {
builder.field(typeEntry.key);
builder.map(typeEntry.value.sourceAsMap());
}
builder.endObject();
}
}
private void writeSettings(Settings settings,XContentBuilder builder,Params params) throws IOException {
builder.startObject(Fields.SETTINGS);
settings.toXContent(builder,params);
builder.endObject();
}
private void writeWarmers(ImmutableList<IndexWarmersMetaData.Entry> warmers,XContentBuilder builder,Params params) throws IOException {
if (warmers != null) {
builder.startObject(Fields.WARMERS);
for (IndexWarmersMetaData.Entry warmer : warmers) {
IndexWarmersMetaData.FACTORY.toXContent(warmer,builder,params);
}
builder.endObject();
}
}
}
);
}
