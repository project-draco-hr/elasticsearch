{
  int cycle=0;
  while (cycle++ < maxMergeAtOnce) {
    MergePolicy.OneMerge merge=writer.getNextMerge();
    if (merge == null)     break;
    writer.mergeInit(merge);
    int totalNumDocs=merge.totalNumDocs();
    long totalSizeInBytes=merge.totalBytesSize();
    long time=System.currentTimeMillis();
    currentMerges.inc();
    currentMergesNumDocs.inc(totalNumDocs);
    currentMergesSizeInBytes.inc(totalSizeInBytes);
    OnGoingMerge onGoingMerge=new OnGoingMerge(merge);
    onGoingMerges.add(onGoingMerge);
    if (logger.isTraceEnabled()) {
      logger.trace("merge [{}] starting..., merging [{}] segments, [{}] docs, [{}] size, into [{}] estimated_size",merge.info == null ? "_na_" : merge.info.info.name,merge.segments.size(),totalNumDocs,new ByteSizeValue(totalSizeInBytes),new ByteSizeValue(merge.estimatedMergeBytes));
    }
    try {
      beforeMerge(onGoingMerge);
      writer.merge(merge);
    }
  finally {
      long took=System.currentTimeMillis() - time;
      onGoingMerges.remove(onGoingMerge);
      afterMerge(onGoingMerge);
      currentMerges.dec();
      currentMergesNumDocs.dec(totalNumDocs);
      currentMergesSizeInBytes.dec(totalSizeInBytes);
      totalMergesNumDocs.inc(totalNumDocs);
      totalMergesSizeInBytes.inc(totalSizeInBytes);
      totalMerges.inc(took);
      if (took > 20000) {
        logger.debug("merge [{}] done, took [{}]",merge.info == null ? "_na_" : merge.info.info.name,TimeValue.timeValueMillis(took));
      }
 else       if (logger.isTraceEnabled()) {
        logger.trace("merge [{}] done, took [{}]",merge.info == null ? "_na_" : merge.info.info.name,TimeValue.timeValueMillis(took));
      }
    }
  }
}
