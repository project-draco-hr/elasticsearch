{
  if (this.nodes.isEmpty()) {
    return false;
  }
  if (logger.isTraceEnabled()) {
    logger.trace("Start balancing cluster");
  }
  final RoutingNodes.UnassignedShards unassigned=routingNodes.unassigned().transactionBegin();
  boolean changed=initialize(routingNodes,unassigned);
  if (!changed && allocation.deciders().canRebalance(allocation).type() == Type.YES) {
    NodeSorter sorter=newNodeSorter();
    if (nodes.size() > 1) {
      for (      String index : buildWeightOrderedIndidces(Operation.BALANCE,sorter)) {
        sorter.reset(Operation.BALANCE,index);
        final float[] weights=sorter.weights;
        final ModelNode[] modelNodes=sorter.modelNodes;
        int lowIdx=0;
        int highIdx=weights.length - 1;
        while (true) {
          final ModelNode minNode=modelNodes[lowIdx];
          final ModelNode maxNode=modelNodes[highIdx];
          advance_range:           if (maxNode.numShards(index) > 0) {
            final float delta=absDelta(weights[lowIdx],weights[highIdx]);
            if (lessThan(delta,threshold)) {
              if (lowIdx > 0 && highIdx - 1 > 0 && (absDelta(weights[0],weights[highIdx - 1]) > threshold)) {
                break advance_range;
              }
              if (logger.isTraceEnabled()) {
                logger.trace("Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]",index,maxNode.getNodeId(),weights[highIdx],minNode.getNodeId(),weights[lowIdx],delta);
              }
              break;
            }
            if (logger.isTraceEnabled()) {
              logger.trace("Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]",maxNode.getNodeId(),weights[highIdx],minNode.getNodeId(),weights[lowIdx],delta);
            }
            if (tryRelocateShard(Operation.BALANCE,minNode,maxNode,index,delta)) {
              weights[lowIdx]=sorter.weight(Operation.BALANCE,modelNodes[lowIdx]);
              weights[highIdx]=sorter.weight(Operation.BALANCE,modelNodes[highIdx]);
              sorter.sort(0,weights.length);
              lowIdx=0;
              highIdx=weights.length - 1;
              changed=true;
              continue;
            }
          }
          if (lowIdx < highIdx - 1) {
            lowIdx++;
          }
 else           if (lowIdx > 0) {
            lowIdx=0;
            highIdx--;
          }
 else {
            break;
          }
        }
      }
    }
  }
  routingNodes.unassigned().transactionEnd(unassigned);
  return changed;
}
