{
  int ops=0;
  long size=0;
  int totalOperations=0;
  final List<Translog.Operation> operations=Lists.newArrayList();
  Translog.Operation operation;
  try {
    operation=snapshot.next();
  }
 catch (  IOException ex) {
    throw new ElasticsearchException("failed to get next operation from translog",ex);
  }
  final TransportRequestOptions recoveryOptions=TransportRequestOptions.options().withCompress(recoverySettings.compress()).withType(TransportRequestOptions.Type.RECOVERY).withTimeout(recoverySettings.internalActionLongTimeout());
  if (operation == null) {
    logger.trace("[{}][{}] no translog operations to send to {}",indexName,shardId,request.targetNode());
  }
  while (operation != null) {
    if (shard.state() == IndexShardState.CLOSED) {
      throw new IndexShardClosedException(request.shardId());
    }
    cancellableThreads.checkForCancel();
    operations.add(operation);
    ops+=1;
    size+=operation.estimateSize();
    totalOperations++;
    if (ops >= recoverySettings.translogOps() || size >= recoverySettings.translogSize().bytes()) {
      cancellableThreads.execute(new Interruptable(){
        @Override public void run() throws InterruptedException {
          final RecoveryTranslogOperationsRequest translogOperationsRequest=new RecoveryTranslogOperationsRequest(request.recoveryId(),request.shardId(),operations,snapshot.estimatedTotalOperations());
          transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.TRANSLOG_OPS,translogOperationsRequest,recoveryOptions,EmptyTransportResponseHandler.INSTANCE_SAME).txGet();
        }
      }
);
      if (logger.isTraceEnabled()) {
        logger.trace("[{}][{}] sent batch of [{}][{}] (total: [{}]) translog operations to {}",indexName,shardId,ops,new ByteSizeValue(size),snapshot.estimatedTotalOperations(),request.targetNode());
      }
      ops=0;
      size=0;
      operations.clear();
    }
    try {
      operation=snapshot.next();
    }
 catch (    IOException ex) {
      throw new ElasticsearchException("failed to get next operation from translog",ex);
    }
  }
  if (!operations.isEmpty()) {
    cancellableThreads.execute(new Interruptable(){
      @Override public void run() throws InterruptedException {
        RecoveryTranslogOperationsRequest translogOperationsRequest=new RecoveryTranslogOperationsRequest(request.recoveryId(),request.shardId(),operations,snapshot.estimatedTotalOperations());
        transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.TRANSLOG_OPS,translogOperationsRequest,recoveryOptions,EmptyTransportResponseHandler.INSTANCE_SAME).txGet();
      }
    }
);
  }
  if (logger.isTraceEnabled()) {
    logger.trace("[{}][{}] sent final batch of [{}][{}] (total: [{}]) translog operations to {}",indexName,shardId,ops,new ByteSizeValue(size),snapshot.estimatedTotalOperations(),request.targetNode());
  }
  return totalOperations;
}
