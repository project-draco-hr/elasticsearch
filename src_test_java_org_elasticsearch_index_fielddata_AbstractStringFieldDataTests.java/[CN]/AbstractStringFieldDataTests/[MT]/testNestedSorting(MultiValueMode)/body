{
  final String[] values=new String[randomIntBetween(2,20)];
  for (int i=0; i < values.length; ++i) {
    values[i]=TestUtil.randomSimpleString(getRandom());
  }
  final int numParents=scaledRandomIntBetween(10,10000);
  List<Document> docs=new ArrayList<>();
  final OpenBitSet parents=new OpenBitSet();
  for (int i=0; i < numParents; ++i) {
    docs.clear();
    final int numChildren=randomInt(4);
    for (int j=0; j < numChildren; ++j) {
      final Document child=new Document();
      final int numValues=randomInt(3);
      for (int k=0; k < numValues; ++k) {
        final String value=RandomPicks.randomFrom(getRandom(),values);
        child.add(new StringField("text",value,Store.YES));
      }
      docs.add(child);
    }
    final Document parent=new Document();
    parent.add(new StringField("type","parent",Store.YES));
    final String value=RandomPicks.randomFrom(getRandom(),values);
    if (value != null) {
      parent.add(new StringField("text",value,Store.YES));
    }
    docs.add(parent);
    parents.set(parents.prevSetBit(parents.length() - 1) + docs.size());
    writer.addDocuments(docs);
    if (randomInt(10) == 0) {
      writer.commit();
    }
  }
  IndexSearcher searcher=new IndexSearcher(DirectoryReader.open(writer,true));
  IndexFieldData<?> fieldData=getForField("text");
  final Object missingValue;
switch (randomInt(4)) {
case 0:
    missingValue="_first";
  break;
case 1:
missingValue="_last";
break;
case 2:
missingValue=new BytesRef(RandomPicks.randomFrom(getRandom(),values));
break;
default :
missingValue=new BytesRef(TestUtil.randomSimpleString(getRandom()));
break;
}
Filter parentFilter=new TermFilter(new Term("type","parent"));
Filter childFilter=new NotFilter(parentFilter);
Nested nested=createNested(parentFilter,childFilter);
BytesRefFieldComparatorSource nestedComparatorSource=new BytesRefFieldComparatorSource(fieldData,missingValue,sortMode,nested);
ToParentBlockJoinQuery query=new ToParentBlockJoinQuery(new XFilteredQuery(new MatchAllDocsQuery(),childFilter),new FixedBitSetCachingWrapperFilter(parentFilter),ScoreMode.None);
Sort sort=new Sort(new SortField("text",nestedComparatorSource));
TopFieldDocs topDocs=searcher.search(query,randomIntBetween(1,numParents),sort);
assertTrue(topDocs.scoreDocs.length > 0);
BytesRef previous=null;
for (int i=0; i < topDocs.scoreDocs.length; ++i) {
final int docID=topDocs.scoreDocs[i].doc;
assertTrue("expected " + docID + " to be a parent",parents.get(docID));
BytesRef cmpValue=null;
for (int child=parents.prevSetBit(docID - 1) + 1; child < docID; ++child) {
String[] sVals=searcher.doc(child).getValues("text");
final BytesRef[] vals;
if (sVals.length == 0) {
vals=new BytesRef[0];
}
 else {
vals=new BytesRef[sVals.length];
for (int j=0; j < vals.length; ++j) {
vals[j]=new BytesRef(sVals[j]);
}
}
for (BytesRef value : vals) {
if (cmpValue == null) {
cmpValue=value;
}
 else if (sortMode == MultiValueMode.MIN && value.compareTo(cmpValue) < 0) {
cmpValue=value;
}
 else if (sortMode == MultiValueMode.MAX && value.compareTo(cmpValue) > 0) {
cmpValue=value;
}
}
}
if (cmpValue == null) {
if ("_first".equals(missingValue)) {
cmpValue=new BytesRef();
}
 else if ("_last".equals(missingValue)) {
cmpValue=XFieldComparatorSource.MAX_TERM;
}
 else {
cmpValue=(BytesRef)missingValue;
}
}
if (previous != null) {
assertTrue(previous.utf8ToString() + "   /   " + cmpValue.utf8ToString(),previous.compareTo(cmpValue) <= 0);
}
previous=cmpValue;
}
searcher.getIndexReader().close();
}
