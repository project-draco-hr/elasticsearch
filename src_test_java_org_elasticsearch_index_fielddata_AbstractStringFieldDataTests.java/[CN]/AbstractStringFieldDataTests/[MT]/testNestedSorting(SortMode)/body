{
  final String[] values=new String[randomIntBetween(2,20)];
  for (int i=0; i < values.length; ++i) {
    values[i]=_TestUtil.randomSimpleString(getRandom());
  }
  final int numParents=atLeast(100);
  List<Document> docs=new ArrayList<Document>();
  final OpenBitSet parents=new OpenBitSet();
  for (int i=0; i < numParents; ++i) {
    docs.clear();
    final int numChildren=randomInt(4);
    for (int j=0; j < numChildren; ++j) {
      final Document child=new Document();
      final int numValues=randomInt(3);
      for (int k=0; k < numValues; ++k) {
        final String value=RandomPicks.randomFrom(getRandom(),values);
        child.add(new StringField("text",value,Store.YES));
      }
      docs.add(child);
    }
    final Document parent=new Document();
    parent.add(new StringField("type","parent",Store.YES));
    final String value=RandomPicks.randomFrom(getRandom(),values);
    if (value != null) {
      parent.add(new StringField("text",value,Store.YES));
    }
    docs.add(parent);
    parents.set(parents.prevSetBit(parents.length() - 1) + docs.size());
    writer.addDocuments(docs);
    if (randomInt(10) == 0) {
      writer.commit();
    }
  }
  IndexSearcher searcher=new IndexSearcher(DirectoryReader.open(writer,true));
  IndexFieldData<?> fieldData=getForField("text");
  final BytesRef missingValue;
switch (randomInt(4)) {
case 0:
    missingValue=new BytesRef();
  break;
case 1:
missingValue=BytesRefFieldComparatorSource.MAX_TERM;
break;
case 2:
missingValue=new BytesRef(RandomPicks.randomFrom(getRandom(),values));
break;
default :
missingValue=new BytesRef(_TestUtil.randomSimpleString(getRandom()));
break;
}
BytesRefFieldComparatorSource innerSource=new BytesRefFieldComparatorSource(fieldData,missingValue,sortMode);
Filter parentFilter=new TermFilter(new Term("type","parent"));
Filter childFilter=new NotFilter(parentFilter);
NestedFieldComparatorSource nestedComparatorSource=new NestedFieldComparatorSource(sortMode,innerSource,parentFilter,childFilter);
ToParentBlockJoinQuery query=new ToParentBlockJoinQuery(new XFilteredQuery(new MatchAllDocsQuery(),childFilter),new FixedBitSetCachingWrapperFilter(parentFilter),ScoreMode.None);
Sort sort=new Sort(new SortField("text",nestedComparatorSource));
TopFieldDocs topDocs=searcher.search(query,randomIntBetween(1,numParents),sort);
assertTrue(topDocs.scoreDocs.length > 0);
BytesRef previous=null;
for (int i=0; i < topDocs.scoreDocs.length; ++i) {
final int docID=topDocs.scoreDocs[i].doc;
assertTrue("expected " + docID + " to be a parent",parents.get(docID));
BytesRef cmpValue=null;
for (int child=parents.prevSetBit(docID - 1) + 1; child < docID; ++child) {
String[] vals=searcher.doc(child).getValues("text");
if (vals.length == 0) {
vals=new String[]{missingValue.utf8ToString()};
}
for (String value : vals) {
final BytesRef bytesValue=new BytesRef(value);
if (cmpValue == null) {
cmpValue=bytesValue;
}
 else if (sortMode == SortMode.MIN && bytesValue.compareTo(cmpValue) < 0) {
cmpValue=bytesValue;
}
 else if (sortMode == SortMode.MAX && bytesValue.compareTo(cmpValue) > 0) {
cmpValue=bytesValue;
}
}
}
if (cmpValue == null) {
cmpValue=missingValue;
}
if (previous != null) {
assertNotNull(cmpValue);
assertTrue(previous.utf8ToString() + "   /   " + cmpValue.utf8ToString(),previous.compareTo(cmpValue) <= 0);
}
previous=cmpValue;
}
searcher.getIndexReader().close();
}
