{
  int successfulShards=0;
  int failedShards=0;
  List<PercolateShardResponse> shardResults=null;
  List<ShardOperationFailedException> shardFailures=null;
  for (int i=0; i < shardsResponses.length(); i++) {
    Object shardResponse=shardsResponses.get(i);
    if (shardResponse == null) {
    }
 else     if (shardResponse instanceof BroadcastShardOperationFailedException) {
      failedShards++;
      if (shardFailures == null) {
        shardFailures=newArrayList();
      }
      shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException)shardResponse));
    }
 else {
      PercolateShardResponse percolateShardResponse=(PercolateShardResponse)shardResponse;
      if (shardResults == null) {
        shardResults=newArrayList();
      }
      shardResults.add(percolateShardResponse);
      successfulShards++;
    }
  }
  long tookInMillis=System.currentTimeMillis() - request.startTime;
  if (shardResults == null) {
    return new PercolateResponse(shardsResponses.length(),successfulShards,failedShards,shardFailures,tookInMillis);
  }
  if (request.onlyCount()) {
    long finalCount=0;
    for (    PercolateShardResponse shardResponse : shardResults) {
      finalCount+=shardResponse.count();
    }
    return new PercolateResponse(shardsResponses.length(),successfulShards,failedShards,shardFailures,finalCount,tookInMillis);
  }
 else {
    long foundMatches=0;
    int numMatches=0;
    for (    PercolateShardResponse response : shardResults) {
      foundMatches+=response.count();
      numMatches+=response.matches().length;
    }
    int requestedSize=shardResults.get(0).requestedSize();
    boolean limit=shardResults.get(0).limit();
    boolean sort=shardResults.get(0).sort();
    boolean matchesScored=shardResults.get(0).score();
    if (limit) {
      requestedSize=Math.min(requestedSize,numMatches);
    }
 else {
      requestedSize=numMatches;
    }
    List<PercolateResponse.Match> finalMatches=new ArrayList<PercolateResponse.Match>(requestedSize);
    if (sort) {
      if (shardResults.size() == 1) {
        PercolateShardResponse response=shardResults.get(0);
        Text index=new StringText(response.getIndex());
        for (int i=0; i < response.matches().length; i++) {
          float score=response.scores().length == 0 ? Float.NaN : response.scores()[i];
          finalMatches.add(new PercolateResponse.Match(index,response.matches()[i],score));
        }
      }
 else {
        int[] slots=new int[shardResults.size()];
        while (true) {
          float lowestScore=Float.NEGATIVE_INFINITY;
          int requestIndex=0;
          int itemIndex=0;
          for (int i=0; i < shardResults.size(); i++) {
            int scoreIndex=slots[i];
            float[] scores=shardResults.get(i).scores();
            if (scoreIndex >= scores.length) {
              continue;
            }
            float score=scores[scoreIndex];
            int cmp=Float.compare(lowestScore,score);
            if (cmp < 0) {
              requestIndex=i;
              itemIndex=scoreIndex;
              lowestScore=score;
            }
          }
          slots[requestIndex]++;
          PercolateShardResponse shardResponse=shardResults.get(requestIndex);
          Text index=new StringText(shardResponse.getIndex());
          Text match=shardResponse.matches()[itemIndex];
          float score=shardResponse.scores()[itemIndex];
          finalMatches.add(new PercolateResponse.Match(index,match,score));
          if (finalMatches.size() == requestedSize) {
            break;
          }
        }
      }
    }
 else {
      outer:       for (      PercolateShardResponse response : shardResults) {
        Text index=new StringText(response.getIndex());
        for (int i=0; i < response.matches().length; i++) {
          float score=response.scores().length == 0 ? 0f : response.scores()[i];
          finalMatches.add(new PercolateResponse.Match(index,response.matches()[i],score));
          if (requestedSize != 0 && finalMatches.size() == requestedSize) {
            break outer;
          }
        }
      }
    }
    return new PercolateResponse(shardsResponses.length(),successfulShards,failedShards,shardFailures,finalMatches.toArray(new PercolateResponse.Match[requestedSize]),foundMatches,tookInMillis,sort || matchesScored);
  }
}
