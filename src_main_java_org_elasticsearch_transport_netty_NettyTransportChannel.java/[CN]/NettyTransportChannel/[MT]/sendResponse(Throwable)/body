{
  ReleasableBytesStreamOutput stream=new ReleasableBytesStreamOutput(transport.bigArrays);
  boolean addedReleaseListener=false;
  try {
    try {
      stream.skip(NettyHeader.HEADER_SIZE);
      RemoteTransportException tx=new RemoteTransportException(transport.nodeName(),transport.wrapAddress(channel.getLocalAddress()),action,error);
      ThrowableObjectOutputStream too=new ThrowableObjectOutputStream(stream);
      too.writeObject(tx);
      too.close();
    }
 catch (    NotSerializableException e) {
      stream.reset();
      stream.skip(NettyHeader.HEADER_SIZE);
      RemoteTransportException tx=new RemoteTransportException(transport.nodeName(),transport.wrapAddress(channel.getLocalAddress()),action,new NotSerializableTransportException(error));
      ThrowableObjectOutputStream too=new ThrowableObjectOutputStream(stream);
      too.writeObject(tx);
      too.close();
    }
    byte status=0;
    status=TransportStatus.setResponse(status);
    status=TransportStatus.setError(status);
    ReleasableBytesReference bytes=stream.bytes();
    ChannelBuffer buffer=bytes.toChannelBuffer();
    NettyHeader.writeHeader(buffer,requestId,status,version);
    ChannelFuture future=channel.write(buffer);
    ReleaseChannelFutureListener listener=new ReleaseChannelFutureListener(bytes);
    future.addListener(listener);
    addedReleaseListener=true;
  }
  finally {
    if (!addedReleaseListener) {
      Releasables.close(stream.bytes());
    }
  }
}
