{
  String mapping=XContentFactory.jsonBuilder().startObject().startObject(TYPE).startObject("_timestamp").field("enabled",true).startObject("fielddata").field("format","doc_values").endObject().field("store","yes").field("index","analyzed").field("path","foo").field("default","1970-01-01").endObject().endObject().endObject().string();
  client().admin().indices().prepareCreate(INDEX).addMapping(TYPE,mapping).get();
  mapping=XContentFactory.jsonBuilder().startObject().startObject("type").startObject("_timestamp").field("enabled",false).startObject("fielddata").field("format","array").endObject().field("store","no").field("index","no").field("path","bar").field("default","1970-01-02").endObject().endObject().endObject().string();
  GetMappingsResponse mappingsBeforeUpdateResponse=client().admin().indices().prepareGetMappings(INDEX).addTypes(TYPE).get();
  try {
    client().admin().indices().preparePutMapping(INDEX).setType(TYPE).setSource(mapping).get();
    fail("This should result in conflicts when merging the mapping");
  }
 catch (  MergeMappingException e) {
    String[] expectedConflicts={"mapper [_timestamp] has different index values","mapper [_timestamp] has different store values","Cannot update default in _timestamp value. Value is 1970-01-01 now encountering 1970-01-02","Cannot update path in _timestamp value. Value is foo path in merged mapping is bar"};
    for (    String conflict : expectedConflicts) {
      assertThat(e.getDetailedMessage(),containsString(conflict));
    }
  }
  compareMappingOnNodes(mappingsBeforeUpdateResponse);
}
