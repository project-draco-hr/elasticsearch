{
  maintainPar&=maintainsParallelism;
  boolean dec=false;
  boolean done=false;
  for (; ; ) {
    releaseWaiters();
    if (done=blocker.isReleasable())     break;
    ForkJoinWorkerThread spare=null;
    for (    ForkJoinWorkerThread w : workers) {
      if (w != null && w.isSuspended()) {
        spare=w;
        break;
      }
    }
    if (done=blocker.isReleasable())     break;
    if (spare != null && spare.tryUnsuspend()) {
      if (dec) {
        int c;
        do {
        }
 while (!UNSAFE.compareAndSwapInt(this,workerCountsOffset,c=workerCounts,c + ONE_RUNNING));
      }
      LockSupport.unpark(spare);
      break;
    }
    int wc=workerCounts;
    if (!dec && (wc & RUNNING_COUNT_MASK) != 0)     dec=UNSAFE.compareAndSwapInt(this,workerCountsOffset,wc,wc-=ONE_RUNNING);
    if (dec) {
      int tc=wc >>> TOTAL_COUNT_SHIFT;
      int pc=parallelism;
      int dc=pc - (wc & RUNNING_COUNT_MASK);
      if ((dc < pc && (dc <= 0 || (dc * dc < (tc - pc) * pc) || !maintainPar)) || tc >= maxPoolSize)       break;
      if (spare == null && UNSAFE.compareAndSwapInt(this,workerCountsOffset,wc,wc + (ONE_RUNNING | ONE_TOTAL))) {
        addWorker();
        break;
      }
    }
  }
  try {
    if (!done)     do {
    }
 while (!blocker.isReleasable() && !blocker.block());
  }
  finally {
    if (dec) {
      int c;
      do {
      }
 while (!UNSAFE.compareAndSwapInt(this,workerCountsOffset,c=workerCounts,c + ONE_RUNNING));
    }
  }
}
