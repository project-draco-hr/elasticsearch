{
  boolean dec=false;
  for (; ; ) {
    releaseWaiters();
    if (joinMe.status < 0)     return;
    ForkJoinWorkerThread spare=null;
    for (    ForkJoinWorkerThread w : workers) {
      if (w != null && w.isSuspended()) {
        spare=w;
        break;
      }
    }
    if (joinMe.status < 0)     return;
    if (spare != null && spare.tryUnsuspend()) {
      if (dec || joinMe.requestSignal() < 0) {
        int c;
        do {
        }
 while (!UNSAFE.compareAndSwapInt(this,workerCountsOffset,c=workerCounts,c + ONE_RUNNING));
      }
      LockSupport.unpark(spare);
      return;
    }
    int wc=workerCounts;
    if (!dec && (wc & RUNNING_COUNT_MASK) != 0 && (dec=UNSAFE.compareAndSwapInt(this,workerCountsOffset,wc,wc-=ONE_RUNNING)) && joinMe.requestSignal() < 0) {
      int c;
      do {
      }
 while (!UNSAFE.compareAndSwapInt(this,workerCountsOffset,c=workerCounts,c + ONE_RUNNING));
      return;
    }
    if (dec) {
      int tc=wc >>> TOTAL_COUNT_SHIFT;
      int pc=parallelism;
      int dc=pc - (wc & RUNNING_COUNT_MASK);
      if ((dc < pc && (dc <= 0 || (dc * dc < (tc - pc) * pc) || !maintainsParallelism)) || tc >= maxPoolSize)       return;
      if (spare == null && UNSAFE.compareAndSwapInt(this,workerCountsOffset,wc,wc + (ONE_RUNNING | ONE_TOTAL))) {
        addWorker();
        return;
      }
    }
  }
}
