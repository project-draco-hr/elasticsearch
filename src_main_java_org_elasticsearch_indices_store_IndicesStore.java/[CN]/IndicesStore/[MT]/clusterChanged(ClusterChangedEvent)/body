{
  if (!event.routingTableChanged()) {
    return;
  }
  if (event.state().blocks().disableStatePersistence()) {
    return;
  }
  RoutingTable routingTable=event.state().routingTable();
  for (  IndexRoutingTable indexRoutingTable : routingTable) {
    IndexService indexService=indicesService.indexService(indexRoutingTable.index());
    if (indexService == null) {
      continue;
    }
    if (!indexService.store().persistent()) {
      continue;
    }
    for (    IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {
      if (indexService.hasShard(indexShardRoutingTable.shardId().id())) {
        continue;
      }
      if (!indexService.store().canDeleteUnallocated(indexShardRoutingTable.shardId())) {
        continue;
      }
      if (indexShardRoutingTable.countWithState(ShardRoutingState.STARTED) == indexShardRoutingTable.size()) {
        if (logger.isDebugEnabled()) {
          logger.debug("[{}][{}] deleting unallocated shard",indexShardRoutingTable.shardId().index().name(),indexShardRoutingTable.shardId().id());
        }
        try {
          indexService.store().deleteUnallocated(indexShardRoutingTable.shardId());
        }
 catch (        Exception e) {
          logger.debug("[{}][{}] failed to delete unallocated shard, ignoring",e,indexShardRoutingTable.shardId().index().name(),indexShardRoutingTable.shardId().id());
        }
      }
    }
  }
  if (nodeEnv.hasNodeFile()) {
    for (    IndexRoutingTable indexRoutingTable : routingTable) {
      IndexService indexService=indicesService.indexService(indexRoutingTable.index());
      if (indexService != null) {
        continue;
      }
      for (      IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {
        boolean shardCanBeDeleted=true;
        for (        ShardRouting shardRouting : indexShardRoutingTable) {
          if (!shardRouting.active()) {
            shardCanBeDeleted=false;
            break;
          }
          String localNodeId=clusterService.localNode().id();
          if (localNodeId.equals(shardRouting.currentNodeId()) || localNodeId.equals(shardRouting.relocatingNodeId())) {
            shardCanBeDeleted=false;
            break;
          }
        }
        if (shardCanBeDeleted) {
          ShardId shardId=indexShardRoutingTable.shardId();
          for (          File shardLocation : nodeEnv.shardLocations(shardId)) {
            if (shardLocation.exists()) {
              logger.debug("[{}][{}] deleting shard that is no longer used",shardId.index().name(),shardId.id());
              FileSystemUtils.deleteRecursively(shardLocation);
            }
          }
        }
      }
    }
    if (danglingTimeout.millis() >= 0) {
synchronized (danglingMutex) {
        for (        String danglingIndex : danglingIndices.keySet()) {
          if (event.state().metaData().hasIndex(danglingIndex)) {
            logger.debug("[{}] no longer dangling (created), removing",danglingIndex);
            DanglingIndex removed=danglingIndices.remove(danglingIndex);
            removed.future.cancel(false);
          }
        }
        try {
          for (          String indexName : nodeEnv.findAllIndices()) {
            if (event.state().metaData().hasIndex(indexName)) {
              continue;
            }
            if (danglingIndices.containsKey(indexName)) {
              continue;
            }
            if (danglingTimeout.millis() == 0) {
              logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, timeout set to 0, deleting now",indexName);
              FileSystemUtils.deleteRecursively(nodeEnv.indexLocations(new Index(indexName)));
            }
 else {
              logger.info("[{}] dangling index, exists on local file system, but not in cluster metadata, scheduling to delete in [{}]",indexName,danglingTimeout);
              danglingIndices.put(indexName,new DanglingIndex(indexName,threadPool.schedule(danglingTimeout,ThreadPool.Names.SAME,new RemoveDanglingIndex(indexName))));
            }
          }
        }
 catch (        Exception e) {
          logger.warn("failed to find dangling indices",e);
        }
      }
    }
  }
}
