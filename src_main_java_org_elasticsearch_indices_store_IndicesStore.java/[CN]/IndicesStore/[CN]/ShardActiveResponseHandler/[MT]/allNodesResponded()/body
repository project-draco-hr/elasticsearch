{
  if (activeCopies.get() != expectedActiveCopies) {
    logger.trace("not deleting shard {}, expected {} active copies, but only {} found active copies",shardId,expectedActiveCopies,activeCopies.get());
    return;
  }
  ClusterState latestClusterState=clusterService.state();
  if (clusterState.getVersion() != latestClusterState.getVersion()) {
    logger.trace("not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,latestClusterState.getVersion(),clusterState.getVersion());
    return;
  }
  clusterService.submitStateUpdateTask("indices_store",new ClusterStateNonMasterUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      if (clusterState.getVersion() != currentState.getVersion()) {
        logger.trace("not deleting shard {}, the update task state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,currentState.getVersion(),clusterState.getVersion());
        return currentState;
      }
      IndexMetaData indexMeta=clusterState.getMetaData().indices().get(shardId.getIndex());
      try {
        indicesService.deleteShardStore("no longer used",shardId,indexMeta);
      }
 catch (      Throwable ex) {
        logger.debug("{} failed to delete unallocated shard, ignoring",ex,shardId);
      }
      if (indicesService.hasIndex(shardId.getIndex()) == false && currentState.nodes().localNode().masterNode() == false) {
        try {
          indicesService.deleteIndexStore("no longer used",indexMeta,currentState);
        }
 catch (        Throwable ex) {
          logger.debug("{} failed to delete unallocated index, ignoring",ex,shardId.getIndex());
        }
      }
      return currentState;
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("{} unexpected error during deletion of unallocated shard",t,shardId);
    }
  }
);
}
