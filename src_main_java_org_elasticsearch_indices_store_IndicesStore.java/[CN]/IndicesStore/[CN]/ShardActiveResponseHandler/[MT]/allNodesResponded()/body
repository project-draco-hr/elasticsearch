{
  if (activeCopies.get() != expectedActiveCopies) {
    logger.trace("not deleting shard {}, expected {} active copies, but only {} found active copies",shardId,expectedActiveCopies,activeCopies.get());
    return;
  }
  ClusterState latestClusterState=clusterService.state();
  if (clusterState.getVersion() != latestClusterState.getVersion()) {
    logger.trace("not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,latestClusterState.getVersion(),clusterState.getVersion());
    return;
  }
  clusterService.submitStateUpdateTask("indices_store",new ClusterStateNonMasterUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState) throws Exception {
      if (clusterState.getVersion() != currentState.getVersion()) {
        logger.trace("not deleting shard {}, the update task state version[{}] is not equal to cluster state before shard active api call [{}]",shardId,currentState.getVersion(),clusterState.getVersion());
        return currentState;
      }
      IndexService indexService=indicesService.indexService(shardId.getIndex());
      IndexMetaData indexMeta=clusterState.getMetaData().indices().get(shardId.getIndex());
      if (indexService == null) {
        if (nodeEnv.hasNodeFile()) {
          Path[] shardLocations=nodeEnv.shardPaths(shardId,indexMeta.settings());
          if (FileSystemUtils.exists(shardLocations)) {
            logger.debug("{} deleting shard that is no longer used",shardId);
            try {
              nodeEnv.deleteShardDirectorySafe(shardId,indexMeta.settings());
            }
 catch (            Exception ex) {
              logger.debug("failed to delete shard locations",ex);
            }
          }
        }
      }
 else {
        if (!indexService.hasShard(shardId.id())) {
          if (indexService.store().canDeleteUnallocated(shardId,indexMeta.settings())) {
            logger.debug("{} deleting shard that is no longer used",shardId);
            try {
              indexService.store().deleteUnallocated(shardId,indexMeta.settings());
            }
 catch (            Exception e) {
              logger.debug("{} failed to delete unallocated shard, ignoring",e,shardId);
            }
          }
        }
 else {
        }
      }
      return currentState;
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("{} unexpected error during deletion of unallocated shard",t,shardId);
    }
  }
);
}
