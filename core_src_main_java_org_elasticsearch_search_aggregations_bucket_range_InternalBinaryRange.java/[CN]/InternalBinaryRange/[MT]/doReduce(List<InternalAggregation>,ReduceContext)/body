{
  long[] docCounts=new long[buckets.length];
  InternalAggregations[][] aggs=new InternalAggregations[buckets.length][];
  for (int i=0; i < aggs.length; ++i) {
    aggs[i]=new InternalAggregations[aggregations.size()];
  }
  for (int i=0; i < aggregations.size(); ++i) {
    InternalBinaryRange range=(InternalBinaryRange)aggregations.get(i);
    if (range.buckets.length != buckets.length) {
      throw new IllegalStateException("Expected " + buckets.length + " buckets, but got "+ range.buckets.length);
    }
    for (int j=0; j < buckets.length; ++j) {
      Bucket bucket=range.buckets[j];
      docCounts[j]+=bucket.docCount;
      aggs[j][i]=bucket.aggregations;
    }
  }
  Bucket[] buckets=new Bucket[this.buckets.length];
  for (int i=0; i < buckets.length; ++i) {
    Bucket b=this.buckets[i];
    buckets[i]=new Bucket(format,keyed,b.key,b.from,b.to,docCounts[i],InternalAggregations.reduce(Arrays.asList(aggs[i]),reduceContext));
  }
  return new InternalBinaryRange(name,format,keyed,buckets,pipelineAggregators(),metaData);
}
