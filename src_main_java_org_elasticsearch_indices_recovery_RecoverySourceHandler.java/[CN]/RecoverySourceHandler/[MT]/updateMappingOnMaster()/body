{
  final BlockingQueue<DocumentMapper> documentMappersToUpdate=ConcurrentCollections.newBlockingQueue();
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicReference<Throwable> mappingCheckException=new AtomicReference<>();
  clusterService.submitStateUpdateTask("recovery_mapping_check",Priority.IMMEDIATE,new MappingUpdateTask(clusterService,indexService,recoverySettings,latch,documentMappersToUpdate,mappingCheckException,this.cancellableThreads));
  cancellableThreads.execute(new Interruptable(){
    @Override public void run() throws InterruptedException {
      latch.await();
    }
  }
);
  if (mappingCheckException.get() != null) {
    logger.warn("error during mapping check, failing recovery",mappingCheckException.get());
    throw new ElasticsearchException("error during mapping check",mappingCheckException.get());
  }
  if (documentMappersToUpdate.isEmpty()) {
    return;
  }
  final CountDownLatch updatedOnMaster=new CountDownLatch(documentMappersToUpdate.size());
  MappingUpdatedAction.MappingUpdateListener listener=new MappingUpdatedAction.MappingUpdateListener(){
    @Override public void onMappingUpdate(){
      updatedOnMaster.countDown();
    }
    @Override public void onFailure(    Throwable t){
      logger.debug("{} recovery to {}: failed to update mapping on master",request.shardId(),request.targetNode(),t);
      updatedOnMaster.countDown();
    }
  }
;
  for (  DocumentMapper documentMapper : documentMappersToUpdate) {
    mappingUpdatedAction.updateMappingOnMaster(indexService.index().getName(),indexService.indexUUID(),documentMapper.type(),documentMapper.mapping(),listener);
  }
  cancellableThreads.execute(new Interruptable(){
    @Override public void run() throws InterruptedException {
      try {
        if (!updatedOnMaster.await(recoverySettings.internalActionTimeout().millis(),TimeUnit.MILLISECONDS)) {
          logger.debug("[{}][{}] recovery [phase2] to {}: waiting on pending mapping update timed out. waited [{}]",indexName,shardId,request.targetNode(),recoverySettings.internalActionTimeout());
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        logger.debug("interrupted while waiting for mapping to update on master");
      }
    }
  }
);
}
