{
  AtomicReader reader=context.reader();
  Terms terms=reader.terms(getFieldNames().indexName());
  AtomicGeoPointFieldData data=null;
  NonEstimatingEstimator estimator=new NonEstimatingEstimator(breakerService.getBreaker());
  if (terms == null) {
    data=new Empty(reader.maxDoc());
    estimator.afterLoad(null,data.getMemorySizeInBytes());
    return data;
  }
  final long initialSize;
  if (terms.size() >= 0) {
    initialSize=1 + terms.size();
  }
 else {
    initialSize=1 + Math.min(1 << 12,reader.maxDoc());
  }
  final int pageSize=Integer.highestOneBit(BigArrays.PAGE_SIZE_IN_BYTES * 8 / encoding.numBitsPerCoordinate() - 1) << 1;
  PagedMutable lat=new PagedMutable(initialSize,pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
  PagedMutable lon=new PagedMutable(initialSize,pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
  final float acceptableTransientOverheadRatio=fieldDataType.getSettings().getAsFloat("acceptable_transient_overhead_ratio",OrdinalsBuilder.DEFAULT_ACCEPTABLE_OVERHEAD_RATIO);
  OrdinalsBuilder builder=new OrdinalsBuilder(terms.size(),reader.maxDoc(),acceptableTransientOverheadRatio);
  boolean success=false;
  try {
    final GeoPointEnum iter=new GeoPointEnum(builder.buildFromTerms(terms.iterator(null)));
    GeoPoint point;
    long ord=0;
    while ((point=iter.next()) != null) {
      ++ord;
      if (lat.size() <= ord) {
        final long newSize=BigArrays.overSize(ord + 1);
        lat=lat.resize(newSize);
        lon=lon.resize(newSize);
      }
      lat.set(ord,encoding.encodeCoordinate(point.getLat()));
      lon.set(ord,encoding.encodeCoordinate(point.getLon()));
    }
    Ordinals build=builder.build(fieldDataType.getSettings());
    if (!build.isMultiValued() && CommonSettings.removeOrdsOnSingleValue(fieldDataType)) {
      Docs ordinals=build.ordinals();
      int maxDoc=reader.maxDoc();
      PagedMutable sLat=new PagedMutable(reader.maxDoc(),pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
      PagedMutable sLon=new PagedMutable(reader.maxDoc(),pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
      for (int i=0; i < maxDoc; i++) {
        final long nativeOrdinal=ordinals.getOrd(i);
        sLat.set(i,lat.get(nativeOrdinal));
        sLon.set(i,lon.get(nativeOrdinal));
      }
      FixedBitSet set=builder.buildDocsWithValuesSet();
      if (set == null) {
        data=new GeoPointCompressedAtomicFieldData.Single(encoding,sLon,sLat,reader.maxDoc(),ordinals.getNumOrds());
      }
 else {
        data=new GeoPointCompressedAtomicFieldData.SingleFixedSet(encoding,sLon,sLat,reader.maxDoc(),set,ordinals.getNumOrds());
      }
    }
 else {
      if (lat.size() != build.getMaxOrd()) {
        lat=lat.resize(build.getMaxOrd());
        lon=lon.resize(build.getMaxOrd());
      }
      data=new GeoPointCompressedAtomicFieldData.WithOrdinals(encoding,lon,lat,reader.maxDoc(),build);
    }
    success=true;
    return data;
  }
  finally {
    if (success) {
      estimator.afterLoad(null,data.getMemorySizeInBytes());
    }
    builder.close();
  }
}
