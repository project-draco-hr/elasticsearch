{
  AtomicReader reader=context.reader();
  Terms terms=reader.terms(getFieldNames().indexName());
  AtomicGeoPointFieldData data=null;
  NonEstimatingEstimator estimator=new NonEstimatingEstimator(breakerService.getBreaker());
  if (terms == null) {
    data=new Empty();
    estimator.afterLoad(null,data.ramBytesUsed());
    return data;
  }
  final long initialSize;
  if (terms.size() >= 0) {
    initialSize=1 + terms.size();
  }
 else {
    initialSize=1 + Math.min(1 << 12,reader.maxDoc());
  }
  final int pageSize=Integer.highestOneBit(BigArrays.PAGE_SIZE_IN_BYTES * 8 / encoding.numBitsPerCoordinate() - 1) << 1;
  PagedMutable lat=new PagedMutable(initialSize,pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
  PagedMutable lon=new PagedMutable(initialSize,pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
  final float acceptableTransientOverheadRatio=fieldDataType.getSettings().getAsFloat("acceptable_transient_overhead_ratio",OrdinalsBuilder.DEFAULT_ACCEPTABLE_OVERHEAD_RATIO);
  boolean success=false;
  try (OrdinalsBuilder builder=new OrdinalsBuilder(terms.size(),reader.maxDoc(),acceptableTransientOverheadRatio)){
    final GeoPointEnum iter=new GeoPointEnum(builder.buildFromTerms(terms.iterator(null)));
    GeoPoint point;
    while ((point=iter.next()) != null) {
      final long ord=builder.currentOrdinal();
      if (lat.size() <= ord) {
        final long newSize=BigArrays.overSize(ord + 1);
        lat=lat.resize(newSize);
        lon=lon.resize(newSize);
      }
      lat.set(ord,encoding.encodeCoordinate(point.getLat()));
      lon.set(ord,encoding.encodeCoordinate(point.getLon()));
    }
    Ordinals build=builder.build(fieldDataType.getSettings());
    BytesValues.WithOrdinals ordinals=build.ordinals();
    if (ordinals.isMultiValued() || CommonSettings.getMemoryStorageHint(fieldDataType) == CommonSettings.MemoryStorageFormat.ORDINALS) {
      if (lat.size() != ordinals.getMaxOrd()) {
        lat=lat.resize(ordinals.getMaxOrd());
        lon=lon.resize(ordinals.getMaxOrd());
      }
      data=new GeoPointCompressedAtomicFieldData.WithOrdinals(encoding,lon,lat,build);
    }
 else {
      int maxDoc=reader.maxDoc();
      PagedMutable sLat=new PagedMutable(reader.maxDoc(),pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
      PagedMutable sLon=new PagedMutable(reader.maxDoc(),pageSize,encoding.numBitsPerCoordinate(),PackedInts.COMPACT);
      final long missing=encoding.encodeCoordinate(0);
      for (int i=0; i < maxDoc; i++) {
        final long nativeOrdinal=ordinals.getOrd(i);
        if (nativeOrdinal != BytesValues.WithOrdinals.MISSING_ORDINAL) {
          sLat.set(i,lat.get(nativeOrdinal));
          sLon.set(i,lon.get(nativeOrdinal));
        }
 else {
          sLat.set(i,missing);
          sLon.set(i,missing);
        }
      }
      FixedBitSet set=builder.buildDocsWithValuesSet();
      if (set == null) {
        data=new GeoPointCompressedAtomicFieldData.Single(encoding,sLon,sLat);
      }
 else {
        data=new GeoPointCompressedAtomicFieldData.SingleFixedSet(encoding,sLon,sLat,set);
      }
    }
    success=true;
    return data;
  }
  finally {
    if (success) {
      estimator.afterLoad(null,data.ramBytesUsed());
    }
  }
}
