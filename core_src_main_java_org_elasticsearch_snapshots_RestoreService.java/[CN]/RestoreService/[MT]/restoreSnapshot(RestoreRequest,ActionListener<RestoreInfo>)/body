{
  try {
    Repository repository=repositoriesService.repository(request.repository());
    final SnapshotId snapshotId=new SnapshotId(request.repository(),request.name());
    final Snapshot snapshot=repository.readSnapshot(snapshotId);
    List<String> filteredIndices=SnapshotUtils.filterIndices(snapshot.indices(),request.indices(),request.indicesOptions());
    MetaData metaDataIn=repository.readSnapshotMetaData(snapshotId,snapshot,filteredIndices);
    final MetaData metaData;
    if (snapshot.version().before(Version.V_2_0_0_beta1)) {
      metaData=MetaData.addDefaultUnitsIfNeeded(logger,metaDataIn);
    }
 else {
      metaData=metaDataIn;
    }
    validateSnapshotRestorable(snapshotId,snapshot);
    final Map<String,String> renamedIndices=renamedIndices(request,filteredIndices);
    clusterService.submitStateUpdateTask(request.cause(),new TimeoutClusterStateUpdateTask(){
      RestoreInfo restoreInfo=null;
      @Override public ClusterState execute(      ClusterState currentState){
        RestoreInProgress restoreInProgress=currentState.custom(RestoreInProgress.TYPE);
        if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {
          throw new ConcurrentSnapshotExecutionException(snapshotId,"Restore process is already running in this cluster");
        }
        ClusterState.Builder builder=ClusterState.builder(currentState);
        MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
        ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
        RoutingTable.Builder rtBuilder=RoutingTable.builder(currentState.routingTable());
        final ImmutableMap<ShardId,RestoreInProgress.ShardRestoreStatus> shards;
        Set<String> aliases=newHashSet();
        if (!renamedIndices.isEmpty()) {
          ImmutableMap.Builder<ShardId,RestoreInProgress.ShardRestoreStatus> shardsBuilder=ImmutableMap.builder();
          for (          Map.Entry<String,String> indexEntry : renamedIndices.entrySet()) {
            String index=indexEntry.getValue();
            boolean partial=checkPartial(index);
            RestoreSource restoreSource=new RestoreSource(snapshotId,snapshot.version(),index);
            String renamedIndex=indexEntry.getKey();
            IndexMetaData snapshotIndexMetaData=metaData.index(index);
            snapshotIndexMetaData=updateIndexSettings(snapshotIndexMetaData,request.indexSettings,request.ignoreIndexSettings);
            try {
              snapshotIndexMetaData=metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData);
            }
 catch (            Exception ex) {
              throw new SnapshotRestoreException(snapshotId,"cannot restore index [" + index + "] because it cannot be upgraded",ex);
            }
            IndexMetaData currentIndexMetaData=currentState.metaData().index(renamedIndex);
            IntSet ignoreShards=new IntHashSet();
            if (currentIndexMetaData == null) {
              createIndexService.validateIndexName(renamedIndex,currentState);
              createIndexService.validateIndexSettings(renamedIndex,snapshotIndexMetaData.settings());
              IndexMetaData.Builder indexMdBuilder=IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndex);
              indexMdBuilder.settings(Settings.settingsBuilder().put(snapshotIndexMetaData.settings()).put(IndexMetaData.SETTING_INDEX_UUID,Strings.randomBase64UUID()));
              if (!request.includeAliases() && !snapshotIndexMetaData.aliases().isEmpty()) {
                indexMdBuilder.removeAllAliases();
              }
 else {
                for (                ObjectCursor<String> alias : snapshotIndexMetaData.aliases().keys()) {
                  aliases.add(alias.value);
                }
              }
              IndexMetaData updatedIndexMetaData=indexMdBuilder.build();
              if (partial) {
                populateIgnoredShards(index,ignoreShards);
              }
              rtBuilder.addAsNewRestore(updatedIndexMetaData,restoreSource,ignoreShards);
              mdBuilder.put(updatedIndexMetaData,true);
            }
 else {
              validateExistingIndex(currentIndexMetaData,snapshotIndexMetaData,renamedIndex,partial);
              IndexMetaData.Builder indexMdBuilder=IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN);
              indexMdBuilder.version(Math.max(snapshotIndexMetaData.version(),currentIndexMetaData.version() + 1));
              if (!request.includeAliases()) {
                if (!snapshotIndexMetaData.aliases().isEmpty()) {
                  indexMdBuilder.removeAllAliases();
                }
                for (                ObjectCursor<AliasMetaData> alias : currentIndexMetaData.aliases().values()) {
                  indexMdBuilder.putAlias(alias.value);
                }
              }
 else {
                for (                ObjectCursor<String> alias : snapshotIndexMetaData.aliases().keys()) {
                  aliases.add(alias.value);
                }
              }
              indexMdBuilder.settings(Settings.settingsBuilder().put(snapshotIndexMetaData.settings()).put(IndexMetaData.SETTING_INDEX_UUID,currentIndexMetaData.indexUUID()));
              IndexMetaData updatedIndexMetaData=indexMdBuilder.index(renamedIndex).build();
              rtBuilder.addAsRestore(updatedIndexMetaData,restoreSource);
              blocks.removeIndexBlock(renamedIndex,INDEX_CLOSED_BLOCK);
              mdBuilder.put(updatedIndexMetaData,true);
            }
            for (int shard=0; shard < snapshotIndexMetaData.getNumberOfShards(); shard++) {
              if (!ignoreShards.contains(shard)) {
                shardsBuilder.put(new ShardId(renamedIndex,shard),new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().localNodeId()));
              }
 else {
                shardsBuilder.put(new ShardId(renamedIndex,shard),new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().localNodeId(),RestoreInProgress.State.FAILURE));
              }
            }
          }
          shards=shardsBuilder.build();
          RestoreInProgress.Entry restoreEntry=new RestoreInProgress.Entry(snapshotId,RestoreInProgress.State.INIT,ImmutableList.copyOf(renamedIndices.keySet()),shards);
          builder.putCustom(RestoreInProgress.TYPE,new RestoreInProgress(restoreEntry));
        }
 else {
          shards=ImmutableMap.of();
        }
        checkAliasNameConflicts(renamedIndices,aliases);
        restoreGlobalStateIfRequested(mdBuilder);
        if (completed(shards)) {
          restoreInfo=new RestoreInfo(request.name(),ImmutableList.copyOf(renamedIndices.keySet()),shards.size(),shards.size() - failedShards(shards));
        }
        ClusterState updatedState=builder.metaData(mdBuilder).blocks(blocks).routingTable(rtBuilder).build();
        RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder(updatedState).routingTable(rtBuilder).build());
        return ClusterState.builder(updatedState).routingResult(routingResult).build();
      }
      private void checkAliasNameConflicts(      Map<String,String> renamedIndices,      Set<String> aliases){
        for (        Map.Entry<String,String> renamedIndex : renamedIndices.entrySet()) {
          if (aliases.contains(renamedIndex.getKey())) {
            throw new SnapshotRestoreException(snapshotId,"cannot rename index [" + renamedIndex.getValue() + "] into ["+ renamedIndex.getKey()+ "] because of conflict with an alias with the same name");
          }
        }
      }
      private void populateIgnoredShards(      String index,      IntSet ignoreShards){
        for (        SnapshotShardFailure failure : snapshot.shardFailures()) {
          if (index.equals(failure.index())) {
            ignoreShards.add(failure.shardId());
          }
        }
      }
      private boolean checkPartial(      String index){
        if (failed(snapshot,index)) {
          if (request.partial()) {
            return true;
          }
 else {
            throw new SnapshotRestoreException(snapshotId,"index [" + index + "] wasn't fully snapshotted - cannot restore");
          }
        }
 else {
          return false;
        }
      }
      private void validateExistingIndex(      IndexMetaData currentIndexMetaData,      IndexMetaData snapshotIndexMetaData,      String renamedIndex,      boolean partial){
        if (currentIndexMetaData.state() != IndexMetaData.State.CLOSE) {
          throw new SnapshotRestoreException(snapshotId,"cannot restore index [" + renamedIndex + "] because it's open");
        }
        if (partial) {
          throw new SnapshotRestoreException(snapshotId,"cannot restore partial index [" + renamedIndex + "] because such index already exists");
        }
        if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {
          throw new SnapshotRestoreException(snapshotId,"cannot restore index [" + renamedIndex + "] with ["+ currentIndexMetaData.getNumberOfShards()+ "] shard from snapshot with ["+ snapshotIndexMetaData.getNumberOfShards()+ "] shards");
        }
      }
      /** 
 * Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and
 * merging them with settings in changeSettings.
 */
      private IndexMetaData updateIndexSettings(      IndexMetaData indexMetaData,      Settings changeSettings,      String[] ignoreSettings){
        if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {
          return indexMetaData;
        }
        Settings normalizedChangeSettings=Settings.settingsBuilder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build();
        IndexMetaData.Builder builder=IndexMetaData.builder(indexMetaData);
        Map<String,String> settingsMap=newHashMap(indexMetaData.settings().getAsMap());
        List<String> simpleMatchPatterns=newArrayList();
        for (        String ignoredSetting : ignoreSettings) {
          if (!Regex.isSimpleMatchPattern(ignoredSetting)) {
            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {
              throw new SnapshotRestoreException(snapshotId,"cannot remove setting [" + ignoredSetting + "] on restore");
            }
 else {
              settingsMap.remove(ignoredSetting);
            }
          }
 else {
            simpleMatchPatterns.add(ignoredSetting);
          }
        }
        if (!simpleMatchPatterns.isEmpty()) {
          String[] removePatterns=simpleMatchPatterns.toArray(new String[simpleMatchPatterns.size()]);
          Iterator<Map.Entry<String,String>> iterator=settingsMap.entrySet().iterator();
          while (iterator.hasNext()) {
            Map.Entry<String,String> entry=iterator.next();
            if (UNREMOVABLE_SETTINGS.contains(entry.getKey()) == false) {
              if (Regex.simpleMatch(removePatterns,entry.getKey())) {
                iterator.remove();
              }
            }
          }
        }
        for (        Map.Entry<String,String> entry : normalizedChangeSettings.getAsMap().entrySet()) {
          if (UNMODIFIABLE_SETTINGS.contains(entry.getKey())) {
            throw new SnapshotRestoreException(snapshotId,"cannot modify setting [" + entry.getKey() + "] on restore");
          }
 else {
            settingsMap.put(entry.getKey(),entry.getValue());
          }
        }
        return builder.settings(Settings.builder().put(settingsMap)).build();
      }
      private void restoreGlobalStateIfRequested(      MetaData.Builder mdBuilder){
        if (request.includeGlobalState()) {
          if (metaData.persistentSettings() != null) {
            boolean changed=false;
            Settings.Builder persistentSettings=Settings.settingsBuilder().put();
            for (            Map.Entry<String,String> entry : metaData.persistentSettings().getAsMap().entrySet()) {
              if (dynamicSettings.isDynamicOrLoggingSetting(entry.getKey())) {
                String error=dynamicSettings.validateDynamicSetting(entry.getKey(),entry.getValue());
                if (error == null) {
                  persistentSettings.put(entry.getKey(),entry.getValue());
                  changed=true;
                }
 else {
                  logger.warn("ignoring persistent setting [{}], [{}]",entry.getKey(),error);
                }
              }
 else {
                logger.warn("ignoring persistent setting [{}], not dynamically updateable",entry.getKey());
              }
            }
            if (changed) {
              mdBuilder.persistentSettings(persistentSettings.build());
            }
          }
          if (metaData.templates() != null) {
            for (            ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {
              mdBuilder.put(cursor.value);
            }
          }
          if (metaData.customs() != null) {
            for (            ObjectObjectCursor<String,MetaData.Custom> cursor : metaData.customs()) {
              if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {
                mdBuilder.putCustom(cursor.key,cursor.value);
              }
            }
          }
        }
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.warn("[{}] failed to restore snapshot",t,snapshotId);
        listener.onFailure(t);
      }
      @Override public TimeValue timeout(){
        return request.masterNodeTimeout();
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        listener.onResponse(restoreInfo);
      }
    }
);
  }
 catch (  Throwable e) {
    logger.warn("[{}][{}] failed to restore snapshot",e,request.repository(),request.name());
    listener.onFailure(e);
  }
}
