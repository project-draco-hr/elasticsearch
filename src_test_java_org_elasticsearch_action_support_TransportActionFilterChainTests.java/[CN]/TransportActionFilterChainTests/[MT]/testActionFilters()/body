{
  int numFilters=randomInt(10);
  Set<Integer> orders=new HashSet<>(numFilters);
  while (orders.size() < numFilters) {
    orders.add(randomInt(10));
  }
  Set<ActionFilter> filters=new HashSet<>();
  for (  Integer order : orders) {
    filters.add(new TestFilter(order,randomFrom(Operation.values())));
  }
  String actionName=randomAsciiOfLength(randomInt(30));
  ActionFilters actionFilters=new ActionFilters(filters);
  TransportAction<TestRequest,TestResponse> transportAction=new TransportAction<TestRequest,TestResponse>(ImmutableSettings.EMPTY,actionName,null,actionFilters){
    @Override protected void doExecute(    TestRequest request,    ActionListener<TestResponse> listener){
      listener.onResponse(new TestResponse());
    }
  }
;
  ArrayList<ActionFilter> actionFiltersByOrder=Lists.newArrayList(filters);
  Collections.sort(actionFiltersByOrder,new Comparator<ActionFilter>(){
    @Override public int compare(    ActionFilter o1,    ActionFilter o2){
      return Integer.compare(o1.order(),o2.order());
    }
  }
);
  List<ActionFilter> expectedActionFilters=Lists.newArrayList();
  boolean errorExpected=false;
  for (  ActionFilter filter : actionFiltersByOrder) {
    TestFilter testFilter=(TestFilter)filter;
    expectedActionFilters.add(testFilter);
    if (testFilter.callback == Operation.LISTENER_FAILURE) {
      errorExpected=true;
    }
    if (!(testFilter.callback == Operation.CONTINUE_PROCESSING)) {
      break;
    }
  }
  PlainListenableActionFuture<TestResponse> future=new PlainListenableActionFuture<>(false,null);
  transportAction.execute(new TestRequest(),future);
  try {
    assertThat(future.get(),notNullValue());
    assertThat("shouldn't get here if an error is expected",errorExpected,equalTo(false));
  }
 catch (  Throwable t) {
    assertThat("shouldn't get here if an error is not expected " + t.getMessage(),errorExpected,equalTo(true));
  }
  List<TestFilter> testFiltersByLastExecution=Lists.newArrayList();
  for (  ActionFilter actionFilter : actionFilters.filters()) {
    testFiltersByLastExecution.add((TestFilter)actionFilter);
  }
  Collections.sort(testFiltersByLastExecution,new Comparator<TestFilter>(){
    @Override public int compare(    TestFilter o1,    TestFilter o2){
      return Long.compare(o1.lastExecution,o2.lastExecution);
    }
  }
);
  ArrayList<TestFilter> finalTestFilters=Lists.newArrayList();
  for (  ActionFilter filter : testFiltersByLastExecution) {
    TestFilter testFilter=(TestFilter)filter;
    finalTestFilters.add(testFilter);
    if (!(testFilter.callback == Operation.CONTINUE_PROCESSING)) {
      break;
    }
  }
  assertThat(finalTestFilters.size(),equalTo(expectedActionFilters.size()));
  for (int i=0; i < finalTestFilters.size(); i++) {
    TestFilter testFilter=finalTestFilters.get(i);
    assertThat(testFilter,equalTo(expectedActionFilters.get(i)));
    assertThat(testFilter.runs.get(),equalTo(1));
    assertThat(testFilter.lastActionName,equalTo(actionName));
  }
}
