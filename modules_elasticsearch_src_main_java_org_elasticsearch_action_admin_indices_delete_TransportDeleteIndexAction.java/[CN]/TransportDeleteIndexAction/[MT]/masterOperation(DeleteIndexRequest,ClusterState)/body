{
  final AtomicReference<DeleteIndexResponse> responseRef=new AtomicReference<DeleteIndexResponse>();
  final AtomicReference<Throwable> failureRef=new AtomicReference<Throwable>();
  final CountDownLatch latch=new CountDownLatch(request.indices().length);
  for (  final String index : request.indices()) {
    deleteIndexService.deleteIndex(new MetaDataDeleteIndexService.Request(index).timeout(request.timeout()),new MetaDataDeleteIndexService.Listener(){
      @Override public void onResponse(      MetaDataDeleteIndexService.Response response){
        responseRef.set(new DeleteIndexResponse(response.acknowledged()));
        IndexMetaData percolatorMetaData=state.metaData().index(PercolatorService.INDEX_NAME);
        if (percolatorMetaData != null && percolatorMetaData.mappings().containsKey(index)) {
          deleteMappingAction.execute(new DeleteMappingRequest(PercolatorService.INDEX_NAME).type(index),new ActionListener<DeleteMappingResponse>(){
            @Override public void onResponse(            DeleteMappingResponse deleteMappingResponse){
              latch.countDown();
            }
            @Override public void onFailure(            Throwable e){
              latch.countDown();
            }
          }
);
        }
 else {
          latch.countDown();
        }
      }
      @Override public void onFailure(      Throwable t){
        failureRef.set(t);
        latch.countDown();
      }
    }
);
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    failureRef.set(e);
  }
  if (failureRef.get() != null) {
    if (failureRef.get() instanceof ElasticSearchException) {
      throw (ElasticSearchException)failureRef.get();
    }
 else {
      throw new ElasticSearchException(failureRef.get().getMessage(),failureRef.get());
    }
  }
  return responseRef.get();
}
