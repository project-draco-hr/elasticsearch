{
  final InternalIndexShard shard=(InternalIndexShard)indicesService.indexServiceSafe(request.shardId().index().name()).shardSafe(request.shardId().id());
  logger.trace("[{}][{}] starting recovery to {}, mark_as_relocated {}",request.shardId().index().name(),request.shardId().id(),request.targetNode(),request.markAsRelocated());
  final RecoveryResponse response=new RecoveryResponse();
  shard.recover(new Engine.RecoveryHandler(){
    @Override public void phase1(    final SnapshotIndexCommit snapshot) throws ElasticSearchException {
      long totalSize=0;
      long existingTotalSize=0;
      try {
        StopWatch stopWatch=new StopWatch().start();
        for (        String name : snapshot.getFiles()) {
          StoreFileMetaData md=shard.store().metaData(name);
          boolean useExisting=false;
          if (request.existingFiles().containsKey(name)) {
            if (!name.startsWith("segments") && md.isSame(request.existingFiles().get(name))) {
              response.phase1ExistingFileNames.add(name);
              response.phase1ExistingFileSizes.add(md.length());
              existingTotalSize+=md.length();
              useExisting=true;
              if (logger.isTraceEnabled()) {
                logger.trace("[{}][{}] recovery [phase1] to {}: not recovering [{}], exists in local store and has checksum [{}], size [{}]",request.shardId().index().name(),request.shardId().id(),request.targetNode(),name,md.checksum(),md.length());
              }
            }
          }
          if (!useExisting) {
            if (request.existingFiles().containsKey(name)) {
              logger.trace("[{}][{}] recovery [phase1] to {}: recovering [{}], exists in local store, but is different: remote [{}], local [{}]",request.shardId().index().name(),request.shardId().id(),request.targetNode(),name,request.existingFiles().get(name),md);
            }
 else {
              logger.trace("[{}][{}] recovery [phase1] to {}: recovering [{}], does not exists in remote",request.shardId().index().name(),request.shardId().id(),request.targetNode(),name);
            }
            response.phase1FileNames.add(name);
            response.phase1FileSizes.add(md.length());
            totalSize+=md.length();
          }
        }
        response.phase1TotalSize=totalSize;
        response.phase1ExistingTotalSize=existingTotalSize;
        logger.trace("[{}][{}] recovery [phase1] to {}: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]",request.shardId().index().name(),request.shardId().id(),request.targetNode(),response.phase1FileNames.size(),new ByteSizeValue(totalSize),response.phase1ExistingFileNames.size(),new ByteSizeValue(existingTotalSize));
        RecoveryFilesInfoRequest recoveryInfoFilesRequest=new RecoveryFilesInfoRequest(request.shardId(),response.phase1FileNames,response.phase1FileSizes,response.phase1ExistingFileNames,response.phase1ExistingFileSizes,response.phase1TotalSize,response.phase1ExistingTotalSize);
        transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.FILES_INFO,recoveryInfoFilesRequest,VoidTransportResponseHandler.INSTANCE).txGet();
        final CountDownLatch latch=new CountDownLatch(response.phase1FileNames.size());
        final AtomicReference<Exception> lastException=new AtomicReference<Exception>();
        for (        final String name : response.phase1FileNames) {
          threadPool.cached().execute(new Runnable(){
            @Override public void run(){
              IndexInput indexInput=null;
              try {
                final int BUFFER_SIZE=(int)fileChunkSize.bytes();
                byte[] buf=new byte[BUFFER_SIZE];
                StoreFileMetaData md=shard.store().metaData(name);
                indexInput=snapshot.getDirectory().openInput(name);
                long len=indexInput.length();
                long readCount=0;
                while (readCount < len) {
                  if (shard.state() == IndexShardState.CLOSED) {
                    throw new IndexShardClosedException(shard.shardId());
                  }
                  int toRead=readCount + BUFFER_SIZE > len ? (int)(len - readCount) : BUFFER_SIZE;
                  long position=indexInput.getFilePointer();
                  indexInput.readBytes(buf,0,toRead,false);
                  transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.FILE_CHUNK,new RecoveryFileChunkRequest(request.shardId(),name,position,len,md.checksum(),buf,toRead),TransportRequestOptions.options().withCompress(compress),VoidTransportResponseHandler.INSTANCE).txGet();
                  readCount+=toRead;
                }
                indexInput.close();
              }
 catch (              Exception e) {
                lastException.set(e);
              }
 finally {
                if (indexInput != null) {
                  try {
                    indexInput.close();
                  }
 catch (                  IOException e) {
                  }
                }
                latch.countDown();
              }
            }
          }
);
        }
        latch.await();
        if (lastException.get() != null) {
          throw lastException.get();
        }
        Set<String> snapshotFiles=Sets.newHashSet(snapshot.getFiles());
        transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.CLEAN_FILES,new RecoveryCleanFilesRequest(shard.shardId(),snapshotFiles),VoidTransportResponseHandler.INSTANCE).txGet();
        stopWatch.stop();
        logger.trace("[{}][{}] recovery [phase1] to {}: took [{}]",request.shardId().index().name(),request.shardId().id(),request.targetNode(),stopWatch.totalTime());
        response.phase1Time=stopWatch.totalTime().millis();
      }
 catch (      Throwable e) {
        throw new RecoverFilesRecoveryException(request.shardId(),response.phase1FileNames.size(),new ByteSizeValue(totalSize),e);
      }
    }
    @Override public void phase2(    Translog.Snapshot snapshot) throws ElasticSearchException {
      if (shard.state() == IndexShardState.CLOSED) {
        throw new IndexShardClosedException(request.shardId());
      }
      logger.trace("[{}][{}] recovery [phase2] to {}: sending transaction log operations",request.shardId().index().name(),request.shardId().id(),request.targetNode());
      StopWatch stopWatch=new StopWatch().start();
      transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.PREPARE_TRANSLOG,new RecoveryPrepareForTranslogOperationsRequest(request.shardId()),VoidTransportResponseHandler.INSTANCE).txGet();
      int totalOperations=sendSnapshot(snapshot);
      stopWatch.stop();
      logger.trace("[{}][{}] recovery [phase2] to {}: took [{}]",request.shardId().index().name(),request.shardId().id(),request.targetNode(),stopWatch.totalTime());
      response.phase2Time=stopWatch.totalTime().millis();
      response.phase2Operations=totalOperations;
    }
    @Override public void phase3(    Translog.Snapshot snapshot) throws ElasticSearchException {
      if (shard.state() == IndexShardState.CLOSED) {
        throw new IndexShardClosedException(request.shardId());
      }
      logger.trace("[{}][{}] recovery [phase3] to {}: sending transaction log operations",request.shardId().index().name(),request.shardId().id(),request.targetNode());
      StopWatch stopWatch=new StopWatch().start();
      int totalOperations=sendSnapshot(snapshot);
      transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.FINALIZE,new RecoveryFinalizeRecoveryRequest(request.shardId()),VoidTransportResponseHandler.INSTANCE).txGet();
      if (request.markAsRelocated()) {
        try {
          shard.relocated();
        }
 catch (        IllegalIndexShardStateException e) {
        }
      }
      stopWatch.stop();
      logger.trace("[{}][{}] recovery [phase3] to {}: took [{}]",request.shardId().index().name(),request.shardId().id(),request.targetNode(),stopWatch.totalTime());
      response.phase3Time=stopWatch.totalTime().millis();
      response.phase3Operations=totalOperations;
    }
    private int sendSnapshot(    Translog.Snapshot snapshot) throws ElasticSearchException {
      int counter=0;
      int totalOperations=0;
      List<Translog.Operation> operations=Lists.newArrayList();
      while (snapshot.hasNext()) {
        if (shard.state() == IndexShardState.CLOSED) {
          throw new IndexShardClosedException(request.shardId());
        }
        operations.add(snapshot.next());
        totalOperations++;
        if (++counter == translogBatchSize) {
          RecoveryTranslogOperationsRequest translogOperationsRequest=new RecoveryTranslogOperationsRequest(request.shardId(),operations);
          transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.TRANSLOG_OPS,translogOperationsRequest,TransportRequestOptions.options().withCompress(compress),VoidTransportResponseHandler.INSTANCE).txGet();
          counter=0;
          operations=Lists.newArrayList();
        }
      }
      if (!operations.isEmpty()) {
        RecoveryTranslogOperationsRequest translogOperationsRequest=new RecoveryTranslogOperationsRequest(request.shardId(),operations);
        transportService.submitRequest(request.targetNode(),RecoveryTarget.Actions.TRANSLOG_OPS,translogOperationsRequest,TransportRequestOptions.options().withCompress(compress),VoidTransportResponseHandler.INSTANCE).txGet();
      }
      return totalOperations;
    }
  }
);
  return response;
}
