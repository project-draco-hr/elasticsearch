{
  String currentFieldName=null;
  String field=null;
  float boostFactor=1;
  FieldValueFactorFunction.Modifier modifier=FieldValueFactorFunction.Modifier.NONE;
  XContentParser.Token token;
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentFieldName=parser.currentName();
    }
 else     if (token.isValue()) {
      if ("field".equals(currentFieldName)) {
        field=parser.text();
      }
 else       if ("factor".equals(currentFieldName)) {
        boostFactor=parser.floatValue();
      }
 else       if ("modifier".equals(currentFieldName)) {
        modifier=FieldValueFactorFunction.Modifier.valueOf(parser.text().toUpperCase(Locale.ROOT));
      }
 else {
        throw new QueryParsingException(parseContext.index(),NAMES[0] + " query does not support [" + currentFieldName+ "]");
      }
    }
 else     if ("factor".equals(currentFieldName) && (token == XContentParser.Token.START_ARRAY || token == XContentParser.Token.START_OBJECT)) {
      throw new QueryParsingException(parseContext.index(),"[" + NAMES[0] + "] field 'factor' does not support lists or objects");
    }
  }
  if (field == null) {
    throw new QueryParsingException(parseContext.index(),"[" + NAMES[0] + "] required field 'field' missing");
  }
  SearchContext searchContext=SearchContext.current();
  FieldMapper mapper=searchContext.mapperService().smartNameFieldMapper(field);
  if (mapper == null) {
    throw new ElasticsearchException("Unable to find a field mapper for field [" + field + "]");
  }
  return new FieldValueFactorFunction(field,boostFactor,modifier,(IndexNumericFieldData)searchContext.fieldData().getForField(mapper));
}
