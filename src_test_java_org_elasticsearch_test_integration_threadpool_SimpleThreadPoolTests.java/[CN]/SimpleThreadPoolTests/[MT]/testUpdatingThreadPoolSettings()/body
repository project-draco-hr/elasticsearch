{
  assertThat(((ThreadPoolExecutor)threadPool.executor(Names.SEARCH)).getKeepAliveTime(TimeUnit.MINUTES),equalTo(5L));
  client1.admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.keep_alive","10m").build()).execute().actionGet();
  assertThat(((ThreadPoolExecutor)threadPool.executor(Names.SEARCH)).getKeepAliveTime(TimeUnit.MINUTES),equalTo(10L));
  final CyclicBarrier barrier=new CyclicBarrier(2);
  Executor oldExecutor=threadPool.executor(Names.SEARCH);
  threadPool.executor(Names.SEARCH).execute(new Runnable(){
    @Override public void run(){
      try {
        barrier.await();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
catch (      BrokenBarrierException ex) {
      }
    }
  }
);
  client1.admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.type","fixed").build()).execute().actionGet();
  assertThat(threadPool.executor(Names.SEARCH),not(sameInstance(oldExecutor)));
  assertThat(((ThreadPoolExecutor)oldExecutor).isShutdown(),equalTo(true));
  assertThat(((ThreadPoolExecutor)oldExecutor).isTerminating(),equalTo(true));
  assertThat(((ThreadPoolExecutor)oldExecutor).isTerminated(),equalTo(false));
  barrier.await();
  threadPool.executor(Names.SEARCH).execute(new Runnable(){
    @Override public void run(){
      try {
        barrier.await();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
catch (      BrokenBarrierException ex) {
      }
    }
  }
);
  client1.admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.type","fixed").build()).execute().actionGet();
  barrier.await();
  NodesInfoResponse nodesInfoResponse=client2.admin().cluster().prepareNodesInfo().all().execute().actionGet();
  for (int i=0; i < 2; i++) {
    NodeInfo nodeInfo=nodesInfoResponse.nodes()[i];
    boolean found=false;
    for (    ThreadPool.Info info : nodeInfo.getThreadPool()) {
      if (info.name().equals(Names.SEARCH)) {
        assertThat(info.type(),equalTo("fixed"));
        assertThat(info.rejectSetting(),equalTo("abort"));
        assertThat(info.queueType(),equalTo("linked"));
        found=true;
        break;
      }
    }
    assertThat(found,equalTo(true));
    Map<String,Object> poolMap=getPoolSettingsThroughJson(nodeInfo.getThreadPool(),Names.SEARCH);
    assertThat(poolMap.get("reject_policy").toString(),equalTo("abort"));
    assertThat(poolMap.get("queue_type").toString(),equalTo("linked"));
  }
  client1.admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put("threadpool.search.type","blocking").put("threadpool.search.wait_time","10s").put("threadpool.search.keep_alive","15s").put("threadpool.search.capacity","100").build()).execute().actionGet();
  nodesInfoResponse=client2.admin().cluster().prepareNodesInfo().all().execute().actionGet();
  for (int i=0; i < 2; i++) {
    NodeInfo nodeInfo=nodesInfoResponse.nodes()[i];
    boolean found=false;
    for (    ThreadPool.Info info : nodeInfo.getThreadPool()) {
      if (info.name().equals(Names.SEARCH)) {
        assertThat(info.type(),equalTo("blocking"));
        assertThat(info.capacity().singles(),equalTo(100L));
        assertThat(info.waitTime().seconds(),equalTo(10L));
        assertThat(info.keepAlive().seconds(),equalTo(15L));
        found=true;
        break;
      }
    }
    assertThat(found,equalTo(true));
    Map<String,Object> poolMap=getPoolSettingsThroughJson(nodeInfo.getThreadPool(),Names.SEARCH);
    assertThat(poolMap.get("capacity").toString(),equalTo("100"));
    assertThat(poolMap.get("wait_time").toString(),equalTo("10s"));
    assertThat(poolMap.get("keep_alive").toString(),equalTo("15s"));
  }
}
