{
  if (request.indices() == null || request.indices().length == 0) {
    throw new IllegalArgumentException("Index name is required");
  }
  final String indicesAsString=Arrays.toString(request.indices());
  clusterService.submitStateUpdateTask("close-indices " + indicesAsString,new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT,request,listener){
    @Override protected ClusterStateUpdateResponse newResponse(    boolean acknowledged){
      return new ClusterStateUpdateResponse(acknowledged);
    }
    @Override public ClusterState execute(    ClusterState currentState){
      Set<String> indicesToClose=new HashSet<>();
      for (      String index : request.indices()) {
        IndexMetaData indexMetaData=currentState.metaData().index(index);
        if (indexMetaData == null) {
          throw new IndexNotFoundException(index);
        }
        if (indexMetaData.getState() != IndexMetaData.State.CLOSE) {
          indicesToClose.add(index);
        }
      }
      if (indicesToClose.isEmpty()) {
        return currentState;
      }
      RestoreInProgress restore=currentState.custom(RestoreInProgress.TYPE);
      if (restore != null) {
        Set<String> indicesToFail=null;
        for (        RestoreInProgress.Entry entry : restore.entries()) {
          for (          ObjectObjectCursor<ShardId,RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {
            if (!shard.value.state().completed()) {
              if (indicesToClose.contains(shard.key.getIndexName())) {
                if (indicesToFail == null) {
                  indicesToFail=new HashSet<>();
                }
                indicesToFail.add(shard.key.getIndexName());
              }
            }
          }
        }
        if (indicesToFail != null) {
          throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail);
        }
      }
      logger.info("closing indices [{}]",indicesAsString);
      MetaData.Builder mdBuilder=MetaData.builder(currentState.metaData());
      ClusterBlocks.Builder blocksBuilder=ClusterBlocks.builder().blocks(currentState.blocks());
      for (      String index : indicesToClose) {
        mdBuilder.put(IndexMetaData.builder(currentState.metaData().index(index)).state(IndexMetaData.State.CLOSE));
        blocksBuilder.addIndexBlock(index,INDEX_CLOSED_BLOCK);
      }
      ClusterState updatedState=ClusterState.builder(currentState).metaData(mdBuilder).blocks(blocksBuilder).build();
      RoutingTable.Builder rtBuilder=RoutingTable.builder(currentState.routingTable());
      for (      String index : indicesToClose) {
        rtBuilder.remove(index);
      }
      RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder(updatedState).routingTable(rtBuilder.build()).build(),"indices closed [" + indicesAsString + "]");
      return ClusterState.builder(updatedState).routingResult(routingResult).build();
    }
  }
);
}
