{
  logger.info("create 2 indices, test1 on t1, and test2 on t2");
  cluster().client().admin().indices().prepareCreate("test1").get();
  cluster2.client().admin().indices().prepareCreate("test2").get();
  logger.info("wait till test1 and test2 exists in the tribe node state");
  awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object o){
      ClusterState tribeState=tribeNode.client().admin().cluster().prepareState().setLocal(true).get().getState();
      return tribeState.getMetaData().hasIndex("test1") && tribeState.getMetaData().hasIndex("test2") && tribeState.getRoutingTable().hasIndex("test1")&& tribeState.getRoutingTable().hasIndex("test2");
    }
  }
);
  logger.info("wait till tribe has the same nodes as the 2 clusters");
  awaitSameNodeCounts();
  assertThat(tribeClient.admin().cluster().prepareHealth().setLocal(true).setWaitForGreenStatus().get().getStatus(),equalTo(ClusterHealthStatus.GREEN));
  logger.info("create 2 docs through the tribe node");
  tribeClient.prepareIndex("test1","type1","1").setSource("field1","value1").get();
  tribeClient.prepareIndex("test2","type1","1").setSource("field1","value1").get();
  tribeClient.admin().indices().prepareRefresh().get();
  logger.info("verify they are there");
  assertHitCount(tribeClient.prepareCount().get(),2l);
  assertHitCount(tribeClient.prepareSearch().get(),2l);
  awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object o){
      ClusterState tribeState=tribeNode.client().admin().cluster().prepareState().setLocal(true).get().getState();
      return tribeState.getMetaData().index("test1").mapping("type1") != null && tribeState.getMetaData().index("test2").mapping("type2") != null;
    }
  }
);
  logger.info("write to another type");
  tribeClient.prepareIndex("test1","type2","1").setSource("field1","value1").get();
  tribeClient.prepareIndex("test2","type2","1").setSource("field1","value1").get();
  tribeClient.admin().indices().prepareRefresh().get();
  logger.info("verify they are there");
  assertHitCount(tribeClient.prepareCount().get(),4l);
  assertHitCount(tribeClient.prepareSearch().get(),4l);
  awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object o){
      ClusterState tribeState=tribeNode.client().admin().cluster().prepareState().setLocal(true).get().getState();
      return tribeState.getMetaData().index("test1").mapping("type1") != null && tribeState.getMetaData().index("test1").mapping("type2") != null && tribeState.getMetaData().index("test2").mapping("type1") != null && tribeState.getMetaData().index("test2").mapping("type2") != null;
    }
  }
);
  logger.info("make sure master level write operations fail... (we don't really have a master)");
  try {
    tribeClient.admin().indices().prepareCreate("tribe_index").setMasterNodeTimeout("10ms").get();
    fail();
  }
 catch (  MasterNotDiscoveredException e) {
  }
  logger.info("delete an index, and make sure its reflected");
  cluster2.client().admin().indices().prepareDelete("test2").get();
  awaitBusy(new Predicate<Object>(){
    @Override public boolean apply(    Object o){
      ClusterState tribeState=tribeNode.client().admin().cluster().prepareState().setLocal(true).get().getState();
      return tribeState.getMetaData().hasIndex("test1") && !tribeState.getMetaData().hasIndex("test2") && tribeState.getRoutingTable().hasIndex("test1")&& !tribeState.getRoutingTable().hasIndex("test2");
    }
  }
);
  logger.info("stop a node, make sure its reflected");
  cluster2.stopRandomNode();
  awaitSameNodeCounts();
}
