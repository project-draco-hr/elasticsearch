{
  assumeTrue("test runs only when at least a type is registered",getCurrentTypes().length > 0);
  String query="{\n" + "    \"range\" : {\n" + "        \"" + DATE_FIELD_NAME + "\" : {\n"+ "            \"gte\": \"01/01/2012\",\n"+ "            \"lt\": \"2030\",\n"+ "            \"format\": \"dd/MM/yyyy||yyyy\"\n"+ "        }\n"+ "    }\n"+ "}";
  Query parsedQuery=parseQuery(query).toQuery(createShardContext()).rewrite(null);
  assertThat(parsedQuery,instanceOf(NumericRangeQuery.class));
  DateTime min=DateTime.parse("2012-01-01T00:00:00.000+00");
  assertThat(((NumericRangeQuery)parsedQuery).getMin().longValue(),is(min.getMillis()));
  DateTime max=DateTime.parse("2030-01-01T00:00:00.000+00");
  assertThat(((NumericRangeQuery)parsedQuery).getMax().longValue(),is(max.getMillis()));
  query="{\n" + "    \"range\" : {\n" + "        \"" + DATE_FIELD_NAME + "\" : {\n"+ "            \"gte\": \"01/01/2012\",\n"+ "            \"lt\": \"2030\",\n"+ "            \"format\": \"yyyy\"\n"+ "        }\n"+ "    }\n"+ "}";
  try {
    parseQuery(query).toQuery(createShardContext()).rewrite(null);
    fail("A Range Query with a specific format but with an unexpected date should raise a ParsingException");
  }
 catch (  ElasticsearchParseException e) {
  }
}
