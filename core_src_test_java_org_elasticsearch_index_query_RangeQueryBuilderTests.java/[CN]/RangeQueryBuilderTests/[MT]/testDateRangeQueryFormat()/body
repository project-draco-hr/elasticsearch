{
  assumeTrue("test runs only when at least a type is registered",getCurrentTypes().length > 0);
  String query="{\n" + "    \"range\" : {\n" + "        \"" + DATE_FIELD_NAME + "\" : {\n"+ "            \"gte\": \"01/01/2012\",\n"+ "            \"lt\": \"2030\",\n"+ "            \"format\": \"dd/MM/yyyy||yyyy\"\n"+ "        }\n"+ "    }\n"+ "}";
  Query parsedQuery=parseQuery(query).toQuery(createShardContext()).rewrite(null);
  assertThat(parsedQuery,either(instanceOf(LegacyNumericRangeQuery.class)).or(instanceOf(PointRangeQuery.class)));
  if (parsedQuery instanceof LegacyNumericRangeQuery) {
    DateTime min=DateTime.parse("2012-01-01T00:00:00.000+00");
    assertThat(((LegacyNumericRangeQuery)parsedQuery).getMin().longValue(),is(min.getMillis()));
    DateTime max=DateTime.parse("2030-01-01T00:00:00.000+00");
    assertThat(((LegacyNumericRangeQuery)parsedQuery).getMax().longValue(),is(max.getMillis()));
  }
 else {
    assertEquals(LongPoint.newRangeQuery(DATE_FIELD_NAME,DateTime.parse("2012-01-01T00:00:00.000+00").getMillis(),DateTime.parse("2030-01-01T00:00:00.000+00").getMillis() - 1),parsedQuery);
  }
  query="{\n" + "    \"range\" : {\n" + "        \"" + DATE_FIELD_NAME + "\" : {\n"+ "            \"gte\": \"01/01/2012\",\n"+ "            \"lt\": \"2030\",\n"+ "            \"format\": \"yyyy\"\n"+ "        }\n"+ "    }\n"+ "}";
  try {
    parseQuery(query).toQuery(createShardContext()).rewrite(null);
    fail("A Range Query with a specific format but with an unexpected date should raise a ParsingException");
  }
 catch (  ElasticsearchParseException e) {
  }
}
