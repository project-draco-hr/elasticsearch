{
  clusterService.submitStateUpdateTask("delete-index [" + request.index + "]",new ProcessedClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      try {
        RoutingTable routingTable=currentState.routingTable();
        if (!routingTable.hasIndex(request.index)) {
          listener.onFailure(new IndexMissingException(new Index(request.index)));
          return currentState;
        }
        logger.info("[{}] deleting index",request.index);
        RoutingTable.Builder routingTableBuilder=new RoutingTable.Builder();
        for (        IndexRoutingTable indexRoutingTable : currentState.routingTable().indicesRouting().values()) {
          if (!indexRoutingTable.index().equals(request.index)) {
            routingTableBuilder.add(indexRoutingTable);
          }
        }
        MetaData newMetaData=newMetaDataBuilder().metaData(currentState.metaData()).remove(request.index).build();
        RoutingAllocation.Result routingResult=shardsAllocation.reroute(newClusterStateBuilder().state(currentState).routingTable(routingTableBuilder).metaData(newMetaData).build());
        ClusterBlocks blocks=ClusterBlocks.builder().blocks(currentState.blocks()).removeIndexBlocks(request.index).build();
        return newClusterStateBuilder().state(currentState).routingResult(routingResult).metaData(newMetaData).blocks(blocks).build();
      }
 catch (      Exception e) {
        listener.onFailure(e);
        return currentState;
      }
    }
    @Override public void clusterStateProcessed(    ClusterState clusterState){
      listener.onResponse(new Response(true));
    }
  }
);
}
