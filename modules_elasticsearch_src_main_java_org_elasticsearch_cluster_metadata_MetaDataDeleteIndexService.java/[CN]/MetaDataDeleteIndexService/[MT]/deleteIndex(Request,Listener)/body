{
  clusterService.submitStateUpdateTask("delete-index [" + request.index + "]",new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      final DeleteIndexListener listener=new DeleteIndexListener(request,userListener);
      try {
        RoutingTable routingTable=currentState.routingTable();
        if (!routingTable.hasIndex(request.index)) {
          listener.onFailure(new IndexMissingException(new Index(request.index)));
          return currentState;
        }
        logger.info("[{}] deleting index",request.index);
        RoutingTable.Builder routingTableBuilder=new RoutingTable.Builder();
        for (        IndexRoutingTable indexRoutingTable : currentState.routingTable().indicesRouting().values()) {
          if (!indexRoutingTable.index().equals(request.index)) {
            routingTableBuilder.add(indexRoutingTable);
          }
        }
        MetaData newMetaData=newMetaDataBuilder().metaData(currentState.metaData()).remove(request.index).build();
        RoutingAllocation.Result routingResult=shardsAllocation.reroute(newClusterStateBuilder().state(currentState).routingTable(routingTableBuilder).metaData(newMetaData).build());
        ClusterBlocks blocks=ClusterBlocks.builder().blocks(currentState.blocks()).removeIndexBlocks(request.index).build();
        Set<String> allocatedNodes=Sets.newHashSet();
        for (        IndexShardRoutingTable indexShardRoutingTable : currentState.routingTable().index(request.index)) {
          for (          ShardRouting shardRouting : indexShardRoutingTable) {
            if (shardRouting.currentNodeId() != null) {
              allocatedNodes.add(shardRouting.currentNodeId());
            }
            if (shardRouting.relocatingNodeId() != null) {
              allocatedNodes.add(shardRouting.relocatingNodeId());
            }
          }
        }
        if (allocatedNodes.isEmpty()) {
          listener.onResponse(new Response(true));
        }
 else {
          final AtomicInteger counter=new AtomicInteger(allocatedNodes.size());
          final NodeIndexDeletedAction.Listener nodeIndexDeleteListener=new NodeIndexDeletedAction.Listener(){
            @Override public void onNodeIndexDeleted(            String index,            String nodeId){
              if (index.equals(request.index)) {
                if (counter.decrementAndGet() == 0) {
                  listener.onResponse(new Response(true));
                  nodeIndexDeletedAction.remove(this);
                }
              }
            }
          }
;
          nodeIndexDeletedAction.add(nodeIndexDeleteListener);
          threadPool.schedule(request.timeout,ThreadPool.Names.SAME,new Runnable(){
            @Override public void run(){
              listener.onResponse(new Response(false));
              nodeIndexDeletedAction.remove(nodeIndexDeleteListener);
            }
          }
);
        }
        return newClusterStateBuilder().state(currentState).routingResult(routingResult).metaData(newMetaData).blocks(blocks).build();
      }
 catch (      Exception e) {
        listener.onFailure(e);
        return currentState;
      }
    }
  }
);
}
