{
  ClusterState clusterState=clusterService.state();
  clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.READ);
  final AtomicArray<MultiTermVectorsItemResponse> responses=new AtomicArray<>(request.requests.size());
  Map<ShardId,MultiTermVectorsShardRequest> shardRequests=new HashMap<>();
  for (int i=0; i < request.requests.size(); i++) {
    TermVectorRequest termVectorRequest=request.requests.get(i);
    termVectorRequest.routing(clusterState.metaData().resolveIndexRouting(termVectorRequest.routing(),termVectorRequest.index()));
    if (!clusterState.metaData().hasConcreteIndex(termVectorRequest.index())) {
      responses.set(i,new MultiTermVectorsItemResponse(null,new MultiTermVectorsResponse.Failure(termVectorRequest.index(),termVectorRequest.type(),termVectorRequest.id(),"[" + termVectorRequest.index() + "] missing")));
      continue;
    }
    String concreteSingleIndex=clusterState.metaData().concreteSingleIndex(termVectorRequest.index(),termVectorRequest.indicesOptions());
    if (termVectorRequest.routing() == null && clusterState.getMetaData().routingRequired(concreteSingleIndex,termVectorRequest.type())) {
      responses.set(i,new MultiTermVectorsItemResponse(null,new MultiTermVectorsResponse.Failure(concreteSingleIndex,termVectorRequest.type(),termVectorRequest.id(),"routing is required for [" + concreteSingleIndex + "]/["+ termVectorRequest.type()+ "]/["+ termVectorRequest.id()+ "]")));
      continue;
    }
    ShardId shardId=clusterService.operationRouting().getShards(clusterState,concreteSingleIndex,termVectorRequest.type(),termVectorRequest.id(),termVectorRequest.routing(),null).shardId();
    MultiTermVectorsShardRequest shardRequest=shardRequests.get(shardId);
    if (shardRequest == null) {
      shardRequest=new MultiTermVectorsShardRequest(request,shardId.index().name(),shardId.id());
      shardRequest.preference(request.preference);
      shardRequests.put(shardId,shardRequest);
    }
    shardRequest.add(i,termVectorRequest);
  }
  if (shardRequests.size() == 0) {
    listener.onResponse(new MultiTermVectorsResponse(responses.toArray(new MultiTermVectorsItemResponse[responses.length()])));
  }
  final AtomicInteger counter=new AtomicInteger(shardRequests.size());
  for (  final MultiTermVectorsShardRequest shardRequest : shardRequests.values()) {
    shardAction.execute(shardRequest,new ActionListener<MultiTermVectorsShardResponse>(){
      @Override public void onResponse(      MultiTermVectorsShardResponse response){
        for (int i=0; i < response.locations.size(); i++) {
          responses.set(response.locations.get(i),new MultiTermVectorsItemResponse(response.responses.get(i),response.failures.get(i)));
        }
        if (counter.decrementAndGet() == 0) {
          finishHim();
        }
      }
      @Override public void onFailure(      Throwable e){
        String message=ExceptionsHelper.detailedMessage(e);
        for (int i=0; i < shardRequest.locations.size(); i++) {
          TermVectorRequest termVectorRequest=shardRequest.requests.get(i);
          responses.set(shardRequest.locations.get(i),new MultiTermVectorsItemResponse(null,new MultiTermVectorsResponse.Failure(shardRequest.index(),termVectorRequest.type(),termVectorRequest.id(),message)));
        }
        if (counter.decrementAndGet() == 0) {
          finishHim();
        }
      }
      private void finishHim(){
        listener.onResponse(new MultiTermVectorsResponse(responses.toArray(new MultiTermVectorsItemResponse[responses.length()])));
      }
    }
);
  }
}
