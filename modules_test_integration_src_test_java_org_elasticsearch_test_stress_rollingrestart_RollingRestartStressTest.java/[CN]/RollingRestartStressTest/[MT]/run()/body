{
  Node[] nodes=new Node[numberOfNodes];
  for (int i=0; i < nodes.length; i++) {
    nodes[i]=NodeBuilder.nodeBuilder().settings(settings).node();
  }
  client=NodeBuilder.nodeBuilder().settings(settings).client(true).node();
  logger.info("********** [START] INDEXING INITIAL DOCS");
  for (long i=0; i < initialNumberOfDocs; i++) {
    indexDoc();
  }
  logger.info("********** [DONE ] INDEXING INITIAL DOCS");
  Indexer[] indexerThreads=new Indexer[indexers];
  for (int i=0; i < indexerThreads.length; i++) {
    indexerThreads[i]=new Indexer();
  }
  for (int i=0; i < indexerThreads.length; i++) {
    indexerThreads[i].start();
  }
  long testStart=System.currentTimeMillis();
  int nodeIndex=0;
  while (true) {
    File nodeData=((InternalNode)nodes[nodeIndex]).injector().getInstance(NodeEnvironment.class).nodeDataLocation();
    nodes[nodeIndex].close();
    if (clearNodeData) {
      FileSystemUtils.deleteRecursively(nodeData);
    }
    try {
      ClusterHealthResponse clusterHealth=client.client().admin().cluster().prepareHealth().setWaitForGreenStatus().setWaitForNodes(Integer.toString(numberOfNodes + 0)).setWaitForRelocatingShards(0).setTimeout("10m").execute().actionGet();
      if (clusterHealth.timedOut()) {
        logger.warn("timed out waiting for green status....");
      }
    }
 catch (    Exception e) {
      logger.warn("failed to execute cluster health....");
    }
    nodes[nodeIndex]=NodeBuilder.nodeBuilder().settings(settings).node();
    try {
      ClusterHealthResponse clusterHealth=client.client().admin().cluster().prepareHealth().setWaitForGreenStatus().setWaitForNodes(Integer.toString(numberOfNodes + 1)).setWaitForRelocatingShards(0).setTimeout("10m").execute().actionGet();
      if (clusterHealth.timedOut()) {
        logger.warn("timed out waiting for green status....");
      }
    }
 catch (    Exception e) {
      logger.warn("failed to execute cluster health....");
    }
    if (++nodeIndex == nodes.length) {
      nodeIndex=0;
    }
    if ((System.currentTimeMillis() - testStart) > period.millis()) {
      logger.info("test finished");
      break;
    }
  }
  for (int i=0; i < indexerThreads.length; i++) {
    indexerThreads[i].close=true;
  }
  Thread.sleep(indexerThrottle.millis() + 10000);
  for (int i=0; i < indexerThreads.length; i++) {
    if (!indexerThreads[i].closed) {
      logger.warn("thread not closed!");
    }
  }
  client.client().admin().indices().prepareRefresh().execute().actionGet();
  IndicesStatusResponse status=client.client().admin().indices().prepareStatus("test").execute().actionGet();
  for (  IndexShardStatus shardStatus : status.index("test")) {
    ShardStatus shard=shardStatus.shards()[0];
    logger.info("shard [{}], docs [{}]",shard.shardId(),shard.getDocs().numDocs());
    for (    ShardStatus shardStatu : shardStatus) {
      if (shard.docs().numDocs() != shardStatu.docs().numDocs()) {
        logger.warn("shard doc number does not match!, got {} and {}",shard.docs().numDocs(),shardStatu.docs().numDocs());
      }
    }
  }
  for (int i=0; i < (nodes.length * 5); i++) {
    CountResponse count=client.client().prepareCount().setQuery(matchAllQuery()).execute().actionGet();
    logger.info("indexed [{}], count [{}], [{}]",count.count(),indexCounter.get(),count.count() == indexCounter.get() ? "OK" : "FAIL");
    if (count.count() != indexCounter.get()) {
      logger.warn("count does not match!");
    }
  }
  client.close();
  for (  Node node : nodes) {
    node.close();
  }
}
