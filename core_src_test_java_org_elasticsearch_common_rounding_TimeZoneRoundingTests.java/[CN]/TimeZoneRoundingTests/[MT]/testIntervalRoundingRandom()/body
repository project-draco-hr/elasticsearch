{
  for (int i=0; i < 1000; i++) {
    TimeUnit unit=randomFrom(new TimeUnit[]{TimeUnit.MINUTES,TimeUnit.HOURS,TimeUnit.DAYS});
    long interval=unit.toMillis(randomIntBetween(1,365));
    DateTimeZone tz=randomDateTimeZone();
    TimeZoneRounding rounding=new TimeZoneRounding.TimeIntervalRounding(interval,tz);
    long date=Math.abs(randomLong() % (2 * (long)10e11));
    try {
      final long roundedDate=rounding.round(date);
      final long nextRoundingValue=rounding.nextRoundingValue(roundedDate);
      assertThat("Rounding should be idempotent",roundedDate,equalTo(rounding.round(roundedDate)));
      assertThat("Rounded value smaller or equal than unrounded",roundedDate,lessThanOrEqualTo(date));
      assertThat("Values smaller than rounded value should round further down",rounding.round(roundedDate - 1),lessThan(roundedDate));
      if (tz.isFixed()) {
        assertThat("NextRounding value should be greater than date",nextRoundingValue,greaterThan(roundedDate));
        assertThat("NextRounding value should be interval from rounded value",nextRoundingValue - roundedDate,equalTo(interval));
        assertThat("NextRounding value should be a rounded date",nextRoundingValue,equalTo(rounding.round(nextRoundingValue)));
      }
    }
 catch (    AssertionError e) {
      logger.error("Rounding error at {}, timezone {}, interval: {},",new DateTime(date,tz),tz,interval);
      throw e;
    }
  }
}
