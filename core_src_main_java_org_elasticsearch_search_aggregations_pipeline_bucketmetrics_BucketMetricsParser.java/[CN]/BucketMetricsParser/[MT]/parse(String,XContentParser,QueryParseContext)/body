{
  XContentParser.Token token;
  String currentFieldName=null;
  String[] bucketsPaths=null;
  String format=null;
  GapPolicy gapPolicy=null;
  Map<String,Object> leftover=new HashMap<>(5);
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentFieldName=parser.currentName();
    }
 else     if (token == XContentParser.Token.VALUE_STRING) {
      if (context.parseFieldMatcher().match(currentFieldName,FORMAT)) {
        format=parser.text();
      }
 else       if (context.parseFieldMatcher().match(currentFieldName,BUCKETS_PATH)) {
        bucketsPaths=new String[]{parser.text()};
      }
 else       if (context.parseFieldMatcher().match(currentFieldName,GAP_POLICY)) {
        gapPolicy=GapPolicy.parse(context,parser.text(),parser.getTokenLocation());
      }
 else {
        leftover.put(currentFieldName,parser.text());
      }
    }
 else     if (token == XContentParser.Token.START_ARRAY) {
      if (context.parseFieldMatcher().match(currentFieldName,BUCKETS_PATH)) {
        List<String> paths=new ArrayList<>();
        while ((token=parser.nextToken()) != XContentParser.Token.END_ARRAY) {
          String path=parser.text();
          paths.add(path);
        }
        bucketsPaths=paths.toArray(new String[paths.size()]);
      }
 else {
        leftover.put(currentFieldName,parser.list());
      }
    }
 else {
      leftover.put(currentFieldName,parser.objectText());
    }
  }
  if (bucketsPaths == null) {
    throw new ParsingException(parser.getTokenLocation(),"Missing required field [" + BUCKETS_PATH.getPreferredName() + "] for aggregation ["+ pipelineAggregatorName+ "]");
  }
  BucketMetricsFactory factory=null;
  try {
    factory=buildFactory(pipelineAggregatorName,bucketsPaths[0],leftover);
    if (format != null) {
      factory.format(format);
    }
    if (gapPolicy != null) {
      factory.gapPolicy(gapPolicy);
    }
  }
 catch (  ParseException exception) {
    throw new ParsingException(parser.getTokenLocation(),"Could not parse settings for aggregation [" + pipelineAggregatorName + "].",exception);
  }
  if (leftover.size() > 0) {
    throw new ParsingException(parser.getTokenLocation(),"Unexpected tokens " + leftover.keySet() + " in ["+ pipelineAggregatorName+ "].");
  }
  assert(factory != null);
  return factory;
}
