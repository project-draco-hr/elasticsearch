{
  final Bootstrap bootstrap=new Bootstrap();
  if (TCP_BLOCKING_CLIENT.get(settings)) {
    bootstrap.group(new OioEventLoopGroup(1,daemonThreadFactory(settings,TRANSPORT_CLIENT_WORKER_THREAD_NAME_PREFIX)));
    bootstrap.channel(OioSocketChannel.class);
  }
 else {
    bootstrap.group(new NioEventLoopGroup(workerCount,daemonThreadFactory(settings,TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX)));
    bootstrap.channel(NioSocketChannel.class);
  }
  bootstrap.handler(new ChannelInitializer<SocketChannel>(){
    @Override protected void initChannel(    SocketChannel ch) throws Exception {
      ch.pipeline().addLast("size",new Netty4SizeHeaderFrameDecoder());
      ch.pipeline().addLast("dispatcher",new Netty4MessageChannelHandler(Netty4Transport.this,".client"));
    }
  }
);
  bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS,Math.toIntExact(connectTimeout.millis()));
  bootstrap.option(ChannelOption.TCP_NODELAY,TCP_NO_DELAY.get(settings));
  bootstrap.option(ChannelOption.SO_KEEPALIVE,TCP_KEEP_ALIVE.get(settings));
  final ByteSizeValue tcpSendBufferSize=TCP_SEND_BUFFER_SIZE.get(settings);
  if (tcpSendBufferSize.bytes() > 0) {
    bootstrap.option(ChannelOption.SO_SNDBUF,Math.toIntExact(tcpSendBufferSize.bytes()));
  }
  final ByteSizeValue tcpReceiveBufferSize=TCP_RECEIVE_BUFFER_SIZE.get(settings);
  if (tcpReceiveBufferSize.bytes() > 0) {
    bootstrap.option(ChannelOption.SO_RCVBUF,Math.toIntExact(tcpReceiveBufferSize.bytes()));
  }
  bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR,recvByteBufAllocator);
  final boolean reuseAddress=TCP_REUSE_ADDRESS.get(settings);
  bootstrap.option(ChannelOption.SO_REUSEADDR,reuseAddress);
  bootstrap.validate();
  return bootstrap;
}
