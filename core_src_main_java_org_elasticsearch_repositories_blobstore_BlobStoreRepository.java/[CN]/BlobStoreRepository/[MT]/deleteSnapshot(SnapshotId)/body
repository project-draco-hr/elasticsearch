{
  if (isReadOnly()) {
    throw new RepositoryException(metadata.name(),"cannot delete snapshot from a readonly repository");
  }
  final RepositoryData repositoryData=getRepositoryData();
  List<String> indices=Collections.emptyList();
  SnapshotInfo snapshot=null;
  try {
    snapshot=getSnapshotInfo(snapshotId);
    indices=snapshot.indices();
  }
 catch (  SnapshotMissingException ex) {
    throw ex;
  }
catch (  IllegalStateException|SnapshotException|ElasticsearchParseException ex) {
    logger.warn("cannot read snapshot file [{}]",ex,snapshotId);
  }
  MetaData metaData=null;
  try {
    if (snapshot != null) {
      metaData=readSnapshotMetaData(snapshotId,snapshot.version(),repositoryData.resolveIndices(indices),true);
    }
 else {
      metaData=readSnapshotMetaData(snapshotId,null,repositoryData.resolveIndices(indices),true);
    }
  }
 catch (  IOException|SnapshotException ex) {
    logger.warn("cannot read metadata for snapshot [{}]",ex,snapshotId);
  }
  try {
    final RepositoryData updatedRepositoryData=repositoryData.removeSnapshot(snapshotId);
    writeIndexGen(updatedRepositoryData);
    safeSnapshotBlobDelete(snapshot,snapshotId.getUUID());
    safeGlobalMetaDataBlobDelete(snapshot,snapshotId.getUUID());
    for (    String index : indices) {
      final IndexId indexId=repositoryData.resolveIndexId(index);
      BlobPath indexPath=basePath().add("indices").add(indexId.getId());
      BlobContainer indexMetaDataBlobContainer=blobStore().blobContainer(indexPath);
      try {
        indexMetaDataFormat(snapshot.version()).delete(indexMetaDataBlobContainer,snapshotId.getUUID());
      }
 catch (      IOException ex) {
        logger.warn("[{}] failed to delete metadata for index [{}]",ex,snapshotId,index);
      }
      if (metaData != null) {
        IndexMetaData indexMetaData=metaData.index(index);
        if (indexMetaData != null) {
          for (int shardId=0; shardId < indexMetaData.getNumberOfShards(); shardId++) {
            try {
              delete(snapshotId,snapshot.version(),indexId,new ShardId(indexMetaData.getIndex(),shardId));
            }
 catch (            SnapshotException ex) {
              logger.warn("[{}] failed to delete shard data for shard [{}][{}]",ex,snapshotId,index,shardId);
            }
          }
        }
      }
    }
    final Collection<IndexId> indicesToCleanUp=Sets.newHashSet(repositoryData.getIndices().values());
    indicesToCleanUp.removeAll(updatedRepositoryData.getIndices().values());
    final BlobContainer indicesBlobContainer=blobStore().blobContainer(basePath().add("indices"));
    for (    final IndexId indexId : indicesToCleanUp) {
      try {
        indicesBlobContainer.deleteBlob(indexId.getId());
      }
 catch (      DirectoryNotEmptyException dnee) {
        logger.debug("[{}] index [{}] no longer part of any snapshots in the repository, but failed to clean up " + "its index folder due to the directory not being empty.",dnee,metadata.name(),indexId);
      }
catch (      IOException ioe) {
        logger.debug("[{}] index [{}] no longer part of any snapshots in the repository, but failed to clean up " + "its index folder.",ioe,metadata.name(),indexId);
      }
    }
  }
 catch (  IOException ex) {
    throw new RepositoryException(metadata.name(),"failed to update snapshot in repository",ex);
  }
}
