{
  TObjectIntHashMap<HashedBytesRef> facets=aggregators[0].facets();
  long totalMissing=0;
  long total=0;
  for (  StaticAggregatorValueProc aggregator : aggregators) {
    totalMissing+=aggregator.missing();
    total+=aggregator.total();
  }
  if (facets.isEmpty()) {
    CacheRecycler.pushObjectIntMap(facets);
    return new InternalStringTermsFacet(facetName,comparatorType,size,ImmutableList.<InternalStringTermsFacet.TermEntry>of(),totalMissing,total);
  }
 else {
    if (size < EntryPriorityQueue.LIMIT) {
      EntryPriorityQueue ordered=new EntryPriorityQueue(size,comparatorType.comparator());
      for (TObjectIntIterator<HashedBytesRef> it=facets.iterator(); it.hasNext(); ) {
        it.advance();
        ordered.insertWithOverflow(new InternalStringTermsFacet.TermEntry(it.key().bytes,it.value()));
      }
      InternalStringTermsFacet.TermEntry[] list=new InternalStringTermsFacet.TermEntry[ordered.size()];
      for (int i=ordered.size() - 1; i >= 0; i--) {
        list[i]=((InternalStringTermsFacet.TermEntry)ordered.pop());
      }
      CacheRecycler.pushObjectIntMap(facets);
      return new InternalStringTermsFacet(facetName,comparatorType,size,Arrays.asList(list),totalMissing,total);
    }
 else {
      BoundedTreeSet<InternalStringTermsFacet.TermEntry> ordered=new BoundedTreeSet<InternalStringTermsFacet.TermEntry>(comparatorType.comparator(),size);
      for (TObjectIntIterator<HashedBytesRef> it=facets.iterator(); it.hasNext(); ) {
        it.advance();
        ordered.add(new InternalStringTermsFacet.TermEntry(it.key().bytes,it.value()));
      }
      CacheRecycler.pushObjectIntMap(facets);
      return new InternalStringTermsFacet(facetName,comparatorType,size,ordered,totalMissing,total);
    }
  }
}
