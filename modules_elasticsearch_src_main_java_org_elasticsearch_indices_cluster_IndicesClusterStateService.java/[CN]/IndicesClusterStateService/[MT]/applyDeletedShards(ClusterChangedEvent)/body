{
  RoutingNode routingNodes=event.state().readOnlyRoutingNodes().nodesToShards().get(event.state().nodes().localNodeId());
  if (routingNodes == null) {
    return;
  }
  for (  final String index : indicesService.indices()) {
    IndexMetaData indexMetaData=event.state().metaData().index(index);
    if (indexMetaData != null) {
      Set<Integer> newShardIds=newHashSet();
      for (      final ShardRouting shardRouting : routingNodes) {
        if (shardRouting.index().equals(index)) {
          newShardIds.add(shardRouting.id());
        }
      }
      final IndexService indexService=indicesService.indexService(index);
      if (indexService == null) {
        continue;
      }
      for (      Integer existingShardId : indexService.shardIds()) {
        if (!newShardIds.contains(existingShardId)) {
          if (indexMetaData.state() == IndexMetaData.State.CLOSE) {
            if (logger.isDebugEnabled()) {
              logger.debug("[{}][{}] removing shard (index is closed)",index,existingShardId);
            }
            indexService.removeShard(existingShardId,"removing shard (index is closed)");
          }
 else {
            if (logger.isDebugEnabled()) {
              logger.debug("[{}][{}] cleaning shard locally (not allocated)",index,existingShardId);
            }
            indexService.cleanShard(existingShardId,"cleaning shard locally (not allocated)");
          }
        }
      }
    }
  }
}
