{
  if (!indicesService.changesAllowed())   return;
  MetaData metaData=event.state().metaData();
  for (  final IndexMetaData indexMetaData : metaData) {
    if (!indicesService.hasIndex(indexMetaData.index())) {
      if (logger.isDebugEnabled()) {
        logger.debug("Index [{}]: Creating",indexMetaData.index());
      }
      indicesService.createIndex(indexMetaData.index(),indexMetaData.settings(),event.state().nodes().localNode().id());
      threadPool.execute(new Runnable(){
        @Override public void run(){
          nodeIndexCreatedAction.nodeIndexCreated(indexMetaData.index(),event.state().nodes().localNodeId());
        }
      }
);
    }
  }
  RoutingTable routingTable=event.state().routingTable();
  RoutingNode routingNodes=event.state().routingNodes().nodesToShards().get(event.state().nodes().localNodeId());
  if (routingNodes != null) {
    applyShards(routingNodes,routingTable,event.state().nodes());
  }
  for (  IndexMetaData indexMetaData : metaData) {
    if (!indicesService.hasIndex(indexMetaData.index())) {
      continue;
    }
    String index=indexMetaData.index();
    IndexService indexService=indicesService.indexServiceSafe(index);
    MapperService mapperService=indexService.mapperService();
    ImmutableMap<String,String> mappings=indexMetaData.mappings();
    for (    Map.Entry<String,String> entry : mappings.entrySet()) {
      String mappingType=entry.getKey();
      String mappingSource=entry.getValue();
      try {
        if (!mapperService.hasMapping(mappingType)) {
          if (logger.isDebugEnabled()) {
            logger.debug("Index [" + index + "] Adding mapping ["+ mappingType+ "], source ["+ mappingSource+ "]");
          }
          mapperService.add(mappingType,mappingSource);
        }
 else {
          DocumentMapper existingMapper=mapperService.documentMapper(mappingType);
          if (!mappingSource.equals(existingMapper.mappingSource())) {
            if (logger.isDebugEnabled()) {
              logger.debug("Index [" + index + "] Updating mapping ["+ mappingType+ "], source ["+ mappingSource+ "]");
            }
            mapperService.add(mappingType,mappingSource);
          }
        }
      }
 catch (      Exception e) {
        logger.warn("Failed to add mapping [" + mappingType + "], source ["+ mappingSource+ "]",e);
      }
    }
  }
  for (  final String index : indicesService.indices()) {
    if (metaData.index(index) == null) {
      if (logger.isDebugEnabled()) {
        logger.debug("Index [{}]: Deleting",index);
      }
      indicesService.deleteIndex(index);
      threadPool.execute(new Runnable(){
        @Override public void run(){
          nodeIndexDeletedAction.nodeIndexDeleted(index,event.state().nodes().localNodeId());
        }
      }
);
    }
 else     if (routingNodes != null) {
      Set<Integer> newShardIds=newHashSet();
      for (      final ShardRouting shardRouting : routingNodes) {
        if (shardRouting.index().equals(index)) {
          newShardIds.add(shardRouting.id());
        }
      }
      final IndexService indexService=indicesService.indexService(index);
      if (indexService == null) {
        continue;
      }
      for (      Integer existingShardId : indexService.shardIds()) {
        if (!newShardIds.contains(existingShardId)) {
          if (logger.isDebugEnabled()) {
            logger.debug("Index [{}]: Deleting shard [{}]",index,existingShardId);
          }
          indexService.deleteShard(existingShardId);
        }
      }
    }
  }
}
