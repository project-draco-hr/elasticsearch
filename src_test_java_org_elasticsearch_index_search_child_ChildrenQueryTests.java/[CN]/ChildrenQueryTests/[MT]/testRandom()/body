{
  Directory directory=newDirectory();
  final Random r=random();
  final IndexWriterConfig iwc=LuceneTestCase.newIndexWriterConfig(r,new MockAnalyzer(r)).setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH).setRAMBufferSizeMB(scaledRandomIntBetween(16,64));
  RandomIndexWriter indexWriter=new RandomIndexWriter(r,directory,iwc);
  int numUniqueChildValues=scaledRandomIntBetween(100,2000);
  String[] childValues=new String[numUniqueChildValues];
  for (int i=0; i < numUniqueChildValues; i++) {
    childValues[i]=Integer.toString(i);
  }
  IntOpenHashSet filteredOrDeletedDocs=new IntOpenHashSet();
  int childDocId=0;
  int numParentDocs=scaledRandomIntBetween(1,numUniqueChildValues);
  ObjectObjectOpenHashMap<String,NavigableMap<String,FloatArrayList>> childValueToParentIds=new ObjectObjectOpenHashMap<>();
  for (int parentDocId=0; parentDocId < numParentDocs; parentDocId++) {
    boolean markParentAsDeleted=rarely();
    boolean filterMe=rarely();
    String parent=Integer.toString(parentDocId);
    Document document=new Document();
    document.add(new StringField(UidFieldMapper.NAME,Uid.createUid("parent",parent),Field.Store.YES));
    document.add(new StringField(TypeFieldMapper.NAME,"parent",Field.Store.NO));
    if (markParentAsDeleted) {
      filteredOrDeletedDocs.add(parentDocId);
      document.add(new StringField("delete","me",Field.Store.NO));
    }
    if (filterMe) {
      filteredOrDeletedDocs.add(parentDocId);
      document.add(new StringField("filter","me",Field.Store.NO));
    }
    indexWriter.addDocument(document);
    int numChildDocs=scaledRandomIntBetween(0,100);
    for (int i=0; i < numChildDocs; i++) {
      boolean markChildAsDeleted=rarely();
      String childValue=childValues[random().nextInt(childValues.length)];
      document=new Document();
      document.add(new StringField(UidFieldMapper.NAME,Uid.createUid("child",Integer.toString(childDocId++)),Field.Store.NO));
      document.add(new StringField(TypeFieldMapper.NAME,"child",Field.Store.NO));
      document.add(new StringField(ParentFieldMapper.NAME,Uid.createUid("parent",parent),Field.Store.NO));
      document.add(new StringField("field1",childValue,Field.Store.NO));
      if (markChildAsDeleted) {
        document.add(new StringField("delete","me",Field.Store.NO));
      }
      indexWriter.addDocument(document);
      if (!markChildAsDeleted) {
        NavigableMap<String,FloatArrayList> parentIdToChildScores;
        if (childValueToParentIds.containsKey(childValue)) {
          parentIdToChildScores=childValueToParentIds.lget();
        }
 else {
          childValueToParentIds.put(childValue,parentIdToChildScores=new TreeMap<>());
        }
        if (!markParentAsDeleted && !filterMe) {
          FloatArrayList childScores=parentIdToChildScores.get(parent);
          if (childScores == null) {
            parentIdToChildScores.put(parent,childScores=new FloatArrayList());
          }
          childScores.add(1f);
        }
      }
    }
  }
  indexWriter.deleteDocuments(new Term("delete","me"));
  indexWriter.commit();
  IndexReader indexReader=DirectoryReader.open(directory);
  IndexSearcher searcher=new IndexSearcher(indexReader);
  Engine.Searcher engineSearcher=new Engine.SimpleSearcher(ChildrenQueryTests.class.getSimpleName(),searcher);
  ((TestSearchContext)SearchContext.current()).setSearcher(new ContextIndexSearcher(SearchContext.current(),engineSearcher));
  ParentFieldMapper parentFieldMapper=SearchContext.current().mapperService().documentMapper("child").parentFieldMapper();
  ParentChildIndexFieldData parentChildIndexFieldData=SearchContext.current().fieldData().getForField(parentFieldMapper);
  BitDocIdSetFilter parentFilter=wrap(new TermFilter(new Term(TypeFieldMapper.NAME,"parent")));
  Filter rawFilterMe=new NotFilter(new TermFilter(new Term("filter","me")));
  int max=numUniqueChildValues / 4;
  for (int i=0; i < max; i++) {
    Filter filterMe;
    if (random().nextBoolean()) {
      filterMe=SearchContext.current().filterCache().cache(rawFilterMe);
    }
 else {
      filterMe=rawFilterMe;
    }
    if (random().nextBoolean()) {
      final int numberOfUpdatableParents=numParentDocs - filteredOrDeletedDocs.size();
      int numberOfUpdates=RandomInts.randomIntBetween(random(),0,Math.min(numberOfUpdatableParents,TEST_NIGHTLY ? 25 : 5));
      for (int j=0; j < numberOfUpdates; j++) {
        int parentId;
        do {
          parentId=random().nextInt(numParentDocs);
        }
 while (filteredOrDeletedDocs.contains(parentId));
        String parentUid=Uid.createUid("parent",Integer.toString(parentId));
        indexWriter.deleteDocuments(new Term(UidFieldMapper.NAME,parentUid));
        Document document=new Document();
        document.add(new StringField(UidFieldMapper.NAME,parentUid,Field.Store.YES));
        document.add(new StringField(TypeFieldMapper.NAME,"parent",Field.Store.NO));
        indexWriter.addDocument(document);
      }
      indexReader.close();
      indexReader=DirectoryReader.open(indexWriter.w,true);
      searcher=new IndexSearcher(indexReader);
      engineSearcher=new Engine.SimpleSearcher(ChildrenConstantScoreQueryTests.class.getSimpleName(),searcher);
      ((TestSearchContext)SearchContext.current()).setSearcher(new ContextIndexSearcher(SearchContext.current(),engineSearcher));
    }
    String childValue=childValues[random().nextInt(numUniqueChildValues)];
    Query childQuery=new ConstantScoreQuery(new TermQuery(new Term("field1",childValue)));
    int shortCircuitParentDocSet=random().nextInt(numParentDocs);
    ScoreType scoreType=ScoreType.values()[random().nextInt(ScoreType.values().length)];
    BitDocIdSetFilter nonNestedDocsFilter=random().nextBoolean() ? wrap(NonNestedDocsFilter.INSTANCE) : null;
    int minChildren=random().nextInt(2) * scaledRandomIntBetween(0,110);
    int maxChildren=random().nextInt(2) * scaledRandomIntBetween(minChildren,110);
    Query query=new ChildrenQuery(parentChildIndexFieldData,"parent","child",parentFilter,childQuery,scoreType,minChildren,maxChildren,shortCircuitParentDocSet,nonNestedDocsFilter);
    query=new FilteredQuery(query,filterMe);
    BitSetCollector collector=new BitSetCollector(indexReader.maxDoc());
    int numHits=1 + random().nextInt(25);
    TopScoreDocCollector actualTopDocsCollector=TopScoreDocCollector.create(numHits,false);
    searcher.search(query,MultiCollector.wrap(collector,actualTopDocsCollector));
    FixedBitSet actualResult=collector.getResult();
    FixedBitSet expectedResult=new FixedBitSet(indexReader.maxDoc());
    MockScorer mockScorer=new MockScorer(scoreType);
    TopScoreDocCollector expectedTopDocsCollector=TopScoreDocCollector.create(numHits,false);
    expectedTopDocsCollector.setScorer(mockScorer);
    if (childValueToParentIds.containsKey(childValue)) {
      LeafReader slowLeafReader=SlowCompositeReaderWrapper.wrap(indexReader);
      Terms terms=slowLeafReader.terms(UidFieldMapper.NAME);
      if (terms != null) {
        NavigableMap<String,FloatArrayList> parentIdToChildScores=childValueToParentIds.lget();
        TermsEnum termsEnum=terms.iterator(null);
        DocsEnum docsEnum=null;
        for (        Map.Entry<String,FloatArrayList> entry : parentIdToChildScores.entrySet()) {
          int count=entry.getValue().elementsCount;
          if (count >= minChildren && (maxChildren == 0 || count <= maxChildren)) {
            TermsEnum.SeekStatus seekStatus=termsEnum.seekCeil(Uid.createUidAsBytes("parent",entry.getKey()));
            if (seekStatus == TermsEnum.SeekStatus.FOUND) {
              docsEnum=termsEnum.docs(slowLeafReader.getLiveDocs(),docsEnum,DocsEnum.FLAG_NONE);
              expectedResult.set(docsEnum.nextDoc());
              mockScorer.scores=entry.getValue();
              expectedTopDocsCollector.collect(docsEnum.docID());
            }
 else             if (seekStatus == TermsEnum.SeekStatus.END) {
              break;
            }
          }
        }
      }
    }
    assertBitSet(actualResult,expectedResult,searcher);
    assertTopDocs(actualTopDocsCollector.topDocs(),expectedTopDocsCollector.topDocs());
  }
  indexWriter.close();
  indexReader.close();
  directory.close();
}
