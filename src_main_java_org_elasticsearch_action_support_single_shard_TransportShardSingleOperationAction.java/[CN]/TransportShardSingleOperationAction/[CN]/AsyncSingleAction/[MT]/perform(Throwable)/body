{
  Throwable lastFailure=this.lastFailure;
  if (lastFailure == null || TransportActions.isReadOverrideException(currentFailure)) {
    lastFailure=currentFailure;
    this.lastFailure=currentFailure;
  }
  final ShardRouting shardRouting=shardIt.nextOrNull();
  if (shardRouting == null) {
    Throwable failure=lastFailure;
    if (failure == null) {
      failure=new NoShardAvailableActionException(shardIt.shardId(),"No shard available for [" + request + "]");
    }
 else {
      if (logger.isDebugEnabled()) {
        logger.debug("{}: failed to execute [{}]",failure,shardIt.shardId(),request);
      }
    }
    listener.onFailure(failure);
    return;
  }
  if (shardRouting.currentNodeId().equals(nodes.localNodeId())) {
    if (request.operationThreaded()) {
      request.beforeLocalFork();
      threadPool.executor(executor).execute(new Runnable(){
        @Override public void run(){
          try {
            Response response=shardOperation(request,shardRouting.id());
            listener.onResponse(response);
          }
 catch (          Throwable e) {
            onFailure(shardRouting,e);
          }
        }
      }
);
    }
 else {
      try {
        final Response response=shardOperation(request,shardRouting.id());
        listener.onResponse(response);
      }
 catch (      Throwable e) {
        onFailure(shardRouting,e);
      }
    }
  }
 else {
    DiscoveryNode node=nodes.get(shardRouting.currentNodeId());
    transportService.sendRequest(node,transportShardAction,new ShardSingleOperationRequest(request,shardRouting.id()),new BaseTransportResponseHandler<Response>(){
      @Override public Response newInstance(){
        return newResponse();
      }
      @Override public String executor(){
        return ThreadPool.Names.SAME;
      }
      @Override public void handleResponse(      final Response response){
        listener.onResponse(response);
      }
      @Override public void handleException(      TransportException exp){
        onFailure(shardRouting,exp);
      }
    }
);
  }
}
