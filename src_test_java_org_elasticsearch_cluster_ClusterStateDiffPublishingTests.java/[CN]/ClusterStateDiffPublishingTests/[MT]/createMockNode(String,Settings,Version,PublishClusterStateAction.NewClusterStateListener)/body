{
  MockTransportService service=buildTransportService(Settings.builder().put(settings).put("name",name,TransportService.SETTING_TRACE_LOG_INCLUDE,"",TransportService.SETTING_TRACE_LOG_EXCLUDE,"NOTHING").build(),version);
  DiscoveryNode discoveryNode=new DiscoveryNode(name,name,service.boundAddress().publishAddress(),ImmutableMap.<String,String>of(),version);
  MockDiscoveryNodesProvider nodesProvider=new MockDiscoveryNodesProvider(discoveryNode);
  PublishClusterStateAction action=buildPublishClusterStateAction(settings,service,nodesProvider,listener);
  MockNode node=new MockNode(discoveryNode,service,action,nodesProvider);
  nodesProvider.addNode(discoveryNode);
  final CountDownLatch latch=new CountDownLatch(nodes.size() * 2 + 1);
  TransportConnectionListener waitForConnection=new TransportConnectionListener(){
    @Override public void onNodeConnected(    DiscoveryNode node){
      latch.countDown();
    }
    @Override public void onNodeDisconnected(    DiscoveryNode node){
      fail("disconnect should not be called " + node);
    }
  }
;
  node.service.addConnectionListener(waitForConnection);
  for (  MockNode curNode : nodes.values()) {
    curNode.service.addConnectionListener(waitForConnection);
    curNode.connectTo(node.discoveryNode);
    node.connectTo(curNode.discoveryNode);
  }
  node.connectTo(node.discoveryNode);
  assertThat("failed to wait for all nodes to connect",latch.await(5,TimeUnit.SECONDS),equalTo(true));
  for (  MockNode curNode : nodes.values()) {
    curNode.service.removeConnectionListener(waitForConnection);
  }
  node.service.removeConnectionListener(waitForConnection);
  if (nodes.put(name,node) != null) {
    fail("Node with the name " + name + " already exist");
  }
  return node;
}
