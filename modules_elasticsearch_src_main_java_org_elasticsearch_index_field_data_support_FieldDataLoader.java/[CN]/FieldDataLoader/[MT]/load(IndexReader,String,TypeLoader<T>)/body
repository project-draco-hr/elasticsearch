{
  loader.init();
  field=StringHelper.intern(field);
  int[][] ordinals=new int[reader.maxDoc()][];
  int t=1;
  boolean multiValued=false;
  TermDocs termDocs=reader.termDocs();
  TermEnum termEnum=reader.terms(new Term(field));
  try {
    do {
      Term term=termEnum.term();
      if (term == null || term.field() != field)       break;
      loader.collectTerm(term.text());
      termDocs.seek(termEnum);
      while (termDocs.next()) {
        int doc=termDocs.doc();
        int[] ordinalPerDoc=ordinals[doc];
        if (ordinalPerDoc == null) {
          ordinalPerDoc=new int[1];
          ordinalPerDoc[0]=t;
          ordinals[doc]=ordinalPerDoc;
        }
 else {
          multiValued=true;
          ordinalPerDoc=Arrays.copyOf(ordinalPerDoc,ordinalPerDoc.length + 1);
          ordinalPerDoc[ordinalPerDoc.length - 1]=t;
          ordinals[doc]=ordinalPerDoc;
        }
      }
      t++;
    }
 while (termEnum.next());
  }
 catch (  RuntimeException e) {
    if (e.getClass().getName().endsWith("StopFillCacheException")) {
    }
 else {
      throw e;
    }
  }
 finally {
    termDocs.close();
    termEnum.close();
  }
  if (multiValued) {
    return loader.buildMultiValue(field,ordinals);
  }
 else {
    int[] sOrders=new int[reader.maxDoc()];
    for (int i=0; i < ordinals.length; i++) {
      if (ordinals[i] != null) {
        sOrders[i]=ordinals[i][0];
      }
    }
    return loader.buildSingleValue(field,sOrders);
  }
}
