{
  loader.init(options);
  field=StringHelper.intern(field);
  int[][] orders=new int[reader.maxDoc()][];
  int t=1;
  boolean multiValued=false;
  TermDocs termDocs=reader.termDocs();
  TermEnum termEnum=reader.terms(new Term(field));
  try {
    do {
      Term term=termEnum.term();
      if (term == null || term.field() != field)       break;
      loader.collectTerm(term.text());
      termDocs.seek(termEnum);
      int df=0;
      while (termDocs.next()) {
        df++;
        int doc=termDocs.doc();
        int[] orderPerDoc=orders[doc];
        if (orderPerDoc == null) {
          orderPerDoc=new int[1];
          orderPerDoc[0]=t;
          orders[doc]=orderPerDoc;
        }
 else {
          multiValued=true;
          orderPerDoc=Arrays.copyOf(orderPerDoc,orderPerDoc.length + 1);
          orderPerDoc[orderPerDoc.length - 1]=t;
          orders[doc]=orderPerDoc;
        }
      }
      if (options.hasFreqs()) {
        loader.collectFreq(df);
      }
      t++;
    }
 while (termEnum.next());
  }
 catch (  RuntimeException e) {
    if (e.getClass().getName().endsWith("StopFillCacheException")) {
    }
 else {
      throw e;
    }
  }
 finally {
    termDocs.close();
    termEnum.close();
  }
  if (multiValued) {
    return loader.buildMultiValue(field,orders);
  }
 else {
    int[] sOrders=new int[reader.maxDoc()];
    for (int i=0; i < orders.length; i++) {
      if (orders[i] != null) {
        sOrders[i]=orders[i][0];
      }
    }
    return loader.buildSingleValue(field,sOrders);
  }
}
