{
  List<InternalAggregation> aggregations=reduceContext.aggregations();
  if (aggregations.size() == 1) {
    AbstractHistogramBase<B> histo=(AbstractHistogramBase<B>)aggregations.get(0);
    if (minDocCount == 1) {
      for (      B bucket : histo.buckets) {
        ((Bucket)bucket).aggregations.reduce(reduceContext.cacheRecycler());
      }
      return histo;
    }
    CollectionUtil.introSort(histo.buckets,order.asc ? InternalOrder.KEY_ASC.comparator() : InternalOrder.KEY_DESC.comparator());
    List<B> list=order.asc ? histo.buckets : Lists.reverse(histo.buckets);
    HistogramBase.Bucket prevBucket=null;
    ListIterator<B> iter=list.listIterator();
    if (minDocCount == 0) {
      while (iter.hasNext()) {
        HistogramBase.Bucket nextBucket=list.get(iter.nextIndex());
        ((Bucket)nextBucket).aggregations.reduce(reduceContext.cacheRecycler());
        if (prevBucket != null) {
          long key=emptyBucketInfo.rounding.nextRoundingValue(prevBucket.getKey());
          while (key != nextBucket.getKey()) {
            iter.add(createBucket(key,0,emptyBucketInfo.subAggregations));
            key=emptyBucketInfo.rounding.nextRoundingValue(key);
          }
        }
        prevBucket=iter.next();
      }
    }
 else {
      while (iter.hasNext()) {
        Bucket bucket=(Bucket)iter.next();
        if (bucket.getDocCount() < minDocCount) {
          iter.remove();
        }
 else {
          bucket.aggregations.reduce(reduceContext.cacheRecycler());
        }
      }
    }
    if (order != InternalOrder.KEY_ASC && order != InternalOrder.KEY_DESC) {
      CollectionUtil.introSort(histo.buckets,order.comparator());
    }
    return histo;
  }
  AbstractHistogramBase reduced=(AbstractHistogramBase)aggregations.get(0);
  Recycler.V<LongObjectOpenHashMap<List<Bucket>>> bucketsByKey=reduceContext.cacheRecycler().longObjectMap(-1);
  for (  InternalAggregation aggregation : aggregations) {
    AbstractHistogramBase<B> histogram=(AbstractHistogramBase)aggregation;
    for (    B bucket : histogram.buckets) {
      List<Bucket> bucketList=bucketsByKey.v().get(((Bucket)bucket).key);
      if (bucketList == null) {
        bucketList=new ArrayList<Bucket>(aggregations.size());
        bucketsByKey.v().put(((Bucket)bucket).key,bucketList);
      }
      bucketList.add((Bucket)bucket);
    }
  }
  List<HistogramBase.Bucket> reducedBuckets=new ArrayList<HistogramBase.Bucket>(bucketsByKey.v().size());
  Object[] buckets=bucketsByKey.v().values;
  boolean[] allocated=bucketsByKey.v().allocated;
  for (int i=0; i < allocated.length; i++) {
    if (allocated[i]) {
      Bucket bucket=((List<Bucket>)buckets[i]).get(0).reduce(((List<Bucket>)buckets[i]),reduceContext.cacheRecycler());
      if (bucket.getDocCount() >= minDocCount) {
        reducedBuckets.add(bucket);
      }
    }
  }
  bucketsByKey.release();
  if (minDocCount == 0) {
    CollectionUtil.introSort(reducedBuckets,order.asc ? InternalOrder.KEY_ASC.comparator() : InternalOrder.KEY_DESC.comparator());
    List<HistogramBase.Bucket> list=order.asc ? reducedBuckets : Lists.reverse(reducedBuckets);
    HistogramBase.Bucket prevBucket=null;
    ListIterator<HistogramBase.Bucket> iter=list.listIterator();
    while (iter.hasNext()) {
      HistogramBase.Bucket nextBucket=list.get(iter.nextIndex());
      if (prevBucket != null) {
        long key=emptyBucketInfo.rounding.nextRoundingValue(prevBucket.getKey());
        while (key != nextBucket.getKey()) {
          iter.add(createBucket(key,0,emptyBucketInfo.subAggregations));
          key=emptyBucketInfo.rounding.nextRoundingValue(key);
        }
      }
      prevBucket=iter.next();
    }
    if (order != InternalOrder.KEY_ASC && order != InternalOrder.KEY_DESC) {
      CollectionUtil.introSort(reducedBuckets,order.comparator());
    }
  }
 else {
    CollectionUtil.introSort(reducedBuckets,order.comparator());
  }
  reduced.buckets=reducedBuckets;
  return reduced;
}
