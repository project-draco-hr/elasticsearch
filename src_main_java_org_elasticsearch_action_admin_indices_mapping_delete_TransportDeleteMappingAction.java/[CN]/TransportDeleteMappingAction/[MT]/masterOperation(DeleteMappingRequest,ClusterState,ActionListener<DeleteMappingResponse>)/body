{
  final String[] concreteIndices=state.metaData().concreteIndices(request.indicesOptions(),request.indices());
  flushAction.execute(new FlushRequest(request).indices(concreteIndices),new ActionListener<FlushResponse>(){
    @Override public void onResponse(    FlushResponse flushResponse){
      if (logger.isTraceEnabled()) {
        traceLogResponse("Flush",flushResponse);
      }
      ImmutableOpenMap<String,ImmutableOpenMap<String,MappingMetaData>> result=clusterService.state().metaData().findMappings(concreteIndices,request.types());
      BoolFilterBuilder filterBuilder=new BoolFilterBuilder();
      Set<String> types=new HashSet<>();
      for (      ObjectObjectCursor<String,ImmutableOpenMap<String,MappingMetaData>> typesMeta : result) {
        for (        ObjectObjectCursor<String,MappingMetaData> type : typesMeta.value) {
          filterBuilder.should(new TypeFilterBuilder(type.key));
          types.add(type.key);
        }
      }
      if (types.size() == 0) {
        throw new TypeMissingException(new Index("_all"),request.types(),"No index has the type.");
      }
      request.types(types.toArray(new String[types.size()]));
      QuerySourceBuilder querySourceBuilder=new QuerySourceBuilder().setQuery(QueryBuilders.filteredQuery(QueryBuilders.matchAllQuery(),filterBuilder));
      DeleteByQueryRequest deleteByQueryRequest=new DeleteByQueryRequest(request).indices(concreteIndices).types(request.types()).source(querySourceBuilder);
      deleteByQueryAction.execute(deleteByQueryRequest,new ActionListener<DeleteByQueryResponse>(){
        @Override public void onResponse(        DeleteByQueryResponse deleteByQueryResponse){
          if (logger.isTraceEnabled()) {
            for (            IndexDeleteByQueryResponse indexResponse : deleteByQueryResponse) {
              logger.trace("Delete by query[{}] completed with total[{}], successful[{}] and failed[{}]",indexResponse.getIndex(),indexResponse.getTotalShards(),indexResponse.getSuccessfulShards(),indexResponse.getFailedShards());
              if (indexResponse.getFailedShards() > 0) {
                for (                ShardOperationFailedException failure : indexResponse.getFailures()) {
                  logger.trace("[{}/{}] Delete by query shard failure reason: {}",failure.index(),failure.shardId(),failure.reason());
                }
              }
            }
          }
          refreshAction.execute(new RefreshRequest(request).indices(concreteIndices),new ActionListener<RefreshResponse>(){
            @Override public void onResponse(            RefreshResponse refreshResponse){
              if (logger.isTraceEnabled()) {
                traceLogResponse("Refresh",refreshResponse);
              }
              removeMapping();
            }
            @Override public void onFailure(            Throwable e){
              if (logger.isDebugEnabled()) {
                logger.debug("Refresh failed completely",e);
              }
              removeMapping();
            }
            protected void removeMapping(){
              DeleteMappingClusterStateUpdateRequest clusterStateUpdateRequest=new DeleteMappingClusterStateUpdateRequest().indices(concreteIndices).types(request.types()).ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout());
              metaDataMappingService.removeMapping(clusterStateUpdateRequest,new ActionListener<ClusterStateUpdateResponse>(){
                @Override public void onResponse(                ClusterStateUpdateResponse response){
                  listener.onResponse(new DeleteMappingResponse(response.isAcknowledged()));
                }
                @Override public void onFailure(                Throwable t){
                  listener.onFailure(t);
                }
              }
);
            }
          }
);
        }
        @Override public void onFailure(        Throwable t){
          listener.onFailure(t);
        }
      }
);
    }
    @Override public void onFailure(    Throwable t){
      listener.onFailure(t);
    }
  }
);
}
