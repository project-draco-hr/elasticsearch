{
  final int[] hashTable=_hashTable;
  ++outPos;
  int seen=first(in,0);
  int literals=0;
  inEnd-=4;
  final int firstPos=inPos;
  while (inPos < inEnd) {
    byte p2=in[inPos + 2];
    seen=(seen << 8) + (p2 & 255);
    int off=hash(seen);
    int ref=hashTable[off];
    hashTable[off]=inPos;
    if (ref >= inPos || ref < firstPos || (off=inPos - ref) > MAX_OFF || in[ref + 2] != p2 || in[ref + 1] != (byte)(seen >> 8) || in[ref] != (byte)(seen >> 16)) {
      out[outPos++]=in[inPos++];
      literals++;
      if (literals == LZFChunk.MAX_LITERAL) {
        out[outPos - 33]=(byte)31;
        literals=0;
        outPos++;
      }
      continue;
    }
    int maxLen=inEnd - inPos + 2;
    if (maxLen > MAX_REF) {
      maxLen=MAX_REF;
    }
    if (literals == 0) {
      outPos--;
    }
 else {
      out[outPos - literals - 1]=(byte)(literals - 1);
      literals=0;
    }
    int len=3;
    while (len < maxLen && in[ref + len] == in[inPos + len]) {
      len++;
    }
    len-=2;
    --off;
    if (len < 7) {
      out[outPos++]=(byte)((off >> 8) + (len << 5));
    }
 else {
      out[outPos++]=(byte)((off >> 8) + (7 << 5));
      out[outPos++]=(byte)(len - 7);
    }
    out[outPos++]=(byte)off;
    outPos++;
    inPos+=len;
    seen=first(in,inPos);
    seen=(seen << 8) + (in[inPos + 2] & 255);
    hashTable[hash(seen)]=inPos;
    ++inPos;
    seen=(seen << 8) + (in[inPos + 2] & 255);
    hashTable[hash(seen)]=inPos;
    ++inPos;
  }
  return handleTail(in,inPos,inEnd + 4,out,outPos,literals);
}
