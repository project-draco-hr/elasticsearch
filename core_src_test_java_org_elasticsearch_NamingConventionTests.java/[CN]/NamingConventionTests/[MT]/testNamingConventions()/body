{
  final Set<Class> notImplementing=new HashSet<>();
  final Set<Class> pureUnitTest=new HashSet<>();
  final Set<Class> missingSuffix=new HashSet<>();
  final Set<Class> integTestsInDisguise=new HashSet<>();
  final Set<Class> notRunnable=new HashSet<>();
  final Set<Class> innerClasses=new HashSet<>();
  String[] packages={"org.elasticsearch","org.apache.lucene"};
  for (  final String packageName : packages) {
    final String path="/" + packageName.replace('.','/');
    final Path startPath=getDataPath(path);
    final Set<Path> ignore=Sets.newHashSet(PathUtils.get("/org/elasticsearch/stresstest"),PathUtils.get("/org/elasticsearch/benchmark/stress"));
    Files.walkFileTree(startPath,new FileVisitor<Path>(){
      private Path pkgPrefix=PathUtils.get(path).getParent();
      @Override public FileVisitResult preVisitDirectory(      Path dir,      BasicFileAttributes attrs) throws IOException {
        Path next=pkgPrefix.resolve(dir.getFileName());
        if (ignore.contains(next)) {
          return FileVisitResult.SKIP_SUBTREE;
        }
        pkgPrefix=next;
        return FileVisitResult.CONTINUE;
      }
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        try {
          String filename=file.getFileName().toString();
          if (filename.endsWith(".class")) {
            Class<?> clazz=loadClass(filename);
            if (clazz.getName().endsWith("Tests") || clazz.getName().endsWith("Test")) {
              if (ESIntegTestCase.class.isAssignableFrom(clazz)) {
                integTestsInDisguise.add(clazz);
              }
              if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) {
                notRunnable.add(clazz);
              }
 else               if (isTestCase(clazz) == false) {
                notImplementing.add(clazz);
              }
 else               if (Modifier.isStatic(clazz.getModifiers())) {
                innerClasses.add(clazz);
              }
            }
 else             if (clazz.getName().endsWith("IT")) {
              if (isTestCase(clazz) == false) {
                notImplementing.add(clazz);
              }
            }
 else             if (Modifier.isAbstract(clazz.getModifiers()) == false && Modifier.isInterface(clazz.getModifiers()) == false) {
              if (isTestCase(clazz)) {
                missingSuffix.add(clazz);
              }
 else               if (junit.framework.Test.class.isAssignableFrom(clazz) || hasTestAnnotation(clazz)) {
                pureUnitTest.add(clazz);
              }
            }
          }
        }
 catch (        ClassNotFoundException e) {
          throw new RuntimeException(e);
        }
        return FileVisitResult.CONTINUE;
      }
      private boolean hasTestAnnotation(      Class<?> clazz){
        for (        Method method : clazz.getDeclaredMethods()) {
          if (method.getAnnotation(Test.class) != null) {
            return true;
          }
        }
        return false;
      }
      private boolean isTestCase(      Class<?> clazz){
        return LuceneTestCase.class.isAssignableFrom(clazz);
      }
      private Class<?> loadClass(      String filename) throws ClassNotFoundException {
        StringBuilder pkg=new StringBuilder();
        for (        Path p : pkgPrefix) {
          pkg.append(p.getFileName().toString()).append(".");
        }
        pkg.append(filename.substring(0,filename.length() - 6));
        return Thread.currentThread().getContextClassLoader().loadClass(pkg.toString());
      }
      @Override public FileVisitResult visitFileFailed(      Path file,      IOException exc) throws IOException {
        throw exc;
      }
      @Override public FileVisitResult postVisitDirectory(      Path dir,      IOException exc) throws IOException {
        pkgPrefix=pkgPrefix.getParent();
        return FileVisitResult.CONTINUE;
      }
    }
);
  }
  assertTrue(missingSuffix.remove(WrongName.class));
  assertTrue(missingSuffix.remove(WrongNameTheSecond.class));
  assertTrue(notRunnable.remove(DummyAbstractTests.class));
  assertTrue(notRunnable.remove(DummyInterfaceTests.class));
  assertTrue(innerClasses.remove(InnerTests.class));
  assertTrue(notImplementing.remove(NotImplementingTests.class));
  assertTrue(notImplementing.remove(NotImplementingTest.class));
  assertTrue(pureUnitTest.remove(PlainUnit.class));
  assertTrue(pureUnitTest.remove(PlainUnitTheSecond.class));
  String classesToSubclass=Joiner.on(',').join(ESTestCase.class.getSimpleName(),ESTestCase.class.getSimpleName(),ESTokenStreamTestCase.class.getSimpleName(),LuceneTestCase.class.getSimpleName());
  assertTrue("Not all subclasses of " + ESTestCase.class.getSimpleName() + " match the naming convention. Concrete classes must end with [Test|Tests]:\n"+ listClasses(missingSuffix),missingSuffix.isEmpty());
  assertTrue("Classes ending with [Test|Tests] are abstract or interfaces:\n" + listClasses(notRunnable),notRunnable.isEmpty());
  assertTrue("Found inner classes that are tests, which are excluded from the test runner:\n" + listClasses(innerClasses),innerClasses.isEmpty());
  assertTrue("Pure Unit-Test found must subclass one of [" + classesToSubclass + "]:\n"+ listClasses(pureUnitTest),pureUnitTest.isEmpty());
  assertTrue("Classes ending with Test|Tests] must subclass [" + classesToSubclass + "]:\n"+ listClasses(notImplementing),notImplementing.isEmpty());
  assertTrue("Subclasses of ESIntegTestCase should end with IT as they are integration tests:\n" + listClasses(integTestsInDisguise),integTestsInDisguise.isEmpty());
}
