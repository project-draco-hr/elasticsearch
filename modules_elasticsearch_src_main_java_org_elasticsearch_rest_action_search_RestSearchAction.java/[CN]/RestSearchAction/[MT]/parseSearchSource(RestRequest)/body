{
  SearchSourceBuilder searchSourceBuilder=new SearchSourceBuilder();
  String queryString=request.param("q");
  if (queryString != null) {
    QueryStringQueryBuilder queryBuilder=QueryBuilders.queryString(queryString);
    queryBuilder.defaultField(request.param("df"));
    queryBuilder.analyzer(request.param("analyzer"));
    String defaultOperator=request.param("default_operator");
    if (defaultOperator != null) {
      if ("OR".equals(defaultOperator)) {
        queryBuilder.defaultOperator(QueryStringQueryBuilder.Operator.OR);
      }
 else       if ("AND".equals(defaultOperator)) {
        queryBuilder.defaultOperator(QueryStringQueryBuilder.Operator.AND);
      }
 else {
        throw new ElasticSearchIllegalArgumentException("Unsupported defaultOperator [" + defaultOperator + "], can either be [OR] or [AND]");
      }
    }
    searchSourceBuilder.query(queryBuilder);
  }
  int from=request.paramAsInt("from",-1);
  if (from != -1) {
    searchSourceBuilder.from(from);
  }
  int size=request.paramAsInt("size",-1);
  if (size != -1) {
    searchSourceBuilder.size(size);
  }
  searchSourceBuilder.queryParserName(request.param("query_parser_name"));
  searchSourceBuilder.explain(request.paramAsBoolean("explain",null));
  String sField=request.param("fields");
  if (sField != null) {
    String[] sFields=fieldsPattern.split(sField);
    if (sFields != null) {
      for (      String field : sFields) {
        searchSourceBuilder.field(field);
      }
    }
  }
  String sSorts=request.param("sort");
  if (sSorts != null) {
    String[] sorts=fieldsPattern.split(sSorts);
    for (    String sort : sorts) {
      int delimiter=sort.lastIndexOf(":");
      if (delimiter != -1) {
        String sortField=sort.substring(0,delimiter);
        String reverse=sort.substring(delimiter + 1);
        if ("asc".equals(reverse)) {
          searchSourceBuilder.sort(sortField,SortOrder.ASC);
        }
 else         if ("desc".equals(reverse)) {
          searchSourceBuilder.sort(sortField,SortOrder.DESC);
        }
      }
 else {
        searchSourceBuilder.sort(sort);
      }
    }
  }
  String sIndicesBoost=request.param("indices_boost");
  if (sIndicesBoost != null) {
    String[] indicesBoost=indicesBoostPattern.split(sIndicesBoost);
    for (    String indexBoost : indicesBoost) {
      int divisor=indexBoost.indexOf(',');
      if (divisor == -1) {
        throw new ElasticSearchIllegalArgumentException("Illegal index boost [" + indexBoost + "], no ','");
      }
      String indexName=indexBoost.substring(0,divisor);
      String sBoost=indexBoost.substring(divisor + 1);
      try {
        searchSourceBuilder.indexBoost(indexName,Float.parseFloat(sBoost));
      }
 catch (      NumberFormatException e) {
        throw new ElasticSearchIllegalArgumentException("Illegal index boost [" + indexBoost + "], boost not a float number");
      }
    }
  }
  return searchSourceBuilder;
}
