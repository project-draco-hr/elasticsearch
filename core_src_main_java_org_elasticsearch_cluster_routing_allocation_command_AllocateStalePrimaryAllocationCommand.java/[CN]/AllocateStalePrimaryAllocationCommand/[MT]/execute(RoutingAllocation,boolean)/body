{
  final DiscoveryNode discoNode;
  try {
    discoNode=allocation.nodes().resolveNode(node);
  }
 catch (  IllegalArgumentException e) {
    return explainOrThrowRejectedCommand(explain,allocation,e);
  }
  final RoutingNodes routingNodes=allocation.routingNodes();
  RoutingNode routingNode=routingNodes.node(discoNode.id());
  if (routingNode == null) {
    return explainOrThrowMissingRoutingNode(allocation,explain,discoNode);
  }
  final ShardRouting shardRouting;
  try {
    shardRouting=allocation.routingTable().shardRoutingTable(shardId).primaryShard();
  }
 catch (  IndexNotFoundException|ShardNotFoundException e) {
    return explainOrThrowRejectedCommand(explain,allocation,e);
  }
  if (shardRouting.unassigned() == false) {
    return explainOrThrowRejectedCommand(explain,allocation,"primary " + shardId + " is already assigned");
  }
  if (acceptDataLoss == false) {
    return explainOrThrowRejectedCommand(explain,allocation,"allocating an empty primary for " + shardId + " can result in data loss. Please confirm by setting the accept_data_loss parameter to true");
  }
  final IndexMetaData indexMetaData=allocation.metaData().index(shardRouting.getIndex());
  if (shardRouting.allocatedPostIndexCreate(indexMetaData) == false) {
    return explainOrThrowRejectedCommand(explain,allocation,"trying to allocate an existing primary shard " + shardId + ", while no such shard has ever been active");
  }
  initializeUnassignedShard(allocation,routingNodes,routingNode,shardRouting);
  return new RerouteExplanation(this,allocation.decision(Decision.YES,name() + " (allocation command)","ignore deciders"));
}
