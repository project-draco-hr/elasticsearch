{
  final String indexName="test";
  final String p_node=internalCluster().startNode();
  client().admin().indices().prepareCreate(indexName).setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1,IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0)).get();
  internalCluster().startNodesAsync(2).get();
  List<IndexRequestBuilder> requests=new ArrayList<>();
  int numDocs=scaledRandomIntBetween(25,250);
  for (int i=0; i < numDocs; i++) {
    requests.add(client().prepareIndex(indexName,"type").setCreate(true).setSource("{}"));
  }
  indexRandom(true,requests);
  assertFalse(client().admin().cluster().prepareHealth().setWaitForNodes("3").setWaitForGreenStatus().get().isTimedOut());
  flush();
  int allowedFailures=randomIntBetween(3,10);
  logger.info("--> blocking recoveries from primary (allowed failures: [{}])",allowedFailures);
  CountDownLatch corruptionCount=new CountDownLatch(allowedFailures);
  ClusterService clusterService=internalCluster().getInstance(ClusterService.class,p_node);
  MockTransportService mockTransportService=(MockTransportService)internalCluster().getInstance(TransportService.class,p_node);
  for (  DiscoveryNode node : clusterService.state().nodes()) {
    if (!node.equals(clusterService.localNode())) {
      mockTransportService.addDelegate(node,new RecoveryCorruption(mockTransportService.original(),corruptionCount));
    }
  }
  client().admin().indices().prepareUpdateSettings(indexName).setSettings(ImmutableSettings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,1)).get();
  corruptionCount.await();
  logger.info("--> stopping replica assignment");
  assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(ImmutableSettings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE,"none")));
  logger.info("--> wait for all replica shards to be removed, on all nodes");
  assertBusy(new Runnable(){
    @Override public void run(){
      for (      String node : internalCluster().getNodeNames()) {
        if (node.equals(p_node)) {
          continue;
        }
        ClusterState state=client(node).admin().cluster().prepareState().setLocal(true).get().getState();
        assertThat(node + " indicates assigned replicas",state.getRoutingTable().index(indexName).shardsWithState(ShardRoutingState.UNASSIGNED).size(),equalTo(1));
      }
    }
  }
);
  logger.info("--> verifying no temporary recoveries are left");
  for (  String node : internalCluster().getNodeNames()) {
    NodeEnvironment nodeEnvironment=internalCluster().getInstance(NodeEnvironment.class,node);
    for (    final File shardLoc : nodeEnvironment.shardLocations(new ShardId(indexName,0))) {
      assertBusy(new Runnable(){
        @Override public void run(){
          try {
            Files.walkFileTree(shardLoc.toPath(),new SimpleFileVisitor<Path>(){
              @Override public FileVisitResult visitFile(              Path file,              BasicFileAttributes attrs) throws IOException {
                assertThat("found a temporary recovery file: " + file,file.getFileName().toString(),not(startsWith("recovery.")));
                return FileVisitResult.CONTINUE;
              }
            }
);
          }
 catch (          IOException e) {
            throw new ElasticsearchException("failed to walk tree",e);
          }
        }
      }
);
    }
  }
}
