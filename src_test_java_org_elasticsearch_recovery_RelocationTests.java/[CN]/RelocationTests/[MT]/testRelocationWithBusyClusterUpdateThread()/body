{
  final String indexName="test";
  final Settings settings=ImmutableSettings.builder().put("gateway.type","local").put(DiscoverySettings.PUBLISH_TIMEOUT,"1s").put("indices.recovery.internal_action_timeout","1s").build();
  String master=internalCluster().startNode(settings);
  ensureGreen();
  List<String> nodes=internalCluster().startNodesAsync(2,settings).get();
  final String node1=nodes.get(0);
  final String node2=nodes.get(1);
  ClusterHealthResponse response=client().admin().cluster().prepareHealth().setWaitForNodes("3").get();
  assertThat(response.isTimedOut(),is(false));
  client().admin().indices().prepareCreate(indexName).setSettings(ImmutableSettings.builder().put(FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + "_name",node1).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS,1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,0)).get();
  List<IndexRequestBuilder> requests=new ArrayList<>();
  int numDocs=scaledRandomIntBetween(25,250);
  for (int i=0; i < numDocs; i++) {
    requests.add(client().prepareIndex(indexName,"type").setCreate(true).setSource("{}"));
  }
  indexRandom(true,requests);
  ensureSearchable(indexName);
  final CountDownLatch allReplicasAssigned=new CountDownLatch(1);
  final CountDownLatch releaseClusterState=new CountDownLatch(1);
  final CountDownLatch unassignedShardsAfterReplicasAssigned=new CountDownLatch(1);
  try {
    internalCluster().getInstance(ClusterService.class,node1).addLast(new ClusterStateListener(){
      @Override public void clusterChanged(      ClusterChangedEvent event){
        if (event.state().routingNodes().hasUnassignedShards() == false) {
          allReplicasAssigned.countDown();
          try {
            releaseClusterState.await();
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
);
    internalCluster().getInstance(ClusterService.class,master).addLast(new ClusterStateListener(){
      @Override public void clusterChanged(      ClusterChangedEvent event){
        if (event.state().routingNodes().hasUnassigned() && allReplicasAssigned.getCount() == 0) {
          unassignedShardsAfterReplicasAssigned.countDown();
        }
      }
    }
);
    logger.info("--> starting replica recovery");
    assertFalse(client().admin().indices().prepareUpdateSettings(indexName).setSettings(ImmutableSettings.builder().put(FilterAllocationDecider.INDEX_ROUTING_INCLUDE_GROUP + "_name",node1 + "," + node2).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS,1)).setTimeout("200ms").get().isAcknowledged());
    logger.info("--> waiting for node1 to process replica existence");
    allReplicasAssigned.await();
    logger.info("--> waiting for recovery to fail");
    unassignedShardsAfterReplicasAssigned.await();
  }
  finally {
    logger.info("--> releasing cluster state update thread");
    releaseClusterState.countDown();
  }
  logger.info("--> waiting for recovery to succeed");
  client().admin().cluster().prepareReroute().get();
  ensureGreen();
}
