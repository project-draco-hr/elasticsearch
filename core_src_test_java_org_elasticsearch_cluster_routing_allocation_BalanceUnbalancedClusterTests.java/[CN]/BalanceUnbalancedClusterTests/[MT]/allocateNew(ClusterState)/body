{
  String index="tweets-2014-12-29:00";
  AllocationService strategy=createAllocationService(settingsBuilder().build());
  MetaData metaData=MetaData.builder(state.metaData()).put(IndexMetaData.builder(index).settings(settings(Version.CURRENT)).numberOfShards(5).numberOfReplicas(1)).build();
  RoutingTable routingTable=RoutingTable.builder(state.routingTable()).addAsNew(metaData.index(index)).build();
  ClusterState clusterState=ClusterState.builder(state).metaData(metaData).routingTable(routingTable).build();
  routingTable=strategy.reroute(clusterState,"reroute").routingTable();
  clusterState=ClusterState.builder(clusterState).routingTable(routingTable).build();
  while (true) {
    if (routingTable.shardsWithState(INITIALIZING).isEmpty()) {
      break;
    }
    routingTable=strategy.applyStartedShards(clusterState,routingTable.shardsWithState(INITIALIZING)).routingTable();
    clusterState=ClusterState.builder(clusterState).routingTable(routingTable).build();
  }
  Map<String,Integer> counts=new HashMap<>();
  for (  IndexShardRoutingTable table : routingTable.index(index)) {
    for (    ShardRouting r : table) {
      String s=r.currentNodeId();
      Integer count=counts.get(s);
      if (count == null) {
        count=0;
      }
      count++;
      counts.put(s,count);
    }
  }
  for (  Map.Entry<String,Integer> count : counts.entrySet()) {
    assertTrue("Node: " + count.getKey() + " has shard mismatch: "+ count.getValue(),count.getValue() >= 2);
    assertTrue("Node: " + count.getKey() + " has shard mismatch: "+ count.getValue(),count.getValue() <= 3);
  }
  return clusterState;
}
