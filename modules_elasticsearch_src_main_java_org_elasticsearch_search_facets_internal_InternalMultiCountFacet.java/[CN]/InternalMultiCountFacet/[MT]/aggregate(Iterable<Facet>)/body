{
  TObjectIntHashMap<Object> aggregated=aggregateCache.get().get();
  aggregated.clear();
  for (  Facet facet : facets) {
    if (!facet.name().equals(name)) {
      continue;
    }
    MultiCountFacet<T> mFacet=(MultiCountFacet<T>)facet;
    for (    Entry<T> entry : mFacet) {
      aggregated.adjustOrPutValue(entry.value(),entry.count(),entry.count());
    }
  }
  BoundedTreeSet<Entry<T>> ordered=new BoundedTreeSet<Entry<T>>(comparatorType.comparator(),requiredSize);
  for (TObjectIntIterator<Object> it=aggregated.iterator(); it.hasNext(); ) {
    it.advance();
    ordered.add(new Entry<T>((T)it.key(),it.value()));
  }
  return new InternalMultiCountFacet<T>(name,valueType,comparatorType,requiredSize,ordered);
}
