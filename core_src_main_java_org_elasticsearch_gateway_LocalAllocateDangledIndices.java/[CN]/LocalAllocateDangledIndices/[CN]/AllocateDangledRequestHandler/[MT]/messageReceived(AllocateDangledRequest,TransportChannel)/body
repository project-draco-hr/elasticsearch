{
  String[] indexNames=new String[request.indices.length];
  for (int i=0; i < request.indices.length; i++) {
    indexNames[i]=request.indices[i].index();
  }
  clusterService.submitStateUpdateTask("allocation dangled indices " + Arrays.toString(indexNames),new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      if (currentState.blocks().disableStatePersistence()) {
        return currentState;
      }
      MetaData.Builder metaData=MetaData.builder(currentState.metaData());
      ClusterBlocks.Builder blocks=ClusterBlocks.builder().blocks(currentState.blocks());
      RoutingTable.Builder routingTableBuilder=RoutingTable.builder(currentState.routingTable());
      boolean importNeeded=false;
      StringBuilder sb=new StringBuilder();
      for (      IndexMetaData indexMetaData : request.indices) {
        if (currentState.metaData().hasIndex(indexMetaData.index())) {
          continue;
        }
        if (currentState.metaData().hasAlias(indexMetaData.index())) {
          logger.warn("ignoring dangled index [{}] on node [{}] due to an existing alias with the same name",indexMetaData.index(),request.fromNode);
          continue;
        }
        importNeeded=true;
        IndexMetaData upgradedIndexMetaData;
        try {
          upgradedIndexMetaData=metaDataIndexUpgradeService.upgradeIndexMetaData(indexMetaData);
        }
 catch (        Exception ex) {
          logger.warn("found dangled index [{}] on node [{}]. This index cannot be upgraded to the latest version, adding as closed",ex,indexMetaData.index(),request.fromNode);
          upgradedIndexMetaData=IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE).version(indexMetaData.version() + 1).build();
        }
        metaData.put(upgradedIndexMetaData,false);
        blocks.addBlocks(upgradedIndexMetaData);
        if (upgradedIndexMetaData.getState() == IndexMetaData.State.OPEN) {
          routingTableBuilder.addAsFromDangling(upgradedIndexMetaData);
        }
        sb.append("[").append(upgradedIndexMetaData.index()).append("/").append(upgradedIndexMetaData.state()).append("]");
      }
      if (!importNeeded) {
        return currentState;
      }
      logger.info("auto importing dangled indices {} from [{}]",sb.toString(),request.fromNode);
      ClusterState updatedState=ClusterState.builder(currentState).metaData(metaData).blocks(blocks).routingTable(routingTableBuilder).build();
      RoutingAllocation.Result routingResult=allocationService.reroute(ClusterState.builder(updatedState).routingTable(routingTableBuilder).build());
      return ClusterState.builder(updatedState).routingResult(routingResult).build();
    }
    @Override public void onFailure(    String source,    Throwable t){
      logger.error("unexpected failure during [{}]",t,source);
      try {
        channel.sendResponse(t);
      }
 catch (      Exception e) {
        logger.warn("failed send response for allocating dangled",e);
      }
    }
    @Override public void clusterStateProcessed(    String source,    ClusterState oldState,    ClusterState newState){
      try {
        channel.sendResponse(new AllocateDangledResponse(true));
      }
 catch (      IOException e) {
        logger.warn("failed send response for allocating dangled",e);
      }
    }
  }
);
}
