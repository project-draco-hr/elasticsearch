{
  if (!newClusterState.metaData().hasIndex(riverIndexName)) {
    if (!currentState.routing().isEmpty()) {
      return RiverClusterState.builder().state(currentState).routing(RiversRouting.builder()).build();
    }
    return currentState;
  }
  RiversRouting.Builder routingBuilder=RiversRouting.builder().routing(currentState.routing());
  boolean dirty=false;
  IndexMetaData indexMetaData=newClusterState.metaData().index(riverIndexName);
  boolean metaFound=true;
  for (  ObjectCursor<MappingMetaData> cursor : indexMetaData.mappings().values()) {
    String mappingType=cursor.value.type();
    if (MapperService.DEFAULT_MAPPING.equals(mappingType)) {
      continue;
    }
    if (!currentState.routing().hasRiverByName(mappingType)) {
      try {
        GetResponse getResponse=client.prepareGet(riverIndexName,mappingType,"_meta").setPreference("_primary").get();
        if (getResponse.isExists()) {
          logger.debug("{}/{}/_meta document found.",riverIndexName,mappingType);
          String riverType=XContentMapValues.nodeStringValue(getResponse.getSourceAsMap().get("type"),null);
          if (riverType == null) {
            logger.warn("no river type provided for [{}], ignoring...",riverIndexName);
          }
 else {
            routingBuilder.put(new RiverRouting(new RiverName(riverType,mappingType),null));
            dirty=true;
          }
        }
 else {
          metaFound=false;
        }
      }
 catch (      NoShardAvailableActionException e) {
      }
catch (      ClusterBlockException e) {
      }
catch (      IndexMissingException e) {
      }
catch (      IllegalIndexShardStateException e) {
      }
catch (      Exception e) {
        logger.warn("failed to get/parse _meta for [{}]",e,mappingType);
      }
    }
  }
  if (!metaFound) {
    if (countDown.countDown()) {
      logger.warn("no river _meta document found after {} attempts",RIVER_START_MAX_RETRIES);
    }
 else {
      logger.debug("no river _meta document found retrying in {} ms",RIVER_START_RETRY_INTERVAL.millis());
      try {
        threadPool.schedule(RIVER_START_RETRY_INTERVAL,ThreadPool.Names.GENERIC,new Runnable(){
          @Override public void run(){
            riverClusterService.submitStateUpdateTask(source,new RiverClusterStateUpdateTask(){
              @Override public RiverClusterState execute(              RiverClusterState currentState){
                return updateRiverClusterState(source,currentState,riverClusterService.state(),countDown);
              }
            }
);
          }
        }
);
      }
 catch (      EsRejectedExecutionException ex) {
        logger.debug("Couldn't schedule river start retry, node might be shutting down",ex);
      }
    }
  }
  for (  RiverRouting routing : currentState.routing()) {
    if (!indexMetaData.mappings().containsKey(routing.riverName().name())) {
      routingBuilder.remove(routing);
      dirty=true;
    }
 else     if (routing.node() != null && !newClusterState.nodes().nodeExists(routing.node().id())) {
      routingBuilder.remove(routing);
      routingBuilder.put(new RiverRouting(routing.riverName(),null));
      dirty=true;
    }
  }
  Map<DiscoveryNode,List<RiverRouting>> nodesToRivers=Maps.newHashMap();
  for (  DiscoveryNode node : newClusterState.nodes()) {
    if (RiverNodeHelper.isRiverNode(node)) {
      nodesToRivers.put(node,Lists.<RiverRouting>newArrayList());
    }
  }
  List<RiverRouting> unassigned=Lists.newArrayList();
  for (  RiverRouting routing : routingBuilder.build()) {
    if (routing.node() == null) {
      unassigned.add(routing);
    }
 else {
      List<RiverRouting> l=nodesToRivers.get(routing.node());
      if (l == null) {
        l=Lists.newArrayList();
        nodesToRivers.put(routing.node(),l);
      }
      l.add(routing);
    }
  }
  for (Iterator<RiverRouting> it=unassigned.iterator(); it.hasNext(); ) {
    RiverRouting routing=it.next();
    DiscoveryNode smallest=null;
    int smallestSize=Integer.MAX_VALUE;
    for (    Map.Entry<DiscoveryNode,List<RiverRouting>> entry : nodesToRivers.entrySet()) {
      if (RiverNodeHelper.isRiverNode(entry.getKey(),routing.riverName())) {
        if (entry.getValue().size() < smallestSize) {
          smallestSize=entry.getValue().size();
          smallest=entry.getKey();
        }
      }
    }
    if (smallest != null) {
      dirty=true;
      it.remove();
      routing.node(smallest);
      nodesToRivers.get(smallest).add(routing);
      logger.debug("going to allocate river [{}] on node {}",routing.riverName().getName(),smallest);
    }
  }
  if (dirty) {
    return RiverClusterState.builder().state(currentState).routing(routingBuilder).build();
  }
  return currentState;
}
