{
  try {
switch (operation.opType()) {
case CREATE:
      Translog.Create create=(Translog.Create)operation;
    Engine.Create engineCreate=IndexShard.prepareCreate(docMapper(create.type()),source(create.source()).type(create.type()).id(create.id()).routing(create.routing()).parent(create.parent()).timestamp(create.timestamp()).ttl(create.ttl()),create.version(),create.versionType().versionTypeForReplicationAndRecovery(),Engine.Operation.Origin.RECOVERY,true,false);
  mapperAnalyzer.setType(create.type());
engine.create(engineCreate);
if (engineCreate.parsedDoc().dynamicMappingsUpdate() != null) {
addMappingUpdate(engineCreate.type(),engineCreate.parsedDoc().dynamicMappingsUpdate());
}
break;
case SAVE:
Translog.Index index=(Translog.Index)operation;
Engine.Index engineIndex=IndexShard.prepareIndex(docMapper(index.type()),source(index.source()).type(index.type()).id(index.id()).routing(index.routing()).parent(index.parent()).timestamp(index.timestamp()).ttl(index.ttl()),index.version(),index.versionType().versionTypeForReplicationAndRecovery(),Engine.Operation.Origin.RECOVERY,true);
mapperAnalyzer.setType(index.type());
engine.index(engineIndex);
if (engineIndex.parsedDoc().dynamicMappingsUpdate() != null) {
addMappingUpdate(engineIndex.type(),engineIndex.parsedDoc().dynamicMappingsUpdate());
}
break;
case DELETE:
Translog.Delete delete=(Translog.Delete)operation;
Uid uid=Uid.createUid(delete.uid().text());
engine.delete(new Engine.Delete(uid.type(),uid.id(),delete.uid(),delete.version(),delete.versionType().versionTypeForReplicationAndRecovery(),Engine.Operation.Origin.RECOVERY,System.nanoTime(),false));
break;
case DELETE_BY_QUERY:
Translog.DeleteByQuery deleteByQuery=(Translog.DeleteByQuery)operation;
engine.delete(prepareDeleteByQuery(queryParserService,mapperService,indexAliasesService,indexCache,deleteByQuery.source(),deleteByQuery.filteringAliases(),Engine.Operation.Origin.RECOVERY,deleteByQuery.types()));
break;
default :
throw new IllegalStateException("No operation defined for [" + operation + "]");
}
}
 catch (ElasticsearchException e) {
boolean hasIgnoreOnRecoveryException=false;
ElasticsearchException current=e;
while (true) {
if (current instanceof IgnoreOnRecoveryEngineException) {
hasIgnoreOnRecoveryException=true;
break;
}
if (current.getCause() instanceof ElasticsearchException) {
current=(ElasticsearchException)current.getCause();
}
 else {
break;
}
}
if (!hasIgnoreOnRecoveryException) {
throw e;
}
}
operationProcessed();
}
