{
  final int limit=100;
  final Recycler.C<Object> c=new Recycler.C<Object>(){
    @Override public Object newInstance(    int sizing){
      return new Object();
    }
    @Override public void clear(    Object value){
    }
  }
;
  final ImmutableMap<String,Recycler<Object>> recyclers=ImmutableMap.<String,Recycler<Object>>builder().put("none",none(c)).put("concurrent-queue",concurrentDeque(c,limit)).put("thread-local",threadLocal(dequeFactory(c,limit))).put("soft-thread-local",threadLocal(softFactory(dequeFactory(c,limit)))).put("locked",locked(deque(c,limit))).put("concurrent",concurrent(dequeFactory(c,limit),Runtime.getRuntime().availableProcessors())).put("soft-concurrent",concurrent(softFactory(dequeFactory(c,limit)),Runtime.getRuntime().availableProcessors())).build();
  final long start=System.nanoTime();
  while (System.nanoTime() - start < TimeUnit.SECONDS.toNanos(10)) {
    for (    Recycler<?> recycler : recyclers.values()) {
      bench(recycler,NUM_RECYCLES,2);
    }
  }
  for (int numThreads=1; numThreads <= 4 * Runtime.getRuntime().availableProcessors(); numThreads*=2) {
    System.out.println("## " + numThreads + " threads\n");
    System.gc();
    Thread.sleep(1000);
    for (    Recycler<?> recycler : recyclers.values()) {
      bench(recycler,NUM_RECYCLES,numThreads);
    }
    for (int i=0; i < 5; ++i) {
      for (      Map.Entry<String,Recycler<Object>> entry : recyclers.entrySet()) {
        System.out.println(entry.getKey() + "\t" + TimeUnit.NANOSECONDS.toMillis(bench(entry.getValue(),NUM_RECYCLES,numThreads)));
      }
      System.out.println();
    }
  }
}
