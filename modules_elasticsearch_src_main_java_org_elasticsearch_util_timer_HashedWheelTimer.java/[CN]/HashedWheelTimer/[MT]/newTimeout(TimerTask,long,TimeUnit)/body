{
  final long currentTime=System.currentTimeMillis();
  if (task == null) {
    throw new NullPointerException("task");
  }
  if (unit == null) {
    throw new NullPointerException("unit");
  }
  delay=unit.toMillis(delay);
  if (delay < tickDuration) {
    delay=tickDuration;
  }
  if (!workerThread.isAlive()) {
    start();
  }
  HashedWheelTimeout timeout;
  final long lastRoundDelay=delay % roundDuration;
  final long lastTickDelay=delay % tickDuration;
  final long relativeIndex=lastRoundDelay / tickDuration + (lastTickDelay != 0 ? 1 : 0);
  final long deadline=currentTime + delay;
  final long remainingRounds=delay / roundDuration - (delay % roundDuration == 0 ? 1 : 0);
  lock.readLock().lock();
  try {
    timeout=new HashedWheelTimeout(task,deadline,(int)(wheelCursor + relativeIndex & mask),remainingRounds);
    wheel[timeout.stopIndex].add(timeout);
  }
  finally {
    lock.readLock().unlock();
  }
  return timeout;
}
