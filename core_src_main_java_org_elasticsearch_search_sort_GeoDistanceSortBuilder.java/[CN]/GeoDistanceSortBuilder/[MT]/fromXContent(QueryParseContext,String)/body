{
  XContentParser parser=context.parser();
  ParseFieldMatcher parseFieldMatcher=context.parseFieldMatcher();
  String fieldName=null;
  List<GeoPoint> geoPoints=new ArrayList<>();
  DistanceUnit unit=DistanceUnit.DEFAULT;
  GeoDistance geoDistance=GeoDistance.DEFAULT;
  SortOrder order=SortOrder.ASC;
  SortMode sortMode=null;
  QueryBuilder<?> nestedFilter=null;
  String nestedPath=null;
  boolean coerce=GeoDistanceSortBuilder.DEFAULT_COERCE;
  boolean ignoreMalformed=GeoDistanceSortBuilder.DEFAULT_IGNORE_MALFORMED;
  XContentParser.Token token;
  String currentName=parser.currentName();
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentName=parser.currentName();
    }
 else     if (token == XContentParser.Token.START_ARRAY) {
      parseGeoPoints(parser,geoPoints);
      fieldName=currentName;
    }
 else     if (token == XContentParser.Token.START_OBJECT) {
      if (parseFieldMatcher.match(currentName,NESTED_FILTER_FIELD)) {
        nestedFilter=context.parseInnerQueryBuilder();
      }
 else {
        fieldName=currentName;
        GeoPoint point=new GeoPoint();
        GeoUtils.parseGeoPoint(parser,point);
        geoPoints.add(point);
      }
    }
 else     if (token.isValue()) {
      if (parseFieldMatcher.match(currentName,ORDER_FIELD)) {
        order=SortOrder.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,UNIT_FIELD)) {
        unit=DistanceUnit.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,DISTANCE_TYPE_FIELD)) {
        geoDistance=GeoDistance.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,COERCE_FIELD)) {
        coerce=parser.booleanValue();
        if (coerce == true) {
          ignoreMalformed=true;
        }
      }
 else       if (parseFieldMatcher.match(currentName,IGNORE_MALFORMED_FIELD)) {
        boolean ignore_malformed_value=parser.booleanValue();
        if (coerce == false) {
          ignoreMalformed=ignore_malformed_value;
        }
      }
 else       if (parseFieldMatcher.match(currentName,SORTMODE_FIELD)) {
        sortMode=SortMode.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,NESTED_PATH_FIELD)) {
        nestedPath=parser.text();
      }
 else       if (parseFieldMatcher.match(currentName,REVERSE_FORBIDDEN)) {
        throw new ParsingException(parser.getTokenLocation(),"Sort option [{}] no longer supported.",REVERSE_FORBIDDEN.getPreferredName());
      }
 else {
        GeoPoint point=new GeoPoint();
        point.resetFromString(parser.text());
        geoPoints.add(point);
        fieldName=currentName;
      }
    }
  }
  GeoDistanceSortBuilder result=new GeoDistanceSortBuilder(fieldName,geoPoints.toArray(new GeoPoint[geoPoints.size()]));
  result.geoDistance(geoDistance);
  result.unit(unit);
  result.order(order);
  if (sortMode != null) {
    result.sortMode(sortMode);
  }
  result.setNestedFilter(nestedFilter);
  result.setNestedPath(nestedPath);
  result.coerce(coerce);
  result.ignoreMalformed(ignoreMalformed);
  return result;
}
