{
  XContentParser parser=context.parser();
  ParseFieldMatcher parseFieldMatcher=context.getParseFieldMatcher();
  String fieldName=null;
  List<GeoPoint> geoPoints=new ArrayList<>();
  DistanceUnit unit=DistanceUnit.DEFAULT;
  GeoDistance geoDistance=GeoDistance.DEFAULT;
  SortOrder order=SortOrder.ASC;
  SortMode sortMode=null;
  QueryBuilder nestedFilter=null;
  String nestedPath=null;
  boolean coerce=GeoValidationMethod.DEFAULT_LENIENT_PARSING;
  boolean ignoreMalformed=GeoValidationMethod.DEFAULT_LENIENT_PARSING;
  GeoValidationMethod validation=null;
  XContentParser.Token token;
  String currentName=parser.currentName();
  while ((token=parser.nextToken()) != XContentParser.Token.END_OBJECT) {
    if (token == XContentParser.Token.FIELD_NAME) {
      currentName=parser.currentName();
    }
 else     if (token == XContentParser.Token.START_ARRAY) {
      parseGeoPoints(parser,geoPoints);
      fieldName=currentName;
    }
 else     if (token == XContentParser.Token.START_OBJECT) {
      if (parseFieldMatcher.match(currentName,NESTED_FILTER_FIELD)) {
        nestedFilter=context.parseInnerQueryBuilder();
      }
 else {
        if (fieldName != null && fieldName.equals(currentName) == false) {
          throw new ParsingException(parser.getTokenLocation(),"Trying to reset fieldName to [{}], already set to [{}].",currentName,fieldName);
        }
        fieldName=currentName;
        GeoPoint point=new GeoPoint();
        GeoUtils.parseGeoPoint(parser,point);
        geoPoints.add(point);
      }
    }
 else     if (token.isValue()) {
      if (parseFieldMatcher.match(currentName,ORDER_FIELD)) {
        order=SortOrder.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,UNIT_FIELD)) {
        unit=DistanceUnit.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,DISTANCE_TYPE_FIELD)) {
        geoDistance=GeoDistance.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,COERCE_FIELD)) {
        coerce=parser.booleanValue();
        if (coerce == true) {
          ignoreMalformed=true;
        }
      }
 else       if (parseFieldMatcher.match(currentName,IGNORE_MALFORMED_FIELD)) {
        boolean ignore_malformed_value=parser.booleanValue();
        if (coerce == false) {
          ignoreMalformed=ignore_malformed_value;
        }
      }
 else       if (parseFieldMatcher.match(currentName,VALIDATION_METHOD_FIELD)) {
        validation=GeoValidationMethod.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,SORTMODE_FIELD)) {
        sortMode=SortMode.fromString(parser.text());
      }
 else       if (parseFieldMatcher.match(currentName,NESTED_PATH_FIELD)) {
        nestedPath=parser.text();
      }
 else       if (token == Token.VALUE_STRING) {
        if (fieldName != null && fieldName.equals(currentName) == false) {
          throw new ParsingException(parser.getTokenLocation(),"Trying to reset fieldName to [{}], already set to [{}].",currentName,fieldName);
        }
        GeoPoint point=new GeoPoint();
        point.resetFromString(parser.text());
        geoPoints.add(point);
        fieldName=currentName;
      }
 else {
        throw new ParsingException(parser.getTokenLocation(),"Only geohashes of type string supported for field [{}]",currentName);
      }
    }
  }
  GeoDistanceSortBuilder result=new GeoDistanceSortBuilder(fieldName,geoPoints.toArray(new GeoPoint[geoPoints.size()]));
  result.geoDistance(geoDistance);
  result.unit(unit);
  result.order(order);
  if (sortMode != null) {
    result.sortMode(sortMode);
  }
  result.setNestedFilter(nestedFilter);
  result.setNestedPath(nestedPath);
  if (validation == null) {
    result.validation(GeoValidationMethod.infer(coerce,ignoreMalformed));
  }
 else {
    result.validation(validation);
  }
  return result;
}
