{
  final RoutingTable routingTable=state.routingTable();
  final DiscoveryNodes nodes=state.getNodes();
  final int shardId=shardRouting.id();
  if (indexService.hasShard(shardId)) {
    IndexShard indexShard=indexService.getShard(shardId);
    if (indexShard.state() == IndexShardState.STARTED || indexShard.state() == IndexShardState.POST_RECOVERY) {
      if (logger.isTraceEnabled()) {
        logger.trace("{} master marked shard as initializing, but shard has state [{}], resending shard started to {}",indexShard.shardId(),indexShard.state(),nodes.getMasterNode());
      }
      if (nodes.getMasterNode() != null) {
        shardStateAction.shardStarted(shardRouting,"master " + nodes.getMasterNode() + " marked shard as initializing, but shard state is ["+ indexShard.state()+ "], mark shard as started",SHARD_STATE_ACTION_LISTENER);
      }
      return;
    }
 else {
      if (indexShard.ignoreRecoveryAttempt()) {
        logger.trace("ignoring recovery instruction for an existing shard {} (shard state: [{}])",indexShard.shardId(),indexShard.state());
        return;
      }
    }
  }
  DiscoveryNode sourceNode=null;
  if (shardRouting.isPeerRecovery()) {
    sourceNode=findSourceNodeForPeerRecovery(logger,routingTable,nodes,shardRouting);
    if (sourceNode == null) {
      logger.trace("ignoring initializing shard {} - no source node can be found.",shardRouting.shardId());
      return;
    }
  }
  if (!indexService.hasShard(shardId)) {
    if (failedShards.containsKey(shardRouting.shardId())) {
      if (nodes.getMasterNode() != null) {
        String message="master " + nodes.getMasterNode() + " marked shard as initializing, but shard is marked as failed, resend shard failure";
        logger.trace("[{}] re-sending failed shard [{}], reason [{}]",shardRouting.shardId(),shardRouting,message);
        shardStateAction.shardFailed(shardRouting,shardRouting,message,null,SHARD_STATE_ACTION_LISTENER);
      }
      return;
    }
    try {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}] creating shard",shardRouting.index(),shardId);
      }
      IndexShard indexShard=indexService.createShard(shardRouting);
      indexShard.addShardFailureCallback(failedShardHandler);
    }
 catch (    IndexShardAlreadyExistsException e) {
    }
catch (    Throwable e) {
      failAndRemoveShard(shardRouting,indexService,true,"failed to create shard",e);
      return;
    }
  }
  final IndexShard indexShard=indexService.getShard(shardId);
  if (indexShard.ignoreRecoveryAttempt()) {
    logger.trace("ignoring recovery instruction for shard {} (shard state: [{}])",indexShard.shardId(),indexShard.state());
    return;
  }
  indexShard.startRecovery(nodes.getLocalNode(),sourceNode,recoveryTargetService,new RecoveryListener(shardRouting,indexService),repositoriesService);
}
