{
  boolean changed=false;
  List<RoutingNode> sortedNodesLeastToHigh=routingNodes.sortedNodesLeastToHigh();
  if (sortedNodesLeastToHigh.isEmpty()) {
    return false;
  }
  int lowIndex=0;
  int highIndex=sortedNodesLeastToHigh.size() - 1;
  boolean relocationPerformed;
  do {
    relocationPerformed=false;
    while (lowIndex != highIndex) {
      RoutingNode lowRoutingNode=sortedNodesLeastToHigh.get(lowIndex);
      RoutingNode highRoutingNode=sortedNodesLeastToHigh.get(highIndex);
      int averageNumOfShards=routingNodes.requiredAverageNumberOfShardsPerNode();
      if (highRoutingNode.numberOfOwningShards() <= averageNumOfShards) {
        highIndex--;
        continue;
      }
      if (lowRoutingNode.shards().size() >= averageNumOfShards) {
        lowIndex++;
        continue;
      }
      boolean relocated=false;
      List<MutableShardRouting> activeShards=highRoutingNode.shardsWithState(STARTED);
      for (      MutableShardRouting activeShard : activeShards) {
        List<MutableShardRouting> allShards=routingNodes.shardsRoutingFor(activeShard);
        boolean ignoreShard=false;
        for (        MutableShardRouting allShard : allShards) {
          if (!allShard.active()) {
            ignoreShard=true;
            break;
          }
        }
        if (ignoreShard) {
          continue;
        }
        if (lowRoutingNode.canAllocate(routingNodes.metaData(),routingNodes.routingTable()) && lowRoutingNode.canAllocate(activeShard)) {
          changed=true;
          lowRoutingNode.add(new MutableShardRouting(activeShard.index(),activeShard.id(),lowRoutingNode.nodeId(),activeShard.currentNodeId(),activeShard.primary(),INITIALIZING));
          activeShard.relocate(lowRoutingNode.nodeId());
          relocated=true;
          relocationPerformed=true;
          break;
        }
      }
      if (!relocated) {
        highIndex--;
      }
    }
  }
 while (relocationPerformed);
  return changed;
}
