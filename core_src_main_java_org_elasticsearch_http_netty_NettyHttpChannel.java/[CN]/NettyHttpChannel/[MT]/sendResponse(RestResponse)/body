{
  HttpResponse resp=newResponse();
  resp.setStatus(getStatus(response.status()));
  CorsHandler.setCorsResponseHeaders(nettyRequest,resp,transport.getCorsConfig());
  String opaque=nettyRequest.headers().get("X-Opaque-Id");
  if (opaque != null) {
    setHeaderField(resp,"X-Opaque-Id",opaque);
  }
  addCustomHeaders(response,resp);
  BytesReference content=response.content();
  ChannelBuffer buffer;
  boolean addedReleaseListener=false;
  try {
    buffer=NettyUtils.toChannelBuffer(content);
    resp.setContent(buffer);
    setHeaderField(resp,HttpHeaders.Names.CONTENT_TYPE,response.contentType(),false);
    setHeaderField(resp,HttpHeaders.Names.CONTENT_LENGTH,String.valueOf(buffer.readableBytes()),false);
    addCookies(resp);
    ChannelFuture future;
    if (orderedUpstreamMessageEvent != null) {
      OrderedDownstreamChannelEvent downstreamChannelEvent=new OrderedDownstreamChannelEvent(orderedUpstreamMessageEvent,0,true,resp);
      future=downstreamChannelEvent.getFuture();
      channel.getPipeline().sendDownstream(downstreamChannelEvent);
    }
 else {
      future=channel.write(resp);
    }
    if (content instanceof Releasable) {
      future.addListener(new ReleaseChannelFutureListener((Releasable)content));
      addedReleaseListener=true;
    }
    if (isCloseConnection()) {
      future.addListener(ChannelFutureListener.CLOSE);
    }
  }
  finally {
    if (!addedReleaseListener && content instanceof Releasable) {
      ((Releasable)content).close();
    }
  }
}
