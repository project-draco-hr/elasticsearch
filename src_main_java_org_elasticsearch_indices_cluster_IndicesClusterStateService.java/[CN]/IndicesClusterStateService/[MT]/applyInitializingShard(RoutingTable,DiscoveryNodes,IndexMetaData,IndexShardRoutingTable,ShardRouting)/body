{
  final IndexService indexService=indicesService.indexService(shardRouting.index());
  if (indexService == null) {
    return;
  }
  final int shardId=shardRouting.id();
  if (indexService.hasShard(shardId)) {
    IndexShard indexShard=indexService.shardSafe(shardId);
    if (indexShard.state() == IndexShardState.STARTED || indexShard.state() == IndexShardState.POST_RECOVERY) {
      if (logger.isTraceEnabled()) {
        logger.trace("{} master marked shard as initializing, but shard has state [{}], resending shard started",indexShard.shardId(),indexShard.state());
      }
      shardStateAction.shardStarted(shardRouting,indexMetaData.getUUID(),"master " + nodes.masterNode() + " marked shard as initializing, but shard state is ["+ indexShard.state()+ "], mark shard as started");
      return;
    }
 else {
      if (indexShard.ignoreRecoveryAttempt()) {
        logger.trace("ignoring recovery instruction for an existing shard {} (shard state: [{}])",indexShard.shardId(),indexShard.state());
        return;
      }
    }
  }
  DiscoveryNode sourceNode=null;
  if (!shardRouting.primary()) {
    IndexShardRoutingTable shardRoutingTable=routingTable.index(shardRouting.index()).shard(shardRouting.id());
    for (    ShardRouting entry : shardRoutingTable) {
      if (entry.primary() && entry.started()) {
        sourceNode=nodes.get(entry.currentNodeId());
        if (sourceNode == null) {
          logger.trace("can't recover replica because primary shard {} is assigned to an unknown node. ignoring.",entry);
          return;
        }
        break;
      }
    }
    if (sourceNode == null) {
      logger.trace("can't recover replica for {} because a primary shard can not be found. ignoring.",shardRouting.shardId());
      return;
    }
  }
 else   if (shardRouting.relocatingNodeId() != null) {
    sourceNode=nodes.get(shardRouting.relocatingNodeId());
    if (sourceNode == null) {
      logger.trace("can't recover from remote primary shard {} because it is assigned to an unknown node [{}]. ignoring.",shardRouting.shardId(),shardRouting.relocatingNodeId());
      return;
    }
  }
  if (!indexService.hasShard(shardId)) {
    if (failedShards.containsKey(shardRouting.shardId())) {
      logger.trace("[{}][{}] not initializing, this shards failed to recover on this node before, waiting for reassignment",shardRouting.index(),shardRouting.id());
      return;
    }
    try {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}] creating shard",shardRouting.index(),shardId);
      }
      InternalIndexShard indexShard=(InternalIndexShard)indexService.createShard(shardId);
      indexShard.routingEntry(shardRouting);
      indexShard.engine().addFailedEngineListener(failedEngineHandler);
    }
 catch (    IndexShardAlreadyExistsException e) {
    }
catch (    Throwable e) {
      logger.warn("[{}][{}] failed to create shard",e,shardRouting.index(),shardRouting.id());
      try {
        indexService.removeShard(shardId,"failed to create [" + ExceptionsHelper.detailedMessage(e) + "]");
      }
 catch (      IndexShardMissingException e1) {
      }
catch (      Throwable e1) {
        logger.warn("[{}][{}] failed to remove shard after failed creation",e1,shardRouting.index(),shardRouting.id());
      }
      failedShards.put(shardRouting.shardId(),new FailedShard(shardRouting.version()));
      shardStateAction.shardFailed(shardRouting,indexMetaData.getUUID(),"Failed to create shard, message [" + detailedMessage(e) + "]");
      return;
    }
  }
  final InternalIndexShard indexShard=(InternalIndexShard)indexService.shardSafe(shardId);
  if (indexShard.ignoreRecoveryAttempt()) {
    logger.trace("ignoring recovery instruction for shard {} (shard state: [{}])",indexShard.shardId(),indexShard.state());
    return;
  }
  if (sourceNode != null) {
    try {
      RecoveryState.Type type=shardRouting.primary() ? RecoveryState.Type.RELOCATION : RecoveryState.Type.REPLICA;
      final StartRecoveryRequest request=new StartRecoveryRequest(indexShard.shardId(),sourceNode,nodes.localNode(),false,indexShard.store().list(),type);
      recoveryTarget.startRecovery(request,indexShard,new PeerRecoveryListener(request,shardRouting,indexService,indexMetaData));
    }
 catch (    Throwable e) {
      handleRecoveryFailure(indexService,indexMetaData,shardRouting,true,e);
    }
  }
 else {
    boolean indexShouldExists=indexShardRouting.primaryAllocatedPostApi();
    IndexShardGatewayService shardGatewayService=indexService.shardInjector(shardId).getInstance(IndexShardGatewayService.class);
    shardGatewayService.recover(indexShouldExists,new IndexShardGatewayService.RecoveryListener(){
      @Override public void onRecoveryDone(){
        shardStateAction.shardStarted(shardRouting,indexMetaData.getUUID(),"after recovery from gateway");
      }
      @Override public void onIgnoreRecovery(      String reason){
      }
      @Override public void onRecoveryFailed(      IndexShardGatewayRecoveryException e){
        handleRecoveryFailure(indexService,indexMetaData,shardRouting,true,e);
      }
    }
);
  }
}
