{
  final IndexService indexService=indicesService.indexService(shardRouting.index());
  if (indexService == null) {
    return;
  }
  final int shardId=shardRouting.id();
  if (indexService.hasShard(shardId)) {
    IndexShard indexShard=indexService.shardSafe(shardId);
    if (indexShard.state() == IndexShardState.STARTED || indexShard.state() == IndexShardState.POST_RECOVERY) {
      if (logger.isTraceEnabled()) {
        logger.trace("{} master marked shard as initializing, but shard has state [{}], resending shard started to {}",indexShard.shardId(),indexShard.state(),nodes.masterNode());
      }
      if (nodes.masterNode() != null) {
        shardStateAction.shardStarted(shardRouting,indexMetaData.getUUID(),"master " + nodes.masterNode() + " marked shard as initializing, but shard state is ["+ indexShard.state()+ "], mark shard as started",nodes.masterNode());
      }
      return;
    }
 else {
      if (indexShard.ignoreRecoveryAttempt()) {
        logger.trace("ignoring recovery instruction for an existing shard {} (shard state: [{}])",indexShard.shardId(),indexShard.state());
        return;
      }
    }
  }
  DiscoveryNode sourceNode=null;
  if (isPeerRecovery(shardRouting)) {
    sourceNode=findSourceNodeForPeerRecovery(routingTable,nodes,shardRouting);
  }
  if (!indexService.hasShard(shardId)) {
    if (failedShards.containsKey(shardRouting.shardId())) {
      logger.trace("[{}][{}] not initializing, this shards failed to recover on this node before, waiting for reassignment",shardRouting.index(),shardRouting.id());
      return;
    }
    try {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}] creating shard",shardRouting.index(),shardId);
      }
      InternalIndexShard indexShard=(InternalIndexShard)indexService.createShard(shardId);
      indexShard.routingEntry(shardRouting);
      indexShard.engine().addFailedEngineListener(failedEngineHandler);
    }
 catch (    IndexShardAlreadyExistsException e) {
    }
catch (    Throwable e) {
      logger.warn("[{}][{}] failed to create shard",e,shardRouting.index(),shardRouting.id());
      try {
        indexService.removeShard(shardId,"failed to create [" + ExceptionsHelper.detailedMessage(e) + "]");
      }
 catch (      IndexShardMissingException e1) {
      }
catch (      Throwable e1) {
        logger.warn("[{}][{}] failed to remove shard after failed creation",e1,shardRouting.index(),shardRouting.id());
      }
      failedShards.put(shardRouting.shardId(),new FailedShard(shardRouting.version()));
      if (nodes.masterNode() != null) {
        shardStateAction.shardFailed(shardRouting,indexMetaData.getUUID(),"Failed to create shard, message [" + detailedMessage(e) + "]",nodes.masterNode());
      }
 else {
        logger.debug("can't send shard failed for {} as there is no current master",shardRouting.shardId());
      }
      return;
    }
  }
  final InternalIndexShard indexShard=(InternalIndexShard)indexService.shardSafe(shardId);
  if (indexShard.ignoreRecoveryAttempt()) {
    logger.trace("ignoring recovery instruction for shard {} (shard state: [{}])",indexShard.shardId(),indexShard.state());
    return;
  }
  if (sourceNode != null) {
    try {
      RecoveryState.Type type=shardRouting.primary() ? RecoveryState.Type.RELOCATION : RecoveryState.Type.REPLICA;
      final Store store=indexShard.store();
      final StartRecoveryRequest request;
      store.incRef();
      try {
        store.failIfCorrupted();
        request=new StartRecoveryRequest(indexShard.shardId(),sourceNode,nodes.localNode(),false,store.getMetadata().asMap(),type,recoveryIdGenerator.incrementAndGet());
      }
  finally {
        store.decRef();
      }
      recoveryTarget.startRecovery(request,indexShard,new PeerRecoveryListener(request,shardRouting,indexService,indexMetaData));
    }
 catch (    Throwable e) {
      indexShard.engine().failEngine("corrupted preexisting index",e);
      handleRecoveryFailure(indexService,indexMetaData,shardRouting,true,e);
    }
  }
 else {
    boolean indexShouldExists=indexShardRouting.primaryAllocatedPostApi();
    IndexShardGatewayService shardGatewayService=indexService.shardInjector(shardId).getInstance(IndexShardGatewayService.class);
    shardGatewayService.recover(indexShouldExists,new IndexShardGatewayService.RecoveryListener(){
      @Override public void onRecoveryDone(){
        shardStateAction.shardStarted(shardRouting,indexMetaData.getUUID(),"after recovery from gateway");
      }
      @Override public void onIgnoreRecovery(      String reason){
      }
      @Override public void onRecoveryFailed(      IndexShardGatewayRecoveryException e){
        handleRecoveryFailure(indexService,indexMetaData,shardRouting,true,e);
      }
    }
);
  }
}
