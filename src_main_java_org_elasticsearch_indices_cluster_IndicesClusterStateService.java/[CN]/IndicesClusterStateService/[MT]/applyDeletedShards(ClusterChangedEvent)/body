{
  RoutingNode routingNode=event.state().readOnlyRoutingNodes().nodesToShards().get(event.state().nodes().localNodeId());
  if (routingNode == null) {
    return;
  }
  TIntHashSet newShardIds=new TIntHashSet();
  for (  IndexService indexService : indicesService) {
    String index=indexService.index().name();
    IndexMetaData indexMetaData=event.state().metaData().index(index);
    if (indexMetaData == null) {
      continue;
    }
    newShardIds.clear();
    List<MutableShardRouting> shards=routingNode.shards();
    for (int i=0; i < shards.size(); i++) {
      ShardRouting shardRouting=shards.get(i);
      if (shardRouting.index().equals(index)) {
        newShardIds.add(shardRouting.id());
      }
    }
    for (    Integer existingShardId : indexService.shardIds()) {
      if (!newShardIds.contains(existingShardId)) {
        if (indexMetaData.state() == IndexMetaData.State.CLOSE) {
          if (logger.isDebugEnabled()) {
            logger.debug("[{}][{}] removing shard (index is closed)",index,existingShardId);
          }
          indexService.removeShard(existingShardId,"removing shard (index is closed)");
        }
 else {
          if (logger.isDebugEnabled()) {
            logger.debug("[{}][{}] removing shard (not allocated)",index,existingShardId);
          }
          indexService.removeShard(existingShardId,"removing shard (not allocated)");
        }
      }
    }
  }
}
