{
  if (!indicesService.changesAllowed()) {
    return;
  }
  RoutingTable routingTable=event.state().routingTable();
  RoutingNodes.RoutingNodeIterator routingNode=event.state().readOnlyRoutingNodes().routingNodeIter(event.state().nodes().localNodeId());
  if (routingNode == null) {
    failedShards.clear();
    return;
  }
  DiscoveryNodes nodes=event.state().nodes();
  for (  final ShardRouting shardRouting : routingNode) {
    final IndexService indexService=indicesService.indexService(shardRouting.index());
    if (indexService == null) {
      continue;
    }
    final IndexMetaData indexMetaData=event.state().metaData().index(shardRouting.index());
    if (indexMetaData == null) {
      continue;
    }
    final int shardId=shardRouting.id();
    if (!indexService.hasShard(shardId) && shardRouting.started()) {
      if (failedShards.containsKey(shardRouting.shardId())) {
        if (nodes.masterNode() != null) {
          shardStateAction.resendShardFailed(shardRouting,indexMetaData.getUUID(),"master " + nodes.masterNode() + " marked shard as started, but shard has previous failed. resending shard failure.",nodes.masterNode());
        }
      }
 else {
        sendFailShard(shardRouting,indexMetaData.getUUID(),"master [" + nodes.masterNode() + "] marked shard as started, but shard has not been created, mark shard as failed",null);
      }
      continue;
    }
    IndexShard indexShard=indexService.shard(shardId);
    if (indexShard != null) {
      ShardRouting currentRoutingEntry=indexShard.routingEntry();
      boolean shardHasBeenRemoved=false;
      if (currentRoutingEntry.initializing() && shardRouting.initializing() && !currentRoutingEntry.equals(shardRouting)) {
        logger.debug("[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])",shardRouting.index(),shardRouting.id(),currentRoutingEntry,shardRouting);
        indexService.removeShard(shardRouting.id(),"removing shard (different instance of it allocated on this node)");
        shardHasBeenRemoved=true;
      }
 else       if (isPeerRecovery(shardRouting)) {
        final DiscoveryNode sourceNode=findSourceNodeForPeerRecovery(routingTable,nodes,shardRouting);
        final Predicate<RecoveryStatus> shouldCancel=new Predicate<RecoveryStatus>(){
          @Override public boolean apply(          @Nullable RecoveryStatus status){
            return status.sourceNode().equals(sourceNode) == false;
          }
        }
;
        if (recoveryTarget.cancelRecoveriesForShard(indexShard.shardId(),"recovery source node changed",shouldCancel)) {
          logger.debug("[{}][{}] removing shard (recovery source changed), current [{}], global [{}])",shardRouting.index(),shardRouting.id(),currentRoutingEntry,shardRouting);
          indexService.removeShard(shardRouting.id(),"removing shard (recovery source node changed)");
          shardHasBeenRemoved=true;
        }
      }
      if (shardHasBeenRemoved == false && (shardRouting.equals(indexShard.routingEntry()) == false || shardRouting.version() > indexShard.routingEntry().version())) {
        if (shardRouting.primary() && indexShard.routingEntry().primary() == false && shardRouting.initializing() && indexShard.allowsPrimaryPromotion() == false) {
          logger.debug("{} reinitialize shard on primary promotion",indexShard.shardId());
          indexService.removeShard(shardId,"promoted to primary");
        }
 else {
          indexShard.updateRoutingEntry(shardRouting,event.state().blocks().disableStatePersistence() == false);
          indexService.shardInjectorSafe(shardId).getInstance(IndexShardGatewayService.class).routingStateChanged();
        }
      }
    }
    if (shardRouting.initializing()) {
      applyInitializingShard(event.state(),indexMetaData,shardRouting);
    }
  }
}
