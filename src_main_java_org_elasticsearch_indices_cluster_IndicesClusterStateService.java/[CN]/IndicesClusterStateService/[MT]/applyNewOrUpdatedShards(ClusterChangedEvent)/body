{
  if (!indicesService.changesAllowed()) {
    return;
  }
  RoutingTable routingTable=event.state().routingTable();
  RoutingNodes.RoutingNodeIterator routingNode=event.state().readOnlyRoutingNodes().routingNodeIter(event.state().nodes().localNodeId());
  if (routingNode == null) {
    failedShards.clear();
    return;
  }
  DiscoveryNodes nodes=event.state().nodes();
  for (  final ShardRouting shardRouting : routingNode) {
    final IndexService indexService=indicesService.indexService(shardRouting.index());
    if (indexService == null) {
      continue;
    }
    final IndexMetaData indexMetaData=event.state().metaData().index(shardRouting.index());
    if (indexMetaData == null) {
      continue;
    }
    final int shardId=shardRouting.id();
    if (!indexService.hasShard(shardId) && shardRouting.started()) {
      if (failedShards.containsKey(shardRouting.shardId())) {
        if (nodes.masterNode() != null) {
          shardStateAction.resendShardFailed(shardRouting,indexMetaData.getUUID(),"master " + nodes.masterNode() + " marked shard as started, but shard has previous failed. resending shard failure.",nodes.masterNode());
        }
      }
 else {
        logger.warn("[{}][{}] master [{}] marked shard as started, but shard has not been created, mark shard as failed",shardRouting.index(),shardId,nodes.masterNode());
        failedShards.put(shardRouting.shardId(),new FailedShard(shardRouting.version()));
        if (nodes.masterNode() != null) {
          shardStateAction.shardFailed(shardRouting,indexMetaData.getUUID(),"master " + nodes.masterNode() + " marked shard as started, but shard has not been created, mark shard as failed",nodes.masterNode());
        }
      }
      continue;
    }
    InternalIndexShard indexShard=(InternalIndexShard)indexService.shard(shardId);
    if (indexShard != null) {
      ShardRouting currentRoutingEntry=indexShard.routingEntry();
      boolean shardHasBeenRemoved=false;
      if (currentRoutingEntry.initializing() && shardRouting.initializing() && !currentRoutingEntry.equals(shardRouting)) {
        logger.debug("[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])",shardRouting.index(),shardRouting.id(),currentRoutingEntry,shardRouting);
        indexService.removeShard(shardRouting.id(),"removing shard (different instance of it allocated on this node)");
        shardHasBeenRemoved=true;
      }
 else       if (isPeerRecovery(shardRouting)) {
        RecoveryState recoveryState=recoveryTarget.recoveryState(indexShard);
        if (recoveryState != null && recoveryState.getStage() != RecoveryState.Stage.DONE) {
          DiscoveryNode sourceNode=findSourceNodeForPeerRecovery(routingTable,nodes,shardRouting);
          if (!recoveryState.getSourceNode().equals(sourceNode)) {
            logger.debug("[{}][{}] removing shard (recovery source changed), current [{}], global [{}])",shardRouting.index(),shardRouting.id(),currentRoutingEntry,shardRouting);
            indexService.removeShard(shardRouting.id(),"removing shard (recovery source node changed)");
            shardHasBeenRemoved=true;
          }
        }
      }
      if (shardHasBeenRemoved == false && !shardRouting.equals(indexShard.routingEntry())) {
        indexShard.routingEntry(shardRouting);
        indexService.shardInjectorSafe(shardId).getInstance(IndexShardGatewayService.class).routingStateChanged();
      }
    }
    if (shardRouting.initializing()) {
      applyInitializingShard(routingTable,nodes,indexMetaData,routingTable.index(shardRouting.index()).shard(shardRouting.id()),shardRouting);
    }
  }
}
