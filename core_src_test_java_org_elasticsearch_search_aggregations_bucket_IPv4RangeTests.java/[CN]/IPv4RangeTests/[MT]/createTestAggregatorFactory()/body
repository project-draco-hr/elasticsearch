{
  int numRanges=randomIntBetween(1,10);
  IPv4RangeAggregatorFactory factory=new IPv4RangeAggregatorFactory("foo");
  for (int i=0; i < numRanges; i++) {
    String key=null;
    if (randomBoolean()) {
      key=randomAsciiOfLengthBetween(1,20);
    }
    if (randomBoolean()) {
      double from=randomBoolean() ? Double.NEGATIVE_INFINITY : randomIntBetween(Integer.MIN_VALUE,Integer.MAX_VALUE - 1000);
      double to=randomBoolean() ? Double.POSITIVE_INFINITY : (Double.isInfinite(from) ? randomIntBetween(Integer.MIN_VALUE,Integer.MAX_VALUE) : randomIntBetween((int)from,Integer.MAX_VALUE));
      if (randomBoolean()) {
        factory.addRange(new Range(key,from,to));
      }
 else {
        String fromAsStr=Double.isInfinite(from) ? null : IpFieldMapper.longToIp((long)from);
        String toAsStr=Double.isInfinite(to) ? null : IpFieldMapper.longToIp((long)to);
        factory.addRange(new Range(key,fromAsStr,toAsStr));
      }
    }
 else {
      int mask=randomInt(32);
      long ipAsLong=randomIntBetween(0,Integer.MAX_VALUE);
      long blockSize=1L << (32 - mask);
      ipAsLong=ipAsLong - (ipAsLong & (blockSize - 1));
      String cidr=Cidrs.createCIDR(ipAsLong,mask);
      factory.addRange(new Range(key,cidr));
    }
  }
  factory.field(INT_FIELD_NAME);
  if (randomBoolean()) {
    factory.keyed(randomBoolean());
  }
  if (randomBoolean()) {
    factory.missing(randomIntBetween(0,10));
  }
  return factory;
}
