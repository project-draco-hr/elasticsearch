{
  int nodes=randomIntBetween(1,3);
  Settings nodeSettings=ImmutableSettings.builder().put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED,true).build();
  internalCluster().startNodesAsync(nodes,nodeSettings).get();
  client().admin().cluster().prepareHealth().setWaitForNodes(nodes + "").get();
  client().prepareIndex("test","doc","1").setSource("foo",5).setRefresh(true).get();
  testSuccess("");
  testSuccess("def list = [doc['foo'].value, 3, 4]; def v = list.get(1); list.add(10)");
  testSuccess("def range = 1..doc['foo'].value; def v = range.get(0)");
  testSuccess("def v = doc['foo'].value; def m = [:]; m.put(\\\"value\\\", v)");
  testSuccess("def t = Instant.now().getMillis()");
  testSuccess("def n = [1,2,3]; GroovyCollections.max(n)");
  testSuccess("def s = String.format(\\\"%d\\\", 4)");
  testFailure("pr = Runtime.getRuntime().exec(\\\"touch /tmp/gotcha\\\"); pr.waitFor()","Method calls not allowed on [java.lang.Runtime]");
  testFailure("d = new DateTime(); d.getClass().getDeclaredMethod(\\\"plus\\\").setAccessible(true)","Expression [MethodCallExpression] is not allowed: d.getClass()");
  testFailure("d = new DateTime(); d.\\\"${'get' + 'Class'}\\\"()." + "\\\"${'getDeclared' + 'Method'}\\\"(\\\"now\\\").\\\"${'set' + 'Accessible'}\\\"(false)","Expression [MethodCallExpression] is not allowed: d.$(get + Class)().$(getDeclared + Method)(now).$(set + Accessible)(false)");
  testFailure("Class.forName(\\\"DateTime\\\").getDeclaredMethod(\\\"plus\\\").setAccessible(true)","Expression [MethodCallExpression] is not allowed: java.lang.Class.forName(DateTime)");
  testFailure("Eval.me('2 + 2')","Method calls not allowed on [groovy.util.Eval]");
  testFailure("Eval.x(5, 'x + 2')","Method calls not allowed on [groovy.util.Eval]");
  testFailure("t = new java.util.concurrent.ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, " + "new java.util.concurrent.LinkedBlockingQueue<Runnable>()); t.execute({ println 5 })","Expression [ConstructorCallExpression] is not allowed: new java.util.concurrent.ThreadPoolExecutor");
  testFailure("d = new Date(); java.lang.reflect.Field f = Date.class.getDeclaredField(\\\"fastTime\\\");" + " f.setAccessible(true); f.get(\\\"fastTime\\\")","Method calls not allowed on [java.lang.reflect.Field]");
  testFailure("t = new Thread({ println 3 }); t.start(); t.join()","Expression [ConstructorCallExpression] is not allowed: new java.lang.Thread");
  testFailure("Thread.start({ println 4 })","Method calls not allowed on [java.lang.Thread]");
  testFailure("import java.util.concurrent.ThreadPoolExecutor;","Importing [java.util.concurrent.ThreadPoolExecutor] is not allowed");
  testFailure("s = new java.net.URL();","Expression [ConstructorCallExpression] is not allowed: new java.net.URL()");
  testFailure("def methodName = 'ex'; Runtime.\\\"${'get' + 'Runtime'}\\\"().\\\"${methodName}ec\\\"(\\\"touch /tmp/gotcha2\\\")","Expression [MethodCallExpression] is not allowed: java.lang.Runtime.$(get + Runtime)().$methodNameec(touch /tmp/gotcha2)");
  testFailure("def c = [doc['foo'].value, 3, 4].&size;  c()","Expression [MethodPointerExpression] is not allowed");
  testFailure("[doc['foo'].value, 3, 4].invokeMethod([1,2],\\\"size\\\", new Object[0])","Expression [MethodCallExpression] is not allowed: [doc[foo].value, 3, 4].invokeMethod([1, 2], size, [])");
}
