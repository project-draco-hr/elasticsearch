{
  ClusterState state=clusterService.state();
  String[] concreteIndices=state.metaData().concreteIndices(request.indicesOptions(),request.indices());
  GroupShardsIterator primaries=state.routingTable().activePrimaryShardsGrouped(concreteIndices,true);
  final Set<SyncedFlushService.SyncedFlushResult> results=ConcurrentCollections.newConcurrentSet();
  final CountDown countDown=new CountDown(primaries.size());
  for (  final ShardIterator shard : primaries) {
    if (shard.size() == 0) {
      results.add(new SyncedFlushService.SyncedFlushResult(shard.shardId(),"no active primary available"));
      if (countDown.countDown()) {
        listener.onResponse(new SealIndicesResponse(results));
      }
    }
 else {
      final ShardId shardId=shard.shardId();
      syncedFlushService.attemptSyncedFlush(shardId,new ActionListener<SyncedFlushService.SyncedFlushResult>(){
        @Override public void onResponse(        SyncedFlushService.SyncedFlushResult syncedFlushResult){
          results.add(syncedFlushResult);
          if (countDown.countDown()) {
            listener.onResponse(new SealIndicesResponse(results));
          }
        }
        @Override public void onFailure(        Throwable e){
          logger.debug("{} unexpected error while executing synced flush",shardId);
          results.add(new SyncedFlushService.SyncedFlushResult(shardId,e.getMessage()));
          if (countDown.countDown()) {
            listener.onResponse(new SealIndicesResponse(results));
          }
        }
      }
);
    }
  }
}
