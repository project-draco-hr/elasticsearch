{
  final Map<String,StorageMetadata> allMetaDatas=listAllMetadatas(container,shardTranslogDirectory);
  long latestTranslogId=-1;
  for (  String name : allMetaDatas.keySet()) {
    String translogName=name.substring(shardTranslogDirectory.length() + 1);
    long translogId=Long.parseLong(translogName.substring(0,translogName.lastIndexOf('.')));
    if (translogId > latestTranslogId) {
      latestTranslogId=translogId;
    }
  }
  if (latestTranslogId == -1) {
    indexShard.start();
    return new RecoveryStatus.Translog(0);
  }
  try {
    ArrayList<Translog.Operation> operations=Lists.newArrayList();
    long size=0;
    int index=1;
    while (true) {
      String translogPartName=shardTranslogDirectory + "/" + String.valueOf(latestTranslogId)+ "."+ index;
      if (!allMetaDatas.containsKey(translogPartName)) {
        break;
      }
      Blob blob=blobStoreContext.getBlobStore().getBlob(container,translogPartName);
      if (blob == null) {
        break;
      }
      size+=blob.getContentLength();
      InputStreamStreamInput streamInput=new InputStreamStreamInput(blob.getContent());
      int numberOfOperations=streamInput.readInt();
      for (int i=0; i < numberOfOperations; i++) {
        operations.add(readTranslogOperation(streamInput));
      }
      index++;
    }
    currentTranslogPartToWrite=index;
    indexShard.performRecoveryPrepareForTranslog();
    indexShard.performRecoveryFinalization(true);
    return new RecoveryStatus.Translog(operations.size());
  }
 catch (  Exception e) {
    throw new IndexShardGatewayRecoveryException(shardId(),"Failed to perform recovery of translog",e);
  }
}
