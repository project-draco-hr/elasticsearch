{
  long totalTimeStart=System.currentTimeMillis();
  boolean indexDirty=false;
  final SnapshotIndexCommit snapshotIndexCommit=snapshot.indexCommit();
  final Translog.Snapshot translogSnapshot=snapshot.translogSnapshot();
  Map<String,StorageMetadata> allIndicesMetadata=null;
  int indexNumberOfFiles=0;
  long indexTotalFilesSize=0;
  long indexTime=0;
  if (snapshot.indexChanged()) {
    long time=System.currentTimeMillis();
    indexDirty=true;
    allIndicesMetadata=listAllMetadatas(container,shardIndexDirectory);
    final CountDownLatch latch=new CountDownLatch(snapshotIndexCommit.getFiles().length);
    final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
    for (    final String fileName : snapshotIndexCommit.getFiles()) {
      if (fileName.equals(snapshotIndexCommit.getSegmentsFileName())) {
        latch.countDown();
        continue;
      }
      IndexInput indexInput=null;
      try {
        indexInput=snapshotIndexCommit.getDirectory().openInput(fileName);
        long totalLength=0;
        int counter=0;
        while (true) {
          String blobName=shardIndexDirectory + "/" + fileName;
          if (counter > 0) {
            blobName=blobName + ".part" + counter;
          }
          StorageMetadata metadata=allIndicesMetadata.get(blobName);
          if (metadata == null) {
            break;
          }
          totalLength+=metadata.getSize();
          counter++;
        }
        if (totalLength == indexInput.length()) {
          latch.countDown();
          continue;
        }
      }
 catch (      Exception e) {
        logger.debug("Failed to verify file equality based on length, copying...",e);
      }
 finally {
        if (indexInput != null) {
          try {
            indexInput.close();
          }
 catch (          IOException e) {
          }
        }
      }
      indexNumberOfFiles++;
      try {
        indexTotalFilesSize+=snapshotIndexCommit.getDirectory().fileLength(fileName);
      }
 catch (      IOException e) {
      }
      deleteFile(shardIndexDirectory + "/" + fileName,allIndicesMetadata);
      try {
        copyFromDirectory(snapshotIndexCommit.getDirectory(),fileName,latch,failures);
      }
 catch (      Exception e) {
        failures.add(e);
        latch.countDown();
      }
    }
    try {
      latch.await();
    }
 catch (    InterruptedException e) {
      failures.add(e);
    }
    if (!failures.isEmpty()) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to perform snapshot (index files)",failures.get(failures.size() - 1));
    }
    indexTime=System.currentTimeMillis() - time;
  }
  int translogNumberOfOperations=0;
  long translogTime=0;
  if (snapshot.newTranslogCreated()) {
    currentTranslogPartToWrite=1;
    String translogBlobName=shardTranslogDirectory + "/" + String.valueOf(translogSnapshot.translogId())+ "."+ currentTranslogPartToWrite;
    try {
      long time=System.currentTimeMillis();
      BytesStreamOutput streamOutput=BytesStreamOutput.Cached.cached();
      streamOutput.writeInt(translogSnapshot.size());
      for (      Translog.Operation operation : translogSnapshot) {
        translogNumberOfOperations++;
        writeTranslogOperation(streamOutput,operation);
      }
      Blob blob=blobStoreContext.getBlobStore().newBlob(translogBlobName);
      blob.setContentLength(streamOutput.size());
      blob.setPayload(new FastByteArrayInputStream(streamOutput.unsafeByteArray(),0,streamOutput.size()));
      blobStoreContext.getBlobStore().putBlob(container,blob);
      currentTranslogPartToWrite++;
      translogTime=System.currentTimeMillis() - time;
    }
 catch (    Exception e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to snapshot translog into [" + translogBlobName + "]",e);
    }
  }
 else   if (snapshot.sameTranslogNewOperations()) {
    String translogBlobName=shardTranslogDirectory + "/" + String.valueOf(translogSnapshot.translogId())+ "."+ currentTranslogPartToWrite;
    try {
      long time=System.currentTimeMillis();
      BytesStreamOutput streamOutput=BytesStreamOutput.Cached.cached();
      streamOutput.writeInt(translogSnapshot.size() - snapshot.lastTranslogSize());
      for (      Translog.Operation operation : translogSnapshot.skipTo(snapshot.lastTranslogSize())) {
        translogNumberOfOperations++;
        writeTranslogOperation(streamOutput,operation);
      }
      Blob blob=blobStoreContext.getBlobStore().newBlob(translogBlobName);
      blob.setContentLength(streamOutput.size());
      blob.setPayload(new FastByteArrayInputStream(streamOutput.unsafeByteArray(),0,streamOutput.size()));
      blobStoreContext.getBlobStore().putBlob(container,blob);
      currentTranslogPartToWrite++;
      translogTime=System.currentTimeMillis() - time;
    }
 catch (    Exception e) {
      throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to append snapshot translog into [" + translogBlobName + "]",e);
    }
  }
  try {
    if (indexDirty) {
      indexNumberOfFiles++;
      deleteFile(snapshotIndexCommit.getSegmentsFileName(),allIndicesMetadata);
      indexTotalFilesSize+=snapshotIndexCommit.getDirectory().fileLength(snapshotIndexCommit.getSegmentsFileName());
      long time=System.currentTimeMillis();
      IndexInput indexInput=snapshotIndexCommit.getDirectory().openInput(snapshotIndexCommit.getSegmentsFileName());
      try {
        Blob blob=blobStoreContext.getBlobStore().newBlob(shardIndexDirectory + "/" + snapshotIndexCommit.getSegmentsFileName());
        InputStreamIndexInput is=new InputStreamIndexInput(indexInput,Long.MAX_VALUE);
        blob.setPayload(is);
        blob.setContentLength(is.actualSizeToRead());
        blobStoreContext.getBlobStore().putBlob(container,blob);
      }
  finally {
        try {
          indexInput.close();
        }
 catch (        Exception e) {
        }
      }
      indexTime+=(System.currentTimeMillis() - time);
    }
  }
 catch (  Exception e) {
    throw new IndexShardGatewaySnapshotFailedException(shardId(),"Failed to finalize index snapshot into [" + snapshotIndexCommit.getSegmentsFileName() + "]",e);
  }
  if (snapshot.newTranslogCreated()) {
    String currentTranslogPrefix=shardTranslogDirectory + "/" + String.valueOf(translogSnapshot.translogId())+ ".";
    Map<String,StorageMetadata> allMetadatas=listAllMetadatas(container,shardTranslogDirectory);
    for (    Map.Entry<String,StorageMetadata> entry : allMetadatas.entrySet()) {
      if (!entry.getKey().startsWith(currentTranslogPrefix)) {
        blobStoreContext.getAsyncBlobStore().removeBlob(container,entry.getKey());
      }
    }
  }
  if (indexDirty) {
    for (    Map.Entry<String,StorageMetadata> entry : allIndicesMetadata.entrySet()) {
      String blobNameToMatch=entry.getKey();
      if (blobNameToMatch.contains(".part")) {
        blobNameToMatch=blobNameToMatch.substring(0,blobNameToMatch.indexOf(".part"));
      }
      blobNameToMatch=blobNameToMatch.substring(shardIndexDirectory.length() + 1);
      boolean found=false;
      for (      final String fileName : snapshotIndexCommit.getFiles()) {
        if (blobNameToMatch.equals(fileName)) {
          found=true;
          break;
        }
      }
      if (!found) {
        blobStoreContext.getAsyncBlobStore().removeBlob(container,entry.getKey());
      }
    }
  }
  return new SnapshotStatus(new TimeValue(System.currentTimeMillis() - totalTimeStart),new SnapshotStatus.Index(indexNumberOfFiles,new SizeValue(indexTotalFilesSize),new TimeValue(indexTime)),new SnapshotStatus.Translog(translogNumberOfOperations,new TimeValue(translogTime)));
}
