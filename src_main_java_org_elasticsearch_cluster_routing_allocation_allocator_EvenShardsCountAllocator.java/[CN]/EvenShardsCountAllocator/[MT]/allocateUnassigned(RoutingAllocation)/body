{
  boolean changed=false;
  RoutingNodes routingNodes=allocation.routingNodes();
  RoutingNode[] nodes=sortedNodesLeastToHigh(allocation);
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  int lastNode=0;
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    for (int i=0; i < nodes.length; i++) {
      RoutingNode node=nodes[lastNode];
      lastNode++;
      if (lastNode == nodes.length) {
        lastNode=0;
      }
      Decision decision=allocation.deciders().canAllocate(shard,node,allocation);
      if (decision.type() == Decision.Type.YES) {
        int numberOfShardsToAllocate=routingNodes.requiredAverageNumberOfShardsPerNode() - node.shards().size();
        if (numberOfShardsToAllocate <= 0) {
          continue;
        }
        changed=true;
        allocation.routingNodes().assignShardToNode(shard,node.nodeId());
        unassignedIterator.remove();
        break;
      }
    }
  }
  for (Iterator<MutableShardRouting> it=routingNodes.unassigned().iterator(); it.hasNext(); ) {
    MutableShardRouting shard=it.next();
    for (    RoutingNode routingNode : sortedNodesLeastToHigh(allocation)) {
      Decision decision=allocation.deciders().canAllocate(shard,routingNode,allocation);
      if (decision.type() == Decision.Type.YES) {
        changed=true;
        allocation.routingNodes().assignShardToNode(shard,routingNode.nodeId());
        it.remove();
        break;
      }
    }
  }
  return changed;
}
