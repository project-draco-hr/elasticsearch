{
  boolean changed=false;
  RoutingNode[] sortedNodesLeastToHigh=sortedNodesLeastToHigh(allocation);
  if (sortedNodesLeastToHigh.length == 0) {
    return false;
  }
  int lowIndex=0;
  int highIndex=sortedNodesLeastToHigh.length - 1;
  boolean relocationPerformed;
  do {
    relocationPerformed=false;
    while (lowIndex != highIndex) {
      RoutingNode lowRoutingNode=sortedNodesLeastToHigh[lowIndex];
      RoutingNode highRoutingNode=sortedNodesLeastToHigh[highIndex];
      int averageNumOfShards=allocation.routingNodes().requiredAverageNumberOfShardsPerNode();
      if (highRoutingNode.numberOfOwningShards() <= averageNumOfShards) {
        highIndex--;
        continue;
      }
      if (lowRoutingNode.shards().size() >= averageNumOfShards) {
        lowIndex++;
        continue;
      }
      boolean relocated=false;
      List<MutableShardRouting> startedShards=highRoutingNode.shardsWithState(STARTED);
      for (      MutableShardRouting startedShard : startedShards) {
        Decision rebalanceDecision=allocation.deciders().canRebalance(startedShard,allocation);
        if (rebalanceDecision.type() == Decision.Type.NO) {
          continue;
        }
        Decision allocateDecision=allocation.deciders().canAllocate(startedShard,lowRoutingNode,allocation);
        if (allocateDecision.type() == Decision.Type.YES) {
          changed=true;
          allocation.routingNodes().assignShardToNode(new MutableShardRouting(startedShard.index(),startedShard.id(),lowRoutingNode.nodeId(),startedShard.currentNodeId(),startedShard.restoreSource(),startedShard.primary(),INITIALIZING,startedShard.version() + 1),lowRoutingNode.nodeId());
          allocation.routingNodes().relocateShard(startedShard,lowRoutingNode.nodeId());
          relocated=true;
          relocationPerformed=true;
          break;
        }
      }
      if (!relocated) {
        highIndex--;
      }
    }
  }
 while (relocationPerformed);
  return changed;
}
