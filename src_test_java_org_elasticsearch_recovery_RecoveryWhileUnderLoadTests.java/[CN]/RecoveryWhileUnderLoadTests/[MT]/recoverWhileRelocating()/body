{
  final int numShards=between(2,10);
  final int numReplicas=0;
  cluster().ensureAtLeastNumNodes(3);
  logger.info("--> creating test index ...");
  int allowNodes=2;
  assertAcked(prepareCreate("test").setSettings(randomSettingsBuilder().put("number_of_shards",numShards).put("number_of_replicas",numReplicas).build()));
  final AtomicLong idGenerator=new AtomicLong();
  final AtomicLong indexCounter=new AtomicLong();
  final AtomicBoolean stop=new AtomicBoolean(false);
  Thread[] writers=new Thread[atLeast(3)];
  final CountDownLatch stopLatch=new CountDownLatch(writers.length);
  logger.info("--> starting {} indexing threads",writers.length);
  final CopyOnWriteArrayList<Throwable> failures=new CopyOnWriteArrayList<Throwable>();
  for (int i=0; i < writers.length; i++) {
    final int indexerId=i;
    final Client client=client();
    writers[i]=new Thread(){
      @Override public void run(){
        long id=-1;
        try {
          logger.info("**** starting indexing thread {}",indexerId);
          while (!stop.get()) {
            id=idGenerator.incrementAndGet();
            client.prepareIndex("test","type1",Long.toString(id) + "-" + indexerId).setSource(MapBuilder.<String,Object>newMapBuilder().put("test","value" + id).map()).execute().actionGet();
            indexCounter.incrementAndGet();
          }
          logger.info("**** done indexing thread {}",indexerId);
        }
 catch (        Throwable e) {
          failures.add(e);
          logger.warn("**** failed indexing thread {} on doc id {}",e,indexerId,id);
        }
 finally {
          stopLatch.countDown();
        }
      }
    }
;
    writers[i].start();
  }
  final int numDocs=between(10000,50000);
  for (int i=0; i < numDocs; i+=between(100,1000)) {
    assertThat(failures,emptyIterable());
    logger.info("--> waiting for {} docs to be indexed ...",i);
    waitForDocs(i);
    logger.info("--> {} docs indexed",i);
    allowNodes=2 / allowNodes;
    allowNodes("test",allowNodes);
    logger.info("--> waiting for GREEN health status ...");
    assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().execute().actionGet().isTimedOut(),equalTo(false));
  }
  logger.info("--> marking and waiting for indexing threads to stop ...");
  stop.set(true);
  assertThat(failures,emptyIterable());
  stopLatch.await();
  logger.info("--> indexing threads stopped");
  logger.info("--> bump up number of replicas to 1 and allow all nodes to hold the index");
  allowNodes("test",3);
  assertAcked(client().admin().indices().prepareUpdateSettings("test").setSettings(ImmutableSettings.settingsBuilder().put("number_of_replicas",1)).get());
  assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().execute().actionGet().isTimedOut(),equalTo(false));
  logger.info("--> refreshing the index");
  refreshAndAssert();
  logger.info("--> verifying indexed content");
  iterateAssertCount(5,indexCounter.get(),10);
}
