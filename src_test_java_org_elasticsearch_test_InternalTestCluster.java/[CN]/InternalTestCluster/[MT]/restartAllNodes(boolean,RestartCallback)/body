{
  ensureOpen();
  List<NodeAndClient> toRemove=new ArrayList<>();
  try {
    for (    NodeAndClient nodeAndClient : nodes.values()) {
      if (!callback.doRestart(nodeAndClient.name)) {
        logger.info("Closing node [{}] during restart",nodeAndClient.name);
        toRemove.add(nodeAndClient);
        nodeAndClient.close();
      }
    }
  }
  finally {
    for (    NodeAndClient nodeAndClient : toRemove) {
      nodes.remove(nodeAndClient.name);
    }
  }
  logger.info("Restarting remaining nodes rollingRestart [{}]",rollingRestart);
  if (rollingRestart) {
    int numNodesRestarted=0;
    for (    NodeAndClient nodeAndClient : nodes.values()) {
      callback.doAfterNodes(numNodesRestarted++,nodeAndClient.nodeClient());
      logger.info("Restarting node [{}] ",nodeAndClient.name);
      nodeAndClient.restart(callback);
    }
  }
 else {
    int numNodesRestarted=0;
    for (    NodeAndClient nodeAndClient : nodes.values()) {
      callback.doAfterNodes(numNodesRestarted++,nodeAndClient.nodeClient());
      logger.info("Stopping node [{}] ",nodeAndClient.name);
      nodeAndClient.node.close();
    }
    for (    NodeAndClient nodeAndClient : nodes.values()) {
      logger.info("Starting node [{}] ",nodeAndClient.name);
      nodeAndClient.restart(callback);
    }
  }
}
