{
  String[] boundAddressesHostStrings=new String[boundAddresses.size()];
  TransportAddress[] transportBoundAddresses=new TransportAddress[boundAddresses.size()];
  for (int i=0; i < boundAddresses.size(); i++) {
    InetSocketAddress boundAddress=boundAddresses.get(i);
    boundAddressesHostStrings[i]=boundAddress.getHostString();
    transportBoundAddresses[i]=new InetSocketTransportAddress(boundAddress);
  }
  final String[] publishHosts;
  if (TransportSettings.DEFAULT_PROFILE.equals(name)) {
    publishHosts=TransportSettings.PUBLISH_HOST.get(settings).toArray(Strings.EMPTY_ARRAY);
  }
 else {
    publishHosts=profileSettings.getAsArray("publish_host",boundAddressesHostStrings);
  }
  final InetAddress publishInetAddress;
  try {
    publishInetAddress=networkService.resolvePublishHostAddresses(publishHosts);
  }
 catch (  Exception e) {
    throw new BindTransportException("Failed to resolve publish address",e);
  }
  int publishPort;
  if (TransportSettings.DEFAULT_PROFILE.equals(name)) {
    publishPort=TransportSettings.PUBLISH_PORT.get(settings);
  }
 else {
    publishPort=profileSettings.getAsInt("publish_port",-1);
  }
  if (publishPort < 0) {
    for (    InetSocketAddress boundAddress : boundAddresses) {
      InetAddress boundInetAddress=boundAddress.getAddress();
      if (boundInetAddress.isAnyLocalAddress() || boundInetAddress.equals(publishInetAddress)) {
        publishPort=boundAddress.getPort();
        break;
      }
    }
  }
  if (publishPort < 0) {
    publishPort=boundAddresses.get(0).getPort();
    logger.warn("Publish port not found by matching publish address [{}] to bound addresses [{}], " + "falling back to port [{}] of first bound address",publishInetAddress,boundAddresses,publishPort);
  }
  final TransportAddress publishAddress=new InetSocketTransportAddress(new InetSocketAddress(publishInetAddress,publishPort));
  return new BoundTransportAddress(transportBoundAddresses,publishAddress);
}
