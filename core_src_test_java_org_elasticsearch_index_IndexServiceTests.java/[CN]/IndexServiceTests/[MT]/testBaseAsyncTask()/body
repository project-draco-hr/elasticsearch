{
  IndexService indexService=newIndexService();
  ThreadPool pool=indexService.getThreadPool();
  AtomicReference<CountDownLatch> latch=new AtomicReference<>(new CountDownLatch(1));
  AtomicReference<CountDownLatch> latch2=new AtomicReference<>(new CountDownLatch(1));
  final AtomicInteger count=new AtomicInteger();
  IndexService.BaseAsyncTask task=new IndexService.BaseAsyncTask(indexService,pool,TimeValue.timeValueMillis(1)){
    @Override protected void runInternal(){
      count.incrementAndGet();
      assertTrue("generic threadpool is configured",Thread.currentThread().getName().contains("[generic]"));
      latch.get().countDown();
      try {
        latch2.get().await();
      }
 catch (      InterruptedException e) {
        fail("interrupted");
      }
      if (randomBoolean()) {
        if (randomBoolean()) {
          throw new RuntimeException("foo");
        }
 else {
          throw new RuntimeException("bar");
        }
      }
    }
    @Override protected String getThreadPool(){
      return ThreadPool.Names.GENERIC;
    }
  }
;
  latch.get().await();
  latch.set(new CountDownLatch(1));
  assertEquals(1,count.get());
  latch2.get().countDown();
  latch2.set(new CountDownLatch(1));
  latch.get().await();
  assertEquals(2,count.get());
  task.close();
  latch2.get().countDown();
  assertEquals(2,count.get());
  task=new IndexService.BaseAsyncTask(indexService,pool,TimeValue.timeValueMillis(1000000)){
    @Override protected void runInternal(){
    }
  }
;
  assertTrue(task.mustReschedule());
  if (randomBoolean()) {
    for (    Integer id : indexService.shardIds()) {
      indexService.removeShard(id,"simon says");
    }
  }
 else {
    indexService.close("simon says",false);
  }
  assertFalse("no shards left",task.mustReschedule());
}
