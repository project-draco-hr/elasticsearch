{
  final Cast cast=new Cast(from,to);
  if (from.equals(to)) {
    return cast;
  }
  if (from.sort == Sort.DEF && to.sort != Sort.VOID || from.sort != Sort.VOID && to.sort == Sort.DEF) {
    final Transform transform=definition.transforms.get(cast);
    if (transform != null) {
      return transform;
    }
    return cast;
  }
switch (from.sort) {
case BOOL:
switch (to.sort) {
case OBJECT:
case BOOL_OBJ:
      return checkTransform(source,cast);
  }
break;
case BYTE:
switch (to.sort) {
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case CHAR:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case BYTE_OBJ:
case SHORT_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case CHAR_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case SHORT:
switch (to.sort) {
case INT:
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case CHAR:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case SHORT_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case CHAR:
switch (to.sort) {
case INT:
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case SHORT:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE_OBJ:
case SHORT_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case INT:
switch (to.sort) {
case LONG:
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case SHORT:
case CHAR:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case LONG:
switch (to.sort) {
case FLOAT:
case DOUBLE:
return cast;
case BYTE:
case SHORT:
case CHAR:
case INT:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case FLOAT:
switch (to.sort) {
case DOUBLE:
return cast;
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case DOUBLE:
switch (to.sort) {
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case FLOAT:
if (explicit) return cast;
break;
case OBJECT:
case NUMBER:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case OBJECT:
case NUMBER:
switch (to.sort) {
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case BOOL_OBJ:
switch (to.sort) {
case BOOL:
return checkTransform(source,cast);
}
break;
case BYTE_OBJ:
switch (to.sort) {
case BYTE:
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case SHORT_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case CHAR:
case CHAR_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case SHORT_OBJ:
switch (to.sort) {
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE:
case CHAR:
case BYTE_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case CHAR_OBJ:
switch (to.sort) {
case CHAR:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE:
case SHORT:
case BYTE_OBJ:
case SHORT_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case INT_OBJ:
switch (to.sort) {
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case LONG_OBJ:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE:
case SHORT:
case CHAR:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case LONG_OBJ:
switch (to.sort) {
case LONG:
case FLOAT:
case DOUBLE:
case FLOAT_OBJ:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE:
case SHORT:
case CHAR:
case INT:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case FLOAT_OBJ:
switch (to.sort) {
case FLOAT:
case DOUBLE:
case DOUBLE_OBJ:
return checkTransform(source,cast);
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
case DOUBLE_OBJ:
switch (to.sort) {
case DOUBLE:
return checkTransform(source,cast);
case BYTE:
case SHORT:
case CHAR:
case INT:
case LONG:
case FLOAT:
case BYTE_OBJ:
case SHORT_OBJ:
case CHAR_OBJ:
case INT_OBJ:
case LONG_OBJ:
case FLOAT_OBJ:
if (explicit) return checkTransform(source,cast);
break;
}
break;
}
try {
from.clazz.asSubclass(to.clazz);
return cast;
}
 catch (final ClassCastException cce0) {
try {
if (explicit) {
to.clazz.asSubclass(from.clazz);
return cast;
}
 else {
throw new ClassCastException(error(source) + "Cannot cast from [" + from.name+ "] to ["+ to.name+ "].");
}
}
 catch (final ClassCastException cce1) {
throw new ClassCastException(error(source) + "Cannot cast from [" + from.name+ "] to ["+ to.name+ "].");
}
}
}
