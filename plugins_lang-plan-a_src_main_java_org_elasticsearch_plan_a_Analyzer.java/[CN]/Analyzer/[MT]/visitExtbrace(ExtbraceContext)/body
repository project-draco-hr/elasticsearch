{
  final ExtNodeMetadata braceenmd=adapter.getExtNodeMetadata(ctx);
  final ParserRuleContext parent=braceenmd.parent;
  final ExternalMetadata parentemd=adapter.getExternalMetadata(parent);
  final boolean array=parentemd.current.sort == Sort.ARRAY;
  final boolean def=parentemd.current.sort == Sort.DEF;
  boolean map=false;
  boolean list=false;
  try {
    parentemd.current.clazz.asSubclass(Map.class);
    map=true;
  }
 catch (  ClassCastException exception) {
  }
  try {
    parentemd.current.clazz.asSubclass(List.class);
    list=true;
  }
 catch (  ClassCastException exception) {
  }
  final ExtdotContext dotctx=ctx.extdot();
  final ExtbraceContext bracectx=ctx.extbrace();
  braceenmd.last=parentemd.scope == 0 && dotctx == null && bracectx == null;
  final ExpressionContext exprctx=adapter.updateExpressionTree(ctx.expression());
  final ExpressionMetadata expremd=adapter.createExpressionMetadata(exprctx);
  if (array || def) {
    expremd.to=array ? definition.intType : definition.objectType;
    visit(exprctx);
    markCast(expremd);
    braceenmd.target="#brace";
    braceenmd.type=def ? definition.defType : definition.getType(parentemd.current.struct,parentemd.current.type.getDimensions() - 1);
    analyzeLoadStoreExternal(ctx);
    parentemd.current=braceenmd.type;
    if (dotctx != null) {
      adapter.createExtNodeMetadata(parent,dotctx);
      visit(dotctx);
    }
 else     if (bracectx != null) {
      adapter.createExtNodeMetadata(parent,bracectx);
      visit(bracectx);
    }
  }
 else {
    final boolean store=braceenmd.last && parentemd.storeExpr != null;
    final boolean get=parentemd.read || parentemd.token > 0 || !braceenmd.last;
    final boolean set=braceenmd.last && store;
    Method getter;
    Method setter;
    Type valuetype;
    Type settype;
    if (map) {
      getter=parentemd.current.struct.methods.get("get");
      setter=parentemd.current.struct.methods.get("put");
      if (getter != null && (getter.rtn.sort == Sort.VOID || getter.arguments.size() != 1)) {
        throw new IllegalArgumentException(error(ctx) + "Illegal map get shortcut for type [" + parentemd.current.name+ "].");
      }
      if (setter != null && setter.arguments.size() != 2) {
        throw new IllegalArgumentException(error(ctx) + "Illegal map set shortcut for type [" + parentemd.current.name+ "].");
      }
      if (getter != null && setter != null && (!getter.arguments.get(0).equals(setter.arguments.get(0)) || !getter.rtn.equals(setter.arguments.get(1)))) {
        throw new IllegalArgumentException(error(ctx) + "Shortcut argument types must match.");
      }
      valuetype=setter != null ? setter.arguments.get(0) : getter != null ? getter.arguments.get(0) : null;
      settype=setter == null ? null : setter.arguments.get(1);
    }
 else     if (list) {
      getter=parentemd.current.struct.methods.get("get");
      setter=parentemd.current.struct.methods.get("add");
      if (getter != null && (getter.rtn.sort == Sort.VOID || getter.arguments.size() != 1 || getter.arguments.get(0).sort != Sort.INT)) {
        throw new IllegalArgumentException(error(ctx) + "Illegal list get shortcut for type [" + parentemd.current.name+ "].");
      }
      if (setter != null && (setter.arguments.size() != 2 || setter.arguments.get(0).sort != Sort.INT)) {
        throw new IllegalArgumentException(error(ctx) + "Illegal list set shortcut for type [" + parentemd.current.name+ "].");
      }
      if (getter != null && setter != null && (!getter.arguments.get(0).equals(setter.arguments.get(0)) || !getter.rtn.equals(setter.arguments.get(1)))) {
        throw new IllegalArgumentException(error(ctx) + "Shortcut argument types must match.");
      }
      valuetype=definition.intType;
      settype=setter == null ? null : setter.arguments.get(1);
    }
 else {
      throw new IllegalStateException(error(ctx) + "Unexpected parser state.");
    }
    if ((get || set) && (!get || getter != null) && (!set || setter != null)) {
      expremd.to=valuetype;
      visit(exprctx);
      markCast(expremd);
      braceenmd.target=new Object[]{getter,setter,true,null};
      braceenmd.type=get ? getter.rtn : settype;
      analyzeLoadStoreExternal(ctx);
      parentemd.current=get ? getter.rtn : setter.rtn;
    }
  }
  if (braceenmd.target == null) {
    throw new IllegalArgumentException(error(ctx) + "Attempting to address a non-array type [" + parentemd.current.name+ "] as an array.");
  }
  return null;
}
