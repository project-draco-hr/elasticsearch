{
  if (!lifecycle.started()) {
    throw new ElasticSearchIllegalStateException("Can't add nodes to a stopped transport");
  }
  try {
    if (node == null) {
      throw new ConnectTransportException(node,"Can't connect to a null node");
    }
    NodeConnections nodeConnections=connectedNodes.get(node.id());
    if (nodeConnections != null) {
      return;
    }
synchronized (this) {
      nodeConnections=connectedNodes.get(node.id());
      if (nodeConnections != null) {
        return;
      }
      ArrayList<Channel> channels=new ArrayList<Channel>();
      Throwable lastConnectException=null;
      for (int connectionIndex=0; connectionIndex < connectionsPerNode; connectionIndex++) {
        for (int i=1; i <= connectRetries; i++) {
          if (!lifecycle.started()) {
            for (            Channel channel1 : channels) {
              channel1.close().awaitUninterruptibly();
            }
            throw new ConnectTransportException(node,"Can't connect when the transport is stopped");
          }
          InetSocketAddress address=((InetSocketTransportAddress)node.address()).address();
          ChannelFuture channelFuture=clientBootstrap.connect(address);
          channelFuture.awaitUninterruptibly((long)(connectTimeout.millis() * 1.25));
          if (!channelFuture.isSuccess()) {
            if (i == connectRetries && connectionIndex == 0) {
              lastConnectException=channelFuture.getCause();
              if (connectionIndex == 0) {
                throw new ConnectTransportException(node,"connectTimeout[" + connectTimeout + "], connectRetries["+ connectRetries+ "]",lastConnectException);
              }
 else {
                break;
              }
            }
 else {
              logger.trace("Retry #[" + i + "], connect to ["+ node+ "]");
              try {
                channelFuture.getChannel().close();
              }
 catch (              Exception e) {
              }
              continue;
            }
          }
          Channel channel=channelFuture.getChannel();
          if (!lifecycle.started()) {
            channel.close();
            for (            Channel channel1 : channels) {
              channel1.close().awaitUninterruptibly();
            }
            throw new ConnectTransportException(node,"Can't connect when the transport is stopped");
          }
          channel.getCloseFuture().addListener(new ChannelCloseListener(node.id()));
          channels.add(channel);
          break;
        }
      }
      if (channels.isEmpty()) {
        if (lastConnectException != null) {
          throw new ConnectTransportException(node,"connectTimeout[" + connectTimeout + "], connectRetries["+ connectRetries+ "]",lastConnectException);
        }
        throw new ConnectTransportException(node,"connectTimeout[" + connectTimeout + "], connectRetries["+ connectRetries+ "], reason unknown");
      }
      if (logger.isDebugEnabled()) {
        logger.debug("Connected to node[{}], number_of_connections[{}]",node,channels.size());
      }
      connectedNodes.put(node.id(),new NodeConnections(node,channels.toArray(new Channel[channels.size()])));
      transportServiceAdapter.raiseNodeConnected(node);
    }
  }
 catch (  Exception e) {
    throw new ConnectTransportException(node,"General node connection failure",e);
  }
}
