{
  int type=current.getType();
  String text=current.getText();
switch (type) {
case XJavascriptParser.AT_CALL:
    Tree identifier=current.getChild(0);
  String call=identifier.getText();
int arguments=current.getChildCount() - 1;
Method method=functions.get(call);
if (method == null) {
throw new IllegalArgumentException("Unrecognized method call (" + call + ").");
}
int arity=method.getParameterTypes().length;
if (arguments != arity) {
throw new IllegalArgumentException("Expected (" + arity + ") arguments for method call ("+ call+ "), but found ("+ arguments+ ").");
}
for (int argument=1; argument <= arguments; ++argument) {
recursiveCompile(current.getChild(argument),Type.DOUBLE_TYPE);
}
gen.invokeStatic(Type.getType(method.getDeclaringClass()),org.objectweb.asm.commons.Method.getMethod(method));
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case XJavascriptParser.VARIABLE:
int index;
text=normalizeQuotes(text);
if (externalsMap.containsKey(text)) {
index=externalsMap.get(text);
}
 else {
index=externalsMap.size();
externalsMap.put(text,index);
}
gen.loadArg(1);
gen.push(index);
gen.arrayLoad(FUNCTION_VALUES_TYPE);
gen.loadArg(0);
gen.invokeVirtual(FUNCTION_VALUES_TYPE,DOUBLE_VAL_METHOD);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case XJavascriptParser.HEX:
pushLong(expected,Long.parseLong(text.substring(2),16));
break;
case XJavascriptParser.OCTAL:
pushLong(expected,Long.parseLong(text.substring(1),8));
break;
case XJavascriptParser.DECIMAL:
gen.push(Double.parseDouble(text));
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case XJavascriptParser.AT_NEGATE:
recursiveCompile(current.getChild(0),Type.DOUBLE_TYPE);
gen.visitInsn(Opcodes.DNEG);
gen.cast(Type.DOUBLE_TYPE,expected);
break;
case XJavascriptParser.AT_ADD:
pushArith(Opcodes.DADD,current,expected);
break;
case XJavascriptParser.AT_SUBTRACT:
pushArith(Opcodes.DSUB,current,expected);
break;
case XJavascriptParser.AT_MULTIPLY:
pushArith(Opcodes.DMUL,current,expected);
break;
case XJavascriptParser.AT_DIVIDE:
pushArith(Opcodes.DDIV,current,expected);
break;
case XJavascriptParser.AT_MODULO:
pushArith(Opcodes.DREM,current,expected);
break;
case XJavascriptParser.AT_BIT_SHL:
pushShift(Opcodes.LSHL,current,expected);
break;
case XJavascriptParser.AT_BIT_SHR:
pushShift(Opcodes.LSHR,current,expected);
break;
case XJavascriptParser.AT_BIT_SHU:
pushShift(Opcodes.LUSHR,current,expected);
break;
case XJavascriptParser.AT_BIT_AND:
pushBitwise(Opcodes.LAND,current,expected);
break;
case XJavascriptParser.AT_BIT_OR:
pushBitwise(Opcodes.LOR,current,expected);
break;
case XJavascriptParser.AT_BIT_XOR:
pushBitwise(Opcodes.LXOR,current,expected);
break;
case XJavascriptParser.AT_BIT_NOT:
recursiveCompile(current.getChild(0),Type.LONG_TYPE);
gen.push(-1L);
gen.visitInsn(Opcodes.LXOR);
gen.cast(Type.LONG_TYPE,expected);
break;
case XJavascriptParser.AT_COMP_EQ:
pushCond(GeneratorAdapter.EQ,current,expected);
break;
case XJavascriptParser.AT_COMP_NEQ:
pushCond(GeneratorAdapter.NE,current,expected);
break;
case XJavascriptParser.AT_COMP_LT:
pushCond(GeneratorAdapter.LT,current,expected);
break;
case XJavascriptParser.AT_COMP_GT:
pushCond(GeneratorAdapter.GT,current,expected);
break;
case XJavascriptParser.AT_COMP_LTE:
pushCond(GeneratorAdapter.LE,current,expected);
break;
case XJavascriptParser.AT_COMP_GTE:
pushCond(GeneratorAdapter.GE,current,expected);
break;
case XJavascriptParser.AT_BOOL_NOT:
Label labelNotTrue=new Label();
Label labelNotReturn=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(Opcodes.IFEQ,labelNotTrue);
pushBoolean(expected,false);
gen.goTo(labelNotReturn);
gen.visitLabel(labelNotTrue);
pushBoolean(expected,true);
gen.visitLabel(labelNotReturn);
break;
case XJavascriptParser.AT_BOOL_AND:
Label andFalse=new Label();
Label andEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(Opcodes.IFEQ,andFalse);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitJumpInsn(Opcodes.IFEQ,andFalse);
pushBoolean(expected,true);
gen.goTo(andEnd);
gen.visitLabel(andFalse);
pushBoolean(expected,false);
gen.visitLabel(andEnd);
break;
case XJavascriptParser.AT_BOOL_OR:
Label orTrue=new Label();
Label orEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(Opcodes.IFNE,orTrue);
recursiveCompile(current.getChild(1),Type.INT_TYPE);
gen.visitJumpInsn(Opcodes.IFNE,orTrue);
pushBoolean(expected,false);
gen.goTo(orEnd);
gen.visitLabel(orTrue);
pushBoolean(expected,true);
gen.visitLabel(orEnd);
break;
case XJavascriptParser.AT_COND_QUE:
Label condFalse=new Label();
Label condEnd=new Label();
recursiveCompile(current.getChild(0),Type.INT_TYPE);
gen.visitJumpInsn(Opcodes.IFEQ,condFalse);
recursiveCompile(current.getChild(1),expected);
gen.goTo(condEnd);
gen.visitLabel(condFalse);
recursiveCompile(current.getChild(2),expected);
gen.visitLabel(condEnd);
break;
default :
throw new IllegalStateException("Unknown operation specified: (" + current.getText() + ").");
}
}
