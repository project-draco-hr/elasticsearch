{
  DiscoveryNode discoNode=allocation.nodes().resolveNode(node);
  boolean found=false;
  for (Iterator<MutableShardRouting> it=allocation.routingNodes().node(discoNode.id()).iterator(); it.hasNext(); ) {
    MutableShardRouting shardRouting=it.next();
    if (!shardRouting.shardId().equals(shardId)) {
      continue;
    }
    found=true;
    if (shardRouting.relocatingNodeId() != null) {
      if (shardRouting.initializing()) {
        it.remove();
        allocation.routingNodes().deassignShard(shardRouting);
        RoutingNode relocatingFromNode=allocation.routingNodes().node(shardRouting.relocatingNodeId());
        if (relocatingFromNode != null) {
          for (          MutableShardRouting fromShardRouting : relocatingFromNode) {
            if (fromShardRouting.shardId().equals(shardRouting.shardId()) && shardRouting.state() == RELOCATING) {
              allocation.routingNodes().cancelRelocationForShard(fromShardRouting);
              break;
            }
          }
        }
      }
 else       if (shardRouting.relocating()) {
        if (!allowPrimary && shardRouting.primary()) {
          throw new ElasticSearchIllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node "+ discoNode+ ", shard is primary and initializing its state");
        }
        it.remove();
        allocation.routingNodes().unassigned().add(new MutableShardRouting(shardRouting.index(),shardRouting.id(),null,shardRouting.primary(),ShardRoutingState.UNASSIGNED,shardRouting.version() + 1));
        RoutingNode initializingNode=allocation.routingNodes().node(shardRouting.relocatingNodeId());
        if (initializingNode != null) {
          for (Iterator<MutableShardRouting> itX=initializingNode.iterator(); itX.hasNext(); ) {
            MutableShardRouting initializingShardRouting=itX.next();
            if (initializingShardRouting.shardId().equals(shardRouting.shardId()) && initializingShardRouting.state() == INITIALIZING) {
              allocation.routingNodes().deassignShard(shardRouting);
              itX.remove();
            }
          }
        }
      }
    }
 else {
      if (!allowPrimary && shardRouting.primary()) {
        throw new ElasticSearchIllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node "+ discoNode+ ", shard is primary and started");
      }
      it.remove();
      allocation.routingNodes().unassigned().add(new MutableShardRouting(shardRouting.index(),shardRouting.id(),null,shardRouting.primary(),ShardRoutingState.UNASSIGNED,shardRouting.version() + 1));
    }
  }
  if (!found) {
    throw new ElasticSearchIllegalArgumentException("[cancel_allocation] can't cancel " + shardId + ", failed to find it on node "+ discoNode);
  }
}
