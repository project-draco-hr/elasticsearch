{
  if (map != null) {
    Method mapRemove=map.getClass().getDeclaredMethod("remove",ThreadLocal.class);
    mapRemove.setAccessible(true);
    Object[] table=(Object[])internalTableField.get(map);
    int staleEntriesCount=0;
    if (table != null) {
      for (int j=0; j < table.length; j++) {
        Object tableValue=table[j];
        if (tableValue != null) {
          boolean remove=false;
          Object key=((Reference<?>)tableValue).get();
          Field valueField=tableValue.getClass().getDeclaredField("value");
          valueField.setAccessible(true);
          Object value=valueField.get(tableValue);
          if ((value != null && CleanableValue.class.isAssignableFrom(value.getClass()))) {
            remove=true;
          }
          if (remove) {
            Object[] args=new Object[4];
            if (key != null) {
              args[0]=key.getClass().getCanonicalName();
              args[1]=key.toString();
            }
            args[2]=value.getClass().getCanonicalName();
            args[3]=value.toString();
            if (logger.isTraceEnabled()) {
              logger.trace("ThreadLocal with key of type [{}] (value [{}]) and a value of type [{}] (value [{}]):  The ThreadLocal has been forcibly removed.",args);
            }
            if (key == null) {
              staleEntriesCount++;
            }
 else {
              mapRemove.invoke(map,key);
            }
          }
        }
      }
    }
    if (staleEntriesCount > 0) {
      Method mapRemoveStale=map.getClass().getDeclaredMethod("expungeStaleEntries");
      mapRemoveStale.setAccessible(true);
      mapRemoveStale.invoke(map);
    }
  }
}
