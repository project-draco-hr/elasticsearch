{
  final ClusterName incomingClusterName=newClusterState.getClusterName();
  if (incomingClusterName != null && !incomingClusterName.equals(this.clusterName)) {
    logger.warn("received cluster state from [{}] which is also master but with a different cluster name [{}]",newClusterState.nodes().masterNode(),incomingClusterName);
    newStateProcessed.onNewClusterStateFailed(new ElasticsearchIllegalStateException("received state from a node that is not part of the cluster"));
    return;
  }
  if (master) {
    logger.debug("received cluster state from [{}] which is also master with cluster name [{}]",newClusterState.nodes().masterNode(),incomingClusterName);
    final ClusterState newState=newClusterState;
    clusterService.submitStateUpdateTask("zen-disco-master_receive_cluster_state_from_another_master [" + newState.nodes().masterNode() + "]",Priority.URGENT,new ProcessedClusterStateUpdateTask(){
      @Override public ClusterState execute(      ClusterState currentState){
        if (newState.version() > currentState.version()) {
          logger.warn("received cluster state from [{}] which is also master but with a newer cluster_state, rejoining to cluster...",newState.nodes().masterNode());
          return rejoin(currentState,"zen-disco-master_receive_cluster_state_from_another_master [" + newState.nodes().masterNode() + "]");
        }
 else {
          logger.warn("received cluster state from [{}] which is also master but with an older cluster_state, telling [{}] to rejoin the cluster",newState.nodes().masterNode(),newState.nodes().masterNode());
          try {
            transportService.connectToNode(newState.nodes().masterNode());
            transportService.sendRequest(newState.nodes().masterNode(),DISCOVERY_REJOIN_ACTION_NAME,new RejoinClusterRequest(currentState.nodes().localNodeId()),new EmptyTransportResponseHandler(ThreadPool.Names.SAME){
              @Override public void handleException(              TransportException exp){
                logger.warn("failed to send rejoin request to [{}]",exp,newState.nodes().masterNode());
              }
            }
);
          }
 catch (          Exception e) {
            logger.warn("failed to send rejoin request to [{}]",e,newState.nodes().masterNode());
          }
          return currentState;
        }
      }
      @Override public void clusterStateProcessed(      String source,      ClusterState oldState,      ClusterState newState){
        newStateProcessed.onNewClusterStateProcessed();
      }
      @Override public void onFailure(      String source,      Throwable t){
        logger.error("unexpected failure during [{}]",t,source);
        newStateProcessed.onNewClusterStateFailed(t);
      }
    }
);
  }
 else {
    if (newClusterState.nodes().localNode() == null) {
      logger.warn("received a cluster state from [{}] and not part of the cluster, should not happen",newClusterState.nodes().masterNode());
      newStateProcessed.onNewClusterStateFailed(new ElasticsearchIllegalStateException("received state from a node that is not part of the cluster"));
    }
 else {
      if (currentJoinThread != null) {
        logger.trace("got a new state from master node while joining the cluster, this is a valid state during the last phase of the join process");
      }
      final ProcessClusterState processClusterState=new ProcessClusterState(newClusterState,newStateProcessed);
      processNewClusterStates.add(processClusterState);
      clusterService.submitStateUpdateTask("zen-disco-receive(from master [" + newClusterState.nodes().masterNode() + "])",Priority.URGENT,new ProcessedClusterStateNonMasterUpdateTask(){
        @Override public ClusterState execute(        ClusterState currentState){
          if (processClusterState.processed) {
            return currentState;
          }
          ProcessClusterState stateToProcess=processNewClusterStates.poll();
          if (stateToProcess == null) {
            return currentState;
          }
          stateToProcess.processed=true;
          while (true) {
            ProcessClusterState potentialState=processNewClusterStates.peek();
            if (potentialState == null) {
              break;
            }
            if (!Objects.equal(stateToProcess.clusterState.nodes().masterNodeId(),potentialState.clusterState.nodes().masterNodeId())) {
              break;
            }
            potentialState=processNewClusterStates.poll();
            potentialState.processed=true;
            if (potentialState.clusterState.version() > stateToProcess.clusterState.version()) {
              stateToProcess=potentialState;
            }
          }
          ClusterState updatedState=stateToProcess.clusterState;
          if (updatedState.version() < currentState.version() && Objects.equal(updatedState.nodes().masterNodeId(),currentState.nodes().masterNodeId())) {
            return currentState;
          }
          latestDiscoNodes=updatedState.nodes();
          if (masterFD.masterNode() == null || !masterFD.masterNode().equals(latestDiscoNodes.masterNode())) {
            masterFD.restart(latestDiscoNodes.masterNode(),"new cluster state received and we are monitoring the wrong master [" + masterFD.masterNode() + "]");
          }
          ClusterState.Builder builder=ClusterState.builder(updatedState);
          if (updatedState.routingTable().version() == currentState.routingTable().version()) {
            builder.routingTable(currentState.routingTable());
          }
          if (updatedState.metaData().version() == currentState.metaData().version()) {
            builder.metaData(currentState.metaData());
          }
 else {
            MetaData.Builder metaDataBuilder=MetaData.builder(updatedState.metaData()).removeAllIndices();
            for (            IndexMetaData indexMetaData : updatedState.metaData()) {
              IndexMetaData currentIndexMetaData=currentState.metaData().index(indexMetaData.index());
              if (currentIndexMetaData == null || currentIndexMetaData.version() != indexMetaData.version()) {
                metaDataBuilder.put(indexMetaData,false);
              }
 else {
                metaDataBuilder.put(currentIndexMetaData,false);
              }
            }
            builder.metaData(metaDataBuilder);
          }
          return builder.build();
        }
        @Override public void onFailure(        String source,        Throwable t){
          logger.error("unexpected failure during [{}]",t,source);
          newStateProcessed.onNewClusterStateFailed(t);
        }
        @Override public void clusterStateProcessed(        String source,        ClusterState oldState,        ClusterState newState){
          sendInitialStateEventIfNeeded();
          newStateProcessed.onNewClusterStateProcessed();
        }
      }
);
    }
  }
}
