{
  super(settings);
  this.threadPool=threadPool;
  this.size=settings.get(INDICES_CACHE_FILTER_SIZE,"10%");
  this.expire=settings.getAsTime(INDICES_CACHE_FILTER_EXPIRE,null);
  this.minimumEntryWeight=settings.getAsInt(INDICES_CACHE_FILTER_MINIMUM_ENTRY_WEIGHT,1024);
  if (minimumEntryWeight <= 0) {
    throw new IllegalArgumentException("minimum_entry_weight must be > 0 but was: " + minimumEntryWeight);
  }
  this.cleanInterval=settings.getAsTime(INDICES_CACHE_FILTER_CLEAN_INTERVAL,TimeValue.timeValueSeconds(60));
  this.concurrencyLevel=settings.getAsInt(INDICES_CACHE_FILTER_CONCURRENCY_LEVEL,16);
  if (concurrencyLevel <= 0) {
    throw new IllegalArgumentException("concurrency_level must be > 0 but was: " + concurrencyLevel);
  }
  computeSizeInBytes();
  buildCache();
  logger.debug("using [node] weighted filter cache with size [{}], actual_size [{}], expire [{}], clean_interval [{}]",size,new ByteSizeValue(sizeInBytes),expire,cleanInterval);
  nodeSettingsService.addListener(new ApplySettings());
  threadPool.schedule(cleanInterval,ThreadPool.Names.SAME,new ReaderCleaner());
}
