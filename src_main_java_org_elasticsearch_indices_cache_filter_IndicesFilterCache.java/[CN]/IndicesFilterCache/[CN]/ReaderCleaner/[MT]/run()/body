{
  if (closed) {
    return;
  }
  if (readersKeysToClean.isEmpty()) {
    threadPool.schedule(cleanInterval,ThreadPool.Names.SAME,this);
    return;
  }
  threadPool.executor(ThreadPool.Names.GENERIC).execute(new Runnable(){
    @Override public void run(){
      THashSet<Object> keys=cacheRecycler.popHashSet();
      try {
        for (Iterator<Object> it=readersKeysToClean.iterator(); it.hasNext(); ) {
          keys.add(it.next());
          it.remove();
        }
        cache.cleanUp();
        if (!keys.isEmpty()) {
          for (Iterator<WeightedFilterCache.FilterCacheKey> it=cache.asMap().keySet().iterator(); it.hasNext(); ) {
            WeightedFilterCache.FilterCacheKey filterCacheKey=it.next();
            if (keys.contains(filterCacheKey.readerKey())) {
              it.remove();
            }
          }
        }
        threadPool.schedule(cleanInterval,ThreadPool.Names.SAME,ReaderCleaner.this);
      }
  finally {
        cacheRecycler.pushHashSet(keys);
      }
    }
  }
);
}
