{
  ClusterState clusterState=clusterService.state();
  for (  String index : indices) {
    IndexRoutingTable indexTable=clusterState.routingTable().indicesRouting().get(index);
    if (indexTable == null) {
      throw new IndexMissingException(new Index(index));
    }
  }
  DocumentMapper documentMapper=null;
  for (  String index : indices) {
    IndexService indexService=indicesService.indexService(index);
    if (indexService != null) {
      documentMapper=indexService.mapperService().parse(mappingType,mappingSource);
    }
 else {
      throw new IndexMissingException(new Index(index));
    }
  }
  String parsedSource=documentMapper.buildSource();
  if (mappingType == null) {
    mappingType=documentMapper.type();
  }
 else   if (!mappingType.equals(documentMapper.type())) {
    throw new InvalidTypeNameException("Type name provided does not match type name within mapping definition");
  }
  if (mappingType.charAt(0) == '_') {
    throw new InvalidTypeNameException("Document mapping type name can't start with '_'");
  }
  logger.info("Indices [" + Arrays.toString(indices) + "]: Put mapping ["+ mappingType+ "] with source ["+ mappingSource+ "]");
  final CountDownLatch latch=new CountDownLatch(clusterService.state().nodes().size() * indices.length);
  final Set<String> indicesSet=Sets.newHashSet(indices);
  final String fMappingType=mappingType;
  NodeMappingCreatedAction.Listener listener=new NodeMappingCreatedAction.Listener(){
    @Override public void onNodeMappingCreated(    NodeMappingCreatedAction.NodeMappingCreatedResponse response){
      if (indicesSet.contains(response.index()) && response.type().equals(fMappingType)) {
        latch.countDown();
      }
    }
  }
;
  nodeMappingCreatedAction.add(listener);
  final String mappingTypeP=mappingType;
  clusterService.submitStateUpdateTask("create-mapping [" + mappingTypeP + "]",new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      MetaData.Builder builder=newMetaDataBuilder().metaData(currentState.metaData());
      for (      String indexName : indices) {
        IndexMetaData indexMetaData=currentState.metaData().index(indexName);
        if (indexMetaData == null) {
          throw new IndexMissingException(new Index(indexName));
        }
        builder.put(newIndexMetaDataBuilder(indexMetaData).addMapping(mappingTypeP,mappingSource));
      }
      return newClusterStateBuilder().state(currentState).metaData(builder).build();
    }
  }
);
  boolean acknowledged;
  try {
    acknowledged=latch.await(timeout.millis(),TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    acknowledged=false;
  }
 finally {
    nodeMappingCreatedAction.remove(listener);
  }
  return new PutMappingResult(acknowledged,parsedSource);
}
