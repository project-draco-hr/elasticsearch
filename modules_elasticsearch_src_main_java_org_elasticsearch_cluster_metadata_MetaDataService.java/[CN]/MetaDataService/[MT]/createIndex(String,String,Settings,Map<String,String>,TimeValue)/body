{
  ClusterState clusterState=clusterService.state();
  if (clusterState.routingTable().hasIndex(index)) {
    throw new IndexAlreadyExistsException(new Index(index));
  }
  if (clusterState.metaData().hasIndex(index)) {
    throw new IndexAlreadyExistsException(new Index(index));
  }
  if (index.contains(" ")) {
    throw new InvalidIndexNameException(new Index(index),index,"must not contain whitespace");
  }
  if (index.contains(",")) {
    throw new InvalidIndexNameException(new Index(index),index,"must not contain ',");
  }
  if (index.contains("#")) {
    throw new InvalidIndexNameException(new Index(index),index,"must not contain '#");
  }
  if (index.charAt(0) == '_') {
    throw new InvalidIndexNameException(new Index(index),index,"must not start with '_'");
  }
  if (!index.toLowerCase().equals(index)) {
    throw new InvalidIndexNameException(new Index(index),index,"must be lowercase");
  }
  if (!Strings.validFileName(index)) {
    throw new InvalidIndexNameException(new Index(index),index,"must not contain the following characters " + Strings.INVALID_FILENAME_CHARS);
  }
  if (clusterState.metaData().aliases().contains(index)) {
    throw new InvalidIndexNameException(new Index(index),index,"an alias with the same name already exists");
  }
  if (mappings == null) {
    mappings=Maps.newHashMap();
  }
 else {
    mappings=Maps.newHashMap(mappings);
  }
  File mappingsDir=new File(environment.configFile(),"mappings");
  if (mappingsDir.exists() && mappingsDir.isDirectory()) {
    File[] mappingsFiles=mappingsDir.listFiles();
    for (    File mappingFile : mappingsFiles) {
      String fileNameNoSuffix=mappingFile.getName().substring(0,mappingFile.getName().lastIndexOf('.'));
      if (mappings.containsKey(fileNameNoSuffix)) {
        continue;
      }
      try {
        mappings.put(fileNameNoSuffix,Streams.copyToString(new FileReader(mappingFile)));
      }
 catch (      IOException e) {
        logger.warn("Failed to read mapping [" + fileNameNoSuffix + "] from location ["+ mappingFile+ "], ignoring...",e);
      }
    }
  }
  final Map<String,String> fMappings=mappings;
  final CountDownLatch latch=new CountDownLatch(clusterService.state().nodes().size());
  NodeIndexCreatedAction.Listener nodeCreatedListener=new NodeIndexCreatedAction.Listener(){
    @Override public void onNodeIndexCreated(    String mIndex,    String nodeId){
      if (index.equals(mIndex)) {
        latch.countDown();
      }
    }
  }
;
  nodeIndexCreatedAction.add(nodeCreatedListener);
  clusterService.submitStateUpdateTask("create-index [" + index + "], cause ["+ cause+ "]",new ClusterStateUpdateTask(){
    @Override public ClusterState execute(    ClusterState currentState){
      RoutingTable.Builder routingTableBuilder=new RoutingTable.Builder();
      for (      IndexRoutingTable indexRoutingTable : currentState.routingTable().indicesRouting().values()) {
        routingTableBuilder.add(indexRoutingTable);
      }
      ImmutableSettings.Builder indexSettingsBuilder=settingsBuilder().put(indexSettings);
      if (indexSettings.get(SETTING_NUMBER_OF_SHARDS) == null) {
        indexSettingsBuilder.put(SETTING_NUMBER_OF_SHARDS,settings.getAsInt(SETTING_NUMBER_OF_SHARDS,5));
      }
      if (indexSettings.get(SETTING_NUMBER_OF_REPLICAS) == null) {
        indexSettingsBuilder.put(SETTING_NUMBER_OF_REPLICAS,settings.getAsInt(SETTING_NUMBER_OF_REPLICAS,1));
      }
      Settings actualIndexSettings=indexSettingsBuilder.build();
      IndexMetaData.Builder indexMetaData=newIndexMetaDataBuilder(index).settings(actualIndexSettings);
      for (      Map.Entry<String,String> entry : fMappings.entrySet()) {
        indexMetaData.putMapping(entry.getKey(),entry.getValue());
      }
      MetaData newMetaData=newMetaDataBuilder().metaData(currentState.metaData()).put(indexMetaData).build();
      IndexRoutingTable.Builder indexRoutingBuilder=new IndexRoutingTable.Builder(index).initializeEmpty(newMetaData.index(index));
      routingTableBuilder.add(indexRoutingBuilder);
      logger.info("Creating Index [{}], cause [{}], shards [{}]/[{}], mappings {}",new Object[]{index,cause,indexMetaData.numberOfShards(),indexMetaData.numberOfReplicas(),fMappings.keySet()});
      RoutingTable newRoutingTable=shardsRoutingStrategy.reroute(newClusterStateBuilder().state(currentState).routingTable(routingTableBuilder).metaData(newMetaData).build());
      return newClusterStateBuilder().state(currentState).routingTable(newRoutingTable).metaData(newMetaData).build();
    }
  }
);
  boolean acknowledged;
  try {
    acknowledged=latch.await(timeout.millis(),TimeUnit.MILLISECONDS);
  }
 catch (  InterruptedException e) {
    acknowledged=false;
  }
 finally {
    nodeIndexCreatedAction.remove(nodeCreatedListener);
  }
  return new CreateIndexResult(acknowledged);
}
