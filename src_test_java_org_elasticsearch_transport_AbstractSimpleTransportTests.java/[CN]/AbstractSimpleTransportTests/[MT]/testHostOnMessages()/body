{
  final CountDownLatch latch=new CountDownLatch(2);
  final AtomicReference<TransportAddress> addressA=new AtomicReference<>();
  final AtomicReference<TransportAddress> addressB=new AtomicReference<>();
  serviceB.registerHandler("action1",new TransportRequestHandler<TestRequest>(){
    @Override public TestRequest newInstance(){
      return new TestRequest();
    }
    @Override public void messageReceived(    TestRequest request,    TransportChannel channel) throws Exception {
      latch.countDown();
      addressA.set(request.remoteAddress());
      channel.sendResponse(new TestResponse());
    }
    @Override public String executor(){
      return ThreadPool.Names.SAME;
    }
    @Override public boolean isForceExecution(){
      return false;
    }
  }
);
  serviceA.sendRequest(nodeB,"action1",new TestRequest(),new TransportResponseHandler<TestResponse>(){
    @Override public TestResponse newInstance(){
      return new TestResponse();
    }
    @Override public void handleResponse(    TestResponse response){
      latch.countDown();
      addressB.set(response.remoteAddress());
    }
    @Override public void handleException(    TransportException exp){
      latch.countDown();
    }
    @Override public String executor(){
      return ThreadPool.Names.SAME;
    }
  }
);
  if (!latch.await(10,TimeUnit.SECONDS)) {
    fail("message round trip did not complete within a sensible time frame");
  }
  assertTrue(nodeA.address().sameHost(addressA.get()));
  assertTrue(nodeB.address().sameHost(addressB.get()));
}
