{
  boolean changed=false;
  if (nodes.dataNodes().isEmpty()) {
    return changed;
  }
  Iterator<MutableShardRouting> unassignedIterator=routingNodes.unassigned().iterator();
  while (unassignedIterator.hasNext()) {
    MutableShardRouting shard=unassignedIterator.next();
    InternalIndexService indexService=(InternalIndexService)indicesService.indexService(shard.index());
    if (indexService == null) {
      continue;
    }
    if (!indexService.store().persistent()) {
      continue;
    }
    if (!shard.primary()) {
      MutableShardRouting primary=routingNodes.findPrimaryForReplica(shard);
      if (primary == null || !primary.active()) {
        continue;
      }
    }
    TransportNodesListShardStoreMetaData.NodesStoreFilesMetaData nodesStoreFilesMetaData=transportNodesListShardStoreMetaData.list(shard.shardId(),false,nodes.dataNodes().keySet()).actionGet();
    if (logger.isDebugEnabled()) {
      if (nodesStoreFilesMetaData.failures().length > 0) {
        StringBuilder sb=new StringBuilder(shard + ": failures when trying to list stores on nodes:");
        for (int i=0; i < nodesStoreFilesMetaData.failures().length; i++) {
          Throwable cause=ExceptionsHelper.unwrapCause(nodesStoreFilesMetaData.failures()[i]);
          if (cause instanceof ConnectTransportException) {
            continue;
          }
          sb.append("\n    -> ").append(nodesStoreFilesMetaData.failures()[i].getDetailedMessage());
        }
        logger.debug(sb.toString());
      }
    }
    long lastSizeMatched=0;
    DiscoveryNode lastDiscoNodeMatched=null;
    RoutingNode lastNodeMatched=null;
    for (    TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData nodeStoreFilesMetaData : nodesStoreFilesMetaData) {
      DiscoveryNode discoNode=nodeStoreFilesMetaData.node();
      logger.trace("{}: checking node [{}]",shard,discoNode);
      IndexStore.StoreFilesMetaData storeFilesMetaData=nodeStoreFilesMetaData.storeFilesMetaData();
      if (storeFilesMetaData == null) {
        continue;
      }
      RoutingNode node=routingNodes.node(discoNode.id());
      if (node == null) {
        continue;
      }
      if (!nodeAllocations.canAllocate(shard,node,routingNodes).allocate()) {
        continue;
      }
      if (storeFilesMetaData.allocated()) {
        continue;
      }
      if (shard.primary() && indexService.gateway() instanceof BlobStoreIndexGateway) {
        BlobStoreIndexGateway indexGateway=(BlobStoreIndexGateway)indexService.gateway();
        try {
          ImmutableMap<String,BlobMetaData> indexBlobsMetaData=indexGateway.listIndexBlobs(shard.id());
          if (logger.isDebugEnabled()) {
            StringBuilder sb=new StringBuilder(shard + ": checking for pre_allocation (gateway) on node " + discoNode+ "\n");
            sb.append("    gateway_files:\n");
            for (            BlobMetaData md : indexBlobsMetaData.values()) {
              sb.append("        [").append(md.name()).append("], size [").append(new ByteSizeValue(md.sizeInBytes())).append("], md5 [").append(md.md5()).append("]\n");
            }
            sb.append("    node_files:\n");
            for (            StoreFileMetaData md : storeFilesMetaData) {
              sb.append("        [").append(md.name()).append("], size [").append(new ByteSizeValue(md.sizeInBytes())).append("], md5 [").append(md.md5()).append("]\n");
            }
            logger.debug(sb.toString());
          }
          logger.trace("{}: checking for pre_allocation (gateway) on node [{}]\n   gateway files",shard,discoNode,indexBlobsMetaData.keySet());
          long sizeMatched=0;
          for (          StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
            if (indexBlobsMetaData.containsKey(storeFileMetaData.name())) {
              if (indexBlobsMetaData.get(storeFileMetaData.name()).md5().equals(storeFileMetaData.md5())) {
                logger.trace("{}: [{}] reusing file since it exists on remote node and on gateway (same md5) with size [{}]",shard,storeFileMetaData.name(),new ByteSizeValue(storeFileMetaData.sizeInBytes()));
                sizeMatched+=storeFileMetaData.sizeInBytes();
              }
 else {
                logger.trace("{}: [{}] ignore file since it exists on remote node and on gateway but has different md5, remote node [{}], gateway [{}]",shard,storeFileMetaData.name(),storeFileMetaData.md5(),indexBlobsMetaData.get(storeFileMetaData.name()).md5());
              }
            }
 else {
              logger.trace("{}: [{}] exists on remote node, does not exists on gateway",shard,storeFileMetaData.name());
            }
          }
          if (sizeMatched > lastSizeMatched) {
            lastSizeMatched=sizeMatched;
            lastDiscoNodeMatched=discoNode;
            lastNodeMatched=node;
            logger.trace("{}: node elected for pre_allocation [{}], total_size_matched [{}]",shard,discoNode,new ByteSizeValue(sizeMatched));
          }
 else {
            logger.trace("{}: node ignored for pre_allocation [{}], total_size_matched [{}] smaller than last_size_matched [{}]",shard,discoNode,new ByteSizeValue(sizeMatched),new ByteSizeValue(lastSizeMatched));
          }
          continue;
        }
 catch (        Exception e) {
          logger.debug("Failed to guess allocation of primary based on gateway for " + shard,e);
        }
      }
      if (!shard.primary()) {
        MutableShardRouting primaryShard=routingNodes.findPrimaryForReplica(shard);
        if (primaryShard != null && primaryShard.active()) {
          TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData primaryNodeStoreFileMetaData=nodesStoreFilesMetaData.nodesMap().get(primaryShard.currentNodeId());
          if (primaryNodeStoreFileMetaData != null && primaryNodeStoreFileMetaData.storeFilesMetaData() != null && primaryNodeStoreFileMetaData.storeFilesMetaData().allocated()) {
            long sizeMatched=0;
            IndexStore.StoreFilesMetaData primaryStoreFilesMetaData=primaryNodeStoreFileMetaData.storeFilesMetaData();
            for (            StoreFileMetaData storeFileMetaData : storeFilesMetaData) {
              if (primaryStoreFilesMetaData.fileExists(storeFileMetaData.name()) && primaryStoreFilesMetaData.file(storeFileMetaData.name()).sizeInBytes() == storeFileMetaData.sizeInBytes()) {
                sizeMatched+=storeFileMetaData.sizeInBytes();
              }
            }
            if (sizeMatched > lastSizeMatched) {
              lastSizeMatched=sizeMatched;
              lastDiscoNodeMatched=discoNode;
              lastNodeMatched=node;
            }
            continue;
          }
        }
      }
    }
    if (lastNodeMatched != null) {
      if (logger.isDebugEnabled()) {
        logger.debug("[{}][{}]: allocating [{}] to [{}] in order to reuse its unallocated persistent store with total_size [{}]",shard.index(),shard.id(),shard,lastDiscoNodeMatched,new ByteSizeValue(lastSizeMatched));
      }
      changed=true;
      lastNodeMatched.add(shard);
      unassignedIterator.remove();
    }
  }
  return changed;
}
