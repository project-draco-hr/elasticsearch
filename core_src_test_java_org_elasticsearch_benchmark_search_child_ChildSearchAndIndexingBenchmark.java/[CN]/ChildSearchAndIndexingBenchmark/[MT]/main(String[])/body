{
  Settings settings=settingsBuilder().put("refresh_interval","-1").put(SETTING_NUMBER_OF_SHARDS,1).put(SETTING_NUMBER_OF_REPLICAS,0).put("cluster.name",ChildSearchAndIndexingBenchmark.class.getSimpleName()).build();
  Node node1=new Node(settingsBuilder().put(settings).put("name","node1").build()).start();
  Client client=node1.client();
  client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout("10s").execute().actionGet();
  try {
    client.admin().indices().create(createIndexRequest(indexName)).actionGet();
    client.admin().indices().preparePutMapping(indexName).setType("child").setSource(XContentFactory.jsonBuilder().startObject().startObject("child").startObject("_parent").field("type","parent").endObject().endObject().endObject()).execute().actionGet();
    Thread.sleep(5000);
    long startTime=System.currentTimeMillis();
    ParentChildIndexGenerator generator=new ParentChildIndexGenerator(client,PARENT_COUNT,NUM_CHILDREN_PER_PARENT,QUERY_VALUE_RATIO_PER_PARENT);
    generator.index();
    System.out.println("--> Indexing took " + ((System.currentTimeMillis() - startTime) / 1000) + " seconds.");
  }
 catch (  IndexAlreadyExistsException e) {
    System.out.println("--> Index already exists, ignoring indexing phase, waiting for green");
    ClusterHealthResponse clusterHealthResponse=client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout("10m").execute().actionGet();
    if (clusterHealthResponse.isTimedOut()) {
      System.err.println("--> Timed out waiting for cluster health");
    }
  }
  client.admin().indices().prepareRefresh().execute().actionGet();
  System.out.println("--> Number of docs in index: " + client.prepareSearch().setSize(0).setQuery(matchAllQuery()).execute().actionGet().getHits().totalHits());
  SearchThread searchThread=new SearchThread(client);
  new Thread(searchThread).start();
  IndexThread indexThread=new IndexThread(client);
  new Thread(indexThread).start();
  System.in.read();
  indexThread.stop();
  searchThread.stop();
  client.close();
  node1.close();
}
