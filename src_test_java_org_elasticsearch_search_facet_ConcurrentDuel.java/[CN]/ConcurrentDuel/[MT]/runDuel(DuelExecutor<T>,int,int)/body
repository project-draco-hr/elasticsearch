{
  List<T> results=new ArrayList<T>();
  T firstRun=executor.run();
  results.add(firstRun);
  for (int i=0; i < 3; i++) {
  }
  final CountDownLatch latch=new CountDownLatch(1);
  final AtomicLong count=new AtomicLong(iterations);
  List<Future<List<T>>> futures=new ArrayList<Future<List<T>>>();
  for (int i=0; i < numTasks; i++) {
    futures.add(pool.submit(new Callable<List<T>>(){
      @Override public List<T> call() throws Exception {
        List<T> results=new ArrayList<T>();
        latch.await();
        while (count.decrementAndGet() >= 0) {
          results.add(executor.run());
        }
        return results;
      }
    }
));
  }
  latch.countDown();
  for (  Future<List<T>> future : futures) {
    results.addAll(future.get());
  }
  return results;
}
