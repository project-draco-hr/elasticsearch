{
  if (!event.localNodeMaster()) {
    return;
  }
  if (event.nodesChanged() || event.metaDataChanged() || event.blocksChanged()) {
    indexerClusterService.submitStateUpdateTask("reroute_indexers_node_changed",new IndexerClusterStateUpdateTask(){
      @Override public IndexerClusterState execute(      IndexerClusterState currentState){
        if (!event.state().metaData().hasIndex(indexerIndexName)) {
          if (!currentState.routing().isEmpty()) {
            return IndexerClusterState.builder().state(currentState).routing(IndexersRouting.builder()).build();
          }
          return currentState;
        }
        IndexersRouting.Builder routingBuilder=IndexersRouting.builder().routing(currentState.routing());
        boolean dirty=false;
        IndexMetaData indexMetaData=event.state().metaData().index(indexerIndexName);
        for (        Map.Entry<String,CompressedString> entry : indexMetaData.mappings().entrySet()) {
          String mappingType=entry.getKey();
          if (!currentState.routing().hasIndexerByName(mappingType)) {
            try {
              client.admin().indices().prepareRefresh(indexerIndexName).execute().actionGet();
              GetResponse getResponse=client.prepareGet(indexerIndexName,mappingType,"_meta").execute().actionGet();
              if (getResponse.exists()) {
                String indexerType=XContentMapValues.nodeStringValue(getResponse.sourceAsMap().get("type"),null);
                if (indexerType == null) {
                  logger.warn("no indexer type provided for [{}], ignoring...",indexerIndexName);
                }
 else {
                  routingBuilder.put(new IndexerRouting(new IndexerName(indexerType,mappingType),null));
                  dirty=true;
                }
              }
            }
 catch (            ClusterBlockException e) {
            }
catch (            IndexMissingException e) {
            }
catch (            Exception e) {
              logger.warn("failed to get/parse _meta for [{}]",e,mappingType);
            }
          }
        }
        for (        IndexerRouting routing : currentState.routing()) {
          if (!indexMetaData.mappings().containsKey(routing.indexerName().name())) {
            routingBuilder.remove(routing);
            dirty=true;
          }
        }
        Map<DiscoveryNode,List<IndexerRouting>> nodesToIndexers=Maps.newHashMap();
        for (        DiscoveryNode node : event.state().nodes()) {
          if (IndexerNodeHelper.isIndexerNode(node)) {
            nodesToIndexers.put(node,Lists.<IndexerRouting>newArrayList());
          }
        }
        List<IndexerRouting> unassigned=Lists.newArrayList();
        for (        IndexerRouting routing : routingBuilder.build()) {
          if (routing.node() == null) {
            unassigned.add(routing);
          }
 else {
            List<IndexerRouting> l=nodesToIndexers.get(routing.node());
            if (l == null) {
              l=Lists.newArrayList();
              nodesToIndexers.put(routing.node(),l);
            }
            l.add(routing);
          }
        }
        for (Iterator<IndexerRouting> it=unassigned.iterator(); it.hasNext(); ) {
          IndexerRouting routing=it.next();
          DiscoveryNode smallest=null;
          int smallestSize=Integer.MAX_VALUE;
          for (          Map.Entry<DiscoveryNode,List<IndexerRouting>> entry : nodesToIndexers.entrySet()) {
            if (IndexerNodeHelper.isIndexerNode(entry.getKey(),routing.indexerName())) {
              if (entry.getValue().size() < smallestSize) {
                smallestSize=entry.getValue().size();
                smallest=entry.getKey();
              }
            }
          }
          if (smallest != null) {
            dirty=true;
            it.remove();
            routing.node(smallest);
            nodesToIndexers.get(smallest).add(routing);
          }
        }
        if (dirty) {
          return IndexerClusterState.builder().state(currentState).routing(routingBuilder).build();
        }
        return currentState;
      }
    }
);
  }
}
