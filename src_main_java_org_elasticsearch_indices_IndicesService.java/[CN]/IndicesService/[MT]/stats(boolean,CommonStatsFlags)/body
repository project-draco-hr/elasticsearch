{
  CommonStats oldStats=new CommonStats(flags);
  if (includePrevious) {
    Flag[] setFlags=flags.getFlags();
    for (    Flag flag : setFlags) {
switch (flag) {
case Get:
        oldStats.get.add(oldShardsStats.getStats);
      break;
case Indexing:
    oldStats.indexing.add(oldShardsStats.indexingStats);
  break;
case Search:
oldStats.search.add(oldShardsStats.searchStats);
break;
case Merge:
oldStats.merge.add(oldShardsStats.mergeStats);
break;
case Refresh:
oldStats.refresh.add(oldShardsStats.refreshStats);
break;
case Flush:
oldStats.flush.add(oldShardsStats.flushStats);
break;
}
}
}
Map<Index,List<IndexShardStats>> statsByShard=Maps.newHashMap();
for (Tuple<IndexService,Injector> value : indices.values()) {
IndexService indexService=value.v1();
for (IndexShard indexShard : indexService) {
try {
if (indexShard.routingEntry() == null) {
continue;
}
IndexShardStats indexShardStats=new IndexShardStats(indexShard.shardId(),new ShardStats[]{new ShardStats(indexShard,indexShard.routingEntry(),flags)});
if (!statsByShard.containsKey(indexService.index())) {
statsByShard.put(indexService.index(),Lists.<IndexShardStats>newArrayList(indexShardStats));
}
 else {
statsByShard.get(indexService.index()).add(indexShardStats);
}
}
 catch (IllegalIndexShardStateException e) {
}
}
}
return new NodeIndicesStats(oldStats,statsByShard);
}
