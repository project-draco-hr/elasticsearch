{
  if (!lifecycle.started()) {
    throw new ElasticsearchIllegalStateException("Can't create an index [" + sIndexName + "], node is closed");
  }
  Index index=new Index(sIndexName);
  if (indices.containsKey(index.name())) {
    throw new IndexAlreadyExistsException(index);
  }
  indicesLifecycle.beforeIndexCreated(index,settings);
  logger.debug("creating Index [{}], shards [{}]/[{}]",sIndexName,settings.get(SETTING_NUMBER_OF_SHARDS),settings.get(SETTING_NUMBER_OF_REPLICAS));
  Settings indexSettings=settingsBuilder().put(this.settings).put(settings).classLoader(settings.getClassLoader()).build();
  ModulesBuilder modules=new ModulesBuilder();
  modules.add(new IndexNameModule(index));
  modules.add(new LocalNodeIdModule(localNodeId));
  modules.add(new IndexSettingsModule(index,indexSettings));
  modules.add(new IndexPluginsModule(indexSettings,pluginsService));
  modules.add(new IndexStoreModule(indexSettings));
  modules.add(new AnalysisModule(indexSettings,indicesAnalysisService));
  modules.add(new SimilarityModule(indexSettings));
  modules.add(new IndexCacheModule(indexSettings));
  modules.add(new IndexFieldDataModule(indexSettings));
  modules.add(new CodecModule(indexSettings));
  modules.add(new MapperServiceModule());
  modules.add(new IndexQueryParserModule(indexSettings));
  modules.add(new IndexAliasesServiceModule());
  modules.add(new IndexModule(indexSettings));
  Injector indexInjector;
  try {
    indexInjector=modules.createChildInjector(injector);
  }
 catch (  CreationException e) {
    throw new IndexCreationException(index,Injectors.getFirstErrorFailure(e));
  }
catch (  Throwable e) {
    throw new IndexCreationException(index,e);
  }
  IndexService indexService=indexInjector.getInstance(IndexService.class);
  indicesLifecycle.afterIndexCreated(indexService);
  indices=newMapBuilder(indices).put(index.name(),new Tuple<>(indexService,indexInjector)).immutableMap();
  return indexService;
}
