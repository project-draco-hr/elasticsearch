{
  final long startTime=System.currentTimeMillis();
  final List<ShardLock> shardLocks=nodeEnv.lockAllForIndex(index,indexSettings,timeout.millis());
  try {
    Map<ShardId,ShardLock> locks=new HashMap<>();
    for (    ShardLock lock : shardLocks) {
      locks.put(lock.getShardId(),lock);
    }
    final List<PendingDelete> remove;
synchronized (pendingDeletes) {
      remove=pendingDeletes.remove(index);
    }
    final long maxSleepTimeMs=10 * 1000;
    long sleepTime=10;
    do {
      if (remove == null || remove.isEmpty()) {
        break;
      }
      Iterator<PendingDelete> iterator=remove.iterator();
      while (iterator.hasNext()) {
        PendingDelete delete=iterator.next();
        ShardLock shardLock=locks.get(delete.shardId);
        if (shardLock != null) {
          try {
            deleteShardStore("pending delete",shardLock,delete.settings);
          }
 catch (          IOException ex) {
            logger.debug("{} retry pending delete",shardLock.getShardId(),ex);
          }
        }
 else {
          logger.warn("{} no shard lock for pending delete",delete.shardId);
        }
        iterator.remove();
      }
      if (remove.isEmpty() == false) {
        logger.warn("{} still pending deletes present for shards {} - retrying",index,remove.toString());
        try {
          Thread.sleep(sleepTime);
          sleepTime=Math.min(maxSleepTimeMs,sleepTime * 2);
          logger.debug("{} schedule pending delete retry after {} ms",index,sleepTime);
        }
 catch (        InterruptedException e) {
          Thread.interrupted();
          return;
        }
      }
    }
 while ((System.currentTimeMillis() - startTime) < timeout.millis());
  }
  finally {
    IOUtils.close(shardLocks);
  }
}
