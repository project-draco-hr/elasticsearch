{
  ImmutableSet<String> indices=ImmutableSet.copyOf(this.indices.keySet());
  final CountDownLatch latch=new CountDownLatch(indices.size());
  final ExecutorService indicesStopExecutor=Executors.newFixedThreadPool(5,EsExecutors.daemonThreadFactory("indices_shutdown"));
  for (  final String index : indices) {
    indicesStopExecutor.execute(new Runnable(){
      @Override public void run(){
        try {
          removeIndex(index,"shutdown",false,new IndexCloseListener(){
            @Override public void onAllShardsClosed(            Index index,            @IndexSettings Settings indexSettings,            List<Throwable> failures){
              latch.countDown();
            }
            @Override public void onShardClosed(            ShardId shardId,            @IndexSettings Settings indexSettings){
            }
            @Override public void onShardCloseFailed(            ShardId shardId,            @IndexSettings Settings indexSettings,            Throwable t){
            }
          }
);
        }
 catch (        Throwable e) {
          latch.countDown();
          logger.warn("failed to delete index on stop [" + index + "]",e);
        }
      }
    }
);
  }
  try {
    if (latch.await(30,TimeUnit.SECONDS) == false) {
      logger.warn("Not all shards are closed yet, waited 30sec - stopping service");
    }
  }
 catch (  InterruptedException e) {
  }
 finally {
    indicesStopExecutor.shutdown();
  }
}
