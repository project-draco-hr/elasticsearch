{
  int successfulShards=0;
  int failedShards=0;
  long numDocs=0;
  long maxDoc=0;
  long numDeletedDocs=0;
  List<ShardOperationFailedException> shardFailures=null;
  ShardTermsResponse aggregator=null;
  for (int i=0; i < shardsResponses.length(); i++) {
    Object shardResponse=shardsResponses.get(i);
    if (shardResponse == null) {
      failedShards++;
    }
 else     if (shardResponse instanceof BroadcastShardOperationFailedException) {
      failedShards++;
      if (shardFailures == null) {
        shardFailures=newArrayList();
      }
      shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException)shardResponse));
    }
 else {
      ShardTermsResponse shardTermsResponse=(ShardTermsResponse)shardResponse;
      if (aggregator == null) {
        aggregator=shardTermsResponse;
      }
 else {
        for (        Map.Entry<String,TObjectIntHashMap<String>> entry : shardTermsResponse.fieldsTermsFreqs().entrySet()) {
          String fieldName=entry.getKey();
          TObjectIntHashMap<String> termsFreqs=aggregator.fieldsTermsFreqs().get(fieldName);
          if (termsFreqs == null) {
            termsFreqs=new TObjectIntHashMap<String>();
            aggregator.put(fieldName,termsFreqs);
          }
          for (TObjectIntIterator<String> it=entry.getValue().iterator(); it.hasNext(); ) {
            it.advance();
            termsFreqs.adjustOrPutValue(it.key(),it.value(),it.value());
          }
        }
      }
      numDocs+=shardTermsResponse.numDocs();
      maxDoc+=shardTermsResponse.maxDoc();
      numDeletedDocs+=shardTermsResponse.numDeletedDocs();
      successfulShards++;
    }
  }
  Map<String,NavigableSet<TermFreq>> fieldTermsFreqs=new HashMap<String,NavigableSet<TermFreq>>();
  if (aggregator != null) {
    for (    Map.Entry<String,TObjectIntHashMap<String>> entry : aggregator.fieldsTermsFreqs().entrySet()) {
      String fieldName=entry.getKey();
      NavigableSet<TermFreq> sortedFreqs=fieldTermsFreqs.get(fieldName);
      if (sortedFreqs == null) {
        Comparator<TermFreq> comparator=request.sortType() == TermsRequest.SortType.FREQ ? TermFreq.freqComparator() : TermFreq.termComparator();
        sortedFreqs=new BoundedTreeSet<TermFreq>(comparator,request.size());
        fieldTermsFreqs.put(fieldName,sortedFreqs);
      }
      for (TObjectIntIterator<String> it=entry.getValue().iterator(); it.hasNext(); ) {
        it.advance();
        if (it.value() >= request.minFreq() && it.value() <= request.maxFreq()) {
          sortedFreqs.add(new TermFreq(it.key(),it.value()));
        }
      }
    }
  }
  FieldTermsFreq[] resultFreqs=new FieldTermsFreq[fieldTermsFreqs.size()];
  int index=0;
  for (  Map.Entry<String,NavigableSet<TermFreq>> entry : fieldTermsFreqs.entrySet()) {
    TermFreq[] freqs=entry.getValue().toArray(new TermFreq[entry.getValue().size()]);
    resultFreqs[index++]=new FieldTermsFreq(entry.getKey(),freqs);
  }
  return new TermsResponse(successfulShards,failedShards,shardFailures,resultFreqs,numDocs,maxDoc,numDeletedDocs);
}
