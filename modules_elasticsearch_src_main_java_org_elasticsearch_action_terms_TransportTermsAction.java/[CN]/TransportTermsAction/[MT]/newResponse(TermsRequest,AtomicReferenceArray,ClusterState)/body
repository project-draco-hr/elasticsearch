{
  int successfulShards=0;
  int failedShards=0;
  long numDocs=0;
  long maxDoc=0;
  long numDeletedDocs=0;
  List<ShardOperationFailedException> shardFailures=null;
  Map<String,TObjectIntHashMap<Object>> aggregator=Maps.newHashMap();
  for (int i=0; i < shardsResponses.length(); i++) {
    Object shardResponse=shardsResponses.get(i);
    if (shardResponse == null) {
      failedShards++;
    }
 else     if (shardResponse instanceof BroadcastShardOperationFailedException) {
      failedShards++;
      if (shardFailures == null) {
        shardFailures=newArrayList();
      }
      shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException)shardResponse));
    }
 else {
      ShardTermsResponse shardTermsResponse=(ShardTermsResponse)shardResponse;
      IndexService indexService=indicesService.indexServiceSafe(shardTermsResponse.index());
      for (      Map.Entry<String,TObjectIntHashMap<Object>> entry : shardTermsResponse.fieldsTermsFreqs().entrySet()) {
        String fieldName=entry.getKey();
        FieldMapper fieldMapper=indexService.mapperService().smartNameFieldMapper(fieldName);
        TObjectIntHashMap<Object> termsFreqs=aggregator.get(fieldName);
        if (termsFreqs == null) {
          termsFreqs=new TObjectIntHashMap<Object>();
          aggregator.put(fieldName,termsFreqs);
        }
        for (TObjectIntIterator<Object> it=entry.getValue().iterator(); it.hasNext(); ) {
          it.advance();
          Object termValue=it.key();
          int freq=it.value();
          if (fieldMapper != null) {
            termValue=fieldMapper.valueForSearch(termValue);
          }
          termsFreqs.adjustOrPutValue(termValue,freq,freq);
        }
      }
      numDocs+=shardTermsResponse.numDocs();
      maxDoc+=shardTermsResponse.maxDoc();
      numDeletedDocs+=shardTermsResponse.numDeletedDocs();
      successfulShards++;
    }
  }
  Map<String,NavigableSet<TermFreq>> fieldTermsFreqs=new HashMap<String,NavigableSet<TermFreq>>();
  if (aggregator != null) {
    for (    Map.Entry<String,TObjectIntHashMap<Object>> entry : aggregator.entrySet()) {
      String fieldName=entry.getKey();
      NavigableSet<TermFreq> sortedFreqs=fieldTermsFreqs.get(fieldName);
      if (sortedFreqs == null) {
        Comparator<TermFreq> comparator=request.sortType() == TermsRequest.SortType.FREQ ? TermFreq.freqComparator() : TermFreq.termComparator();
        sortedFreqs=new BoundedTreeSet<TermFreq>(comparator,request.size());
        fieldTermsFreqs.put(fieldName,sortedFreqs);
      }
      for (TObjectIntIterator<Object> it=entry.getValue().iterator(); it.hasNext(); ) {
        it.advance();
        if (it.value() >= request.minFreq() && it.value() <= request.maxFreq()) {
          sortedFreqs.add(new TermFreq(it.key(),it.value()));
        }
      }
    }
  }
  FieldTermsFreq[] resultFreqs=new FieldTermsFreq[fieldTermsFreqs.size()];
  int index=0;
  for (  Map.Entry<String,NavigableSet<TermFreq>> entry : fieldTermsFreqs.entrySet()) {
    TermFreq[] freqs=entry.getValue().toArray(new TermFreq[entry.getValue().size()]);
    resultFreqs[index++]=new FieldTermsFreq(entry.getKey(),freqs);
  }
  return new TermsResponse(shardsResponses.length(),successfulShards,failedShards,shardFailures,resultFreqs,numDocs,maxDoc,numDeletedDocs);
}
