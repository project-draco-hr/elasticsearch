{
synchronized (mutex) {
    boolean activeInactiveStatusChanges=false;
    List<IndexShard> activeToInactiveIndexingShards=Lists.newArrayList();
    List<IndexShard> inactiveToActiveIndexingShards=Lists.newArrayList();
    for (    IndexService indexService : indicesService) {
      for (      IndexShard indexShard : indexService) {
        long time=threadPool.estimatedTimeInMillis();
        Translog translog=((InternalIndexShard)indexShard).translog();
        ShardIndexingStatus status=shardsIndicesStatus.get(indexShard.shardId());
        if (status == null) {
          continue;
        }
        if (status.translogId == translog.currentId() && translog.estimatedNumberOfOperations() == 0) {
          if (status.time == -1) {
            status.time=time;
          }
          if (!status.inactiveIndexing) {
            if ((time - status.time) > inactiveTime.millis() && indexShard.mergeStats().getCurrent() == 0) {
              activeToInactiveIndexingShards.add(indexShard);
              status.inactiveIndexing=true;
              activeInactiveStatusChanges=true;
              logger.debug("marking shard [{}][{}] as inactive (inactive_time[{}]) indexing wise, setting size to [{}]",indexShard.shardId().index().name(),indexShard.shardId().id(),inactiveTime,Engine.INACTIVE_SHARD_INDEXING_BUFFER);
            }
          }
        }
 else {
          if (status.inactiveIndexing) {
            inactiveToActiveIndexingShards.add(indexShard);
            status.inactiveIndexing=false;
            activeInactiveStatusChanges=true;
            logger.debug("marking shard [{}][{}] as active indexing wise",indexShard.shardId().index().name(),indexShard.shardId().id());
          }
          status.time=-1;
        }
        status.translogId=translog.currentId();
        status.translogNumberOfOperations=translog.estimatedNumberOfOperations();
      }
    }
    for (    IndexShard indexShard : activeToInactiveIndexingShards) {
      try {
        ((InternalIndexShard)indexShard).engine().updateIndexingBufferSize(Engine.INACTIVE_SHARD_INDEXING_BUFFER);
      }
 catch (      EngineClosedException e) {
      }
catch (      FlushNotAllowedEngineException e) {
      }
    }
    if (activeInactiveStatusChanges) {
      calcAndSetShardIndexingBuffer("shards became active/inactive (indexing wise)");
    }
  }
}
