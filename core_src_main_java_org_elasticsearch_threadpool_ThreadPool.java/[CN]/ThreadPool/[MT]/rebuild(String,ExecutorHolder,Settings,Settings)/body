{
  if (Names.SAME.equals(name)) {
    return previousExecutorHolder;
  }
  if (settings == null) {
    settings=Settings.Builder.EMPTY_SETTINGS;
  }
  Info previousInfo=previousExecutorHolder != null ? previousExecutorHolder.info : null;
  String type=settings.get("type",previousInfo != null ? previousInfo.getThreadPoolType().getType() : defaultSettings.get("type"));
  ThreadPoolType threadPoolType=ThreadPoolType.fromType(type);
  ThreadFactory threadFactory=EsExecutors.daemonThreadFactory(this.settings,name);
  if (ThreadPoolType.DIRECT == threadPoolType) {
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}]",name,type);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}]",name,type);
    }
    return new ExecutorHolder(DIRECT_EXECUTOR,new Info(name,threadPoolType));
  }
 else   if (ThreadPoolType.CACHED == threadPoolType) {
    if (!Names.GENERIC.equals(name)) {
      throw new IllegalArgumentException("thread pool type cached is reserved only for the generic thread pool and can not be applied to [" + name + "]");
    }
    TimeValue defaultKeepAlive=defaultSettings.getAsTime("keep_alive",timeValueMinutes(5));
    if (previousExecutorHolder != null) {
      if (ThreadPoolType.CACHED == previousInfo.getThreadPoolType()) {
        TimeValue updatedKeepAlive=settings.getAsTime("keep_alive",previousInfo.getKeepAlive());
        if (!previousInfo.getKeepAlive().equals(updatedKeepAlive)) {
          logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,updatedKeepAlive);
          ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setKeepAliveTime(updatedKeepAlive.millis(),TimeUnit.MILLISECONDS);
          return new ExecutorHolder(previousExecutorHolder.executor(),new Info(name,threadPoolType,-1,-1,updatedKeepAlive,null));
        }
        return previousExecutorHolder;
      }
      if (previousInfo.getKeepAlive() != null) {
        defaultKeepAlive=previousInfo.getKeepAlive();
      }
    }
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultKeepAlive);
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,keepAlive);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}], keep_alive [{}]",name,type,keepAlive);
    }
    Executor executor=EsExecutors.newCached(name,keepAlive.millis(),TimeUnit.MILLISECONDS,threadFactory);
    return new ExecutorHolder(executor,new Info(name,threadPoolType,-1,-1,keepAlive,null));
  }
 else   if (ThreadPoolType.FIXED == threadPoolType) {
    int defaultSize=defaultSettings.getAsInt("size",EsExecutors.boundedNumberOfProcessors(settings));
    SizeValue defaultQueueSize=getAsSizeOrUnbounded(defaultSettings,"queue",getAsSizeOrUnbounded(defaultSettings,"queue_size",null));
    if (previousExecutorHolder != null) {
      if (ThreadPoolType.FIXED == previousInfo.getThreadPoolType()) {
        SizeValue updatedQueueSize=getAsSizeOrUnbounded(settings,"capacity",getAsSizeOrUnbounded(settings,"queue",getAsSizeOrUnbounded(settings,"queue_size",previousInfo.getQueueSize())));
        if (Objects.equals(previousInfo.getQueueSize(),updatedQueueSize)) {
          int updatedSize=applyHardSizeLimit(name,settings.getAsInt("size",previousInfo.getMax()));
          if (previousInfo.getMax() != updatedSize) {
            logger.debug("updating thread_pool [{}], type [{}], size [{}], queue_size [{}]",name,type,updatedSize,updatedQueueSize);
            if (updatedSize > previousInfo.getMax()) {
              ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setMaximumPoolSize(updatedSize);
              ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setCorePoolSize(updatedSize);
            }
 else {
              ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setCorePoolSize(updatedSize);
              ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setMaximumPoolSize(updatedSize);
            }
            return new ExecutorHolder(previousExecutorHolder.executor(),new Info(name,threadPoolType,updatedSize,updatedSize,null,updatedQueueSize));
          }
          return previousExecutorHolder;
        }
      }
      if (previousInfo.getMax() >= 0) {
        defaultSize=previousInfo.getMax();
      }
      defaultQueueSize=previousInfo.getQueueSize();
    }
    int size=applyHardSizeLimit(name,settings.getAsInt("size",defaultSize));
    SizeValue queueSize=getAsSizeOrUnbounded(settings,"capacity",getAsSizeOrUnbounded(settings,"queue",getAsSizeOrUnbounded(settings,"queue_size",defaultQueueSize)));
    logger.debug("creating thread_pool [{}], type [{}], size [{}], queue_size [{}]",name,type,size,queueSize);
    Executor executor=EsExecutors.newFixed(name,size,queueSize == null ? -1 : (int)queueSize.singles(),threadFactory);
    return new ExecutorHolder(executor,new Info(name,threadPoolType,size,size,null,queueSize));
  }
 else   if (ThreadPoolType.SCALING == threadPoolType) {
    TimeValue defaultKeepAlive=defaultSettings.getAsTime("keep_alive",timeValueMinutes(5));
    int defaultMin=defaultSettings.getAsInt("min",1);
    int defaultSize=defaultSettings.getAsInt("size",EsExecutors.boundedNumberOfProcessors(settings));
    if (previousExecutorHolder != null) {
      if (ThreadPoolType.SCALING == previousInfo.getThreadPoolType()) {
        TimeValue updatedKeepAlive=settings.getAsTime("keep_alive",previousInfo.getKeepAlive());
        int updatedMin=settings.getAsInt("min",previousInfo.getMin());
        int updatedSize=settings.getAsInt("max",settings.getAsInt("size",previousInfo.getMax()));
        if (!previousInfo.getKeepAlive().equals(updatedKeepAlive) || previousInfo.getMin() != updatedMin || previousInfo.getMax() != updatedSize) {
          logger.debug("updating thread_pool [{}], type [{}], keep_alive [{}]",name,type,updatedKeepAlive);
          if (!previousInfo.getKeepAlive().equals(updatedKeepAlive)) {
            ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setKeepAliveTime(updatedKeepAlive.millis(),TimeUnit.MILLISECONDS);
          }
          if (previousInfo.getMin() != updatedMin) {
            ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setCorePoolSize(updatedMin);
          }
          if (previousInfo.getMax() != updatedSize) {
            ((EsThreadPoolExecutor)previousExecutorHolder.executor()).setMaximumPoolSize(updatedSize);
          }
          return new ExecutorHolder(previousExecutorHolder.executor(),new Info(name,threadPoolType,updatedMin,updatedSize,updatedKeepAlive,null));
        }
        return previousExecutorHolder;
      }
      if (previousInfo.getKeepAlive() != null) {
        defaultKeepAlive=previousInfo.getKeepAlive();
      }
      if (previousInfo.getMin() >= 0) {
        defaultMin=previousInfo.getMin();
      }
      if (previousInfo.getMax() >= 0) {
        defaultSize=previousInfo.getMax();
      }
    }
    TimeValue keepAlive=settings.getAsTime("keep_alive",defaultKeepAlive);
    int min=settings.getAsInt("min",defaultMin);
    int size=settings.getAsInt("max",settings.getAsInt("size",defaultSize));
    if (previousExecutorHolder != null) {
      logger.debug("updating thread_pool [{}], type [{}], min [{}], size [{}], keep_alive [{}]",name,type,min,size,keepAlive);
    }
 else {
      logger.debug("creating thread_pool [{}], type [{}], min [{}], size [{}], keep_alive [{}]",name,type,min,size,keepAlive);
    }
    Executor executor=EsExecutors.newScaling(name,min,size,keepAlive.millis(),TimeUnit.MILLISECONDS,threadFactory);
    return new ExecutorHolder(executor,new Info(name,threadPoolType,min,size,keepAlive,null));
  }
  throw new IllegalArgumentException("No type found [" + type + "], for ["+ name+ "]");
}
