{
  if (before != null) {
    throw new IllegalStateException(error("Illegal tree structure"));
  }
 else   if (store) {
    throw new IllegalArgumentException(error("Cannot assign a value to a new call."));
  }
  final Type type;
  try {
    type=definition.getType(this.type);
  }
 catch (  final IllegalArgumentException exception) {
    throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
  }
  final Struct struct=type.struct;
  constructor=struct.constructors.get("new");
  if (constructor != null) {
    final Type[] types=new Type[constructor.arguments.size()];
    constructor.arguments.toArray(types);
    if (constructor.arguments.size() != arguments.size()) {
      throw new IllegalArgumentException(error("When calling constructor on type [" + struct.name + "]"+ " expected ["+ constructor.arguments.size()+ "] arguments, but found ["+ arguments.size()+ "]."));
    }
    for (int argument=0; argument < arguments.size(); ++argument) {
      final AExpression expression=arguments.get(argument);
      expression.expected=types[argument];
      expression.analyze(settings,definition,variables);
      arguments.set(argument,expression.cast(settings,definition,variables));
    }
    statement=true;
    after=type;
  }
 else {
    throw new IllegalArgumentException(error("Unknown new call on type [" + struct.name + "]."));
  }
  return this;
}
