{
  if (before != null) {
    throw new IllegalArgumentException(error("Illegal new call with a target already defined."));
  }
 else   if (store) {
    throw new IllegalArgumentException(error("Cannot assign a value to a new call."));
  }
  final Type type;
  try {
    type=Definition.getType(this.type);
  }
 catch (  IllegalArgumentException exception) {
    throw new IllegalArgumentException(error("Not a type [" + this.type + "]."));
  }
  Struct struct=type.struct;
  constructor=struct.constructors.get(new Definition.MethodKey("new",arguments.size()));
  if (constructor != null) {
    Type[] types=new Type[constructor.arguments.size()];
    constructor.arguments.toArray(types);
    if (constructor.arguments.size() != arguments.size()) {
      throw new IllegalArgumentException(error("When calling constructor on type [" + struct.name + "]"+ " expected ["+ constructor.arguments.size()+ "] arguments, but found ["+ arguments.size()+ "]."));
    }
    for (int argument=0; argument < arguments.size(); ++argument) {
      AExpression expression=arguments.get(argument);
      expression.expected=types[argument];
      expression.internal=true;
      expression.analyze(variables);
      arguments.set(argument,expression.cast(variables));
    }
    statement=true;
    after=type;
  }
 else {
    throw new IllegalArgumentException(error("Unknown new call on type [" + struct.name + "]."));
  }
  return this;
}
