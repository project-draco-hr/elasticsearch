{
  List<DiscoveryNode> discoNodes=Lists.newArrayList();
  DescribeInstancesResult descInstances;
  try {
    descInstances=client.describeInstances(new DescribeInstancesRequest());
  }
 catch (  AmazonClientException e) {
    logger.info("Exception while retrieving instance list from AWS API: {}",e.getMessage());
    logger.debug("Full exception:",e);
    return discoNodes;
  }
  logger.trace("building dynamic unicast discovery nodes...");
  for (  Reservation reservation : descInstances.getReservations()) {
    for (    Instance instance : reservation.getInstances()) {
      if (!availabilityZones.isEmpty()) {
        if (!availabilityZones.contains(instance.getPlacement().getAvailabilityZone())) {
          logger.trace("filtering out instance {} based on availability_zone {}, not part of {}",instance.getInstanceId(),instance.getPlacement().getAvailabilityZone(),availabilityZones);
          continue;
        }
      }
      if (!groups.isEmpty()) {
        List<GroupIdentifier> instanceSecurityGroups=instance.getSecurityGroups();
        ArrayList<String> securityGroupNames=new ArrayList<String>();
        for (        GroupIdentifier sg : instanceSecurityGroups) {
          securityGroupNames.add(sg.getGroupName());
        }
        if (bindAnyGroup) {
          if (Collections.disjoint(securityGroupNames,groups)) {
            logger.trace("filtering out instance {} based on groups {}, not part of {}",instance.getInstanceId(),instanceSecurityGroups,groups);
            continue;
          }
        }
 else {
          if (!securityGroupNames.containsAll(groups)) {
            logger.trace("filtering out instance {} based on groups {}, does not include all of {}",instance.getInstanceId(),instanceSecurityGroups,groups);
            continue;
          }
        }
      }
      boolean filterByTag=false;
      if (!tags.isEmpty()) {
        if (instance.getTags() == null) {
          filterByTag=true;
        }
 else {
          for (          Map.Entry<String,String> entry : tags.entrySet()) {
            boolean found=false;
            for (            Tag tag : instance.getTags()) {
              if (entry.getKey().equals(tag.getKey()) && entry.getValue().equals(tag.getValue())) {
                found=true;
                break;
              }
            }
            if (!found) {
              filterByTag=true;
              break;
            }
          }
        }
      }
      if (filterByTag) {
        logger.trace("filtering out instance {} based tags {}, not part of {}",instance.getInstanceId(),tags,instance.getTags());
        continue;
      }
      InstanceState state=instance.getState();
      if (state.getName().equalsIgnoreCase("pending") || state.getName().equalsIgnoreCase("running")) {
        String address=null;
switch (hostType) {
case PRIVATE_DNS:
          address=instance.getPrivateDnsName();
        break;
case PRIVATE_IP:
      address=instance.getPrivateIpAddress();
    break;
case PUBLIC_DNS:
  address=instance.getPublicDnsName();
break;
case PUBLIC_IP:
address=instance.getPublicDnsName();
break;
}
if (address != null) {
try {
TransportAddress[] addresses=transportService.addressesFromString(address);
for (int i=0; (i < addresses.length && i < UnicastZenPing.LIMIT_PORTS_COUNT); i++) {
logger.trace("adding {}, address {}, transport_address {}",instance.getInstanceId(),address,addresses[i]);
discoNodes.add(new DiscoveryNode("#cloud-" + instance.getInstanceId() + "-"+ i,addresses[i],Version.CURRENT));
}
}
 catch (Exception e) {
logger.warn("failed to add {}, address {}",e,instance.getInstanceId(),address);
}
}
 else {
logger.trace("not adding {}, address is null, host_type {}",instance.getInstanceId(),hostType);
}
}
 else {
logger.trace("not adding {}, state {} is not pending or running",instance.getInstanceId(),state.getName());
}
}
}
logger.debug("using dynamic discovery nodes {}",discoNodes);
return discoNodes;
}
