{
  Set<DiscoveryNode> nodesToPing=Sets.newHashSet();
  for (  DiscoveryNode node : listedNodes) {
    nodesToPing.add(node);
  }
  for (  DiscoveryNode node : nodes) {
    nodesToPing.add(node);
  }
  final CountDownLatch latch=new CountDownLatch(nodesToPing.size());
  final ConcurrentMap<DiscoveryNode,ClusterStateResponse> clusterStateResponses=ConcurrentCollections.newConcurrentMap();
  for (  final DiscoveryNode listedNode : nodesToPing) {
    threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new Runnable(){
      @Override public void run(){
        try {
          if (!transportService.nodeConnected(listedNode)) {
            try {
              if (nodes.contains(listedNode)) {
                logger.trace("connecting to cluster node [{}]",listedNode);
                transportService.connectToNode(listedNode);
              }
 else {
                logger.trace("connecting to listed node (light) [{}]",listedNode);
                transportService.connectToNodeLight(listedNode);
              }
            }
 catch (            Exception e) {
              logger.debug("failed to connect to node [{}], ignoring...",e,listedNode);
              latch.countDown();
              return;
            }
          }
          transportService.sendRequest(listedNode,ClusterStateAction.NAME,headers.applyTo(Requests.clusterStateRequest().clear().nodes(true).local(true)),TransportRequestOptions.options().withType(TransportRequestOptions.Type.STATE).withTimeout(pingTimeout),new BaseTransportResponseHandler<ClusterStateResponse>(){
            @Override public ClusterStateResponse newInstance(){
              return new ClusterStateResponse();
            }
            @Override public String executor(){
              return ThreadPool.Names.SAME;
            }
            @Override public void handleResponse(            ClusterStateResponse response){
              clusterStateResponses.put(listedNode,response);
              latch.countDown();
            }
            @Override public void handleException(            TransportException e){
              logger.info("failed to get local cluster state for {}, disconnecting...",e,listedNode);
              transportService.disconnectFromNode(listedNode);
              latch.countDown();
            }
          }
);
        }
 catch (        Throwable e) {
          logger.info("failed to get local cluster state info for {}, disconnecting...",e,listedNode);
          transportService.disconnectFromNode(listedNode);
          latch.countDown();
        }
      }
    }
);
  }
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    return;
  }
  HashSet<DiscoveryNode> newNodes=new HashSet<>();
  HashSet<DiscoveryNode> newFilteredNodes=new HashSet<>();
  for (  Map.Entry<DiscoveryNode,ClusterStateResponse> entry : clusterStateResponses.entrySet()) {
    if (!ignoreClusterName && !clusterName.equals(entry.getValue().getClusterName())) {
      logger.warn("node {} not part of the cluster {}, ignoring...",entry.getValue().getState().nodes().localNode(),clusterName);
      newFilteredNodes.add(entry.getKey());
      continue;
    }
    for (    ObjectCursor<DiscoveryNode> cursor : entry.getValue().getState().nodes().dataNodes().values()) {
      newNodes.add(cursor.value);
    }
  }
  nodes=validateNewNodes(newNodes);
  filteredNodes=ImmutableList.copyOf(newFilteredNodes);
}
