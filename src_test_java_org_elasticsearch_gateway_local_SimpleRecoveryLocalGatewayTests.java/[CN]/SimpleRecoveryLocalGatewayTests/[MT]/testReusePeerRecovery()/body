{
  buildNode("node1");
  buildNode("node2");
  buildNode("node3");
  buildNode("node4");
  cleanAndCloseNodes();
  ImmutableSettings.Builder settings=ImmutableSettings.settingsBuilder().put("action.admin.cluster.node.shutdown.delay","10ms").put("gateway.recover_after_nodes",4).put(BalancedShardsAllocator.SETTING_THRESHOLD,1.1f);
  startNode("node1",settings);
  startNode("node2",settings);
  startNode("node3",settings);
  startNode("node4",settings);
  logger.info("--> indexing docs");
  for (int i=0; i < 1000; i++) {
    client("node1").prepareIndex("test","type").setSource("field","value").execute().actionGet();
    if ((i % 200) == 0) {
      client("node1").admin().indices().prepareFlush().execute().actionGet();
    }
  }
  logger.info("Running Cluster Health");
  ClusterHealthResponse clusterHealth=client("node1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0)).actionGet();
  logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
  assertThat(clusterHealth.isTimedOut(),equalTo(false));
  assertThat(clusterHealth.getStatus(),equalTo(ClusterHealthStatus.GREEN));
  logger.info("--> shutting down the nodes");
  client("node1").admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION,true)).execute().actionGet();
  for (int i=1; i < 5; i++) {
    closeNode("node" + i);
  }
  logger.info("--> start the nodes back up");
  startNode("node1",settings);
  startNode("node2",settings);
  startNode("node3",settings);
  startNode("node4",settings);
  logger.info("Running Cluster Health");
  clusterHealth=client("node1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForActiveShards(10)).actionGet();
  logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
  assertThat(clusterHealth.isTimedOut(),equalTo(false));
  assertThat(clusterHealth.getStatus(),equalTo(ClusterHealthStatus.GREEN));
  logger.info("--> shutting down the nodes");
  client("node1").admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder().put(DisableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_DISABLE_ALLOCATION,true)).execute().actionGet();
  for (int i=1; i < 5; i++) {
    closeNode("node" + i);
  }
  logger.info("--> start the nodes back up");
  startNode("node1",settings);
  startNode("node2",settings);
  startNode("node3",settings);
  startNode("node4",settings);
  logger.info("Running Cluster Health");
  clusterHealth=client("node1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForActiveShards(10)).actionGet();
  logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
  assertThat(clusterHealth.isTimedOut(),equalTo(false));
  assertThat(clusterHealth.getStatus(),equalTo(ClusterHealthStatus.GREEN));
  IndicesStatusResponse statusResponse=client("node1").admin().indices().prepareStatus("test").setRecovery(true).execute().actionGet();
  for (  IndexShardStatus indexShardStatus : statusResponse.getIndex("test")) {
    for (    ShardStatus shardStatus : indexShardStatus) {
      if (!shardStatus.getShardRouting().primary()) {
        logger.info("--> shard {}, recovered {}, reuse {}",shardStatus.getShardId(),shardStatus.getPeerRecoveryStatus().getRecoveredIndexSize(),shardStatus.getPeerRecoveryStatus().getReusedIndexSize());
        assertThat(shardStatus.getPeerRecoveryStatus().getRecoveredIndexSize().bytes(),greaterThan(0l));
        assertThat(shardStatus.getPeerRecoveryStatus().getReusedIndexSize().bytes(),greaterThan(0l));
        assertThat(shardStatus.getPeerRecoveryStatus().getReusedIndexSize().bytes(),greaterThan(shardStatus.getPeerRecoveryStatus().getRecoveredIndexSize().bytes()));
      }
    }
  }
}
