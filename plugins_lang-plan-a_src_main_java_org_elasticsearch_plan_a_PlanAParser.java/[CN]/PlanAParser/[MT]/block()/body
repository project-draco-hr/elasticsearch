{
  BlockContext _localctx=new BlockContext(_ctx,getState());
  enterRule(_localctx,4,RULE_block);
  int _la;
  try {
    setState(147);
switch (_input.LA(1)) {
case LBRACK:
      _localctx=new MultipleContext(_localctx);
    enterOuterAlt(_localctx,1);
{
    setState(138);
    match(LBRACK);
    setState(142);
    _errHandler.sync(this);
    _la=_input.LA(1);
    while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LP) | (1L << IF) | (1L << WHILE)| (1L << DO)| (1L << FOR)| (1L << CONTINUE)| (1L << BREAK)| (1L << RETURN)| (1L << NEW)| (1L << TRY)| (1L << THROW)| (1L << BOOLNOT)| (1L << BWNOT)| (1L << ADD)| (1L << SUB)| (1L << INCR)| (1L << DECR))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (OCTAL - 64)) | (1L << (HEX - 64)) | (1L << (INTEGER - 64))| (1L << (DECIMAL - 64))| (1L << (STRING - 64))| (1L << (CHAR - 64))| (1L << (TRUE - 64))| (1L << (FALSE - 64))| (1L << (NULL - 64))| (1L << (TYPE - 64))| (1L << (ID - 64)))) != 0)) {
{
{
          setState(139);
          statement();
        }
      }
      setState(144);
      _errHandler.sync(this);
      _la=_input.LA(1);
    }
    setState(145);
    match(RBRACK);
  }
break;
case LP:
case IF:
case WHILE:
case DO:
case FOR:
case CONTINUE:
case BREAK:
case RETURN:
case NEW:
case TRY:
case THROW:
case BOOLNOT:
case BWNOT:
case ADD:
case SUB:
case INCR:
case DECR:
case OCTAL:
case HEX:
case INTEGER:
case DECIMAL:
case STRING:
case CHAR:
case TRUE:
case FALSE:
case NULL:
case TYPE:
case ID:
_localctx=new SingleContext(_localctx);
enterOuterAlt(_localctx,2);
{
setState(146);
statement();
}
break;
default :
throw new NoViableAltException(this);
}
}
 catch (RecognitionException re) {
_localctx.exception=re;
_errHandler.reportError(this,re);
_errHandler.recover(this,re);
}
 finally {
exitRule();
}
return _localctx;
}
