{
  Settings settings=settingsBuilder().put("index.refresh_interval","-1").put(SETTING_NUMBER_OF_SHARDS,1).put(SETTING_NUMBER_OF_REPLICAS,0).build();
  Node node1=nodeBuilder().settings(settingsBuilder().put(settings).put("name","node1")).node();
  Client client=node1.client();
  int count=(int)SizeValue.parseSizeValue("1m").singles();
  int nestedCount=10;
  int rootDocs=count / nestedCount;
  int batch=100;
  int queryWarmup=5;
  int queryCount=500;
  String indexName="test";
  ClusterHealthResponse clusterHealthResponse=client.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet();
  if (clusterHealthResponse.isTimedOut()) {
    System.err.println("--> Timed out waiting for cluster health");
  }
  try {
    client.admin().indices().prepareCreate(indexName).addMapping("type",XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field1").field("type","integer").endObject().startObject("field2").field("type","nested").startObject("properties").startObject("field3").field("type","integer").endObject().endObject().endObject().endObject().endObject().endObject()).execute().actionGet();
    clusterHealthResponse=client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().execute().actionGet();
    if (clusterHealthResponse.isTimedOut()) {
      System.err.println("--> Timed out waiting for cluster health");
    }
    StopWatch stopWatch=new StopWatch().start();
    System.out.println("--> Indexing [" + rootDocs + "] root documents and ["+ (rootDocs * nestedCount)+ "] nested objects");
    long ITERS=rootDocs / batch;
    long i=1;
    int counter=0;
    for (; i <= ITERS; i++) {
      BulkRequestBuilder request=client.prepareBulk();
      for (int j=0; j < batch; j++) {
        counter++;
        XContentBuilder doc=XContentFactory.jsonBuilder().startObject().field("field1",counter).startArray("field2");
        for (int k=0; k < nestedCount; k++) {
          doc=doc.startObject().field("field3",k).endObject();
        }
        doc=doc.endArray();
        request.add(Requests.indexRequest(indexName).type("type").id(Integer.toString(counter)).source(doc));
      }
      BulkResponse response=request.execute().actionGet();
      if (response.hasFailures()) {
        System.err.println("--> failures...");
      }
      if (((i * batch) % 10000) == 0) {
        System.out.println("--> Indexed " + (i * batch) + " took "+ stopWatch.stop().lastTaskTime());
        stopWatch.start();
      }
    }
    System.out.println("--> Indexing took " + stopWatch.totalTime() + ", TPS "+ (((double)(count * (1 + nestedCount))) / stopWatch.totalTime().secondsFrac()));
  }
 catch (  Exception e) {
    System.out.println("--> Index already exists, ignoring indexing phase, waiting for green");
    clusterHealthResponse=client.admin().cluster().prepareHealth(indexName).setWaitForGreenStatus().setTimeout("10m").execute().actionGet();
    if (clusterHealthResponse.isTimedOut()) {
      System.err.println("--> Timed out waiting for cluster health");
    }
  }
  client.admin().indices().prepareRefresh().execute().actionGet();
  System.out.println("--> Number of docs in index: " + client.prepareSearch().setSize(0).setQuery(matchAllQuery()).execute().actionGet().getHits().totalHits());
  NodesStatsResponse statsResponse=client.admin().cluster().prepareNodesStats().setJvm(true).execute().actionGet();
  System.out.println("--> Committed heap size: " + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());
  System.out.println("--> Used heap size: " + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());
  System.out.println("--> Running match_all with sorting on nested field");
  for (int j=0; j < queryWarmup; j++) {
    SearchResponse searchResponse=client.prepareSearch().setQuery(matchAllQuery()).addSort(SortBuilders.fieldSort("field2.field3").setNestedPath("field2").sortMode("avg").order(SortOrder.ASC)).execute().actionGet();
    if (j == 0) {
      System.out.println("--> Warmup took: " + searchResponse.getTook());
    }
    if (searchResponse.getHits().totalHits() != rootDocs) {
      System.err.println("--> mismatch on hits");
    }
  }
  long totalQueryTime=0;
  for (int j=0; j < queryCount; j++) {
    SearchResponse searchResponse=client.prepareSearch().setQuery(matchAllQuery()).addSort(SortBuilders.fieldSort("field2.field3").setNestedPath("field2").sortMode("avg").order(j % 2 == 0 ? SortOrder.ASC : SortOrder.DESC)).execute().actionGet();
    if (searchResponse.getHits().totalHits() != rootDocs) {
      System.err.println("--> mismatch on hits");
    }
    totalQueryTime+=searchResponse.getTookInMillis();
  }
  System.out.println("--> Sorting by nested fields took: " + (totalQueryTime / queryCount) + "ms");
  statsResponse=client.admin().cluster().prepareNodesStats().setJvm(true).execute().actionGet();
  System.out.println("--> Committed heap size: " + statsResponse.getNodes()[0].getJvm().getMem().getHeapCommitted());
  System.out.println("--> Used heap size: " + statsResponse.getNodes()[0].getJvm().getMem().getHeapUsed());
}
